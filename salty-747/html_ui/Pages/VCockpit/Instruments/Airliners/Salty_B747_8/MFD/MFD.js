/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Bool"] = "bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["Enum"] = "enum";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["HPA"] = "hectopascals";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["LBS"] = "pounds";
    SimVarValueType["LLA"] = "latlonalt";
    SimVarValueType["Mach"] = "mach";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["MetersPerSecond"] = "meters per second";
    SimVarValueType["MetersPerSecondSquared"] = "meters per second squared";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["Number"] = "number";
    SimVarValueType["Percent"] = "percent";
    SimVarValueType["PercentOver100"] = "percent over 100";
    SimVarValueType["Pounds"] = "pounds";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["Rankine"] = "rankine";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["SlugsPerCubicFoot"] = "slug per cubic foot";
    SimVarValueType["String"] = "string";
    SimVarValueType["Volts"] = "Volts";
})(SimVarValueType || (SimVarValueType = {}));
const latlonaltRegEx = new RegExp(/latlonalt/i);
const latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
const pbhRegex = new RegExp(/pbh/i);
const pid_structRegex = new RegExp(/pid_struct/i);
const xyzRegex = new RegExp(/xyz/i);
const stringRegex = new RegExp(/string/i);
const boolRegex = new RegExp(/boolean|bool/i);
const numberRegex = new RegExp(/number/i);
const defaultSource = '';
SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
        if (simvar) {
            let output;
            const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (registeredID >= 0) {
                if (numberRegex.test(unit)) {
                    output = simvar.getValueReg(registeredID);
                }
                else if (stringRegex.test(unit)) {
                    output = simvar.getValueReg_String(registeredID);
                }
                else if (latlonaltRegEx.test(unit)) {
                    output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
                }
                else if (pbhRegex.test(unit)) {
                    output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
                }
                else if (pid_structRegex.test(unit)) {
                    output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
                }
                else if (xyzRegex.test(unit)) {
                    output = new XYZ(simvar.getValue_XYZ(name, dataSource));
                }
                else {
                    output = simvar.getValueReg(registeredID);
                }
            }
            return output;
        }
        else {
            console.warn('SimVar handler is not defined (' + name + ')');
        }
    }
    catch (error) {
        console.warn('ERROR ', error, ' GetSimVarValue ' + name + ' unit : ' + unit);
        return null;
    }
    return null;
};
SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == undefined) {
        console.warn(name + ' : Trying to set a null value');
        return Promise.resolve();
    }
    try {
        if (simvar) {
            const regID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (regID >= 0) {
                if (stringRegex.test(unit)) {
                    return Coherent.call('setValueReg_String', regID, value);
                }
                else if (boolRegex.test(unit)) {
                    return Coherent.call('setValueReg_Bool', regID, !!value);
                }
                else if (numberRegex.test(unit)) {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
                else if (latlonaltRegEx.test(unit)) {
                    return Coherent.call('setValue_LatLongAlt', name, value, dataSource);
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    return Coherent.call('setValue_LatLongAltPBH', name, value, dataSource);
                }
                else if (pbhRegex.test(unit)) {
                    return Coherent.call('setValue_PBH', name, value, dataSource);
                }
                else if (pid_structRegex.test(unit)) {
                    return Coherent.call('setValue_PID_STRUCT', name, value, dataSource);
                }
                else if (xyzRegex.test(unit)) {
                    return Coherent.call('setValue_XYZ', name, value, dataSource);
                }
                else {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
            }
        }
        else {
            console.warn('SimVar handler is not defined');
        }
    }
    catch (error) {
        console.warn('error SetSimVarValue ' + error);
    }
    return Promise.resolve();
};

/**
 * A utility class for working with common aeronautical constants and calculations.
 */
class AeroMath {
    // ---- Ideal gas law relationships for air ----
    /**
     * Gets the static pressure of air, in hectopascals, given temperature and density.
     * @param temperature The temperature, in degrees Celsius.
     * @param density The density, in kilograms per cubic meter.
     * @returns The static pressure of air, in hectopascals, with the specified temperature and density.
     */
    static pressureAir(temperature, density) {
        return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    /**
     * Gets the density of air, in kilograms per cubic meter, given static pressure and temperature.
     * @param pressure The static pressure, in hectopascals.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The density of air, in kilograms per cubic meter, with the specified static pressure and temperature.
     */
    static densityAir(pressure, temperature) {
        return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    /**
     * Gets the temperature of air, in degrees Celsius, given static pressure and density.
     * @param pressure The static pressure, in hectopascals.
     * @param density The density, in kilograms per cubic meter.
     * @returns The temperature of air, in degrees Celsius, with the specified static pressure and temperature.
     */
    static temperatureAir(pressure, density) {
        return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    // ---- Other properties of air ----.
    /**
     * Gets the speed of sound in air, in meters per second, for a given temperature.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The speed of sound in air, in meters per second, for the given temperature.
     */
    static soundSpeedAir(temperature) {
        // speed of sound = sqrt(gamma * R * T)
        // gamma = 1.4
        // R = specific gas constant of dry air
        return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    // ---- Pressure ratios ----
    /**
     * Gets the ratio of total pressure to static pressure for a given mach number in a subsonic compressible airflow.
     * @param mach The mach number.
     * @returns The ratio of total pressure to static pressure for the specific mach number.
     */
    static totalPressureRatioAir(mach) {
        return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    // ---- Temperature ratios ----
    /**
     * Gets the ratio of total air temperature to static air temperature for a given mach number.
     * @param mach The mach number.
     * @param recovery The recovery factor. This is a value in the range `[0, 1]` representing the fraction of the
     * kinetic energy of the airflow that is converted to heat. Defaults to 1.
     * @returns The ratio of total air temperature to static air temperature for the specified mach number.
     */
    static totalTemperatureRatioAir(mach, recovery = 1) {
        return 1 + 0.2 * recovery * mach * mach;
    }
    // ---- ISA modeling ----
    /**
     * Gets the ISA temperature, in degrees Celsius, at a given pressure altitude. The supported pressure altitude range
     * is from -610 to 80000 meters above MSL. This method will return the temperature at -610 meters for all altitudes
     * below this range, and the temperature at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA temperature, in degrees Celsius, for the specified pressure altitude.
     */
    static isaTemperature(altitude) {
        // We don't use lookup table for perf reasons.
        if (altitude < 11000) {
            return 15 + Math.max(altitude, -610) * -0.0065;
        }
        else if (altitude < 20000) {
            return -56.5;
        }
        else if (altitude < 32000) {
            return -56.5 + (altitude - 20000) * 0.001;
        }
        else if (altitude < 47000) {
            return -44.5 + (altitude - 32000) * 0.0028;
        }
        else if (altitude < 51000) {
            return -2.5;
        }
        else if (altitude < 71000) {
            return -2.5 + (altitude - 51000) * -0.0028;
        }
        else {
            return -58.5 + (Math.min(altitude, 80000) - 71000) * -0.002;
        }
    }
    /**
     * Gets the ISA pressure, in hectopascals, at a given pressure altitude. The supported pressure altitude range is
     * from -610 to 80000 meters above MSL. This method will return the pressure at -610 meters for all altitudes below
     * this range, and the pressure at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA pressure, in hectopascals, for the specified pressure altitude.
     */
    static isaPressure(altitude) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // P(h) = P(h0) * (1 + dT/dh / T(h0) * (h - h0)) ^ (-g / (R * dT/dh))
        // Temperature constant with altitude:
        // P(h) = P(h0) * e^(-g / (R * T) * (h - h0))
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (altitude < -610) {
            // Modeling stops at -610 meters, so return the pressure for -610 meters for any altitude below this.
            return 1099.15;
        }
        else if (altitude <= 11000) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return 1013.25 * Math.pow(1 - 2.2558e-5 * altitude, 5.2558);
        }
        else if (altitude <= 20000) {
            // Tropopause
            // dT/dh = 0
            return 226.320 * Math.exp(-1.57686e-4 * (altitude - 11000));
        }
        else if (altitude <= 32000) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 54.7499 * Math.pow(1 + 4.61574e-6 * (altitude - 20000), -34.1627);
        }
        else if (altitude <= 47000) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 8.68058 * Math.pow(1 + 1.22458e-5 * (altitude - 32000), -12.2010);
        }
        else if (altitude <= 51000) {
            // Stratopause
            // dT/dh = 0
            return 1.10914 * Math.exp(-1.26225e-4 * (altitude - 47000));
        }
        else if (altitude <= 71000) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return 0.669439 * Math.pow(1 - 1.03455e-5 * (altitude - 51000), 12.2010);
        }
        else if (altitude <= 80000) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return 0.0395680 * Math.pow(1 - 9.31749e-6 * (altitude - 71000), 17.0814);
        }
        else {
            // Modeling stops at 80000 meters, so return the pressure for 80000 meters for any altitude above this.
            return 0.0088638;
        }
    }
    /**
     * Gets the ISA density, in kilograms per cubic meter, at a given pressure altitude. The supported pressure altitude
     * range is from -610 to 80000 meters above MSL. This method will return the density at -610 meters for all altitudes
     * below this range, and the density at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The ISA density, in kilograms per cubic meter, for the specified pressure altitude.
     */
    static isaDensity(altitude, deltaIsa = 0) {
        return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the speed of sound, in meters per second, at a given pressure altitude under ISA conditions.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The speed of sound, in meters per second, at the specified pressure altitude under ISA conditions.
     */
    static soundSpeedIsa(altitude, deltaIsa = 0) {
        return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    // ---- Speed conversions ----
    // The following section contains methods for converting between different speeds: CAS, TAS, and mach.
    // All conversions are based on the following:
    // Constants:
    // gamma (adiabatic index of air) = 1.4
    // pressure_sea_level_isa = 1013.25 hPa
    // sound_speed_sea_level_isa = 340.2964 m/s
    // Relationship between mach and impact pressure (only valid for subsonic flow):
    // mach = sqrt(5 * ((impact_pressure / static_pressure + 1) ^ ((gamma - 1) / gamma)) - 1)
    // impact_pressure = static_pressure * ((1 + 0.2 * mach ^ 2) ^ (gamma / (gamma - 1)) - 1)
    // Relationship between mach and airspeed:
    // mach = airspeed / sound_speed
    // airspeed = mach * sound_speed
    /**
     * Converts true airspeed (TAS) to mach number.
     * @param tas The true airspeed to convert, in the same units as `soundSpeed`.
     * @param soundSpeed The speed of sound, in the same units as `tas`.
     * @returns The mach number equivalent of the specified true airspeed.
     */
    static tasToMach(tas, soundSpeed) {
        return tas / soundSpeed;
    }
    /**
     * Converts true airspeed (TAS) to mach number under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The mach number equivalent of the specified true airspeed at the specified pressure altitude under ISA
     * conditions.
     */
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
        return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts mach number to true airspeed (TAS).
     * @param mach The mach number to convert.
     * @param soundSpeed The speed of sound.
     * @returns The true airspeed equivalent of the specified mach number, in the same units as `soundSpeed`.
     */
    static machToTas(mach, soundSpeed) {
        return mach * soundSpeed;
    }
    /**
     * Converts mach number to true airspeed (TAS), in meters per second, under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified mach number at the specified
     * pressure altitude under ISA conditions.
     */
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
        return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number. The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified static pressure.
     */
    static casToMach(cas, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate mach from CAS by
        // calculating the impact pressure using sea level ISA conditions, then using that impact pressure to calculate
        // mach using ambient static pressure.
        const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
        const impactPressure = 1013.25 * (Math.pow(1 + (0.2 * mach0 * mach0), 3.5) - 1);
        return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified pressure altitude under
     * ISA conditions.
     */
    static casToMachIsa(cas, altitude) {
        return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number at the specified
     * static pressure.
     */
    static machToCas(mach, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate CAS from mach by
        // calculating the impact pressure using ambient static pressure, then using that impact pressure to calculate
        // CAS using sea level ISA conditions.
        const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number  at the specified
     * pressure altitude under ISA conditions.
     */
    static machToCasIsa(mach, altitude) {
        return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS).
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * ambient pressure and temperature.
     */
    static casToTas(cas, pressure, temperature) {
        return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS) under ISA conditions.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
        return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS).
     * @param tas The true airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * ambient pressure and temperature.
     */
    static tasToCas(tas, pressure, temperature) {
        return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS) under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
        return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    // ---- Lift and drag equations ----
    // force_coefficient = force / (dynamic_pressure * area)
    // dynamic_pressure = 0.5 * density * speed ^ 2
    /**
     * Calculates a fluid flow force coefficient given a force and flow parameters.
     * @param force The flow force, in newtons.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force coefficient given the specified force and flow parameters.
     */
    static flowCoefFromForce(force, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return force / (dynamicPressure * area);
    }
    /**
     * Calculates a fluid flow force given a coefficient and flow parameters.
     * @param coef The flow force coefficient.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force given the specified coefficient and flow parameters.
     */
    static flowForceFromCoef(coef, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return coef * dynamicPressure * area;
    }
}
/** The ideal gas constant, in units of joules per mole per kelvin. */
AeroMath.R = 8.314462618153;
/** The specific gas constant of dry air, in units of joules per kilogram per kelvin. */
AeroMath.R_AIR = 287.057;
/** Approximate value of the adiabatic index of air near room temperature. */
AeroMath.GAMMA_AIR = 1.4;
/** The speed of sound in air at sea level under ISA conditions, in meters per second. */
AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
AeroMath.lift = AeroMath.flowForceFromCoef;
AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
AeroMath.drag = AeroMath.flowForceFromCoef;

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.canConvert(value.unit)) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number' && (!unit || this.unit.canConvert(unit))) {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    abs(out) {
        if (out) {
            return out.set(Math.abs(this.number), this.unit);
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        if (isNaN(converted) && this.isNaN()) {
            return true;
        }
        const diff = this.number - converted;
        return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, out);
        }
        else {
            return this.source.add(arg1, out);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, out);
        }
        else {
            return this.source.subtract(arg1, out);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor, out) {
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs(out) {
        return this.source.abs(out);
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family, numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i++].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i++].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.family = family;
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
/**
 * Predefined unit families.
 */
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["Distance"] = "distance";
    UnitFamily["Angle"] = "angle";
    UnitFamily["Duration"] = "duration";
    UnitFamily["Weight"] = "weight";
    UnitFamily["Mass"] = "weight";
    UnitFamily["Volume"] = "volume";
    UnitFamily["Pressure"] = "pressure";
    UnitFamily["Temperature"] = "temperature";
    UnitFamily["TemperatureDelta"] = "temperature_delta";
    UnitFamily["Speed"] = "speed";
    UnitFamily["Acceleration"] = "acceleration";
    UnitFamily["WeightFlux"] = "weight_flux";
    UnitFamily["MassFlux"] = "weight_flux";
    UnitFamily["VolumeFlux"] = "volume_flux";
    UnitFamily["Density"] = "density";
    UnitFamily["Force"] = "force";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.Distance, 'meter', 1);
UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, 'foot', 0.3048);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, 'kilometer', 1000);
/** Statute mile. */
UnitType.MILE = new SimpleUnit(UnitFamily.Distance, 'mile', 1609.34);
/** Nautical mile. */
UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, 'nautical mile', 1852);
/** Great-arc radian. The average radius of Earth. */
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, 'great arc radian', 6378100);
/** 9.80665 meters, for internal use. */
UnitType.G_METER = new SimpleUnit(UnitFamily.Distance, '9.80665 meter', 9.80665);
UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.Weight, 'pound', 0.453592);
UnitType.SLUG = new SimpleUnit(UnitFamily.Weight, 'slug', 14.59390);
UnitType.TON = new SimpleUnit(UnitFamily.Weight, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, 'tonne', 1000);
/** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, 'liter', 0.80283679);
/** Weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'gallon', 3.0390664);
/** Weight equivalent of one imperial gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'imperial gallon', 3.6497683);
UnitType.LITER = new SimpleUnit(UnitFamily.Volume, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, 'gallon', 3.78541);
/** Hectopascal. */
UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, 'hectopascal', 1);
/** Atmosphere. */
UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, 'atmosphere', 1013.25);
/** Inch of mercury. */
UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, 'inch of mercury', 33.8639);
/** Millimeter of mercury. */
UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, 'millimeter of mercury', 1.33322);
UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, 'kelvin', 1, 0);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, '° Fahrenheit', 5 / 9, 459.67);
UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, '° Rankine', 5 / 9, 0);
/** Change in degrees Celsius. */
UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Celsius', 1);
/** Change in degrees Fahrenheit. */
UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Fahrenheit', 5 / 9);
UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], 'knot');
/** Kilometer per hour. */
UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
/** Miles per hour. */
UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
/** Meter per minute. */
UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
/** Meter per second. */
UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
/** Foot per minute. */
UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
/** Foot per second. */
UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
/** Meter per minute per second. */
UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
/** Meter per second per second. */
UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Foot per minute per second. */
UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
/** Foot per second per second. */
UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
/** Knot per second. */
UnitType.KNOT_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.NMILE], [UnitType.HOUR, UnitType.SECOND]);
/** Average gravitational acceleration on Earth at sea level. */
UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);
/** Kilogram per hour. */
UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
/** Pound per hour. */
UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
/** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one imperial gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
/** Density in slugs per cubic foot */
UnitType.SLUG_PER_FT3 = new CompoundUnit(UnitFamily.Density, [UnitType.SLUG], [UnitType.FOOT, UnitType.FOOT, UnitType.FOOT]);
/** Density in kilograms per cubic meter */
UnitType.KG_PER_M3 = new CompoundUnit(UnitFamily.Density, [UnitType.KILOGRAM], [UnitType.METER, UnitType.METER, UnitType.METER]);
/** Newton. */
UnitType.NEWTON = new CompoundUnit(UnitFamily.Force, [UnitType.KILOGRAM, UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Pound (force). */
UnitType.POUND_FORCE = new CompoundUnit(UnitFamily.Force, [UnitType.POUND, UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    publish(topic, data, sync = false, isCached = true) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync, isCached);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.resolvedSimVars = new Map();
        this.indexedSimVars = new Map();
        this.subscribed = new Set();
        for (const [topic, entry] of simVarMap) {
            if (entry.indexed) {
                this.indexedSimVars.set(topic, {
                    name: entry.name,
                    type: entry.type,
                    map: entry.map,
                    indexes: entry.indexed === true ? undefined : new Set(entry.indexed),
                    defaultIndex: entry.defaultIndex,
                });
            }
            else {
                this.resolvedSimVars.set(topic, Object.assign({}, entry));
            }
        }
        const handleSubscribedTopic = (topic) => {
            if (this.resolvedSimVars.has(topic)) {
                // If topic matches an already resolved topic -> start publishing.
                this.onTopicSubscribed(topic);
            }
            else {
                // Check if topic matches indexed topic.
                this.tryMatchIndexedSubscribedTopic(topic);
            }
        };
        // Iterate over each subscribed topic on the bus to see if it matches any of our topics. If so, start publishing.
        this.bus.forEachSubscribedTopic(handleSubscribedTopic);
        // Listen to first-time topic subscriptions. If any of them match our topics, start publishing.
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(handleSubscribedTopic);
    }
    /**
     * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
     * publishing the indexed topic.
     * @param topic The subscribed topic to check.
     */
    tryMatchIndexedSubscribedTopic(topic) {
        var _a;
        if (this.indexedSimVars.size === 0) {
            return;
        }
        let entry = this.indexedSimVars.get(topic);
        if (entry) {
            // The subscribed topic matches an unsuffixed topic -> check if the unsuffixed topic should be published and if
            // so, resolve the default index.
            if (entry.defaultIndex !== null) {
                const resolved = this.resolveIndexedSimVar(topic, entry, (_a = entry.defaultIndex) !== null && _a !== void 0 ? _a : 1);
                if (resolved !== undefined) {
                    this.onTopicSubscribed(resolved);
                }
            }
            return;
        }
        if (!SimVarPublisher.INDEXED_REGEX.test(topic)) { // Don't generate an array if we don't have to.
            return;
        }
        const match = topic.match(SimVarPublisher.INDEXED_REGEX);
        const [, matchedTopic, index] = match;
        entry = this.indexedSimVars.get(matchedTopic);
        if (entry) {
            const resolved = this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index));
            if (resolved !== undefined) {
                this.onTopicSubscribed(resolved);
            }
        }
    }
    /**
     * Attempts to resolve an indexed topic with an index, generating a version of the topic which is mapped to an
     * indexed simvar. The resolved indexed topic can then be published.
     * @param topic The topic to resolve.
     * @param entry The entry of the topic to resolve.
     * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
     * a suffix) and will be mapped the index-1 version of its simvar.
     * @returns The resolved indexed topic, or `undefined` if the topic could not be resolved with the specified index.
     */
    resolveIndexedSimVar(topic, entry, index) {
        index !== null && index !== void 0 ? index : (index = 1);
        const resolvedTopic = `${topic}_${index}`;
        if (this.resolvedSimVars.has(resolvedTopic)) {
            return resolvedTopic;
        }
        const defaultIndex = entry.defaultIndex === undefined ? 1 : entry.defaultIndex;
        // Ensure that the index we are trying to resolve is a valid index for the topic.
        if (entry.indexes !== undefined && !entry.indexes.has(index)) {
            return undefined;
        }
        this.resolvedSimVars.set(resolvedTopic, {
            name: entry.name.replace('#index#', `${index !== null && index !== void 0 ? index : 1}`),
            type: entry.type,
            map: entry.map,
            unsuffixedTopic: defaultIndex === index ? topic : undefined
        });
        return resolvedTopic;
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry !== undefined) {
            const value = this.getValueFromEntry(entry);
            this.publish(topic, value);
            // Check if we need to publish the same value to the unsuffixed version of the topic.
            if (entry.unsuffixedTopic) {
                this.publish(entry.unsuffixedTopic, value);
            }
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return this.getValueFromEntry(entry);
    }
    /**
     * Gets the current value for a resolved topic entry.
     * @param entry An entry for a resolved topic.
     * @returns The current value for the specified entry.
     */
    getValueFromEntry(entry) {
        return entry.map === undefined
            ? this.getSimVarValue(entry)
            : entry.map(this.getSimVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getSimVarValue(entry) {
        const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}
SimVarPublisher.INDEXED_REGEX = /(.*)_(0|[1-9]\d*)$/;
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class GameVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
        // Start polling all simvars for which there are existing subscriptions.
        for (const topic of this.simvars.keys()) {
            if (bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((topic) => {
            if (this.simvars.has(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const value = this.getValue(topic);
        if (value !== undefined) {
            this.publish(topic, value);
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.simvars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return entry.map === undefined
            ? this.getGameVarValue(entry)
            : entry.map(this.getGameVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getGameVarValue(entry) {
        const svValue = SimVar.GetGameVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for air data computer information.
 */
class AdcPublisher extends SimVarPublisher {
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['ias', { name: 'AIRSPEED INDICATED:#index#', type: SimVarValueType.Knots, indexed: true }],
            ['tas', { name: 'AIRSPEED TRUE:#index#', type: SimVarValueType.Knots, indexed: true }],
            [
                'mach_to_kias_factor',
                {
                    name: 'AIRSPEED INDICATED:#index#',
                    type: SimVarValueType.Knots,
                    map: (kias) => {
                        const factor = kias < 1 || this.mach === 0 ? AeroMath.machToCas(1, this.pressure) : kias / this.mach;
                        return isFinite(factor) ? factor : 1;
                    },
                    indexed: true
                }
            ],
            ['indicated_alt', { name: 'INDICATED ALTITUDE:#index#', type: SimVarValueType.Feet, indexed: true }],
            ['altimeter_baro_setting_inhg', { name: 'KOHLSMAN SETTING HG:#index#', type: SimVarValueType.InHG, indexed: true }],
            ['altimeter_baro_setting_mb', { name: 'KOHLSMAN SETTING MB:#index#', type: SimVarValueType.MB, indexed: true }],
            ['altimeter_baro_preselect_raw', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, indexed: true }],
            ['altimeter_baro_preselect_inhg', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => UnitType.HPA.convertTo(raw / 16, UnitType.IN_HG), indexed: true }],
            ['altimeter_baro_preselect_mb', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => raw / 16, indexed: true }],
            ['altimeter_baro_is_std', { name: 'L:XMLVAR_Baro#index#_ForcedToSTD', type: SimVarValueType.Bool, indexed: true }],
            ['radio_alt', { name: 'RADIO HEIGHT', type: SimVarValueType.Feet }],
            ['pressure_alt', { name: 'PRESSURE ALTITUDE', type: SimVarValueType.Feet }],
            ['vertical_speed', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
            ['ambient_density', { name: 'AMBIENT DENSITY', type: SimVarValueType.SlugsPerCubicFoot }],
            ['ambient_temp_c', { name: 'AMBIENT TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_pressure_inhg', { name: 'AMBIENT PRESSURE', type: SimVarValueType.InHG }],
            ['isa_temp_c', { name: 'STANDARD ATM TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ram_air_temp_c', { name: 'TOTAL AIR TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
            ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
            ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
            ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }],
            ['stall_aoa', { name: 'STALL ALPHA', type: SimVarValueType.Degree }],
            ['zero_lift_aoa', { name: 'ZERO LIFT ALPHA', type: SimVarValueType.Degree }],
            ['mach_number', { name: 'AIRSPEED MACH', type: SimVarValueType.Mach }],
        ]);
        super(simvars, bus, pacer);
        this.mach = 0;
        this.pressure = 1013.25;
        (_a = this.needUpdateMachToKiasData) !== null && _a !== void 0 ? _a : (this.needUpdateMachToKiasData = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('mach_to_kias_factor')) {
            this.needUpdateMachToKiasData = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        const isSlewing = SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
        if (!isSlewing) {
            if (this.needUpdateMachToKiasData) {
                this.mach = SimVar.GetSimVarValue('AIRSPEED MACH', SimVarValueType.Number);
                this.pressure = SimVar.GetSimVarValue('AMBIENT PRESSURE', SimVarValueType.HPA);
            }
            super.onUpdate();
        }
    }
}

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags, valuesToSet, mask) {
        return (flags & ~mask) | (valuesToSet & mask);
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
class HandlerSubscription {
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler, initialNotifyFunc, onDestroy) {
        this.handler = handler;
        this.initialNotifyFunc = initialNotifyFunc;
        this.onDestroy = onDestroy;
        this._isAlive = true;
        this._isPaused = false;
        this.canInitialNotify = initialNotifyFunc !== undefined;
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify() {
        if (!this._isAlive) {
            throw new Error('HandlerSubscription: cannot notify a dead Subscription.');
        }
        this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot pause a dead Subscription.');
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot resume a dead Subscription.');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        if (initialNotify) {
            this.initialNotify();
        }
        return this;
    }
    /** @inheritdoc */
    destroy() {
        if (!this._isAlive) {
            return;
        }
        this._isAlive = false;
        this.onDestroy && this.onDestroy(this);
    }
}

/**
 * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
 * to change the state of the output subscribable.
 */
class SubscribablePipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let onDestroy;
        if (typeof arg4 === 'function') {
            handler = (fromVal) => {
                to.set(arg3(fromVal, to.get()));
            };
            onDestroy = arg4;
        }
        else {
            handler = (fromVal) => {
                to.set(fromVal);
            };
            onDestroy = arg3;
        }
        super(handler, (sub) => { sub.handler(from.get()); }, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribable {
    constructor() {
        this.isSubscribable = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this subscribable.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.notifySubscription(this.singletonSub);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribable: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        this.notifySubscription(sub);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribable: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
/**
 * An implementation of {@link MappedSubscribable}.
 */
class MappedSubscribableClass extends AbstractSubscribable {
    /**
     * Constructor.
     * @param input This subscribable's input.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     */
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
        super();
        this.input = input;
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.input.get()));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.input.get());
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSub = this.input.sub(inputValue => {
            this.updateValue(inputValue);
        }, true);
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     * @param inputValue The input value.
     */
    updateValue(inputValue) {
        const value = this.mapFunc(inputValue, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot pause a dead subscribable');
        }
        if (this._isPaused) {
            return this;
        }
        this.inputSub.pause();
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot resume a dead subscribable');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        this.inputSub.resume(true);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        this.inputSub.destroy();
    }
}

/**
 * A subscribable subject whose value can be freely manipulated.
 */
class Subject extends AbstractSubscribable {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        super();
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.isMutableSubscribable = true;
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /** @inheritdoc */
    notifySub(sub) {
        sub(this.value);
    }
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value) {
        let changed = false;
        for (const prop in value) {
            changed = value[prop] !== this.value[prop];
            if (changed) {
                break;
            }
        }
        Object.assign(this.value, value);
        changed && this.notify();
    }
    /** @inheritdoc */
    notify() {
        super.notify();
    }
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get() {
        return this.value;
    }
}

/**
 * Utility methods for working with Subscribables.
 */
class SubscribableUtils {
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isSubscribable === true;
    }
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isMutableSubscribable === true;
    }
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable(value, excludeSubscribables) {
        if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
            return value;
        }
        else {
            return Subject.create(value);
        }
    }
}
/**
 * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
 * `NaN`.
 * @param a The first number to compare.
 * @param b The second number to compare.
 * @returns Whether the two numbers are strictly equal or both `NaN`.
 */
SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || (isNaN(a) && isNaN(b));

/**
 * Utility class for generating common functions for mapping subscribables.
 */
class SubscribableMapFunctions {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity() {
        return (input) => input;
    }
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not() {
        return (input) => !input;
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise.
     */
    static or() {
        return (input) => input.length > 0 && input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if no tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if no tuple member is `true` or there are no
     * tuple members, and to `false` otherwise.
     */
    static nor() {
        return (input) => !input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static and() {
        return (input) => input.length > 0 && !input.includes(false);
    }
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate() {
        return (input) => -input;
    }
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs() {
        return Math.abs;
    }
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision(precision) {
        return SubscribableUtils.isSubscribable(precision)
            ? (input) => {
                const precisionVal = precision.get();
                return Math.round(input / precisionVal) * precisionVal;
            }
            : (input) => {
                return Math.round(input / precision) * precision;
            };
    }
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy(threshold) {
        return SubscribableUtils.isSubscribable(threshold)
            ? (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal
            : (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise.
     * @param freq The maximum frequency at which to map the input to itself, in hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    static atFrequency(freq, timeFunc = Date.now) {
        let t0;
        let timeRemaining = 0;
        if (SubscribableUtils.isSubscribable(freq)) {
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    const period = 1000 / freq.get();
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
        else {
            const period = 1000 / freq;
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
    }
}

/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
class MappedSubject extends AbstractSubscribable {
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
        super();
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        this.inputs = inputs;
        this.inputValues = inputs.map(input => input.get());
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.inputValues, undefined));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.inputValues, undefined);
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSubs = this.inputs.map((input, index) => input.sub(inputValue => {
            this.inputValues[index] = inputValue;
            this.updateValue();
        }));
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(...args) {
        let mapFunc, equalityFunc, mutateFunc, initialVal;
        if (typeof args[0] === 'function') {
            // Mapping function was supplied.
            mapFunc = args.shift();
            if (typeof args[0] === 'function') {
                equalityFunc = args.shift();
            }
            else {
                equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
            }
            if (typeof args[0] === 'function') {
                mutateFunc = args.shift();
                initialVal = args.shift();
            }
        }
        else {
            mapFunc = MappedSubject.IDENTITY_MAP;
            equalityFunc = MappedSubject.NEVER_EQUALS;
        }
        return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     */
    updateValue() {
        const value = this.mapFunc(this.inputValues, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot pause a dead subject');
        }
        if (this._isPaused) {
            return this;
        }
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].pause();
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot resume a dead subject');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputValues[i] = this.inputs[i].get();
            this.inputSubs[i].resume();
        }
        this.updateValue();
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].destroy();
        }
    }
}
MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
MappedSubject.NEVER_EQUALS = () => false;

/**
 * A Subject which provides a {@link NumberUnitInterface} value.
 */
class NumberUnitSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Returns a number {@link Subscribable} of this `NumberUnit` converted according to a unit or unit `Subscribable`
     *
     * @param unit the unit to subscribe to
     *
     * @returns a `MappedSubscribable<number>`
     */
    asUnit(unit) {
        return MappedSubject.create(([numberUnit, toUnit]) => numberUnit.asUnit(toUnit), this, SubscribableUtils.toSubscribable(unit, true));
    }
}

/**
 * 2D vector mathematical operations.
 */
class Vec2Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y) {
        const vec = new Float64Array(2);
        if (x !== undefined && y !== undefined) {
            vec[0] = x;
            vec[1] = y;
        }
        return vec;
    }
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
    /**
     * Checks if a point is within a polygon.
     * @param polygon The polygon to check against.
     * @param point The point to test.
     * @returns True if the point is within or on the polygon, false otherwise.
     * @throws An error if first and last points in a polygon are not the same.
     */
    static pointWithinPolygon(polygon, point) {
        //Adapted from https://github.com/rowanwins/point-in-polygon-hao
        let k = 0;
        let f = 0;
        let u1 = 0;
        let v1 = 0;
        let u2 = 0;
        let v2 = 0;
        let currentP = null;
        let nextP = null;
        const x = point[0];
        const y = point[1];
        const contourLen = polygon.length - 1;
        currentP = polygon[0];
        if (currentP[0] !== polygon[contourLen][0] &&
            currentP[1] !== polygon[contourLen][1]) {
            throw new Error('First and last coordinates in a ring must be the same');
        }
        u1 = currentP[0] - x;
        v1 = currentP[1] - y;
        for (let i = 0; i < polygon.length - 1; i++) {
            nextP = polygon[i + 1];
            v2 = nextP[1] - y;
            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {
                currentP = nextP;
                v1 = v2;
                u1 = currentP[0] - x;
                continue;
            }
            u2 = nextP[0] - point[0];
            if (v2 > 0 && v1 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f > 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 > 0 && v2 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f < 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v2 === 0 && v1 < 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 < 0) {
                f = u1 * v2 - u2 * v1;
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 === 0) {
                if (u2 <= 0 && u1 >= 0) {
                    return undefined;
                }
                else if (u1 <= 0 && u2 >= 0) {
                    return undefined;
                }
            }
            currentP = nextP;
            v1 = v2;
            u1 = u2;
        }
        if (k % 2 === 0) {
            return false;
        }
        return true;
    }
}
/**
 * 3D vector mathematical operations.
 */
class Vec3Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y, z) {
        const vec = new Float64Array(3);
        if (x !== undefined && y !== undefined && z !== undefined) {
            vec[0] = x;
            vec[1] = y;
            vec[2] = z;
        }
        return vec;
    }
    /**
     * Gets the spherical angle theta (polar angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi (azimuthal angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x The new x-component.
     * @param y The new y-component.
     * @param z The new z-component.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r The new length (magnitude).
     * @param theta The new spherical angle theta (polar angle), in radians.
     * @param phi The new spherical angle phi (azimuthal angle), in radians.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = r * sinTheta * Math.cos(phi);
        vec[1] = r * sinTheta * Math.sin(phi);
        vec[2] = r * Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]) && isFinite(vec[2]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}
/**
 * N-dimensional vector mathematical operations.
 */
class VecNMath {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(length, ...components) {
        const vec = new Float64Array(length);
        for (let i = 0; i < length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec, ...components) {
        for (let i = 0; i < vec.length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec) {
        return Math.hypot(...vec);
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1, v2) {
        if (v1.length !== v2.length) {
            throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
        }
        let dot = 0;
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            dot += v1[i] * v2[i];
        }
        return dot;
    }
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            out[i] = v1[i] / mag;
        }
        return out;
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        if (vec1.length !== vec2.length) {
            return false;
        }
        for (let i = 0; i < vec1.length; i++) {
            if (vec1[i] !== vec2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        for (let i = 0; i < vec.length; i++) {
            if (!isFinite(vec[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from, to) {
        if (from.length !== to.length) {
            throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
        }
        to.set(from);
        return to;
    }
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0]) && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1]);
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a 3D vector to be observed.
 */
class Vec3Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
        let x, y, z;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
            z = arg3;
        }
        else {
            x = arg1[0];
            y = arg1[1];
            z = arg1[2];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(z, this.value[2]);
        if (!equals) {
            Vec3Math.set(x, y, z, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
class VecNSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static create(initialVal) {
        return new VecNSubject(initialVal);
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     * @deprecated Use `VecNSubject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new VecNSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, ...args) {
        let array;
        if (typeof arg1 === 'number') {
            array = args;
            args.unshift(arg1);
        }
        else {
            array = arg1;
        }
        if (array.length > this.value.length) {
            throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
        }
        let equals = true;
        const len = array.length;
        for (let i = 0; i < len; i++) {
            if (!SubscribableUtils.NUMERIC_NAN_EQUALITY(array[i], this.value[i])) {
                equals = false;
                break;
            }
        }
        if (!equals) {
            this.value.set(array);
            this.notify();
        }
    }
}

/**
 * A closed heat system with temperature sources contributing to a volume.
 */
class TemperatureSystem {
    /**
     * Creates an instance of a TemperatureSystem.
     * @param capacity The heat capacity of the system, in joules per kelvin.
     */
    constructor(capacity) {
        this.capacity = capacity;
        this.sources = [];
        this._value = Subject.create(0);
    }
    /**
     * Gets the system's output value.
     * @returns The system's output temperature value, in degrees Celsius.
     */
    get value() {
        return this._value;
    }
    /**
     * Directly sets the current temperature value.
     * @param value The temperature value, in degrees Celsius.
     */
    set(value) {
        this._value.set(Math.max(-273.15, value));
    }
    /**
     * Adds a temperature source.
     * @param source The temperature source.
     * @returns The index of the added temperature source.
     */
    addSource(source) {
        return this.sources.push(source) - 1;
    }
    /**
     * Sets the temperature of a temperature source.
     * @param index The index of the source.
     * @param temperature The temperature to set to, in degrees Celsius.
     */
    setSourceTemp(index, temperature) {
        const source = this.sources[index];
        if (source !== undefined) {
            source.temperature = temperature;
        }
    }
    /**
     * Sets the conductivity of a temperature source.
     * @param index The index of the source.
     * @param conductivity The conductivity to set to, in watts per meter-kelvin.
     */
    setSourceConductivity(index, conductivity) {
        const source = this.sources[index];
        if (source !== undefined) {
            source.conductivity = conductivity;
        }
    }
    /**
     * Sets the heat capacity of the system.
     * @param capacity The heat capacity of the system, in joules per kelvin.
     */
    setCapacity(capacity) {
        this.capacity = capacity;
    }
    /**
     * Updates the temperature of this system following a period of elapsed time. This method assumes that this system's
     * sources, their temperatures and conductivities, and this system's heat capacity at the time this method is called
     * all remained constant throughout the time elapsed.
     * @param deltaTime The elapsed time, in milliseconds.
     */
    update(deltaTime) {
        // If no time has elapsed, or if there are no heat sources/sinks, then the system temperature cannot change.
        if (deltaTime === 0 || this.sources.length === 0) {
            return;
        }
        // For each time step, assuming the temperature of the sources, their conductivities, and the system heat capacity
        // all remain constant, the total heat of the system, Q, is governed by the equation
        // dQ/dt = A + k_s * Q(t) / C
        // 
        // A = T_1 * k_1 + T_2 * k_2 + ... T_n * k_n,
        //   where T_i, k_i are the absolute temperature and thermal conductivity, respectively, of source i
        //
        // k_s = k_1 + k_2 + ... + k_n
        //
        // C is the system's heat capacity
        //
        // Solving the first-order DE above yields
        // Q(t) = A * C / k_s + (Q(0) - A * C / k_s) * e ^ (-k_s * t / C)
        const Q0 = (this._value.get() + 273.15) * this.capacity;
        let A = 0, k = 0;
        for (let i = 0; i < this.sources.length; i++) {
            const source = this.sources[i];
            A += Math.max(source.temperature + 273.15, 0) * source.conductivity;
            k += source.conductivity;
        }
        let Q;
        if (k === 0) {
            // If k_s equals 0, then the DE above simplifies to
            // dQ/dt = A
            //
            // Solving for Q(t) yields
            // Q(t) = Q(0) + A * t
            Q = Q0 + A * deltaTime / 1000;
        }
        else {
            const B = A * this.capacity / k;
            Q = B + (Q0 - B) * Math.exp(-k * deltaTime / 1000 / this.capacity);
        }
        this._value.set(Math.max(Q, 0) / this.capacity - 273.15);
    }
}

/**
 * A 2D affine transformation. By default, Transform2D objects are initially created as identity transformations.
 */
class Transform2D {
    constructor() {
        this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    /**
     * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
        let scaleX = arg1;
        if (arg1 instanceof Transform2D) {
            [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewX;
        array[2] = translateX;
        array[3] = skewY;
        array[4] = scaleY;
        array[5] = translateY;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[4] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y) {
        this.array[0] = x;
        this.array[4] = y;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param value The new x skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(value) {
        this.array[1] = value;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param value The new y skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[2] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y) {
        this.array[2] = x;
        this.array[5] = y;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_10 = array[3];
        const e_11 = array[4];
        const e_12 = array[5];
        const i_00 = e_11;
        const i_01 = -e_10;
        const i_10 = -e_01;
        const i_11 = e_00;
        const i_20 = e_01 * e_12 - e_02 * e_11;
        const i_21 = -(e_00 * e_12 - e_02 * e_10);
        const det = e_00 * i_00 + e_01 * i_01;
        return this.set(i_00 / det, i_10 / det, i_20 / det, i_01 / det, i_11 / det, i_21 / det);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform2D().set(this);
    }
    /**
     * Applies this transformation to a 2D vector.
     * @param vec A 2D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
        const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
        return Vec2Math.set(x, y, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y) {
        Transform2D.offsetOriginCache[0].toTranslation(-x, -y);
        Transform2D.offsetOriginCache[1] = this;
        Transform2D.offsetOriginCache[2].toTranslation(x, y);
        return Transform2D.concat(this, Transform2D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y) {
        return this.set(1, 0, x, 0, 1, y);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, originX, originY) {
        this.set(x, 0, 0, 0, y, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, originX, originY) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toReflection(theta, originX, originY) {
        const sin = Math.sin(2 * theta);
        const cos = Math.cos(2 * theta);
        this.set(cos, sin, 0, sin, -cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, order = 'after') {
        if (order === 'before') {
            Transform2D.addCache[0].toTranslation(x, y);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            Transform2D.addCache[1].toTranslation(x, y);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, arg3, arg4, arg5) {
        let originX, originY, order;
        if (typeof arg3 === 'number') {
            originX = arg3;
            originY = arg4;
            order = arg5;
        }
        else {
            order = arg3;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toScale(x, y) : Transform2D.addCache[0].toScale(x, y, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toScale(x, y) : Transform2D.addCache[1].toScale(x, y, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, arg2, arg3, arg4) {
        let originX, originY, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            order = arg4;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toRotation(theta) : Transform2D.addCache[0].toRotation(theta, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toRotation(theta) : Transform2D.addCache[1].toRotation(theta, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addReflection(theta, arg2, arg3, arg4) {
        let originX, originY, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            order = arg4;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toReflection(theta) : Transform2D.addCache[0].toReflection(theta, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toReflection(theta) : Transform2D.addCache[1].toReflection(theta, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform2D.concatCache[0];
        const newTransform = Transform2D.concatCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform2D.offsetOriginCache = [new Transform2D(), undefined, new Transform2D()];
Transform2D.addCache = [new Transform2D(), new Transform2D()];
Transform2D.concatCache = [new Transform2D(), new Transform2D()];

/**
 * A 3D affine transformation. By default, Transform3D objects are initially created as identity transformations.
 */
class Transform3D {
    constructor() {
        this.array = new Float64Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0
        ]);
    }
    /**
     * Gets the parameters of this transformation as a 12-tuple:
     * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
        let scaleX = arg1;
        if (arg1 instanceof Transform3D) {
            [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewXY;
        array[2] = skewXZ;
        array[3] = translateX;
        array[4] = skewYX;
        array[5] = scaleY;
        array[6] = skewYZ;
        array[7] = translateY;
        array[8] = skewZX;
        array[9] = skewZY;
        array[10] = scaleZ;
        array[11] = translateZ;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the z scaling factor of this transformation.
     * @param value The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleZ(value) {
        this.array[10] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @param z The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y, z) {
        this.array[0] = x;
        this.array[5] = y;
        this.array[10] = z;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param y The new x skew factor along the y axis.
     * @param z The new x skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(y, z) {
        this.array[1] = y;
        this.array[2] = z;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param x The new y skew factor along the x axis.
     * @param z The new y skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(x, z) {
        this.array[4] = x;
        this.array[6] = z;
        return this;
    }
    /**
     * Sets the z skew factor of this transformation.
     * @param x The new z skew factor along the x axis.
     * @param y The new z skew factor along the y axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewZ(x, y) {
        this.array[8] = x;
        this.array[9] = y;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[7] = value;
        return this;
    }
    /**
     * Sets the z translation of this transformation.
     * @param value The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateZ(value) {
        this.array[11] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @param z The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y, z) {
        this.array[3] = x;
        this.array[7] = y;
        this.array[11] = z;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     * @throws Error if this transformation cannot be inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_03 = array[3];
        const e_10 = array[4];
        const e_11 = array[5];
        const e_12 = array[6];
        const e_13 = array[7];
        const e_20 = array[8];
        const e_21 = array[9];
        const e_22 = array[10];
        const e_23 = array[11];
        const c_00 = e_11 * e_22 - e_12 * e_21;
        const c_01 = e_12 * e_20 - e_10 * e_22;
        const c_02 = e_10 * e_21 - e_11 * e_20;
        const c_10 = e_02 * e_21 - e_01 * e_22;
        const c_11 = e_00 * e_22 - e_02 * e_20;
        const c_12 = e_01 * e_20 - e_00 * e_21;
        const c_20 = e_01 * e_12 - e_02 * e_11;
        const c_21 = e_02 * e_10 - e_00 * e_12;
        const c_22 = e_00 * e_11 - e_01 * e_10;
        const det = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
        if (det === 0) {
            throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
        }
        const i_00 = c_00 / det;
        const i_01 = c_10 / det;
        const i_02 = c_20 / det;
        const i_10 = c_01 / det;
        const i_11 = c_11 / det;
        const i_12 = c_21 / det;
        const i_20 = c_02 / det;
        const i_21 = c_12 / det;
        const i_22 = c_22 / det;
        const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
        const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
        const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
        return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform3D().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
        const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
        const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
        return Vec3Math.set(x, y, z, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @param z The z-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y, z) {
        Transform3D.offsetOriginCache[0].toTranslation(-x, -y, -z);
        Transform3D.offsetOriginCache[1] = this;
        Transform3D.offsetOriginCache[2].toTranslation(x, y, z);
        return Transform3D.concat(this, Transform3D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y, z) {
        return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, z, originX, originY, originZ) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationX(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationY(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationZ(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
        const abs = Math.hypot(axisX, axisY, axisZ);
        const ux = axisX / abs;
        const uy = axisY / abs;
        const uz = axisZ / abs;
        const ux_uy = ux * uy;
        const ux_uz = ux * uz;
        const uy_uz = uy * uz;
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        const cosCompl = 1 - cos;
        this.set(cos + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin, ux_uz * cosCompl * uy * sin, 0, ux_uy * cosCompl + uz * sin, cos + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin, 0, ux_uz * cosCompl - uy * sin, uy_uz * cosCompl + ux * sin, cos + uz * uz * cosCompl, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, z, order = 'after') {
        if (order === 'before') {
            Transform3D.addCache[0].toTranslation(x, y, z);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            Transform3D.addCache[1].toTranslation(x, y, z);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, z, arg4, arg5, arg6, arg7) {
        let originX, originY, originZ, order;
        if (typeof arg4 === 'number') {
            originX = arg4;
            originY = arg5;
            originZ = arg6;
            order = arg7;
        }
        else {
            order = arg4;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toScale(x, y, z) : Transform3D.addCache[0].toScale(x, y, z, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toScale(x, y, z) : Transform3D.addCache[1].toScale(x, y, z, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationX(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationX(theta) : Transform3D.addCache[0].toRotationX(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationX(theta) : Transform3D.addCache[1].toRotationX(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationY(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationY(theta) : Transform3D.addCache[0].toRotationY(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationY(theta) : Transform3D.addCache[1].toRotationY(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationZ(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationZ(theta) : Transform3D.addCache[0].toRotationZ(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationZ(theta) : Transform3D.addCache[1].toRotationZ(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, axisX, axisY, axisZ, arg5, arg6, arg7, arg8) {
        let originX, originY, originZ, order;
        if (typeof arg5 === 'number') {
            originX = arg5;
            originY = arg6;
            originZ = arg7;
            order = arg8;
        }
        else {
            order = arg5;
        }
        if (order === 'before') {
            originX === undefined
                ? Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ)
                : Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined
                ? Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ)
                : Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform3D.concatCache[0];
        const newTransform = Transform3D.concatCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    newArray[j * 4 + i] =
                        oldArray[i] * nextArray[j * 4]
                            + oldArray[4 + i] * nextArray[j * 4 + 1]
                            + oldArray[8 + i] * nextArray[j * 4 + 2]
                            + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform3D.offsetOriginCache = [new Transform3D(), undefined, new Transform3D()];
Transform3D.addCache = [new Transform3D(), new Transform3D()];
Transform3D.concatCache = [new Transform3D(), new Transform3D()];

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value, precision = 1) {
        return Math.round(value / precision) * precision;
    }
    /**
     * Ceils a number.
     * @param value The number to ceil.
     * @param precision The precision with which to ceil. Defaults to `1`.
     * @returns The ceiled number.
     */
    static ceil(value, precision = 1) {
        return Math.ceil(value / precision) * precision;
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start, end, directional = true) {
        const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
        return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 360)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in degrees.
     * @param end The ending angle, in degrees.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in degrees, in the range `[0, 360)`.
     */
    static diffAngleDeg(start, end, directional = true) {
        const diff = ((end - start) % 360 + 360) % 360;
        return directional ? diff : Math.min(diff, 360 - diff);
    }
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        if (x0 !== x1 && y0 !== y1) {
            const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
            return fraction * (y1 - y0) + y0;
        }
        else {
            return y0;
        }
    }
    /**
     * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
     * lengths, then only the components shared by all vectors are interpolated in the result.
     * @param out The object to which to write the result.
     * @param x The key of the vector to interpolate.
     * @param x0 The key of the first known vector.
     * @param x1 The key of the second known vector.
     * @param y0 The first known vector.
     * @param y1 The second known vector.
     * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
     * Defaults to false.
     * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
     * Defaults to false.
     * @returns The interpolated vector corresponding to the specified key.
     */
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        const length = Math.min(y0.length, y1.length, out.length);
        for (let i = 0; i < length; i++) {
            out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
        }
        return out;
    }
}
/** Twice the value of pi. */
MathUtils.TWO_PI = Math.PI * 2;
/** Half the value of pi. */
MathUtils.HALF_PI = Math.PI / 2;
/** Square root of 3. */
MathUtils.SQRT3 = Math.sqrt(3);
/** Square root of 1/3. */
MathUtils.SQRT1_3 = 1 / Math.sqrt(3);

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values. When
 * a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time elapsed
 * since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The calculation
 * of the weighting is such that the weight of each raw value in the sequence decays exponentially with the "age"
 * (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to the
 * sequence) of the value.
 */
class ExpSmoother {
    /**
     * Constructor.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.dtThreshold = dtThreshold;
        this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or null if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        let next;
        if (this.tau > 0 && this.lastValue !== null) {
            const factor = this.calculateFactor(dt);
            next = ExpSmoother.smooth(raw, this.lastValue, factor);
        }
        else {
            next = raw;
        }
        this.lastValue = next;
        return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
        if (dt > this.dtThreshold) {
            return 0;
        }
        else {
            return Math.exp(-dt / this.tau);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        return this.lastValue = (value !== null && value !== void 0 ? value : null);
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint ot which to write the result.
     * @returns The antipode of this point.
     * @throws Error if argument `out` is undefined.
     */
    antipode(out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.antipode(out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /** @inheritdoc */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The antipode of this point.
     */
    antipode(out) {
        return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    /** @inheritdoc */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        if (other) {
            if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
                return true;
            }
            const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
            const distance = this.distance(other);
            return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /** @inheritdoc */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static equals(arg1, arg2, arg3, arg4, arg5) {
        if (arg1 instanceof Float64Array) {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else if (typeof arg1 === 'number') {
            return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distance(arg1, arg2, arg3, arg4) {
        if (arg1 instanceof Float64Array) {
            return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
        }
        else {
            let lat1, lon1, lat2, lon2;
            if (typeof arg1 === 'number') {
                lat1 = arg1;
                lon1 = arg2;
                lat2 = arg3;
                lon2 = arg4;
            }
            else {
                lat1 = arg1.lat;
                lon1 = arg1.lon;
                lat2 = arg2.lat;
                lon2 = arg2.lon;
            }
            lat1 *= Avionics.Utils.DEG2RAD;
            lon1 *= Avionics.Utils.DEG2RAD;
            lat2 *= Avionics.Utils.DEG2RAD;
            lon2 *= Avionics.Utils.DEG2RAD;
            // haversine formula
            const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
            const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
            const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distanceRhumb(arg1, arg2, arg3, arg4) {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === 'number') {
            lat1 = arg1 * Avionics.Utils.DEG2RAD;
            lon1 = arg2 * Avionics.Utils.DEG2RAD;
            lat2 = arg3 * Avionics.Utils.DEG2RAD;
            lon2 = arg4 * Avionics.Utils.DEG2RAD;
        }
        else if (arg1 instanceof Float64Array) {
            const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
            lat1 = point1.lat;
            lon1 = point1.lon;
            const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
            lat2 = point2.lat;
            lon2 = point2.lon;
        }
        else {
            lat1 = arg1.lat;
            lon1 = arg1.lon;
            lat2 = arg2.lat;
            lon2 = arg2.lon;
        }
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1, lon1, lat2, lon2) {
        return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this._sinRadius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return this._sinRadius * angle;
    }
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length) {
        return length / this._sinRadius;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        this._sinRadius = Math.sin(this._radius);
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse() {
        Vec3Math.multScalar(this._center, -1, this._center);
        this._radius = Math.PI - this._radius;
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
        return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Inverts a heading value by adding 180 and normalizing.
     * @param heading The heading to invert/reciprocate.
     * @returns The inverted/reciprocated heading.
     * */
    static reciprocateHeading(heading) {
        return NavMath.normalizeHeading(heading + 180);
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius, in meters.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param radius The airplane turn radius, in meters.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="@microsoft/msfs-types/coherent/facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/**
 * A Subject which provides a {@link GeoPointInterface} value.
 */
class GeoPointSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     */
    constructor(value, tolerance) {
        super();
        this.value = value;
        this.tolerance = tolerance;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     * @returns A GeoPointSubject.
     */
    static create(initialVal, tolerance) {
        return new GeoPointSubject(initialVal, tolerance);
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
}

/**
 * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
 * to define the type of projection to be implemented.
 */
class AbstractGeoProjection {
    constructor() {
        this.center = new GeoPoint(0, 0);
        this.centerTranslation = new Float64Array(2);
        this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE); // 1 pixel = 1 nautical mile
        this.preRotation = new Float64Array(3);
        this.translation = new Float64Array(2);
        this.postRotation = 0;
        this.rotationSin = 0;
        this.rotationCos = 1;
        this.reflectY = 1;
        this.preRotationForwardTransform = new Transform3D();
        this.preRotationReverseTransform = new Transform3D();
        this.rotationCache = [new Transform3D(), new Transform3D()];
    }
    /** @inheritdoc */
    getCenter() {
        return this.center.readonly;
    }
    /** @inheritdoc */
    getScaleFactor() {
        return this.scaleFactor;
    }
    /** @inheritdoc */
    getPreRotation() {
        return this.preRotation;
    }
    /** @inheritdoc */
    getTranslation() {
        return this.translation;
    }
    /** @inheritdoc */
    getPostRotation() {
        return this.postRotation;
    }
    /** @inheritdoc */
    getReflectY() {
        return this.reflectY === -1;
    }
    /** @inheritdoc */
    setCenter(point) {
        this.center.set(point);
        this.updateCenterTranslation();
        return this;
    }
    /** @inheritdoc */
    setScaleFactor(factor) {
        this.scaleFactor = factor;
        return this;
    }
    /** @inheritdoc */
    setPreRotation(vec) {
        this.preRotation.set(vec);
        this.updatePreRotationTransforms();
        this.updateCenterTranslation();
        return this;
    }
    /** @inheritdoc */
    setTranslation(vec) {
        this.translation.set(vec);
        return this;
    }
    /** @inheritdoc */
    setPostRotation(rotation) {
        this.postRotation = rotation;
        this.rotationCos = Math.cos(rotation);
        this.rotationSin = Math.sin(rotation);
        return this;
    }
    /** @inheritdoc */
    setReflectY(val) {
        this.reflectY = val ? -1 : 1;
        return this;
    }
    /** @inheritdoc */
    copyParametersFrom(other) {
        return this.setCenter(other.getCenter())
            .setPreRotation(other.getPreRotation())
            .setScaleFactor(other.getScaleFactor())
            .setTranslation(other.getTranslation())
            .setPostRotation(other.getPostRotation())
            .setReflectY(other.getReflectY());
    }
    /**
     * Updates the pre-rotation transformation matrices.
     */
    updatePreRotationTransforms() {
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        this.rotationCache[0].toRotationX(gamma);
        this.rotationCache[1].toRotationY(-phi);
        Transform3D.concat(this.preRotationForwardTransform, this.rotationCache);
        this.preRotationReverseTransform.set(this.preRotationForwardTransform);
        this.preRotationReverseTransform.invert();
    }
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    updateCenterTranslation() {
        const centerArray = AbstractGeoProjection.vec2Cache[0];
        centerArray[0] = this.center.lon;
        centerArray[1] = this.center.lat;
        this.preRotateForward(centerArray, centerArray);
        this.projectRaw(centerArray, this.centerTranslation);
    }
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateForward(vec, out) {
        const lambda = this.preRotation[0];
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        if (lambda === 0 && phi === 0 && gamma === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        if (phi === 0 && gamma === 0) {
            return Vec2Math.set(rotatedLon, lat, out);
        }
        const cartesianVec = GeoPoint.sphericalToCartesian(lat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
        const rotatedCartesianVec = this.preRotationForwardTransform.apply(cartesianVec, cartesianVec);
        const rotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);
        return Vec2Math.set(rotated.lon, rotated.lat, out);
    }
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateReverse(vec, out) {
        const lambda = this.preRotation[0];
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        if (lambda === 0 && phi === 0 && gamma === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        let rotatedLat = lat;
        let rotatedLon = lon;
        if (phi !== 0 || gamma !== 0) {
            const rotatedCartesianVec = GeoPoint.sphericalToCartesian(rotatedLat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
            const cartesianVec = this.preRotationReverseTransform.apply(rotatedCartesianVec, rotatedCartesianVec);
            const unrotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);
            rotatedLat = unrotated.lat;
            rotatedLon = unrotated.lon;
        }
        rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    /** @inheritdoc */
    project(point, out) {
        if (point instanceof Float64Array) {
            out.set(point);
        }
        else {
            out[0] = point.lon;
            out[1] = point.lat;
        }
        this.preRotateForward(out, out);
        this.projectRaw(out, out);
        // translate projected center point to origin
        out[0] -= this.centerTranslation[0];
        out[1] -= this.centerTranslation[1];
        // apply y-reflection
        out[1] *= this.reflectY;
        // apply scale factor
        out[0] *= this.scaleFactor;
        out[1] *= this.scaleFactor;
        // apply post-projection rotation
        const x = out[0];
        const y = out[1];
        out[0] = x * this.rotationCos - y * this.rotationSin;
        out[1] = x * this.rotationSin + y * this.rotationCos;
        // apply post-projection translation
        out[0] += this.translation[0];
        out[1] += this.translation[1];
        return out;
    }
    /** @inheritdoc */
    invert(vec, out) {
        const projected = AbstractGeoProjection.vec2Cache[0];
        projected.set(vec);
        // invert post-projection translation
        projected[0] -= this.translation[0];
        projected[1] -= this.translation[1];
        // invert post-projection rotation
        const x = projected[0];
        const y = projected[1];
        projected[0] = x * this.rotationCos + y * this.rotationSin;
        projected[1] = -x * this.rotationSin + y * this.rotationCos;
        // invert scale factor
        projected[0] /= this.scaleFactor;
        projected[1] /= this.scaleFactor;
        // invert y-reflection
        projected[1] *= this.reflectY;
        // translate projected center point to default projected position
        projected[0] += this.centerTranslation[0];
        projected[1] += this.centerTranslation[1];
        const inverted = this.invertRaw(projected, projected);
        this.preRotateReverse(inverted, inverted);
        if (out instanceof Float64Array) {
            out.set(inverted);
            return out;
        }
        else {
            return out.set(inverted[1], inverted[0]);
        }
    }
}
AbstractGeoProjection.vec2Cache = [new Float64Array(2)];
AbstractGeoProjection.vec3Cache = [new Float64Array(3)];
AbstractGeoProjection.geoPointCache = [new GeoPoint(0, 0)];
/**
 * A Mercator projection.
 */
class MercatorProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    projectRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.DEG2RAD;
        out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
        return out;
    }
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    invertRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.RAD2DEG;
        out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
        return out;
    }
}

/**
 * Resamples projected great- and small-circle paths between defined endpoints into series of straight line segments and circular arcs.
 */
class GeoCircleResampler {
    /**
     * Constructor.
     * @param minDistance The minimum great-circle distance this resampler enforces between two adjacent resampled
     * points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance, in pixels, this resampler uses when deciding whether to discard
     * a resampled point during the simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by `2^[maxDepth] - 1`.
     */
    constructor(minDistance, dpTolerance, maxDepth) {
        this.minDistance = minDistance;
        this.dpTolerance = dpTolerance;
        this.maxDepth = maxDepth;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.startVector = {
            type: 'start',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            index: 0
        };
        this.lineVector = {
            type: 'line',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            index: 0
        };
        this.arcVector = {
            type: 'arc',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            projectedArcCenter: new Float64Array(2),
            projectedArcRadius: 0,
            projectedArcStartAngle: 0,
            projectedArcEndAngle: 0,
            index: 0
        };
        this.state = {
            index: 0,
            prevX: 0,
            prevY: 0,
            vectorType: 'line',
            arcCenterX: 0,
            arcCenterY: 0,
            arcRadius: 0,
            isArcCounterClockwise: false
        };
        this.cosMinDistance = Math.cos(minDistance);
        this.dpTolSq = dpTolerance * dpTolerance;
    }
    /**
     * Resamples a projected great- or small-circle path.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     */
    resample(projection, circle, start, end, handler) {
        let startPoint, startVec, endPoint, endVec;
        if (start instanceof Float64Array) {
            startPoint = this.geoPointCache[0].setFromCartesian(start);
            startVec = start;
        }
        else {
            startPoint = start;
            startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
        }
        if (end instanceof Float64Array) {
            endPoint = this.geoPointCache[0].setFromCartesian(end);
            endVec = end;
        }
        else {
            endPoint = end;
            endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
        }
        const startLat = startPoint.lat;
        const startLon = startPoint.lon;
        const endLat = endPoint.lat;
        const endLon = endPoint.lon;
        const startProjected = projection.project(start, this.vec2Cache[0]);
        const endProjected = projection.project(end, this.vec2Cache[1]);
        const startX = startProjected[0];
        const startY = startProjected[1];
        const endX = endProjected[0];
        const endY = endProjected[1];
        this.startVector.point.set(startLat, startLon);
        Vec2Math.copy(startProjected, this.startVector.projected);
        handler(this.startVector);
        this.state.index = 1;
        this.state.prevX = startX;
        this.state.prevY = startY;
        this.state.vectorType = 'line';
        const state = this.resampleHelper(projection, circle, startLat, startLon, startVec[0], startVec[1], startVec[2], startX, startY, endLat, endLon, endVec[0], endVec[1], endVec[2], endX, endY, handler, 0, this.state);
        this.callHandler(handler, endLat, endLon, endX, endY, state);
    }
    /**
     * Resamples a projected great- or small-circle path. This method will recursively split the path into two halves
     * and resample the midpoint. Based on the projected position of the midpoint relative to those of the start and end
     * points, the projected path is modeled as either a straight line from the start to the end or a circular arc
     * connecting the start, end, and midpoints. Recursion continues as long as the maximum depth has not been reached
     * and at least one of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * If the path is modeled as a line: the distance from the projected midpoint to the model line is greater than
     * this resampler's Douglas-Peucker tolerance.
     * * If the path is modeled as an arc: the distance from the projected one-quarter or the three-quarter point along
     * the path to the model arc is greater than this resampler's Douglas-Peucker tolerance.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param lat1 The latitude of the start of the path, in degrees.
     * @param lon1 The longitude of the start of the path, in degrees.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path, in pixels.
     * @param projY1 The y-component of the projected location of the start of the path, in pixels.
     * @param lat2 The latitude of the end of the path, in degrees.
     * @param lon2 The longitude of the end of the path, in degrees.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path, in pixels.
     * @param projY2 The y-component of the projected location of the end of the path, in pixels.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param state The current state of the resampling algorithm.
     * @returns The index of the next resampled point.
     */
    resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, state) {
        if (depth >= this.maxDepth) {
            return state;
        }
        const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
        const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
        const angularWidth = circle.angleAlong(startVec, endVec, Math.PI);
        if (angularWidth <= GeoCircle.ANGULAR_TOLERANCE) {
            return state;
        }
        const midVec = circle.offsetAngleAlong(startVec, angularWidth / 2, this.vec3Cache[2]);
        const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
        const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
        const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
        const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
        const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
        const midProjected = projection.project(midPoint, this.vec2Cache[2]);
        const lat0 = midPoint.lat;
        const lon0 = midPoint.lon;
        const x0 = midVec[0];
        const y0 = midVec[1];
        const z0 = midVec[2];
        const projX0 = midProjected[0];
        const projY0 = midProjected[1];
        const A = projX2 - projX1;
        const B = projY2 - projY1;
        const C = projX1 * projX1 - projX2 * projX2 + projY1 * projY1 - projY2 * projY2;
        const D = projX0 - projX1;
        const E = projY0 - projY1;
        const F = projX1 * projX1 - projX0 * projX0 + projY1 * projY1 - projY0 * projY0;
        // Calculate the Douglas-Peucker metric
        const det = 2 * (A * E - B * D);
        const dpDisSq = (det * det / 4) / deltaProjectedDot;
        if (dpDisSq > this.dpTolSq) {
            // Attempt to model the projected path with an arc
            // Find the center of circle containing the arc passing through the projected start, end, and mid points.
            const arcCenterX = (B * F - C * E) / det;
            const arcCenterY = (C * D - A * F) / det;
            const arcRadius = Math.hypot(arcCenterX - projX1, arcCenterY - projY1);
            const startToEndVec = Vec3Math.set(A, B, 0, this.vec3Cache[3]);
            const centerToMidVec = Vec3Math.set(projX0 - arcCenterX, projY0 - arcCenterY, 0, this.vec3Cache[4]);
            const cross = Vec3Math.cross(startToEndVec, centerToMidVec, this.vec3Cache[4]);
            state.vectorType = 'arc';
            state.arcCenterX = arcCenterX;
            state.arcCenterY = arcCenterY;
            state.arcRadius = arcRadius;
            state.isArcCounterClockwise = cross[2] > 0;
        }
        else {
            state.vectorType = 'line';
        }
        const cosDistance = Vec3Math.dot(startVec, midVec);
        if (cosDistance > this.cosMinDistance) { // cosine of distance increases with decreasing distance
            // We are below the minimum distance required to continue resampling -> decide if we need to continue or if
            // the path can satisfactorily be modeled as either a straight line or a circular arc.
            if (state.vectorType === 'line') {
                // The path can be modeled as a line.
                return state;
            }
            // To find whether the path can be modeled as an arc, we need to project the one-quarter and three-quarter points
            // along the path and find the projected points' distances from the arc modeled above. If the distances are
            // within the D-P tolerance, then the path can be modeled as an arc.
            const query = circle.offsetAngleAlong(startVec, angularWidth / 4, this.geoPointCache[0]);
            const projectedQuery = projection.project(query, this.vec2Cache[0]);
            let distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
            if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
                circle.offsetAngleAlong(startVec, 3 * angularWidth / 4, query);
                projection.project(query, projectedQuery);
                distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
                if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
                    return state;
                }
            }
        }
        state = this.resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, state);
        this.callHandler(handler, lat0, lon0, projX0, projY0, state);
        state.index++;
        state.prevX = projX0;
        state.prevY = projY0;
        return this.resampleHelper(projection, circle, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, state);
    }
    /**
     * Calls a handler function for a resampled point.
     * @param handler The handler function to call.
     * @param lat The latitude of the resampled point, in degrees.
     * @param lon The longitude of the resampled point, in degrees.
     * @param projX The x-coordinate of the projected resampled point, in pixels.
     * @param projY The y-coordinate of the projected resampled point, in pixels.
     * @param state The current state of the resampling algorithm.
     */
    callHandler(handler, lat, lon, projX, projY, state) {
        let vector;
        if (state.vectorType === 'line') {
            vector = this.lineVector;
        }
        else {
            vector = this.arcVector;
            Vec2Math.set(state.arcCenterX, state.arcCenterY, vector.projectedArcCenter);
            vector.projectedArcRadius = state.arcRadius;
            vector.projectedArcStartAngle = Math.atan2(state.prevY - state.arcCenterY, state.prevX - state.arcCenterX);
            vector.projectedArcEndAngle = Math.atan2(projY - state.arcCenterY, projX - state.arcCenterX);
            if (vector.projectedArcEndAngle < vector.projectedArcStartAngle !== state.isArcCounterClockwise) {
                vector.projectedArcEndAngle += state.isArcCounterClockwise ? -MathUtils.TWO_PI : MathUtils.TWO_PI;
            }
        }
        vector.point.set(lat, lon);
        Vec2Math.set(projX, projY, vector.projected);
        vector.index = state.index;
        handler(vector);
    }
}

/**
 * A publisher for AHRS information.
 */
class AhrsPublisher extends SimVarPublisher {
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['pitch_deg', { name: 'ATTITUDE INDICATOR PITCH DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['roll_deg', { name: 'ATTITUDE INDICATOR BANK DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg_true', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, map: (heading) => MagVar.magneticToTrue(heading, this.magVar), indexed: true }],
            ['delta_heading_rate', { name: 'DELTA HEADING RATE:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
            ['actual_hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
            ['actual_hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
            ['actual_pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
            ['actual_roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
        ]);
        super(simvars, bus, pacer);
        this.magVar = 0;
        (_a = this.needUpdateMagVar) !== null && _a !== void 0 ? _a : (this.needUpdateMagVar = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('hdg_deg_true')) {
            this.needUpdateMagVar = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needUpdateMagVar) {
            this.magVar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        }
        super.onUpdate();
    }
}

/**
 * A publisher for anti-ice system information.
 */
class AntiIcePublisher extends SimVarPublisher {
    /**
     * Creates an instance of an AntiIcePublisher.
     * @param bus The event bus to use with this instance.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        const engineIndexedSimVars = [
            ['anti_ice_engine_switch_on', { name: 'ENG ANTI ICE', type: SimVarValueType.Bool }],
            ['anti_ice_prop_switch_on', { name: 'PROP DEICE SWITCH', type: SimVarValueType.Bool }]
        ];
        const simvars = new Map(AntiIcePublisher.nonIndexedSimVars);
        // add engine-indexed simvars
        const engineCount = SimVar.GetSimVarValue('NUMBER OF ENGINES', SimVarValueType.Number);
        for (const [topic, simvar] of engineIndexedSimVars) {
            for (let i = 1; i <= engineCount; i++) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
    }
}
AntiIcePublisher.nonIndexedSimVars = [
    ['anti_ice_structural_switch_on', { name: 'STRUCTURAL DEICE SWITCH', type: SimVarValueType.Bool }],
    ['anti_ice_windshield_switch_on', { name: 'WINDSHIELD DEICE SWITCH', type: SimVarValueType.Bool }]
];

/**
 * A basic implementation of {@link Consumer}.
 */
class BasicConsumer {
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe, state = {}, currentHandler) {
        this.subscribe = subscribe;
        this.state = state;
        this.currentHandler = currentHandler;
        /** @inheritdoc */
        this.isConsumer = true;
        this.activeSubs = new Map();
    }
    /** @inheritdoc */
    handle(handler, paused = false) {
        let activeHandler;
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            activeHandler = (data) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.currentHandler(data, this.state, handler);
            };
        }
        else {
            activeHandler = handler;
        }
        let activeSubArray = this.activeSubs.get(handler);
        if (!activeSubArray) {
            activeSubArray = [];
            this.activeSubs.set(handler, activeSubArray);
        }
        const onDestroyed = (destroyed) => {
            const activeSubsArray = this.activeSubs.get(handler);
            if (activeSubsArray) {
                activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
                if (activeSubsArray.length === 0) {
                    this.activeSubs.delete(handler);
                }
            }
        };
        const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
        // Need to handle the case where the subscription is destroyed immediately
        if (sub.isAlive) {
            activeSubArray.push(sub);
        }
        else if (activeSubArray.length === 0) {
            this.activeSubs.delete(handler);
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        var _a;
        const activeSubArray = this.activeSubs.get(handler);
        if (activeSubArray) {
            (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
            if (activeSubArray.length === 0) {
                this.activeSubs.delete(handler);
            }
        }
    }
    /** @inheritdoc */
    atFrequency(frequency, immediateFirstPublish = true) {
        const initialState = {
            previousTime: Date.now(),
            firstRun: immediateFirstPublish
        };
        return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    getAtFrequencyHandler(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime || state.firstRun) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                if (state.firstRun) {
                    state.firstRun = false;
                }
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    withPrecision(precision) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    getWithPrecisionHandler(precision) {
        return (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
                state.hasLastValue = true;
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        };
    }
    /** @inheritdoc */
    whenChangedBy(amount) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    getWhenChangedByHandler(amount) {
        return (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (!state.hasLastValue || diff >= amount) {
                state.hasLastValue = true;
                state.lastValue = dataValue;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    whenChanged() {
        return new BasicConsumer(this.subscribe, { lastValue: '', hasLastValue: false }, this.getWhenChangedHandler());
    }
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    getWhenChangedHandler() {
        return (data, state, next) => {
            if (!state.hasLastValue || state.lastValue !== data) {
                state.hasLastValue = true;
                state.lastValue = data;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    onlyAfter(deltaTime) {
        return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    getOnlyAfterHandler(deltaTime) {
        return (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        };
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}
/**
 * A {@link Subscription} for a {@link BasicConsumer}.
 */
class ConsumerSubscription {
    /**
     * Constructor.
     * @param sub The event bus subscription backing this subscription.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(sub, onDestroy) {
        this.sub = sub;
        this.onDestroy = onDestroy;
    }
    /** @inheritdoc */
    get isAlive() {
        return this.sub.isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this.sub.isPaused;
    }
    /** @inheritdoc */
    get canInitialNotify() {
        return this.sub.canInitialNotify;
    }
    /** @inheritdoc */
    pause() {
        this.sub.pause();
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        this.sub.resume(initialNotify);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this.sub.destroy();
        this.onDestroy(this);
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new BasicConsumer((handler, paused) => {
            return this.bus.on(topic, handler, paused);
        });
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    ['ap_heading_selected', { name: 'AUTOPILOT HEADING LOCK DIR:1', type: SimVarValueType.Degree }],
    ['ap_heading_selected_1', { name: 'AUTOPILOT HEADING LOCK DIR:1', type: SimVarValueType.Degree }],
    ['ap_heading_selected_2', { name: 'AUTOPILOT HEADING LOCK DIR:2', type: SimVarValueType.Degree }],
    ['ap_heading_selected_3', { name: 'AUTOPILOT HEADING LOCK DIR:3', type: SimVarValueType.Degree }],
    ['ap_altitude_selected', { name: 'AUTOPILOT ALTITUDE LOCK VAR:1', type: SimVarValueType.Feet }],
    ['ap_altitude_selected_1', { name: 'AUTOPILOT ALTITUDE LOCK VAR:1', type: SimVarValueType.Feet }],
    ['ap_altitude_selected_2', { name: 'AUTOPILOT ALTITUDE LOCK VAR:2', type: SimVarValueType.Feet }],
    ['ap_altitude_selected_3', { name: 'AUTOPILOT ALTITUDE LOCK VAR:3', type: SimVarValueType.Feet }],
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_yd_status', { name: 'AUTOPILOT YAW DAMPER', type: SimVarValueType.Bool }],
    ['ap_heading_hold', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_hold', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_max_bank_id', { name: 'AUTOPILOT MAX BANK ID', type: SimVarValueType.Number }],
    ['ap_max_bank_value', { name: 'AUTOPILOT MAX BANK', type: SimVarValueType.Degree }],
    ['ap_wing_lvl_hold', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_hold', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['ap_toga_hold', { name: 'AUTOPILOT TAKEOFF POWER ACTIVE', type: SimVarValueType.Bool }],
    ['ap_vs_selected', { name: 'AUTOPILOT VERTICAL HOLD VAR:1', type: SimVarValueType.FPM }],
    ['ap_fpa_selected', { name: 'L:WT_AP_FPA_Target:1', type: SimVarValueType.Degree }],
    ['ap_ias_selected', { name: 'AUTOPILOT AIRSPEED HOLD VAR', type: SimVarValueType.Knots }],
    ['ap_mach_selected', { name: 'AUTOPILOT MACH HOLD VAR', type: SimVarValueType.Number }],
    ['ap_selected_speed_is_mach', { name: 'AUTOPILOT MANAGED SPEED IN MACH', type: SimVarValueType.Bool }],
    ['ap_selected_speed_is_manual', { name: 'L:XMLVAR_SpeedIsManuallySet', type: SimVarValueType.Bool }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_is_active_1', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:1', type: SimVarValueType.Bool }],
    ['flight_director_is_active_2', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:2', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }],
    ['ap_pitch_selected', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }]
]);
/**
 * Publishes autopilot data
 */
class AutopilotPublisher extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
        this.publish('ap_master_engage', true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
        this.publish('ap_master_disengage', true);
    }
    /**
     * Publish a YD engage event
     */
    publishYdEngage() {
        this.publish('ap_yd_engage', true);
    }
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage() {
        this.publish('ap_yd_disengage', true);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
        this.publish('ap_lock_set', lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
        this.publish('ap_lock_release', lock);
    }
}
/**
 * Manages an autopilot system
 */
class AutopilotInstrument {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
        this.bus = bus;
        // this.hEvents = this.bus.getSubscriber<HEvent>();
        this.publisher = new AutopilotPublisher(bus);
        this.simVarPublisher = new APSimVarPublisher(bus);
        this.simVarSubscriber = new EventSubscriber(bus);
    }
    /**
     * Initialize the instrument
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        // console.log('initting autopilot');
        this.simVarSubscriber.on('ap_master_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishMasterEngage();
            }
            else {
                this.publisher.publishMasterDisengage();
            }
        });
        this.simVarSubscriber.on('ap_yd_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishYdEngage();
            }
            else {
                this.publisher.publishYdDisengage();
            }
        });
        this.simVarSubscriber.on('ap_alt_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Alt);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Alt);
            }
        });
        this.simVarSubscriber.on('ap_pitch_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Pitch);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Pitch);
            }
        });
        this.simVarSubscriber.on('ap_heading_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Heading);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Heading);
            }
        });
        this.simVarSubscriber.on('ap_nav_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Nav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Nav);
            }
        });
        this.simVarSubscriber.on('ap_approach_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Approach);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Approach);
            }
        });
        this.simVarSubscriber.on('ap_backcourse_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Backcourse);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Backcourse);
            }
        });
        this.simVarSubscriber.on('ap_bank_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Bank);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Bank);
            }
        });
        this.simVarSubscriber.on('ap_wing_lvl_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.WingLevel);
            }
            else {
                this.publisher.publishLockRelease(APLockType.WingLevel);
            }
        });
        this.simVarSubscriber.on('ap_flc_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Flc);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Flc);
            }
        });
        this.simVarSubscriber.on('ap_vs_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Vs);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Vs);
            }
        });
        this.simVarSubscriber.on('ap_glideslope_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Glideslope);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Glideslope);
            }
        });
        this.simVarSubscriber.on('vnav_active').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.VNav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.VNav);
            }
        });
    }
    /** update our publishers */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/** A collection of helper functions dealing with radios and frequencies. */
class RadioUtils {
    /**
     * Checks whether a frequency is a NAV frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a NAV frequency.
     */
    static isNavFrequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 108e3 || freqKhz > 117950) {
            return false;
        }
        return freqKhz % 50 === 0;
    }
    /**
     * Checks if frequency is a localizer frequency based on the number.
     * @param freq The frequency to check, in megahertz.
     * @returns True if frequency is between 108.1 and 111.95 MHz (inclusive) and the tenths place is odd.
     */
    static isLocalizerFrequency(freq) {
        return freq >= 108.1 && freq <= 111.95 && (Math.trunc(freq * 10) % 2 === 1);
    }
    /**
     * Checks whether a frequency is a 8.33 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 8.33 kHz-spacing COM frequency.
     */
    static isCom833Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136990) {
            return false;
        }
        return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    /**
     * Checks whether a frequency is a 25 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 25 kHz-spacing COM frequency.
     */
    static isCom25Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136975) {
            return false;
        }
        return freqKhz % 25 === 0;
    }
    /**
     * Checks whether a frequency is an ADF frequency.
     * @param freq The frequency to check, in kilohertz.
     * @returns Whether the specified frequency is an ADF frequency.
     */
    static isAdfFrequency(freq) {
        const freqHz = Math.round(freq * 1000);
        if (freqHz < 190e3 || freqHz > 1799500) {
            return false;
        }
        return freqHz % 500 === 0;
    }
}
RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];

/**
 * VOR signal to/from flags.
 */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));
/**
 * A publisher of NAV, COM, ADF radio and marker beacon tuning-related sim var events.
 */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of NavComSimVarPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ...NavComSimVarPublisher.createNavRadioDefinitions(),
            ...NavComSimVarPublisher.createComRadioDefinitions(),
            ...NavComSimVarPublisher.createAdfRadioDefinitions(),
            ...NavComSimVarPublisher.createMarkerBeaconDefinitions(),
            ...NavComSimVarPublisher.createGpsDefinitions()
        ]);
        super(simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions.
     * @returns An array of nav radio sim var event definitions.
     */
    static createNavRadioDefinitions() {
        return [
            ['nav_active_frequency', { name: 'NAV ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_standby_frequency', { name: 'NAV STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_signal', { name: 'NAV SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_sound', { name: 'NAV SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_ident', { name: 'NAV IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_volume', { name: 'NAV VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_obs', { name: 'NAV OBS:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_dme', { name: 'NAV HAS DME:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_nav', { name: 'NAV HAS NAV:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_cdi', { name: 'NAV CDI:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme', { name: 'NAV DME:#index#', type: SimVarValueType.NM, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial', { name: 'NAV RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial_error', { name: 'NAV RADIAL ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_to_from', { name: 'NAV TOFROM:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer', { name: 'NAV HAS LOCALIZER:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer_crs', { name: 'NAV LOCALIZER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_airport_ident', { name: 'NAV LOC AIRPORT IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_designator', { name: 'NAV LOC RUNWAY DESIGNATOR:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_number', { name: 'NAV LOC RUNWAY NUMBER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_glideslope', { name: 'NAV HAS GLIDE SLOPE:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_error', { name: 'NAV GLIDE SLOPE ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_raw_gs', { name: 'NAV RAW GLIDE SLOPE:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_lla', { name: 'NAV VOR LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme_lla', { name: 'NAV DME LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_lla', { name: 'NAV GS LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_magvar', { name: 'NAV MAGVAR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of com radio sim var event definitions.
     * @returns An array of com radio sim var event definitions.
     */
    static createComRadioDefinitions() {
        return [
            ['com_active_frequency', { name: 'COM ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_standby_frequency', { name: 'COM STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_name', { name: 'COM ACTIVE FREQ NAME:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_type', { name: 'COM ACTIVE FREQ TYPE:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_ident', { name: 'COM ACTIVE FREQ IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            // Note: 'COM RECEIVE' is whether the radio is receiving OR transmitting,
            // whereas 'COM RECEIVE EX1' is exclusively its receiving state.
            ['com_receive', { name: 'COM RECEIVE EX1:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_status', { name: 'COM STATUS:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_transmit', { name: 'COM TRANSMIT:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_spacing_mode', { name: 'COM SPACING MODE:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_volume', { name: 'COM VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3], defaultIndex: null }],
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions.
     * @returns An array of ADF radio sim var event definitions.
     */
    static createAdfRadioDefinitions() {
        return [
            ['adf_active_frequency', { name: 'ADF ACTIVE FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_standby_frequency', { name: 'ADF STANDBY FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_sound', { name: 'ADF SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['adf_volume', { name: 'ADF VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2], defaultIndex: null }],
            ['adf_ident', { name: 'ADF IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2], defaultIndex: null }],
            ['adf_signal', { name: 'ADF SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['adf_bearing', { name: 'ADF RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2], defaultIndex: null }],
            ['adf_lla', { name: 'ADF LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createMarkerBeaconDefinitions() {
        return [
            ['marker_beacon_hisense_on', { name: 'MARKER BEACON SENSITIVITY HIGH', type: SimVarValueType.Bool }],
            ['marker_beacon_sound', { name: 'MARKER SOUND', type: SimVarValueType.Bool }],
            ['marker_beacon_state', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
            ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createGpsDefinitions() {
        return [
            ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
            ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
            ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
            ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
            ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
            ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
            ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
        ];
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher of nav radio, ADF radio, GPS, and marker beacon-related sim var events.
 *
 * @deprecated Please use `NavComSimVarPublisher` instead.
 */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    static createNavRadioDefinitions(index) {
        return [
            [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
            [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
            [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
            [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
            [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
            [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`nav_radial_error_${index}`, { name: `NAV RADIAL ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
            [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
            [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
            [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
            [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
            [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    static createAdfRadioDefinitions(index) {
        return [
            [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
        ];
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 *
 * Requires that the topics defined in {@link NavComEvents} are published to the event bus.
 */
class APRadioNavInstrument {
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.navRadioData = {
            0: {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index: 1, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index: 1, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index: 1, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index: 1, type: NavSourceType.Nav }),
                magVar: 0
            },
            1: {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index: 1, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index: 1, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index: 1, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index: 1, type: NavSourceType.Nav }),
                magVar: 0
            },
            2: {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index: 2, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index: 2, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index: 2, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index: 2, type: NavSourceType.Nav }),
                magVar: 0
            },
            3: {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index: 3, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index: 3, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index: 3, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index: 3, type: NavSourceType.Nav }),
                magVar: 0
            },
            4: {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index: 4, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index: 4, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index: 4, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index: 4, type: NavSourceType.Nav }),
                magVar: 0
            }
        };
        this.currentCdiIndex = 1;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    init() {
        const navComSubscriber = this.bus.getSubscriber();
        navComSubscriber.on('nav_glideslope_1').whenChanged().handle(hasGs => this.setGlideslopeValue(1, 'isValid', hasGs));
        navComSubscriber.on('nav_gs_lla_1').handle(lla => this.setGlideslopePosition(1, lla));
        navComSubscriber.on('nav_gs_error_1').whenChanged().handle(gsError => this.setGlideslopeValue(1, 'deviation', gsError));
        navComSubscriber.on('nav_raw_gs_1').whenChanged().handle(rawGs => this.setGlideslopeValue(1, 'gsAngle', rawGs));
        navComSubscriber.on('nav_localizer_1').whenChanged().handle(hasLoc => this.setLocalizerValue(1, 'isValid', hasLoc));
        navComSubscriber.on('nav_localizer_crs_1').whenChanged().handle(locCourse => this.setLocalizerValue(1, 'course', locCourse));
        navComSubscriber.on('nav_cdi_1').whenChanged().handle(deviation => this.setCDIValue(1, 'deviation', deviation));
        navComSubscriber.on('nav_obs_1').whenChanged().handle(obs => this.setOBSValue(1, 'heading', obs));
        navComSubscriber.on('nav_lla_1').handle(lla => this.setNavPosition(1, lla));
        navComSubscriber.on('nav_magvar_1').whenChanged().handle(magVar => this.setMagVar(1, magVar));
        navComSubscriber.on('nav_has_nav_1').whenChanged().handle(hasNav => !hasNav && this.setCDIValue(1, 'deviation', null));
        navComSubscriber.on('nav_glideslope_2').whenChanged().handle(hasGs => this.setGlideslopeValue(2, 'isValid', hasGs));
        navComSubscriber.on('nav_gs_lla_2').handle(lla => this.setGlideslopePosition(2, lla));
        navComSubscriber.on('nav_gs_error_2').whenChanged().handle(gsError => this.setGlideslopeValue(2, 'deviation', gsError));
        navComSubscriber.on('nav_raw_gs_2').whenChanged().handle(rawGs => this.setGlideslopeValue(2, 'gsAngle', rawGs));
        navComSubscriber.on('nav_localizer_2').whenChanged().handle(hasLoc => this.setLocalizerValue(2, 'isValid', hasLoc));
        navComSubscriber.on('nav_localizer_crs_2').whenChanged().handle(locCourse => this.setLocalizerValue(2, 'course', locCourse));
        navComSubscriber.on('nav_cdi_2').whenChanged().handle(deviation => this.setCDIValue(2, 'deviation', deviation));
        navComSubscriber.on('nav_obs_2').whenChanged().handle(obs => this.setOBSValue(2, 'heading', obs));
        navComSubscriber.on('nav_lla_2').handle(lla => this.setNavPosition(2, lla));
        navComSubscriber.on('nav_magvar_2').whenChanged().handle(magVar => this.setMagVar(2, magVar));
        navComSubscriber.on('nav_has_nav_2').whenChanged().handle(hasNav => !hasNav && this.setCDIValue(2, 'deviation', null));
        navComSubscriber.on('nav_glideslope_3').whenChanged().handle(hasGs => this.setGlideslopeValue(3, 'isValid', hasGs));
        navComSubscriber.on('nav_gs_lla_3').handle(lla => this.setGlideslopePosition(3, lla));
        navComSubscriber.on('nav_gs_error_3').whenChanged().handle(gsError => this.setGlideslopeValue(3, 'deviation', gsError));
        navComSubscriber.on('nav_raw_gs_3').whenChanged().handle(rawGs => this.setGlideslopeValue(3, 'gsAngle', rawGs));
        navComSubscriber.on('nav_localizer_3').whenChanged().handle(hasLoc => this.setLocalizerValue(3, 'isValid', hasLoc));
        navComSubscriber.on('nav_localizer_crs_3').whenChanged().handle(locCourse => this.setLocalizerValue(3, 'course', locCourse));
        navComSubscriber.on('nav_cdi_3').whenChanged().handle(deviation => this.setCDIValue(3, 'deviation', deviation));
        navComSubscriber.on('nav_obs_3').whenChanged().handle(obs => this.setOBSValue(3, 'heading', obs));
        navComSubscriber.on('nav_lla_3').handle(lla => this.setNavPosition(3, lla));
        navComSubscriber.on('nav_magvar_3').whenChanged().handle(magVar => this.setMagVar(3, magVar));
        navComSubscriber.on('nav_has_nav_3').whenChanged().handle(hasNav => !hasNav && this.setCDIValue(3, 'deviation', null));
        navComSubscriber.on('nav_glideslope_4').whenChanged().handle(hasGs => this.setGlideslopeValue(4, 'isValid', hasGs));
        navComSubscriber.on('nav_gs_lla_4').handle(lla => this.setGlideslopePosition(4, lla));
        navComSubscriber.on('nav_gs_error_4').whenChanged().handle(gsError => this.setGlideslopeValue(4, 'deviation', gsError));
        navComSubscriber.on('nav_raw_gs_4').whenChanged().handle(rawGs => this.setGlideslopeValue(4, 'gsAngle', rawGs));
        navComSubscriber.on('nav_localizer_4').whenChanged().handle(hasLoc => this.setLocalizerValue(4, 'isValid', hasLoc));
        navComSubscriber.on('nav_localizer_crs_4').whenChanged().handle(locCourse => this.setLocalizerValue(4, 'course', locCourse));
        navComSubscriber.on('nav_cdi_4').whenChanged().handle(deviation => this.setCDIValue(4, 'deviation', deviation));
        navComSubscriber.on('nav_obs_4').whenChanged().handle(obs => this.setOBSValue(4, 'heading', obs));
        navComSubscriber.on('nav_lla_4').handle(lla => this.setNavPosition(4, lla));
        navComSubscriber.on('nav_magvar_4').whenChanged().handle(magVar => this.setMagVar(4, magVar));
        navComSubscriber.on('nav_has_nav_4').whenChanged().handle(hasNav => !hasNav && this.setCDIValue(4, 'deviation', null));
        const navEvents = this.bus.getSubscriber();
        navEvents.on('cdi_select').handle(source => {
            const oldIndex = this.currentCdiIndex;
            this.currentCdiIndex = source.type === NavSourceType.Nav ? source.index : 0;
            if (oldIndex !== this.currentCdiIndex) {
                const data = this.navRadioData[this.currentCdiIndex];
                this.publisher.pub('nav_radio_active_gs_location', data.gsLocation);
                this.publisher.pub('nav_radio_active_nav_location', data.navLocation);
                this.publisher.pub('nav_radio_active_glideslope', data.glideslope);
                this.publisher.pub('nav_radio_active_localizer', data.localizer);
                this.publisher.pub('nav_radio_active_cdi_deviation', data.cdi);
                this.publisher.pub('nav_radio_active_obs_setting', data.obs);
                this.publisher.pub('nav_radio_active_magvar', data.magVar);
            }
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setGlideslopeValue(index, field, value) {
        this.navRadioData[index].glideslope[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_glideslope', this.navRadioData[index].glideslope);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_glideslope_1', this.navRadioData[index].glideslope);
                break;
            case 2:
                this.publisher.pub('nav_radio_glideslope_2', this.navRadioData[index].glideslope);
                break;
            case 3:
                this.publisher.pub('nav_radio_glideslope_3', this.navRadioData[index].glideslope);
                break;
            case 4:
                this.publisher.pub('nav_radio_glideslope_4', this.navRadioData[index].glideslope);
                break;
        }
    }
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setGlideslopePosition(index, lla) {
        this.navRadioData[index].gsLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_gs_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_gs_location_1', this.navRadioData[index].gsLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_gs_location_2', this.navRadioData[index].gsLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_gs_location_3', this.navRadioData[index].gsLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_gs_location_4', this.navRadioData[index].gsLocation);
                break;
        }
    }
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setNavPosition(index, lla) {
        this.navRadioData[index].navLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_nav_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_nav_location_1', this.navRadioData[index].navLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_nav_location_2', this.navRadioData[index].navLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_nav_location_3', this.navRadioData[index].navLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_nav_location_4', this.navRadioData[index].navLocation);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setLocalizerValue(index, field, value) {
        this.navRadioData[index].localizer[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_localizer', this.navRadioData[index].localizer);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_localizer_1', this.navRadioData[index].localizer);
                break;
            case 2:
                this.publisher.pub('nav_radio_localizer_2', this.navRadioData[index].localizer);
                break;
            case 3:
                this.publisher.pub('nav_radio_localizer_3', this.navRadioData[index].localizer);
                break;
            case 4:
                this.publisher.pub('nav_radio_localizer_4', this.navRadioData[index].localizer);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setCDIValue(index, field, value) {
        this.navRadioData[index].cdi[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_cdi_deviation', this.navRadioData[index].cdi);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_cdi_1', this.navRadioData[index].cdi);
                break;
            case 2:
                this.publisher.pub('nav_radio_cdi_2', this.navRadioData[index].cdi);
                break;
            case 3:
                this.publisher.pub('nav_radio_cdi_3', this.navRadioData[index].cdi);
                break;
            case 4:
                this.publisher.pub('nav_radio_cdi_4', this.navRadioData[index].cdi);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setOBSValue(index, field, value) {
        this.navRadioData[index].obs[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_obs_setting', this.navRadioData[index].obs);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_obs_1', this.navRadioData[index].obs);
                break;
            case 2:
                this.publisher.pub('nav_radio_obs_2', this.navRadioData[index].obs);
                break;
            case 3:
                this.publisher.pub('nav_radio_obs_3', this.navRadioData[index].obs);
                break;
            case 4:
                this.publisher.pub('nav_radio_obs_4', this.navRadioData[index].obs);
                break;
        }
    }
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    setMagVar(index, magVar) {
        magVar = NavMath.normalizeHeading(-magVar + 180) % 360 - 180;
        this.navRadioData[index].magVar = magVar;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_magvar', magVar);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_magvar_1', this.navRadioData[index].magVar);
                break;
            case 2:
                this.publisher.pub('nav_radio_magvar_2', this.navRadioData[index].magVar);
                break;
            case 3:
                this.publisher.pub('nav_radio_magvar_3', this.navRadioData[index].magVar);
                break;
            case 4:
                this.publisher.pub('nav_radio_magvar_4', this.navRadioData[index].magVar);
                break;
        }
    }
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    createEmptyLocalizer(id) {
        return {
            isValid: false,
            course: 0,
            source: id
        };
    }
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    createEmptyGlideslope(id) {
        return {
            isValid: false,
            gsAngle: 0,
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    createEmptyCdi(id) {
        return {
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    createEmptyObs(id) {
        return {
            heading: 0,
            source: id
        };
    }
}

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to this backplane.
     * @param name A symbolic name for the publisher for reference.
     * @param publisher The publisher to add.
     * @param override Whether to override any existing publishers added to this backplane under the same name. If
     * `true`, any existing publisher with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new publisher will not be added if this backplane already has a publisher with the same
     * name or a publisher of the same type. Defaults to `false`.
     */
    addPublisher(name, publisher, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, publisher, this.publishers)) {
            this.publishers.set(name, publisher);
        }
    }
    /**
     * Add an instrument to this backplane.
     * @param name A symbolic name for the instrument for reference.
     * @param instrument The instrument to add.
     * @param override Whether to override any existing instruments added to this backplane under the same name. If
     * `true`, any existing instrument with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new instrument will not be added if this backplane already has an instrument with the same
     * name or an instrument of the same type. Defaults to `false`.
     */
    addInstrument(name, instrument, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, instrument, this.instruments)) {
            this.instruments.set(name, instrument);
        }
    }
    /**
     * Gets a publisher from this backplane.
     * @param name The name of the publisher to get.
     * @returns The publisher in this backplane with the specified name, or `undefined` if there is no such publisher.
     */
    getPublisher(name) {
        return this.publishers.get(name);
    }
    /**
     * Gets an instrument from this backplane.
     * @param name The name of the instrument to get.
     * @returns The instrument in this backplane with the specified name, or `undefined` if there is no such instrument.
     */
    getInstrument(name) {
        return this.instruments.get(name);
    }
    /**
     * Checks for duplicate publishers or instruments of the same name or type.
     * @param name the name of the publisher or instrument
     * @param objToCheck the object to check
     * @param map the map to check
     * @returns true if the object is already in the map
     */
    static checkAlreadyExists(name, objToCheck, map) {
        if (map.has(name)) {
            console.warn(`${name} already exists in backplane.`);
            return true;
        }
        // check if there already is a publisher with the same type
        for (const p of map.values()) {
            if (p.constructor === objToCheck.constructor) {
                console.warn(`${name} already exists in backplane.`);
                return true;
            }
        }
        return false;
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Brake information.
 */
class BrakeSimvarPublisher extends SimVarPublisher {
    /**
     * Create a BrakePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['brake_position_left', { name: 'BRAKE LEFT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_right', { name: 'BRAKE RIGHT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_left_raw', { name: 'BRAKE LEFT POSITION EX1', type: SimVarValueType.Percent }],
            ['brake_position_right_raw', { name: 'BRAKE RIGHT POSITION EX1', type: SimVarValueType.Percent }],
            ['left_wheel_rpm', { name: 'LEFT WHEEL RPM', type: SimVarValueType.RPM }],
            ['right_wheel_rpm', { name: 'RIGHT WHEEL RPM', type: SimVarValueType.RPM }],
            ['parking_brake_set', { name: 'BRAKE PARKING POSITION', type: SimVarValueType.Bool }],
            ['autobrake_switch_pos', { name: 'AUTO BRAKE SWITCH CB', type: SimVarValueType.Number }],
            ['autobrake_active', { name: 'AUTOBRAKES ACTIVE', type: SimVarValueType.Bool }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    /**
     * Creates a new instance of ClockPublisher.
     * @param bus The event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
        this.needPublishRealTime = false;
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['simTime', { name: 'E:ABSOLUTE TIME', type: SimVarValueType.Seconds, map: ClockPublisher.absoluteTimeToUNIXTime }],
            ['simRate', { name: 'E:SIMULATION RATE', type: SimVarValueType.Number }]
        ]), bus, pacer);
        if (this.bus.getTopicSubscriberCount('realTime') > 0) {
            this.needPublishRealTime = true;
        }
        else {
            const sub = this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
                if (topic === 'realTime') {
                    this.needPublishRealTime = true;
                    sub.destroy();
                }
            }, true);
            sub.resume();
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
        if (this.hiFreqInterval === undefined) {
            this.hiFreqInterval = setInterval(() => this.publish('simTimeHiFreq', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds'))), 0);
        }
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
        if (this.hiFreqInterval !== undefined) {
            clearInterval(this.hiFreqInterval);
            this.hiFreqInterval = undefined;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needPublishRealTime) {
            this.publish('realTime', Date.now());
        }
        this.simVarPublisher.onUpdate();
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}
/**
 * A clock which keeps track of real-world and sim time.
 */
class Clock {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
        this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
        this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
        this.publisher.onUpdate();
    }
}

/**
 * A publisher for control surfaces information.
 */
class ControlSurfacesPublisher extends SimVarPublisher {
    /**
     * Create an ControlSurfacesPublisher.
     * @param bus The EventBus to publish to.
     * @param gearCount The number of landing gear to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, gearCount, pacer) {
        const nonIndexedSimVars = [
            ['flaps_handle_index', { name: 'FLAPS HANDLE INDEX', type: SimVarValueType.Number }],
            ['flaps_left_angle', { name: 'TRAILING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_right_angle', { name: 'TRAILING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_left_percent', { name: 'TRAILING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['flaps_right_percent', { name: 'TRAILING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['slats_left_angle', { name: 'LEADING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['slats_right_angle', { name: 'LEADING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['slats_left_percent', { name: 'LEADING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['slats_right_percent', { name: 'LEADING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['spoilers_left_percent', { name: 'SPOILERS LEFT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_right_percent', { name: 'SPOILERS RIGHT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_without_spoilerons_left_percent', { name: 'SPOILERS WITHOUT SPOILERONS LEFT POSITION', type: SimVarValueType.Percent }],
            ['elevator_trim_angle', { name: 'ELEVATOR TRIM POSITION', type: SimVarValueType.Degree }],
            ['elevator_trim_pct', { name: 'ELEVATOR TRIM PCT', type: SimVarValueType.Percent }],
            ['elevator_trim_neutral_pct', { name: 'AIRCRAFT ELEVATOR TRIM NEUTRAL', type: SimVarValueType.Percent }],
            ['aileron_trim_angle', { name: 'AILERON TRIM', type: SimVarValueType.Degree }],
            ['aileron_trim_pct', { name: 'AILERON TRIM PCT', type: SimVarValueType.Percent }],
            ['rudder_trim_angle', { name: 'RUDDER TRIM', type: SimVarValueType.Degree }],
            ['rudder_trim_pct', { name: 'RUDDER TRIM PCT', type: SimVarValueType.Percent }],
            ['aileron_left_percent', { name: 'AILERON LEFT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['aileron_right_percent', { name: 'AILERON RIGHT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['elevator_percent', { name: 'ELEVATOR DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['rudder_percent', { name: 'RUDDER DEFLECTION PCT', type: SimVarValueType.Percent }]
        ];
        const gearIndexedSimVars = [
            ['gear_position', { name: 'GEAR POSITION', type: SimVarValueType.Number }],
            ['gear_is_on_ground', { name: 'GEAR IS ON GROUND', type: SimVarValueType.Bool }]
        ];
        const simvars = new Map(nonIndexedSimVars);
        // set un-indexed simvar topics to pull from index 0
        for (const [topic, simvar] of [...gearIndexedSimVars]) {
            simvars.set(`${topic}`, {
                name: `${simvar.name}:0`,
                type: simvar.type,
                map: simvar.map
            });
        }
        // add landing gear indexed simvar topics
        // HINT: for some reason index 0 is nose. not 1-based.
        gearCount = Math.max(gearCount, 1);
        for (let i = 0; i < gearCount; i++) {
            for (const [topic, simvar] of gearIndexedSimVars) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
    }
}

/**
 * A publisher for control surfaces information.
 */
class HydraulicsPublisher extends SimVarPublisher {
    /**
     * Create an HydraulicsPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['hyd_pump_switch_state', { name: 'HYDRAULIC SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['hyd_pressure', { name: 'HYDRAULIC PRESSURE:#index#', type: SimVarValueType.PSI, indexed: true }],
            ['hyd_reservoir_perc', { name: 'HYDRAULIC RESERVOIR PERCENT:#index#', type: SimVarValueType.Percent, indexed: true }]
        ]);
        super(simvars, bus, pacer);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use generic listener event sync (default false).
     * If true, FlowEventSync will only work for gauges.
     * @param shouldResync Whether the eventbus should ask for a resync of all previously cached events (default true)
     */
    constructor(useAlternativeEventSync = false, shouldResync = true) {
        this._topicSubsMap = new Map();
        this._wildcardSubs = new Array();
        this._notifyDepthMap = new Map();
        this._wildcardNotifyDepth = 0;
        this._eventCache = new Map();
        this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
        this._busId = Math.floor(Math.random() * 2147483647);
        // fallback to flowevent when genericdatalistener not avail (su9)
        useAlternativeEventSync = (typeof RegisterGenericDataListener === 'undefined');
        const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        if (shouldResync === true) {
            this.syncEvent('event_bus', 'resync_request', false);
            this.on('event_bus', (data) => {
                if (data == 'resync_request') {
                    this.resyncEvents();
                }
            });
        }
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic, handler, paused = false) {
        let subs = this._topicSubsMap.get(topic);
        if (subs === undefined) {
            this._topicSubsMap.set(topic, subs = []);
            this.pub('event_bus_topic_first_sub', topic, false, false);
        }
        const initialNotifyFunc = (sub) => {
            const lastState = this._eventCache.get(topic);
            if (lastState !== undefined) {
                sub.handler(lastState.data);
            }
        };
        const onDestroyFunc = (sub) => {
            var _a;
            // If we are not in the middle of a notify operation, remove the subscription.
            // Otherwise, do nothing and let the post-notify clean-up code handle it.
            if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
                const subsToSplice = this._topicSubsMap.get(topic);
                if (subsToSplice) {
                    subsToSplice.splice(subsToSplice.indexOf(sub), 1);
                }
            }
        };
        const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
        subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic, handler) {
        const handlers = this._topicSubsMap.get(topic);
        const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler) {
        const sub = new HandlerSubscription(handler, undefined, this.onWildcardSubDestroyedFunc);
        this._wildcardSubs.push(sub);
        return sub;
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler) {
        const toDestroy = this._wildcardSubs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        var _a;
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const subs = this._topicSubsMap.get(topic);
        if (subs !== undefined) {
            let needCleanUpSubs = false;
            const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
            this._notifyDepthMap.set(topic, notifyDepth + 1);
            const len = subs.length;
            for (let i = 0; i < len; i++) {
                try {
                    const sub = subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(data);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            this._notifyDepthMap.set(topic, notifyDepth);
            if (needCleanUpSubs && notifyDepth === 0) {
                const filteredSubs = subs.filter(sub => sub.isAlive);
                this._topicSubsMap.set(topic, filteredSubs);
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        let needCleanUpSubs = false;
        this._wildcardNotifyDepth++;
        const wcLen = this._wildcardSubs.length;
        for (let i = 0; i < wcLen; i++) {
            const sub = this._wildcardSubs[i];
            if (sub.isAlive && !sub.isPaused) {
                sub.handler(topic, data);
            }
            needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        }
        this._wildcardNotifyDepth--;
        if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
            this._wildcardSubs = this._wildcardSubs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    onWildcardSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this._wildcardNotifyDepth === 0) {
            this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic) {
        var _a, _b;
        return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Executes a function once for each topic with at least one subscriber.
     * @param fn The function to execute.
     */
    forEachSubscribedTopic(fn) {
        this._topicSubsMap.forEach((subs, topic) => { subs.length > 0 && fn(topic, subs.length); });
    }
}
/**
 * An abstract class for bus sync implementations.
 */
class EventBusSyncBase {
    /**
     * Creates an instance of EventBusFlowEventSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.
     */
    constructor(recvEventCb, busId) {
        this.isPaused = false;
        this.lastEventSynced = -1;
        this.dataPackageQueue = [];
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.hookReceiveEvent();
        /** Sends the queued up data packages */
        const sendFn = () => {
            if (!this.isPaused && this.dataPackageQueue.length > 0) {
                // console.log(`Sending ${this.dataPackageQueue.length} packages`);
                const syncDataPackage = {
                    busId: this.busId,
                    packagedId: Math.floor(Math.random() * 1000000000),
                    data: this.dataPackageQueue
                };
                if (this.executeSync(syncDataPackage)) {
                    this.dataPackageQueue.length = 0;
                }
                else {
                    console.warn('Failed to send sync data package');
                }
            }
            requestAnimationFrame(sendFn);
        };
        requestAnimationFrame(sendFn);
    }
    /**
     * Processes events received and sends them onto the local bus.
     * @param syncData The data package to process.
     */
    processEventsReceived(syncData) {
        if (this.busId !== syncData.busId) {
            // HINT: coherent events are still received twice, so check for this
            if (this.lastEventSynced !== syncData.packagedId) {
                this.lastEventSynced = syncData.packagedId;
                syncData.data.forEach((data) => {
                    try {
                        this.recvEventCb(data.topic, data.data !== undefined ? data.data : undefined, false, data.isCached);
                    }
                    catch (e) {
                        console.error(e);
                        if (e instanceof Error) {
                            console.error(e.stack);
                        }
                    }
                });
            }
        }
    }
    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // stringify data
        const dataObj = data;
        // build a data package
        const dataPackage = {
            topic: topic,
            data: dataObj,
            isCached: isCached
        };
        // queue data package
        this.dataPackageQueue.push(dataPackage);
    }
}
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 * DON'T USE this, it has bad performance implications.
 * @deprecated
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
class EventBusCoherentSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // HINT: Stringifying the data again to circumvent the bad perf on Coherent interop
        try {
            this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, undefined, true);
        this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
            try {
                const evt = JSON.parse(e);
                this.processEventsReceived(evt);
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 */
class EventBusFlowEventSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // console.log('Sending sync package: ' + syncDataPackage.packagedId);
        try {
            LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        Coherent.on('OnInteractionEvent', (target, args) => {
            // identify if its a busevent
            if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
                return;
            }
            this.processEventsReceived(JSON.parse(args[2]));
        });
    }
}
EventBusFlowEventSync.EB_LISTENER_KEY = 'EB_EVENTS';
//// END GLOBALS DECLARATION
/**
 * A class that manages event bus synchronization via the Generic Data Listener.
 */
class EventBusListenerSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        try {
            this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        // pause the sync until the listener is ready
        this.isPaused = true;
        this.listener = RegisterGenericDataListener(() => {
            this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
                try {
                    this.processEventsReceived(data);
                }
                catch (error) {
                    console.error(error);
                }
            });
            this.isPaused = false;
        });
    }
}
EventBusListenerSync.EB_KEY = 'wt.eb.evt';
EventBusListenerSync.EB_LISTENER_KEY = 'JS_LISTENER_GENERICDATA';

/**
 * Captures the state of a value from a consumer.
 */
class ConsumerValue {
    /**
     * Creates an instance of a ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     */
    constructor(consumer, initialValue) {
        this.consumerHandler = (v) => { this.value = v; };
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialValue;
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused. While paused, this object's value will not update.
     */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Gets the current value.
     * @returns The current value.
     */
    get() {
        return this.value;
    }
    /**
     * Sets the consumer from which this object derives its value. If the consumer is null, this object's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This object, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this object. Once paused, this object's value will not be updated.
     * @returns This object, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this object. Once resumed, this object's value will be updated from consumed
     * events.
     * @returns This object, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /**
     * Destroys this object. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        this.isDestroyed = true;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * Creates a new ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     * @returns The created ConsumerValue.
     */
    static create(consumer, initialValue) {
        return new ConsumerValue(consumer, initialValue);
    }
}

/**
 * A publisher for publishing H:Events on the bus.
 */
class HEventPublisher extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
        // console.log(`dispaching hevent:  ${hEvent}`);
        this.publish('hEvent', hEvent, sync, false);
    }
}

/**
 * A subscribable subject which derives its value from an event consumer.
 */
class ConsumerSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
        super();
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.consumerHandler = this.onEventConsumed.bind(this);
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialVal;
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
        return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    onEventConsumed(value) {
        if (!this.equalityFunc(this.value, value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isDestroyed = true;
    }
}

/**
 * A utility class which provides the current game state.
 */
class GameStateProvider {
    /**
     * Constructor.
     */
    constructor() {
        this.gameState = Subject.create(undefined);
        window.document.addEventListener('OnVCockpitPanelAttributesChanged', this.onAttributesChanged.bind(this));
        this.onAttributesChanged();
    }
    /**
     * Responds to changes in document attributes.
     */
    onAttributesChanged() {
        var _a;
        if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute('gamestate')) {
            const attribute = window.parent.document.body.getAttribute('gamestate');
            if (attribute !== null) {
                this.gameState.set(GameState[attribute]);
                return;
            }
        }
        this.gameState.set(undefined);
    }
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get() {
        var _a;
        return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : (GameStateProvider.INSTANCE = new GameStateProvider())).gameState;
    }
}

/**
 * A manager for key events. Allows key events to be triggered and intercepted, and also publishes intercepted key
 * events on the event bus.
 */
class KeyEventManager {
    /**
     * Constructor.
     * @param keyListener The Coherent key intercept view listener.
     * @param bus The event bus.
     */
    constructor(keyListener, bus) {
        this.keyListener = keyListener;
        this.bus = bus;
        Coherent.on('keyIntercepted', this.onKeyIntercepted.bind(this));
    }
    /**
     * Responds to key intercept events.
     * @param key The key that was intercepted.
     * @param value1 The second data value of the key event.
     * @param value0 The first data value of the key event.
     * @param value2 The third data value of the key event.
     */
    onKeyIntercepted(key, value1, value0, value2) {
        // Even though values are uint32, we will do what the sim does and pretend they're actually sint32
        if (value0 !== undefined && value0 >= 2147483648) {
            value0 -= 4294967296;
        }
        this.bus.pub('key_intercept', { key, value0, value1, value2 }, false, false);
    }
    /**
     * Triggers a key event.
     * @param key The key to trigger.
     * @param bypass Whether the event should bypass intercepts.
     * @param value0 The first data value of the key event. Defaults to `0`.
     * @param value1 The second data value of the key event. Defaults to `0`.
     * @param value2 The third data value of the key event. Defaults to `0`.
     * @returns A Promise which is fulfilled after the key event has been triggered.
     */
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
        return Coherent.call('TRIGGER_KEY_EVENT', key, bypass, value0, value1, value2);
    }
    /**
     * Enables interception for a key.
     * @param key The key to intercept.
     * @param passThrough Whether to pass the event through to the sim after it has been intercepted.
     */
    interceptKey(key, passThrough) {
        Coherent.call('INTERCEPT_KEY_EVENT', key, passThrough ? 0 : 1);
    }
    /**
     * Gets an instance of KeyEventManager. If an instance does not already exist, a new one will be created.
     * @param bus The event bus.
     * @returns A Promise which will be fulfilled with an instance of KeyEventManager.
     */
    static getManager(bus) {
        if (KeyEventManager.INSTANCE) {
            return Promise.resolve(KeyEventManager.INSTANCE);
        }
        if (!KeyEventManager.isCreatingInstance) {
            KeyEventManager.createInstance(bus);
        }
        return new Promise(resolve => {
            KeyEventManager.pendingPromiseResolves.push(resolve);
        });
    }
    /**
     * Creates an instance of KeyEventManager and fulfills all pending Promises to get the manager instance once
     * the instance is created.
     * @param bus The event bus.
     */
    static async createInstance(bus) {
        KeyEventManager.isCreatingInstance = true;
        KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
        KeyEventManager.isCreatingInstance = false;
        for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
            KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
        }
    }
    /**
     * Creates an instance of KeyEventManager.
     * @param bus The event bus.
     * @returns A Promise which is fulfilled with a new instance of KeyEventManager after it has been created.
     */
    static create(bus) {
        return new Promise((resolve, reject) => {
            const gameState = GameStateProvider.get();
            const sub = gameState.sub(state => {
                if (window['IsDestroying']) {
                    sub.destroy();
                    reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                    return;
                }
                if (state === GameState.briefing || state === GameState.ingame) {
                    sub.destroy();
                    const keyListener = RegisterViewListener('JS_LISTENER_KEYEVENT', () => {
                        if (window['IsDestroying']) {
                            reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                            return;
                        }
                        resolve(new KeyEventManager(keyListener, bus));
                    });
                }
            }, false, true);
            sub.resume(true);
        });
    }
}
KeyEventManager.isCreatingInstance = false;
KeyEventManager.pendingPromiseResolves = [];

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
/**
 * The class of airport facility.
 */
var AirportClass;
(function (AirportClass) {
    /** No other airport class could be identified. */
    AirportClass[AirportClass["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClass[AirportClass["HardSurface"] = 1] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClass[AirportClass["SoftSurface"] = 2] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClass[AirportClass["AllWater"] = 3] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClass[AirportClass["HeliportOnly"] = 4] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClass[AirportClass["Private"] = 5] = "Private";
})(AirportClass || (AirportClass = {}));
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
var AirportClassMask;
(function (AirportClassMask) {
    /** No other airport class could be identified. */
    AirportClassMask[AirportClassMask["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClassMask[AirportClassMask["HardSurface"] = 2] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClassMask[AirportClassMask["SoftSurface"] = 4] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClassMask[AirportClassMask["AllWater"] = 8] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClassMask[AirportClassMask["HeliportOnly"] = 16] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClassMask[AirportClassMask["Private"] = 32] = "Private";
})(AirportClassMask || (AirportClassMask = {}));
/**
 * An enumeration of possible intersection types.
 */
var IntersectionType;
(function (IntersectionType) {
    IntersectionType[IntersectionType["None"] = 0] = "None";
    IntersectionType[IntersectionType["Named"] = 1] = "Named";
    IntersectionType[IntersectionType["Unnamed"] = 2] = "Unnamed";
    IntersectionType[IntersectionType["Vor"] = 3] = "Vor";
    IntersectionType[IntersectionType["NDB"] = 4] = "NDB";
    IntersectionType[IntersectionType["Offroute"] = 5] = "Offroute";
    IntersectionType[IntersectionType["IAF"] = 6] = "IAF";
    IntersectionType[IntersectionType["FAF"] = 7] = "FAF";
    IntersectionType[IntersectionType["RNAV"] = 8] = "RNAV";
    IntersectionType[IntersectionType["VFR"] = 9] = "VFR";
})(IntersectionType || (IntersectionType = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a lateral and vertical discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
    /** A leg representing a lateral and vertical discontinuity in the flight plan that does not prevent sequencing. */
    LegType[LegType["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["All"] = 0] = "All";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
    FacilitySearchType[FacilitySearchType["Visual"] = 7] = "Visual";
    FacilitySearchType[FacilitySearchType["AllExceptVisual"] = 8] = "AllExceptVisual";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao) {
        return icao.substr(3, 4).trim();
    }
    /**
     * Checks whether an ICAO string defines a facility (optionally of a specific type).
     * @param icao An ICAO string.
     * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
     * the ICAO string defines any valid facility type.
     * @returns Whether the given ICAO string defines a facility of the specified type.
     */
    static isFacility(icao, type) {
        switch (icao[0]) {
            case 'A':
                return type === undefined || type === FacilityType.Airport;
            case 'W':
                return type === undefined || type === FacilityType.Intersection;
            case 'V':
                return type === undefined || type === FacilityType.VOR;
            case 'N':
                return type === undefined || type === FacilityType.NDB;
            case 'U':
                return type === undefined || type === FacilityType.USR;
            case 'R':
                return type === undefined || type === FacilityType.RWY;
            case 'S':
                return type === undefined || type === FacilityType.VIS;
            default:
                return false;
        }
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao) {
        return icao.substr(1, 2).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';
/**
 * Utility functions for working with facilities.
 */
class FacilityUtils {
    /**
     * Checks whether a facility is of a given type.
     * @param facility The facility to check.
     * @param type The facility type to check against.
     * @returns Whether the facility is of the specified type.
     */
    static isFacilityType(facility, type) {
        // Need to check for the intersection version of VOR/NDB facilities - these facilities have identical ICAOs
        // to their VOR/NDB counterparts, so we need to manually check the __Type property on the facility object.
        if (facility['__Type'] === 'JS_FacilityIntersection') {
            return type === FacilityType.Intersection;
        }
        return ICAO.isFacility(facility.icao, type);
    }
    /**
     * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
     * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
     * is returned.
     * @param facility A facility.
     * @returns The magnetic variation at the specified facility, in degrees.
     */
    static getMagVar(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            return -facility.magneticVariation; // VOR facility magvar is positive west instead of the standard positive east
        }
        else {
            return MagVar.get(facility.lat, facility.lon);
        }
    }
    /**
     * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees.
     * @param distance The distance, in nautical miles.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
     * facility.
     */
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
        return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    /**
     * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
     * @param reference1 The first reference facility.
     * @param radial1 The first magnetic radial, in degrees.
     * @param reference2 The second reference facility.
     * @param radial2 The second magnetic radial, in degrees.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
     * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
     */
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
        const magVar1 = FacilityUtils.getMagVar(reference1);
        const magVar2 = FacilityUtils.getMagVar(reference2);
        const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
        const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
        const radial1IncludesRef2 = radialCircle1.includes(reference2);
        const radial2IncludesRef1 = radialCircle2.includes(reference1);
        if (radial1IncludesRef2 && radial2IncludesRef1) {
            // Radials are parallel or antiparallel, and therefore do not have a unique intersection point.
            return out.set(NaN, NaN);
        }
        else if (radial1IncludesRef2) {
            // Reference 2 lies along the great circle of radial 1. The intersection point therefore is either reference 2
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
        }
        else if (radial2IncludesRef1) {
            // Reference 1 lies along the great circle of radial 2. The intersection point therefore is either reference 1
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
        }
        // Radials, unlike great circles, do not circumscribe the globe. Therefore, we choose the order of the intersection
        // operation carefully to ensure that the first solution (if it exists) is the "correct" intersection.
        const numIntersections = radialCircle1.encircles(reference2)
            ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache)
            : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
        if (numIntersections === 0) {
            return out.set(NaN, NaN);
        }
        return out.set(FacilityUtils.intersectionCache[0]);
    }
}
FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Utility functions for working with user facilities.
 */
class UserFacilityUtils {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
        const fac = {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat,
            lon,
            userFacilityType: UserFacilityType.LAT_LONG,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(lat, lon)
        };
        return fac;
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees, of the reference facility on which the new facility lies.
     * @param distance The distance, in nautical miles, from the reference facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_DISTANCE,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference.icao,
            reference1Radial: radial,
            reference1MagVar: FacilityUtils.getMagVar(reference),
            reference1Distance: distance
        };
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference1 The first reference facility.
     * @param radial1 The magnetic radial, in degrees, of the first reference facility on which the new facility lies.
     * @param reference2 The second reference facility.
     * @param radial2 The magnetic radial, in degrees, of the second reference facility on which the new facility lies.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility, or `undefined` if the specified radials do not intersect at a unique point.
     */
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
        if (isNaN(location.lat) || isNaN(location.lon)) {
            return undefined;
        }
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_RADIAL,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference1.icao,
            reference1Radial: radial1,
            reference1MagVar: FacilityUtils.getMagVar(reference1),
            reference2Icao: reference2.icao,
            reference2Radial: radial2,
            reference2MagVar: FacilityUtils.getMagVar(reference2)
        };
    }
}
UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];

var RunwaySurfaceCategory;
(function (RunwaySurfaceCategory) {
    RunwaySurfaceCategory[RunwaySurfaceCategory["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Water"] = 8] = "Water";
})(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator, lowerCase = false) {
        const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
        return lowerCase
            ? letter.toLowerCase()
            : letter;
    }
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            elevationEnd: 0,
            gradient: 0,
            latitude: 0,
            longitude: 0,
            length: 0,
            width: 0,
            startThresholdLength: 0,
            endThresholdLength: 0,
            surface: RunwaySurfaceType.Concrete,
            lighting: RunwayLightingType.Unknown
        };
    }
    /**
     * Utility method to return all of the one-way runways from a single airport facility
     * @param airport is the Airport Facility to evaluate
     * @returns all of the one-way runways in the airport facility, sorted.
     */
    static getOneWayRunwaysFromAirport(airport) {
        const runways = [];
        airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach(d => {
            runways.push(d[0]);
            runways.push(d[1]);
        });
        runways.sort(RunwayUtils.sortRunways);
        return runways;
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let endThresholdElevation = 0;
            let ilsFrequency;
            let startThresholdLength = 0, endThresholdLength = 0;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                endThresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
                startThresholdLength = runway.primaryThresholdLength;
                endThresholdLength = runway.secondaryThresholdLength;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                endThresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
                startThresholdLength = runway.secondaryThresholdLength;
                endThresholdLength = runway.primaryThresholdLength;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                elevationEnd: endThresholdElevation,
                gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency,
                length: runway.length,
                width: runway.width,
                startThresholdLength,
                endThresholdLength,
                surface: runway.surface,
                lighting: runway.lighting
            });
        }
        return splitRunways;
    }
    /**
     * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
     * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
     * then the name will be the designation of the primary runway only.
     * @param runway A paired runway.
     * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
     * @returns The name for the specified paired runway.
     */
    static getRunwayPairNameString(runway, padded = true) {
        const pad = padded ? 2 : 0;
        const dashIndex = runway.designation.search('-');
        const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
        const secondary = dashIndex < 0 ? '' : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
        return primary + secondary;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    /**
     * Gets the primary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The primary runway number for the specified runway.
     */
    static getRunwayNumberPrimary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return parseInt(runway.designation);
        }
        else {
            return parseInt(runway.designation.substring(0, dashIndex));
        }
    }
    /**
     * Gets the secondary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
     * runway.
     */
    static getRunwayNumberSecondary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return undefined;
        }
        else {
            return parseInt(runway.designation.substring(dashIndex + 1));
        }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg1, arg2) {
        let runway;
        if (typeof arg1 === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else if (typeof arg1 === 'number') {
            const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else {
            runway = arg1;
        }
        const runwayDesignation = runway.designation;
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            // Note: drop the leading zero in the runway designation for the search because some third-party sceneries
            // format the frequency names without the leading zero.
            const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ''));
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
        const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
        if (!matchedRunway) {
            return undefined;
        }
        return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
        let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        switch (runwayDesignator) {
            case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
                break;
            case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
                break;
            default:
                oppositeRunwayDesignator = runwayDesignator;
                break;
        }
        return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport, or the ICAO of the airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        const icao = typeof airport === 'string' ? airport : airport.icao;
        return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    /**
     * Gets the runway surface category from a runway or runway surface type.
     * @param runway A runway or runway surface type.
     * @returns The surface category of the specified runway or runway surface type.
     */
    static getSurfaceCategory(runway) {
        const surface = typeof runway === 'object' ? runway.surface : runway;
        if (this.SURFACES_HARD.includes(surface)) {
            return RunwaySurfaceCategory.Hard;
        }
        else if (this.SURFACES_SOFT.includes(surface)) {
            return RunwaySurfaceCategory.Soft;
        }
        else if (this.SURFACES_WATER.includes(surface)) {
            return RunwaySurfaceCategory.Water;
        }
        else {
            return RunwaySurfaceCategory.Unknown;
        }
    }
}
RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: '',
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 'L',
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 'R',
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 'C',
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 'W',
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 'A',
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 'B',
};
RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban,
];
RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
];
RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
];
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A utility class for working with approach procedures.
 */
class ApproachUtils {
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType(query) {
        const rnavTypeFlags = typeof query === 'number' ? query : query.rnavTypeFlags;
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param approach The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isRnpAr(approach) {
        return approach.approachType === ApproachType.APPROACH_TYPE_RNAV
            && approach.rnavTypeFlags === RnavTypeFlags.None
            && approach.runwayNumber !== 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getFrequencyFromAirport(facility, approach) {
        if (typeof approach === 'number') {
            approach = facility.approaches[approach];
        }
        if (approach) {
            switch (approach.approachType) {
                case ApproachType.APPROACH_TYPE_ILS:
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LDA:
                case ApproachType.APPROACH_TYPE_SDF:
                    return RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                    return RunwayUtils.getBcFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
            }
        }
        return undefined;
    }
    /**
     * Gets the reference facility for an approach. Only ILS, LOC (BC), LDA, SDF, VOR(DME), and NDB(DME) approaches can
     * have reference facilities.
     * @param approach The approach for which to get a reference facility.
     * @param facLoader The facility loader.
     * @returns A Promise which is fulfilled with the reference facility for the specified approach, or `undefined` if
     * one could not be found.
     */
    static async getReferenceFacility(approach, facLoader) {
        let facilityType;
        let isLoc = false;
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
                isLoc = true;
            // eslint-disable-next-line no-fallthrough
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                facilityType = FacilityType.VOR;
                break;
            case ApproachType.APPROACH_TYPE_NDB:
            case ApproachType.APPROACH_TYPE_NDBDME:
                facilityType = FacilityType.NDB;
                break;
            default:
                return undefined;
        }
        const finalLegs = approach.finalLegs;
        // Find the faf
        let fafLeg = undefined;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = finalLegs[i];
            if (BitFlags.isAll(leg.fixTypeFlags, FixTypeFlags.FAF)) {
                fafLeg = leg;
                break;
            }
        }
        if (!fafLeg) {
            return undefined;
        }
        if (!ICAO.isFacility(fafLeg.originIcao, facilityType)) {
            return undefined;
        }
        try {
            const facility = await facLoader.getFacility(facilityType, fafLeg.originIcao);
            if (isLoc && facility.type !== VorType.ILS) {
                return undefined;
            }
            else {
                return facility;
            }
        }
        catch (_a) {
            return undefined;
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
const airportIcaoRegionPattern = new RegExp(/^A../);
/**
 * A type map of facility type to facility search type.
 */
({
    /** Airport facility type. */
    [FacilityType.Airport]: FacilitySearchType.Airport,
    /** Intersection facility type. */
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    /** NDB facility type. */
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    /** VOR facility type. */
    [FacilityType.VOR]: FacilitySearchType.Vor,
    /** USR facility type. */
    [FacilityType.USR]: FacilitySearchType.User,
    /** Visual facility type. */
    [FacilityType.VIS]: FacilitySearchType.Visual
});
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => FacilityLoader.init(), 2000);
            }, true);
        }
        this.awaitInitialization().then(() => this.onInitialized());
    }
    /**
     * Initializes this facility loader.
     */
    static init() {
        FacilityLoader.isInitialized = true;
        for (const resolve of this.initPromiseResolveQueue) {
            resolve();
        }
        this.initPromiseResolveQueue.length = 0;
    }
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    awaitInitialization() {
        if (FacilityLoader.isInitialized) {
            return Promise.resolve();
        }
        else {
            return new Promise(resolve => {
                FacilityLoader.initPromiseResolveQueue.push(resolve);
            });
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        // Remove the region code from the icao
        if (type === FacilityType.Airport) {
            icao = icao.replace(airportIcaoRegionPattern, 'A  ');
        }
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const cachedFac = cache.get(icao);
        if (cachedFac !== undefined) {
            return Promise.resolve(cachedFac);
        }
        const currentTime = Date.now();
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            if (request !== undefined) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                Coherent.call(type, icao).then((isValid) => {
                    if (!isValid) {
                        rejection(`Facility ${icao} could not be found.`);
                        queue.delete(icao);
                    }
                });
            });
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            queue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startNearestSearchSession(type) {
        switch (type) {
            case FacilitySearchType.User:
            case FacilitySearchType.Visual:
                return this.startRepoNearestSearchSession(type);
            case FacilitySearchType.AllExceptVisual:
                return this.startCoherentNearestSearchSession(FacilitySearchType.All);
            default:
                return this.startCoherentNearestSearchSession(type);
        }
    }
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startCoherentNearestSearchSession(type) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestVorSearchSession(sessionId);
                break;
            case FacilitySearchType.Boundary:
                session = new NearestBoundarySearchSession(sessionId);
                break;
            default:
                session = new CoherentNearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    startRepoNearestSearchSession(type) {
        // Session ID doesn't really matter for these, so in order to not conflict with IDs from Coherent, we will set
        // them all to negative numbers
        const sessionId = FacilityLoader.repoSearchSessionId--;
        switch (type) {
            case FacilitySearchType.User:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            case FacilitySearchType.Visual:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            default:
                throw new Error();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        let results;
        if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
            const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
            results = await Coherent.call('SEARCH_BY_IDENT', ident, coherentFilter, maxItems);
        }
        else {
            results = [];
        }
        const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
        if (facRepositorySearchTypes) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, facRepositorySearchTypes);
        }
        return results;
    }
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
        const results = await this.searchByIdent(filter, ident, maxItems);
        if (!results) {
            return [];
        }
        const promises = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i];
            const facIdent = ICAO.getIdent(icao);
            if (facIdent === ident) {
                const facType = ICAO.getFacilityType(icao);
                promises.push(this.getFacility(facType, icao));
            }
        }
        const foundFacilities = await Promise.all(promises);
        if (foundFacilities.length > 1) {
            foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
            return foundFacilities;
        }
        else if (foundFacilities.length === 1) {
            return foundFacilities;
        }
        else {
            return [];
        }
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const isMismatch = facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W';
        const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
        const request = queue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, isMismatch);
            queue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session instanceof CoherentNearestSearchSession) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
};
FacilityLoader.repoSearchSessionId = -1;
FacilityLoader.isInitialized = false;
FacilityLoader.initPromiseResolveQueue = [];
/**
 * A session for searching for nearest facilities through Coherent.
 */
class CoherentNearestSearchSession {
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
        Coherent.call('SET_NEAREST_EXTENDED_AIRPORT_FILTERS', this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
}
/**
 * Default filters for the nearest airports search session.
 */
NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
};
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     */
    setIntersectionFilter(typeMask) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask);
    }
}
/**
 * Default filters for the nearest intersections search session.
 */
NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
};
/**
 * A session for searching for nearest VORs.
 */
class NearestVorSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
        Coherent.call('SET_NEAREST_VOR_FILTER', this.sessionId, classMask, typeMask);
    }
}
/**
 * Default filters for the nearest VORs search session.
 */
NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
};
/**
 * A session for searching for nearest airspace boundaries.
 */
class NearestBoundarySearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask) {
        Coherent.call('SET_NEAREST_BOUNDARY_FILTER', this.sessionId, classMask);
    }
}
/**
 * A session for searching for nearest facilities that uses the facility repository.
 */
class NearestRepoFacilitySearchSession {
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo, sessionId) {
        this.repo = repo;
        this.sessionId = sessionId;
        this.filter = undefined;
        this.cachedResults = new Set();
        this.searchId = 0;
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
        const added = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i].icao;
            if (this.cachedResults.has(icao)) {
                this.cachedResults.delete(icao);
            }
            else {
                added.push(icao);
            }
        }
        const removed = Array.from(this.cachedResults);
        this.cachedResults.clear();
        for (let i = 0; i < results.length; i++) {
            this.cachedResults.add(results[i].icao);
        }
        return Promise.resolve({
            sessionId: this.sessionId,
            searchId: this.searchId++,
            added,
            removed
        });
    }
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter) {
        this.filter = filter;
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

/**
 * Utility functions for working with arrays.
 */
class ArrayUtils {
    /**
     * Creates a new array with initialized values.
     * @param length The length of the new array.
     * @param init A function which generates initial values for the new array at each index.
     * @returns A new array of the specified length with initialized values.
     */
    static create(length, init) {
        const newArray = [];
        for (let i = 0; i < length; i++) {
            newArray[i] = init(i);
        }
        return newArray;
    }
    /**
     * Gets the element at a specific index in an array.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array.
     * @throws RangeError if the index is out of bounds.
     */
    static at(array, index) {
        if (index < 0) {
            index += array.length;
        }
        if (index < 0 || index >= array.length) {
            throw new RangeError();
        }
        return array[index];
    }
    /**
     * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
     */
    static peekAt(array, index) {
        if (index < 0) {
            index += array.length;
        }
        return array[index];
    }
    /**
     * Gets the first element of an array.
     * @param array An array.
     * @returns The first element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static first(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[0];
    }
    /**
     * Gets the first element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The first element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekFirst(array) {
        return array[0];
    }
    /**
     * Gets the last element of an array.
     * @param array An array.
     * @returns The last element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static last(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[array.length - 1];
    }
    /**
     * Gets the last element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The last element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekLast(array) {
        return array[array.length - 1];
    }
    /**
     * Checks if a certain element is included in an array.
     * @param array An array.
     * @param searchElement The element to search for.
     * @param fromIndex The position in this array at which to begin searching for `searchElement`.
     * @returns Whether the search element is included in the specified array.
     */
    static includes(array, searchElement, fromIndex) {
        return array.includes(searchElement, fromIndex);
    }
    /**
     * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
     * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
     * @param a The first array.
     * @param b The second array.
     * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
     * to a function which uses the strict equality operator (`===`).
     * @returns Whether the two specified arrays are equal.
     */
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!equalsFunc(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
     * mapped elements to a maximum depth of one, leaving the original array intact.
     * @param array An array.
     * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
     * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
     * elements to a maximum depth of one.
     */
    static flatMap(array, map) {
        const out = [];
        for (let i = 0; i < array.length; i++) {
            const mapped = map(array[i], i, array);
            if (Array.isArray(mapped)) {
                for (let j = 0; j < mapped.length; j++) {
                    out[out.length] = mapped[j];
                }
            }
            else {
                out[out.length] = mapped;
            }
        }
        return out;
    }
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat(array, depth = 1) {
        const out = [];
        this.flatHelper(array, depth, 0, out);
        return out;
    }
    /**
     * Recursively flattens an array and writes the flattened sequence of elements into another array.
     * @param array The array to flatten.
     * @param maxDepth The maximum depth to which to flatten.
     * @param depth The current flattening depth.
     * @param out The array to which to write the flattened sequence of elements.
     */
    static flatHelper(array, maxDepth, depth, out) {
        for (let i = 0; i < array.length; i++) {
            const element = array[i];
            if (Array.isArray(element) && depth < maxDepth) {
                this.flatHelper(element, maxDepth, depth + 1, out);
            }
            else {
                out[out.length] = element;
            }
        }
    }
    /**
     * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
     * length and the same elements in the same order as the source array.
     * @param source The array to copy.
     * @param target The array to copy into. If not defined, a new array will be created.
     * @returns The target array, after the source array has been copied into it.
     */
    static shallowCopy(source, target = []) {
        target.length = source.length;
        for (let i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        return target;
    }
    /**
     * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
     * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
     * where `index` is the index at which the query element would be found if it were contained in the sorted array.
     * @param array An array.
     * @param element The element to search for.
     * @param comparator A function which determines the sorting order of elements in the array. The function should
     * return a negative number if the first element is to be sorted before the second, a positive number if the first
     * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
     * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
     * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
     * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
     * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
     * the query element would be found if it were contained in the sorted array, if no element in the array has a
     * sorting order equal to the query.
     */
    static binarySearch(array, element, comparator, first = true) {
        let min = 0;
        let max = array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = comparator(element, array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array) {
        return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
}
ArrayUtils.STRICT_EQUALS = (a, b) => a === b;

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
class BinaryHeap {
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
        this.comparator = comparator;
        this.tree = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
        return this.tree.length;
    }
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
        return this.tree[0];
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
        if (this.tree.length === 0) {
            return undefined;
        }
        const min = this.tree[0];
        this.swap(0, this.tree.length - 1);
        this.tree.length--;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
        this.tree.push(element);
        this.heapifyUp(this.tree.length - 1);
        return this;
    }
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element) {
        if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
            return element;
        }
        return this.removeMinAndInsert(element);
    }
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element) {
        const min = this.tree[0];
        this.tree[0] = element;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
        this.tree.length = 0;
        return this;
    }
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyUp(index) {
        let parent = BinaryHeap.parent(index);
        while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
            this.swap(parent, index);
            index = parent;
            parent = BinaryHeap.parent(index);
        }
    }
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyDown(index) {
        const len = this.tree.length;
        while (index < len) {
            const left = BinaryHeap.left(index);
            const right = BinaryHeap.right(index);
            let needSwapFlags = 0;
            if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
                needSwapFlags |= 1;
            }
            if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
                needSwapFlags |= 2;
            }
            if (needSwapFlags === 3) {
                needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
            }
            if (needSwapFlags === 0) {
                break;
            }
            const swapChild = needSwapFlags === 1 ? left : right;
            this.swap(index, swapChild);
            index = swapChild;
        }
    }
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    swap(index1, index2) {
        const old1 = this.tree[index1];
        this.tree[index1] = this.tree[index2];
        this.tree[index2] = old1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    static left(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    static right(index) {
        return index * 2 + 2;
    }
}

/**
 * A sorted array.
 */
class SortedArray {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index.
     * @param index An index.
     * @returns The element at the specified index.
     * @throws RangeError if index is out of bounds.
     */
    get(index) {
        if (index < 0 || index >= this._array.length) {
            throw new RangeError();
        }
        return this._array[index];
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    peek(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array.
     * @returns The first element in this array.
     * @throws RangeError if this array is empty.
     */
    first() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[0];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    peekFirst() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array.
     * @returns The last element in this array.
     * @throws RangeError if this array is empty.
     */
    last() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[this._array.length - 1];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    peekLast() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Removes an element at a specific index from this array and returns it.
     * @param index The index of the element to remove.
     * @returns The removed element, or `undefined` if no element was removed.
     */
    removeAt(index) {
        if (index < 0 || index >= this._array.length) {
            return undefined;
        }
        return this._array.splice(index, 1)[0];
    }
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop() {
        return this._array.pop();
    }
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift() {
        return this._array.shift();
    }
    /**
     * Re-sorts this array using its sorting function.
     */
    resort() {
        this._array.sort(this.comparatorFunc);
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A linearly interpolated N-dimensional lookup table.
 */
class LerpLookupTable {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg) {
        this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
        if (typeof arg === 'number') {
            this._dimensionCount = isNaN(arg) ? 0 : Math.max(0, arg);
            return;
        }
        const leastDimension = arg.reduce((accum, current) => (current.length < accum.length) ? current : accum);
        this._dimensionCount = Math.max(0, leastDimension ? (leastDimension.length - 1) : 0);
        if (this._dimensionCount === 0) {
            return;
        }
        for (let i = 0; i < arg.length; i++) {
            this.insertBreakpoint(arg[i]);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
        return this._dimensionCount;
    }
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table');
        }
        if (breakpoint.length - 1 < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
        }
        this.insertBreakpointHelper(breakpoint, 0, this.table);
        return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
        const dimensionKey = breakpoint[dimension + 1];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        if (dimension === this._dimensionCount - 1) {
            let match = array.match(query);
            if (!match) {
                match = { key: dimensionKey, value: breakpoint[0] };
                array.insert(match);
            }
        }
        else {
            let next = array.match(query);
            if (!next) {
                array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
        }
    }
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot look up a key in a 0-dimensional table');
        }
        if (key.length < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
        }
        const value = this.lookupHelper(key, 0, this.table);
        if (value === undefined) {
            throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
        }
        return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray) {
        const dimensionKey = key[dimension];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        const index = lookupArray.matchIndex(query);
        let start;
        let end;
        if (index >= 0) {
            start = lookupArray.peek(index);
            end = start;
        }
        else {
            start = lookupArray.peek(-index - 2);
            end = lookupArray.peek(-index - 1);
            if (!start) {
                start = end;
            }
            if (!end) {
                end = start;
            }
        }
        if (!start || !end) {
            return undefined;
        }
        let startValue;
        let endValue;
        if (dimension === this.dimensionCount - 1) {
            startValue = start.value;
            endValue = end.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            startValue = this.lookupHelper(key, dimension + 1, start.array);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            endValue = this.lookupHelper(key, dimension + 1, end.array);
        }
        if (startValue === undefined || endValue === undefined) {
            return undefined;
        }
        if (startValue === endValue) {
            return startValue;
        }
        return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
}
LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
LerpLookupTable.tempBreakpoint = { key: 0 };

/**
 * A k-dimensional search tree.
 */
class KdTree {
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount, keyFunc) {
        this.keyFunc = keyFunc;
        this.elements = [];
        this.keys = [];
        this.nodes = [];
        this.minDepth = -1;
        this.maxDepth = -1;
        this.dimensionCount = Math.trunc(dimensionCount);
        if (this.dimensionCount < 2) {
            throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
        }
        this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
        this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
            return (a, b) => {
                const aKey = this.keys[a];
                const bKey = this.keys[b];
                for (let i = 0; i < this.dimensionCount; i++) {
                    const dimension = (i + index) % this.dimensionCount;
                    if (aKey[dimension] < bKey[dimension]) {
                        return -1;
                    }
                    else if (aKey[dimension] > bKey[dimension]) {
                        return 1;
                    }
                }
                return 0;
            };
        });
        this.keyCache = [
            new Float64Array(this.dimensionCount)
        ];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements in this tree. */
    get size() {
        return this.elements.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    searchKey(key, radius, arg3, out, filter) {
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(undefined, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(undefined, key, radius, arg3);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(element, radius, arg3, out, filter) {
        const key = this.keyFunc(element, this.keyCache[0]);
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(element, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(element, key, radius, arg3);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(element, key, radius, visitor) {
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            return visitor(elementInner, keyInner, distance, queryKey, queryElement);
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            return searchRadius + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
        if (maxResultCount <= 0) {
            out.length = 0;
            return out;
        }
        const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
                if (heap.size === maxResultCount) {
                    heap.insertAndRemoveMin(elementIndex);
                }
                else {
                    heap.insert(elementIndex);
                }
            }
            return true;
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            let maxDist = searchRadius;
            if (heap.size === maxResultCount) {
                maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
            }
            return maxDist + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
        out.length = heap.size;
        for (let i = out.length - 1; i >= 0; i--) {
            out[i] = this.elements[heap.removeMin()];
        }
        return out;
    }
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
        const elementIndex = this.nodes[nodeIndex];
        if (elementIndex === undefined) {
            return true;
        }
        const nodeKey = this.keys[elementIndex];
        const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
        if (distanceFromNode <= radius) {
            if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
                return false;
            }
        }
        const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        const lesserNodeIndex = KdTree.lesser(nodeIndex);
        const greaterNodeIndex = KdTree.greater(nodeIndex);
        if (this.nodes[lesserNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, -1)) {
            if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        if (this.nodes[greaterNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, 1)) {
            if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        const insertDepth = this.insertElementInTree(element) + 1;
        this.maxDepth = Math.max(this.maxDepth, insertDepth);
        if (insertDepth === this.minDepth + 1) {
            this.minDepth = KdTree.depth(this.nodes.indexOf(undefined, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
        }
        // Rebalance the tree if max depth is greater than twice the min depth.
        if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
            this.rebuild();
        }
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        for (const element of elements) {
            this.elements.push(element);
            this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
            const insertedIndex = this.elements.length - 1;
            for (let i = 0; i < this.dimensionCount; i++) {
                this.indexArrays[i].push(insertedIndex);
            }
        }
        this.rebuild();
    }
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    insertElementInTree(element) {
        const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
        let index = 0;
        let depth = 0;
        let elementIndex;
        while ((elementIndex = this.nodes[index]) !== undefined) {
            const pivotDimension = depth % this.dimensionCount;
            const keyToCompare = key[pivotDimension];
            if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
                index = KdTree.lesser(index);
            }
            else {
                index = KdTree.greater(index);
            }
            depth++;
        }
        this.elements.push(element);
        this.keys.push(key);
        const insertedIndex = this.elements.length - 1;
        this.nodes[index] = insertedIndex;
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].push(insertedIndex);
        }
        return depth;
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        if (!this.removeElementFromArrays(element)) {
            return false;
        }
        this.resetIndexArrays();
        this.rebuild();
        return true;
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        let removed = false;
        for (const element of elements) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
            this.rebuild();
        }
        return removed;
    }
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    removeElementFromArrays(element) {
        const index = this.elements.indexOf(element);
        if (index < 0) {
            return false;
        }
        const lastIndex = this.elements.length - 1;
        this.elements[index] = this.elements[lastIndex];
        this.keys[index] = this.keys[lastIndex];
        this.elements.length--;
        this.keys.length--;
        return true;
    }
    /**
     * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
     * number of elements in the tree.
     */
    resetIndexArrays() {
        for (let i = 0; i < this.dimensionCount; i++) {
            const array = this.indexArrays[i];
            array.length = this.elements.length;
            for (let j = 0; j < array.length; j++) {
                array[j] = j;
            }
        }
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        let removed = false;
        for (const element of toRemove) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
        }
        this.insertAll(toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        // clear the tree structure
        this.nodes.length = 0;
        if (this.size === 0) {
            return;
        }
        // sort index arrays
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].sort(this.indexSortFuncs[i]);
        }
        this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
        const log = Math.log2(this.elements.length + 1);
        this.minDepth = Math.floor(log) - 1;
        this.maxDepth = Math.ceil(log) - 1;
    }
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    buildSubTree(nodeIndex, pivotDimension, start, end) {
        const tempArray = this.indexArrays[this.dimensionCount];
        const sortedArray = this.indexArrays[0];
        const medianIndex = Math.trunc((start + end) / 2);
        const medianKeyIndex = sortedArray[medianIndex];
        // Insert median into its position in the tree
        this.nodes[nodeIndex] = medianKeyIndex;
        if (end - start === 1) {
            return;
        }
        if (end - start <= 3) {
            const lesserIndex = medianIndex - 1;
            const greaterIndex = medianIndex + 1;
            if (lesserIndex >= start) {
                this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
            }
            if (greaterIndex < end) {
                this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
            }
            return;
        }
        for (let i = start; i < end; i++) {
            tempArray[i] = sortedArray[i];
        }
        // Partition the index arrays not in the pivot dimension around the median key in the pivot dimension and at the
        // same time rotate the index arrays such that the index array sorted in the next pivot dimension is located at
        // index 0.
        for (let i = 1; i < this.dimensionCount; i++) {
            const targetArray = this.indexArrays[i - 1];
            const toPartitionArray = this.indexArrays[i];
            let lesserCount = 0;
            let greaterCount = 0;
            for (let j = start; j < end; j++) {
                const keyIndex = toPartitionArray[j];
                if (keyIndex === medianKeyIndex) {
                    targetArray[medianIndex] = keyIndex;
                }
                else {
                    const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
                    if (comparison <= 0) {
                        const index = start + (lesserCount++);
                        targetArray[index] = keyIndex;
                    }
                    else {
                        const index = medianIndex + 1 + (greaterCount++);
                        targetArray[index] = keyIndex;
                    }
                }
            }
        }
        // Copy the temporary array (now containing the sorted indexes in the pivot dimension) to the last index array.
        const newSortedArray = this.indexArrays[this.dimensionCount - 1];
        for (let i = start; i < end; i++) {
            newSortedArray[i] = tempArray[i];
        }
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
        this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.elements.length = 0;
        this.keys.length = 0;
        this.nodes.length = 0;
        for (let i = 0; i < this.indexArrays.length; i++) {
            this.indexArrays[i].length = 0;
        }
        this.minDepth = -1;
        this.maxDepth = -1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    static lesser(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    static greater(index) {
        return index * 2 + 2;
    }
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    static leastIndexAtDepth(depth) {
        return 1 << depth - 1;
    }
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    static depth(index) {
        return Math.trunc(Math.log2(index + 1));
    }
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    static distance(key1, key2, dimensionCount) {
        let sumSq = 0;
        for (let i = 0; i < dimensionCount; i++) {
            const diff = key1[i] - key2[i];
            sumSq += diff * diff;
        }
        return Math.sqrt(sumSq);
    }
}

/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
class GeoKdTree {
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc) {
        this.keyFunc = keyFunc;
        this.cartesianTree = new KdTree(3, (element, out) => {
            const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
            out[0] = vec[0];
            out[1] = vec[1];
            out[2] = vec[2];
            return out;
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
        let center, radius;
        let argA, argB, argC;
        if (typeof arg1 === 'number') {
            center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
            radius = arg3;
            argA = arg4;
            argB = arg5;
            argC = arg6;
        }
        else if (!(arg1 instanceof Float64Array)) {
            center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        else {
            center = arg1;
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
        if (typeof argA === 'number') {
            return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
        }
        else {
            this.doVisitorSearch(center, radiusCartesian, argA);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(center, radiusCartesian, visitor) {
        this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
            const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
            const greatCircleDist = GeoPoint.distance(vec, center);
            return visitor(element, vec, greatCircleDist, center);
        });
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
        const cartesianFilter = filter
            ? (element, key) => {
                const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
                const greatCircleDist = GeoPoint.distance(vec, center);
                return filter(element, vec, greatCircleDist, center);
            }
            : undefined;
        return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        this.cartesianTree.insert(element);
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        this.cartesianTree.insertAll(elements);
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        return this.cartesianTree.remove(element);
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        return this.cartesianTree.removeAll(elements);
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        this.cartesianTree.rebuild();
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.cartesianTree.clear();
    }
}
GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];

/**
 * Types of subscribable array change event.
 */
var SubscribableArrayEventType;
(function (SubscribableArrayEventType) {
    /** An element was added. */
    SubscribableArrayEventType["Added"] = "Added";
    /** An element was removed. */
    SubscribableArrayEventType["Removed"] = "Removed";
    /** The array was cleared. */
    SubscribableArrayEventType["Cleared"] = "Cleared";
})(SubscribableArrayEventType || (SubscribableArrayEventType = {}));

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class AbstractSubscribableArray {
    constructor() {
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this array.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
        const array = this.getArray();
        if (index > array.length - 1) {
            throw new Error('Index out of range');
        }
        return array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
        return this.getArray()[index];
    }
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    notify(index, type, modifiedItem) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(index, type, modifiedItem, this.getArray());
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(index, type, modifiedItem, this.getArray());
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const array = this.getArray();
        sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
}

/**
 * A subscribable which provides a sorted version of a source SubscribableArray.
 */
class SortedMappedSubscribableArray extends AbstractSubscribableArray {
    /**
     * Constructor.
     * @param source The source array subject for this subscribable.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(source, comparatorFunc, equalityFunc) {
        super();
        this.source = source;
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this.sorted = new SortedArray(this.comparatorFunc, this.equalityFunc);
        this.sourceSub = source.sub(this.onSourceChanged.bind(this), true);
    }
    /** @inheritdoc */
    get length() {
        return this.sorted.length;
    }
    /**
     * Creates a new SortedMappedSubscribableArray.
     * @param source The source array subject for the new mapped sorted array.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create(source, comparatorFunc, equalityFunc) {
        return new SortedMappedSubscribableArray(source, comparatorFunc, equalityFunc);
    }
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    onSourceChanged(index, type, item) {
        switch (type) {
            case SubscribableArrayEventType.Cleared:
                if (this.sorted.length !== 0) {
                    this.sorted.clear();
                    this.notify(0, SubscribableArrayEventType.Cleared);
                }
                break;
            case SubscribableArrayEventType.Added:
                if (item) {
                    this.insert(item);
                }
                break;
            case SubscribableArrayEventType.Removed:
                if (item) {
                    this.remove(item);
                }
                break;
        }
    }
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    insert(elements) {
        if (this.sorted.length === 0) {
            // since we know all elements will be added to one contiguous index range, we can do a small optimization here
            // with notifications
            elements instanceof Array ? this.sorted.insertAll(elements) : this.sorted.insert(elements);
            this.notify(0, SubscribableArrayEventType.Added, elements instanceof Array ? this.sorted.array : elements);
        }
        else {
            if (elements instanceof Array) {
                const len = elements.length;
                for (let i = 0; i < len; i++) {
                    const toInsert = elements[i];
                    this.notify(this.sorted.insert(toInsert), SubscribableArrayEventType.Added, toInsert);
                }
            }
            else {
                this.notify(this.sorted.insert(elements), SubscribableArrayEventType.Added, elements);
            }
        }
    }
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    remove(elements) {
        if (elements instanceof Array) {
            const len = elements.length;
            for (let i = 0; i < len; i++) {
                const toRemove = elements[i];
                const removedIndex = this.sorted.remove(toRemove);
                if (removedIndex >= 0) {
                    this.notify(removedIndex, SubscribableArrayEventType.Removed, toRemove);
                }
            }
        }
        else {
            const removedIndex = this.sorted.remove(elements);
            if (removedIndex >= 0) {
                this.notify(removedIndex, SubscribableArrayEventType.Removed, elements);
            }
        }
    }
    /** @inheritdoc */
    getArray() {
        return this.sorted.array;
    }
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy() {
        this.sourceSub.destroy();
    }
}

/**
 * Types of facility repository sync events.
 */
var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType["Add"] = "Add";
    FacilityRepositorySyncType["Remove"] = "Remove";
    FacilityRepositorySyncType["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType["DumpResponse"] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRepository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.repos = new Map();
        this.trees = {
            [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
            [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        };
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        // Request a dump from any existing instances on other instruments to initialize the repository.
        this.pubSyncEvent({
            type: FacilityRepositorySyncType.DumpRequest, uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
        });
    }
    /**
     * Gets the number of facilities stored in this repository.
     * @param types The types of facilities to count. Defaults to all facility types.
     * @returns The number of facilities stored in this repository.
     */
    size(types) {
        var _a, _b;
        let size = 0;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                size += repo.size;
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
            }
        }
        return size;
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(type, lat, lon, radius, arg5, out, filter) {
        if (type !== FacilityType.USR && type !== FacilityType.VIS) {
            throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
        }
        if (typeof arg5 === 'number') {
            return this.trees[type].search(lat, lon, radius, arg5, out, filter);
        }
        else {
            this.trees[type].search(lat, lon, radius, arg5);
        }
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
        }
        this.addToRepo(fac);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    /**
     * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
     * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
     * replaced with the new one.
     * @param facs The facilities to add.
     */
    addMultiple(facs) {
        this.addMultipleToRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        if (!ICAO.isFacility(icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
        }
        this.removeFromRepo(icao);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    /**
     * Removes multiple facilities from this repository and all other repositories synced with this one.
     * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
     */
    removeMultiple(facs) {
        this.removeMultipleFromRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map(fac => typeof fac === 'object' ? fac.icao : fac) });
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                repo.forEach(fn);
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
            }
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === undefined) {
            this.repos.set(facilityType, repo = new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            if (existing === undefined) {
                this.trees[facilityType].insert(fac);
            }
            else {
                this.trees[facilityType].removeAndInsert([existing], [fac]);
            }
        }
        if (existing === undefined) {
            this.publisher.pub('facility_added', fac, false, false);
        }
        else {
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Adds multiple facilities to this repository.
     * @param facs The facilities to add.
     */
    addMultipleToRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const addedFacilities = [];
        const changedFacilitiesRemoved = [];
        const changedFacilitiesAdded = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const facilityType = ICAO.getFacilityType(fac.icao);
            let repo = this.repos.get(facilityType);
            if (repo === undefined) {
                this.repos.set(facilityType, repo = new Map());
            }
            const existing = repo.get(fac.icao);
            repo.set(fac.icao, fac);
            if (existing === undefined) {
                addedFacilities.push(fac);
            }
            else {
                changedFacilitiesRemoved.push(existing);
                changedFacilitiesAdded.push(fac);
            }
        }
        const addedUserFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (addedUserFacilities.length > 0) {
            const removedUserFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
            this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
        }
        const addedVisFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (addedVisFacilities.length > 0) {
            const removedVisFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
            this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
        }
        for (let i = 0; i < addedFacilities.length; i++) {
            const fac = addedFacilities[i];
            this.publisher.pub('facility_added', fac, false, false);
        }
        for (let i = 0; i < changedFacilitiesAdded.length; i++) {
            const fac = changedFacilitiesAdded[i];
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     */
    removeFromRepo(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        const facilityType = ICAO.getFacilityType(icao);
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === undefined) {
            return;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === undefined) {
            return;
        }
        repo.delete(icao);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            this.trees[facilityType].remove(facilityInRepo);
        }
        this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
        this.publisher.pub('facility_removed', facilityInRepo, false, false);
    }
    /**
     * Removes multiple facilities from this repository.
     * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
     */
    removeMultipleFromRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const removedFacilities = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const icao = typeof fac === 'string' ? fac : fac.icao;
            const repo = this.repos.get(ICAO.getFacilityType(icao));
            if (repo === undefined) {
                continue;
            }
            const facilityInRepo = repo.get(icao);
            if (facilityInRepo === undefined) {
                continue;
            }
            repo.delete(icao);
            removedFacilities.push(facilityInRepo);
        }
        const removedUserFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (removedUserFacilities.length > 0) {
            this.trees[FacilityType.USR].removeAll(removedUserFacilities);
        }
        const removedVisFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (removedVisFacilities.length > 0) {
            this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
        }
        for (let i = 0; i < removedFacilities.length; i++) {
            const removedFac = removedFacilities[i];
            this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
            this.publisher.pub('facility_removed', removedFac, false, false);
        }
    }
    /**
     * Publishes a facility added or removed sync event over the event bus.
     * @param data The event data.
     */
    pubSyncEvent(data) {
        this.ignoreSync = true;
        this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.DumpResponse:
                // Only accept responses to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    break;
                }
                else {
                    this.lastDumpRequestUid = undefined;
                }
            // eslint-disable-next-line no-fallthrough
            case FacilityRepositorySyncType.Add:
                if (data.facs.length === 1) {
                    this.addToRepo(data.facs[0]);
                }
                else {
                    this.addMultipleToRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.Remove:
                if (data.facs.length === 1) {
                    this.removeFromRepo(data.facs[0]);
                }
                else {
                    this.removeMultipleFromRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.DumpRequest:
                // Don't respond to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRepository.INSTANCE = new FacilityRepository(bus));
    }
}
FacilityRepository.SYNC_TOPIC = 'facilityrepo_sync';
FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
};

/**
 * A task queue backed by an array.
 */
class ArrayTaskQueue {
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks) {
        this.tasks = tasks;
        this.head = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    hasNext() {
        return this.head < this.tasks.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    next() {
        return this.tasks[this.head++];
    }
}

/**
 * A process which dispatches tasks in a task queue potentially over multiple frames.
 */
class ThrottledTaskQueueProcess {
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue, handler) {
        this.queue = queue;
        this.handler = handler;
        this._hasStarted = false;
        this._hasEnded = false;
        this._shouldAbort = false;
    }
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted() {
        return this._hasStarted;
    }
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded() {
        return this._hasEnded;
    }
    /**
     * Starts this process.
     */
    start() {
        this._hasStarted = true;
        this.processQueue(0);
    }
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    processQueue(elapsedFrameCount) {
        let dispatchCount = 0;
        const t0 = performance.now();
        while (!this._shouldAbort && this.queue.hasNext()) {
            if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
                const task = this.queue.next();
                task();
                dispatchCount++;
            }
            else {
                break;
            }
        }
        if (this._shouldAbort) {
            return;
        }
        if (!this.queue.hasNext()) {
            this.handler.onFinished(elapsedFrameCount);
            this._hasEnded = true;
        }
        else {
            this.handler.onPaused(elapsedFrameCount);
            requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
        }
    }
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort() {
        if (this._hasStarted && !this._hasEnded) {
            this.handler.onAborted();
            this._shouldAbort = true;
            this._hasEnded = true;
        }
    }
}

/**
 * A nearest search session for boundaries (airspaces) in the form of LodBoundary objects.
 */
class NearestLodBoundarySearchSession {
    /**
     * Constructor.
     * @param cache The boundary cache this search session uses.
     * @param session The nearest boundary facility search session this search session uses.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     */
    constructor(cache, session, frameBudget) {
        this.cache = cache;
        this.session = session;
        this.frameBudget = frameBudget;
    }
    /**
     * Searches for the nearest boundaries around a specified location.
     * @param lat The latitude of the search center, in degrees.
     * @param lon The longitude of the search center, in degrees.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items for which to search.
     * @returns The nearest search results.
     */
    async searchNearest(lat, lon, radius, maxItems) {
        const facilityResults = await this.session.searchNearest(lat, lon, radius, maxItems);
        const results = { added: [], removed: facilityResults.removed };
        const tasks = facilityResults.added.map((fac, index) => () => { results.added[index] = this.cache.get(fac); });
        await new Promise(resolve => {
            const taskQueue = new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget, resolve));
            taskQueue.start();
        });
        return results;
    }
    /**
     * Sets this session's boundary class filter. The new filter takes effect with the next search executed in this
     * session.
     * @param classMask A bitmask defining the boundary classes to include in the search (`0`: exclude, `1`: include).
     * The bit index for each boundary class is equal to the value of the corresponding `BoundaryType` enum.
     */
    setFilter(classMask) {
        this.session.setBoundaryFilter(classMask);
    }
}
/**
 * A throttled task queue handler for retrieving and creating new LodBoundary objects in response to a nearest search.
 */
class NearestLodBoundarySearchTaskQueueHandler {
    /**
     * Constructor.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     * @param resolve The Promise resolve function this handler will call when the task queue is finished.
     */
    constructor(frameBudget, resolve) {
        this.frameBudget = frameBudget;
        this.resolve = resolve;
    }
    /** @inheritdoc */
    onStarted() {
        // noop
    }
    /** @inheritdoc */
    canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
        return timeElapsed < this.frameBudget;
    }
    /** @inheritdoc */
    onPaused() {
        // noop
    }
    /** @inheritdoc */
    onFinished() {
        this.resolve();
    }
    /** @inheritdoc */
    onAborted() {
        // noop
    }
}

/**
 * The transition type to which a flight path vector belongs.
 */
var FlightPathVectorFlags;
(function (FlightPathVectorFlags) {
    FlightPathVectorFlags[FlightPathVectorFlags["None"] = 0] = "None";
    /** A turn to a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["TurnToCourse"] = 1] = "TurnToCourse";
    /** An arcing turn to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Arc"] = 2] = "Arc";
    /** A direct course to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Direct"] = 4] = "Direct";
    /** A path to intercept a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["InterceptCourse"] = 8] = "InterceptCourse";
    /** Inbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    /** Outbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    /** A direct hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    /** A teardrop hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    /** A parallel hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    /** A course reversal. */
    FlightPathVectorFlags[FlightPathVectorFlags["CourseReversal"] = 512] = "CourseReversal";
    /** A turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["LegToLegTurn"] = 1024] = "LegToLegTurn";
    /** An anticipated turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    /** A fallback path. */
    FlightPathVectorFlags[FlightPathVectorFlags["Fallback"] = 4096] = "Fallback";
})(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        // *********************************************************************************************************
        // ******** When adding new fields, they MUST be initialized, even if it just gets set to undefined ********
        // ******** This is so that it can be used with Object.keys()                                       ********
        // *********************************************************************************************************
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction. */
        this.originRunway = undefined;
        /** The ICAO for the facility associated with the departure procedure. */
        this.departureFacilityIcao = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The ICAO for the facility associated with the arrival procedure. */
        this.arrivalFacilityIcao = undefined;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The arrival runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.arrivalRunway = undefined;
        /** The ICAO for the facility associated with the approach procedure. */
        this.approachFacilityIcao = undefined;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /** The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
/**
 * Bitflags describing a leg definition.
 */
var LegDefinitionFlags;
(function (LegDefinitionFlags) {
    LegDefinitionFlags[LegDefinitionFlags["None"] = 0] = "None";
    LegDefinitionFlags[LegDefinitionFlags["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags[LegDefinitionFlags["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags[LegDefinitionFlags["Obs"] = 4] = "Obs";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
})(LegDefinitionFlags || (LegDefinitionFlags = {}));
/**
 * Vertical flight phase.
 */
var VerticalFlightPhase;
(function (VerticalFlightPhase) {
    VerticalFlightPhase["Climb"] = "Climb";
    VerticalFlightPhase["Descent"] = "Descent";
})(VerticalFlightPhase || (VerticalFlightPhase = {}));
var SpeedUnit;
(function (SpeedUnit) {
    SpeedUnit[SpeedUnit["IAS"] = 0] = "IAS";
    SpeedUnit[SpeedUnit["MACH"] = 1] = "MACH";
})(SpeedUnit || (SpeedUnit = {}));
/** Types of speed restrictions on legs. */
var SpeedRestrictionType;
(function (SpeedRestrictionType) {
    SpeedRestrictionType[SpeedRestrictionType["Unused"] = 0] = "Unused";
    SpeedRestrictionType[SpeedRestrictionType["At"] = 1] = "At";
    SpeedRestrictionType[SpeedRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType[SpeedRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType[SpeedRestrictionType["Between"] = 4] = "Between";
})(SpeedRestrictionType || (SpeedRestrictionType = {}));

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            flags: FlightPathVectorFlags.None,
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector, circle, start, end, flags) {
        vector.flags = flags;
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the direction of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The direction of the turn described by the flight path circle vector.
     */
    static getVectorTurnDirection(vector) {
        return vector.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
     */
    static getVectorTurnRadius(vector) {
        return Math.min(vector.radius, Math.PI - vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the true course for a flight plan leg.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
     * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
     * @returns The true course for the specified flight plan leg.
     */
    static getLegTrueCourse(leg, point, magVarFacility) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const magVar = magVarFacility
            ? -magVarFacility.magneticVariation // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.reverse();
        }
        return out;
    }
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle, out) {
        return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > MathUtils.HALF_PI
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
        }
        const radius = turnDirection === 'left'
            ? turnRadius
            : Math.PI - turnRadius;
        const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
        const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
        return out.set(turnCenter, radius);
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
            return posAngularDistance >= Math.PI ? -Infinity : Infinity;
        }
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angularTolerance = circle.angularWidth(tolerance);
        if (typeof end !== 'number') {
            end = circle.angleAlong(start, end, Math.PI, angularTolerance);
        }
        if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const angle = circle.angleAlong(start, pos, Math.PI);
        if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
        return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static projectVelocityToCircle(speed, position, direction, projectTo) {
        if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return NaN;
        }
        if (speed === 0) {
            return 0;
        }
        if (!(position instanceof Float64Array)) {
            position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
        }
        const velocityPath = typeof direction === 'number'
            ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction)
            : direction.isGreatCircle()
                ? direction
                : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
        const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
        const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
        const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
        const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
        const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
        return speed * sinTheta * sign;
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress(legCalc) {
        var _a, _b, _c, _d, _e, _f;
        var _g, _h, _j, _k, _l, _m;
        const vectors = legCalc.ingressToEgress;
        let vectorIndex = 0;
        let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
        const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
        const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
        const firstEgressVector = legCalc.egress[0];
        const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
        if (lastIngressVector && ingressJoinVector) {
            // Check if the last ingress vector joins the base flight path before the end of a vector. If so, we need to
            // replace the base flight path vector the ingress joins with a shortened version starting where the ingress
            // ends.
            const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
            const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector
                ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon)
                : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
            const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
            const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
            if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
                // Ingress joins the base flight path before the end of the joined vector.
                if (ingressEndAlongVectorDistance > normalizedTolerance) {
                    // Ingress joins the base flight path after the start of the joined vector.
                    ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
                    FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : (vectors[_g] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
                }
                else {
                    // Ingress joins the base flight path at or before the start of the joined vector.
                    Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : (vectors[_h] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVector);
                }
            }
            flightPathVectorIndex++;
        }
        const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
        for (let i = flightPathVectorIndex; i < end; i++) {
            Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : (vectors[_j] = FlightPathUtils.createEmptyCircleVector()), legCalc.flightPath[i]);
            flightPathVectorIndex++;
        }
        if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
            if (firstEgressVector) {
                // Check if the first egress vector joins the base flight path in after the start of a vector. If so, we need
                // to replace the base flight path vector the egress joins with a shortened version starting where the egress
                // starts.
                const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
                const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
                const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
                const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
                if (egressStartAlongVectorDistance > normalizedTolerance) {
                    // Egress joins the base flight path after the start of the joined vector.
                    if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
                        // Egress joins the base flight path before the end of the joined vector.
                        egressJoinVectorCircle.closest(egressStart, egressStart);
                        FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : (vectors[_k] = FlightPathUtils.createEmptyCircleVector()), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                    }
                    else {
                        // Egress joins the base flight path at or after the end of the joined vector.
                        Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : (vectors[_l] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
                    }
                }
            }
            else {
                // There is no egress, but there is a base flight path vector flagged as the vector with which the egress
                // joins. This is technically an invalid state, but we can easily just treat this as a regular "no-egress"
                // case and copy the entire egress join vector into the resolved vectors array.
                Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : (vectors[_m] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
            }
        }
        vectors.length = vectorIndex;
        return legCalc;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
}
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg, flags) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        if (turnEndPoint.equals(start)) {
            return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle, flags = 0) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const intersectionIndex = (numIntersections === 1 || circle.encircles(start)) ? 0 : 1;
        const endVec = intersections[intersectionIndex];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
[
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
[new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths via a turn starting at the start
 * point followed by an angled intercept path which intercepts the final path before the end point.
 */
class InterceptGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
        }
        const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
        if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // initial and final paths are parallel
            return 0;
        }
        const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
        const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
        // The set of centers of great circles that intersect the end path at the desired intercept angle
        const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
        const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
        if (startTurnDirection === undefined) {
            // Calculate the intercept point if the intercept path were to pass through the start point.
            const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
            if (interceptCount === 0) {
                // No great-circle path passing through the start point can intercept the final path at the desired intercept angle.
                startTurnDirection = startPath.encircles(end) ? 'left' : 'right';
            }
            else {
                let intersectionIndex = 0;
                if (interceptCount > 1) {
                    // There are two great-circle paths passing through the start point that intercept the final path at the
                    // desired angle. One of them will be directed toward the end path and the other will be directed away from
                    // it. We want to choose the one directed toward it.
                    intersectionIndex = endPath.encircles(start) ? 0 : 1;
                }
                let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                // sin x ~= x for x near 0, so to check if the angle between the start path and intercept path is parallel or
                // antiparallel we just have to check the magnitude of their cross product instead of the arcsine of the
                // magnitude.
                if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                    // If start and intercept paths are parallel or antiparallel, it doesn't really matter which direction we
                    // turn, so we will just turn in the direction that aligns us with the end path.
                    cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                    if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                        // If start and end paths are antiparallel (they can't be parallel since we would have returned from the
                        // method by now), then we just arbitrarily choose to turn right.
                        startTurnDirection = 'right';
                    }
                    else {
                        startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                    }
                }
                else {
                    startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                }
            }
        }
        const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
        const endTurnRadiusRad = endTurnRadius === undefined ? undefined : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
        if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // If the desired intercept angle is 0 degrees, the only valid path is when the starting turn ends exactly on the
            // path to intercept and the end of the turn lies before the end point
            if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
                // starting turn is not tangent to path to intercept
                return 0;
            }
            const startTurnEnd = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd, end, Math.PI);
            if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                // the end of the starting turn lies after the end point.
                return 0;
            }
            return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        // Find the great-circle path that intersects the path to intercept at the desired intercept angle and is tangent
        // to the starting turn.
        // The set of centers of great circles that are tangent to the starting turn
        const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
        const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
        if (interceptPathCount === 0) {
            return 0;
        }
        const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
        let interceptCrossSign;
        if (startToEndPathAngleRad >= interceptAngleRad) {
            // The start turn is considered to overshoot if it crosses to the contralateral side of the final path before
            // joining the intercept path that requires the shortest turn to join. The contralateral side is defined as the
            // right side for left turns and the left side for right turns. If this occurs, we need to choose the second
            // intercept path (if it exists). This is because choosing the first intercept path would trigger a case below
            // that attempts to end the start turn early, which could produce a path that requires the plane to track toward
            // the final path at an angle greater than the intercept angle.
            const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
            const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
            interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
            interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === 'right') ? 1 : -1;
        }
        else {
            // If the start path intersects the final path at a shallower angle than the intercept path, then we always want
            // to choose the intercept path that requires the shortest turn to join. Even if the turn has overshot the final
            // path by the time it can join the chosen intercept path, we handle that case below by attempting to end the
            // start turn early. We are guaranteed that ending the start turn early will not result in a path that requires
            // the plane to track toward the final path at an angle greater than the intercept angle because if it did, that
            // would mean the start turn does not overshoot the final path and therefore we wouldn't have needed to end the
            // start turn early in the first place.
            interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
            interceptCrossSign = startTurnDirection === 'right' ? 1 : -1;
        }
        const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
        const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        // Required turn anticipation for the end turn to join the intercept and final paths.
        let minDInterceptEnd = 0;
        if (endTurnRadiusRad !== undefined) {
            const endTheta = Math.PI - interceptAngleRad;
            minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
            if (isNaN(minDInterceptEnd)) {
                // Turn radius is too large for the end turn to join the intercept and final paths
                return 0;
            }
        }
        const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
        if (interceptToEndOffset < minDInterceptEnd) {
            // The intercept path does not intercept the final path early enough to make the end turn before the end point
            return 0;
        }
        let vectorIndex = index;
        if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            // The start turn ends too late to make a turn to join the final path or the start turn overshoots the end path
            // before reaching the intercept course -> attempt to end the start turn early
            if (endTurnRadiusRad === undefined) {
                // We don't need to calculate a final turn, so attempt to end the start turn where it intersects the end path
                const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
                if (startTurnEndPathIntersectionCount === 0) {
                    return 0;
                }
                const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === 'right' ? 0 : 1];
                if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The start turn intercepts the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
            }
            else {
                // We need to calculate a final turn to join the end path. This final turn must be tangent to the starting turn
                // and the end path.
                const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the starting turn
                const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the end path
                const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === 'left' ? 1 : -1));
                const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
                if (endTurnCircleCount === 0) {
                    return 0;
                }
                const endTurnCenter = intersections[0];
                const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === 'left' ? 'right' : 'left', InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
                endTurnCircle.closest(startTurnCenter, startTurnEnd);
                const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The end turn joins the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
            }
        }
        else {
            if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
            }
            let interceptPathEnd = intercept;
            if (endTurnRadiusRad !== undefined) {
                interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
            }
            if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
            }
            if (endTurnRadius !== undefined) {
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
            }
        }
        return vectorIndex - index;
    }
}
InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
        this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
        }
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        // Calculate the relative directions of the start point, intersection point, and end point.
        const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
        // positive -> start point lies after the intersection (with respect to the direction of start path)
        const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        // positive -> end point lies after the intersection (with respect to the direction of end path)
        const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        // along-track distance from the intersection point to the start/end of the minimum-radius turn from start path to end path
        let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        if (isNaN(minD)) {
            // Turn radius is too large for any turn to join the start and end paths
            minD = Infinity;
        }
        const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
        const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
        const towardEndPointTurnDirection = startPath.encircles(end, false) ? 'left' : 'right';
        let needCalculateTwoTurnPath = false;
        let needCalculateOneTurnPath = false;
        if (isEndForwardOfIntersection) {
            if (desiredTurnDirection === undefined || desiredTurnDirection === towardEndPointTurnDirection) {
                const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
                const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
                if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
                    // The minimum turn radius is too large to intercept the final path before the end point
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
                else {
                    // Make a single constant-radius turn either starting at the start point, or ending at the end point,
                    // depending on which is closer to the intersection point.
                    const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
                    if (intersectionStartDistance <= intersectionEndDistance) {
                        // start turn at start point
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
                        if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
                        }
                    }
                    else {
                        // end turn at end point
                        let turnStart = start;
                        if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
                        }
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                    }
                }
            }
            else {
                if (pathDot >= 0) {
                    // The start and end paths intersect at an angle <= 90 degrees. This means that for a turn away from the end
                    // point, the total flight path distance is minimized when the turn joins the start and end paths directly.
                    if (intersectionStartOffset <= minD) {
                        // The start point lies at or before the required turn start point to minimize the flight path distance.
                        needCalculateOneTurnPath = true;
                    }
                    else {
                        needCalculateTwoTurnPath = !preferSingleTurn;
                        needCalculateOneTurnPath = preferSingleTurn;
                    }
                }
                else {
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
            }
        }
        else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
        }
        let needDirectFallback = false;
        if (needCalculateTwoTurnPath) {
            const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
            // Attempt to make a turn to intercept the end path at 45 degrees. At this point we are in fallback territory
            // so we won't honor the desired starting turn direction.
            const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, undefined, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
            if (numInterceptVectors === 0) {
                needDirectFallback = allowDirectFallback;
            }
            else {
                vectorIndex += numInterceptVectors;
                const lastVector = vectors[vectorIndex - 1];
                const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
                if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
                }
            }
        }
        else if (needCalculateOneTurnPath) {
            // Make a single constant-radius turn from the start path to join the end path. The turn must start after the
            // intersection of the start and end paths (the only case where the turn starts before the intersection is
            // handled above).
            minD = Math.min(minD, Math.PI / 2);
            if (minD > Math.PI / 2) {
                // No amount of anticipation can provide a turn which joins the start and end paths of the desired radius.
                needDirectFallback = allowDirectFallback;
            }
            else {
                const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
                const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
                const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
                const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
                if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
                }
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
                }
            }
        }
        if (needDirectFallback) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45; // degrees
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, undefined, flags);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, undefined, flags);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
class DirectToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
        let vectorIndex = index;
        if (typeof startPath === 'number') {
            startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
        }
        const endPos = DirectToPointBuilder.geoPointCache[0];
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            endPos.set(end);
            end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
        }
        else {
            endPos.setFromCartesian(end);
        }
        const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
        if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
            return vectorIndex - index;
        }
        else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
            return vectorIndex - index;
        }
        const startPathEncirclesTerminator = startPath.encircles(end);
        const startPathIncludesTerminator = startPath.includes(end);
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right');
        const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === 'left'
            ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2])
            : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
        const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
        // The angle between the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
        const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
        flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
        if (!GeoPoint.equals(turnEndVec, start)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
        }
        if (!GeoPoint.equals(turnEndVec, end)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, undefined, flags);
        }
        return vectorIndex - index;
    }
}
DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the magnetic variation, in degrees, to use when calculating a flight plan leg's course. If the leg defines
     * an origin or fix VOR facility, then the magnetic variation defined at the VOR is used. Otherwise the computed
     * magnetic variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The magnetic variation, in degrees, to use when calculating the specified flight plan leg's course.
     */
    getLegMagVar(leg, point) {
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR)) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR)) ? leg.fixIcao
                : undefined;
        const facility = facIcao !== undefined ? this.facilityCache.get(facIcao) : undefined;
        // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
        return facility === undefined ? MagVar.get(point) : -facility.magneticVariation;
    }
    /**
     * Gets the true course, in degrees, for a flight plan leg. If the leg defines an origin or fix VOR facility, then
     * the magnetic variation defined at the VOR is used to adjust magnetic course. Otherwise the computed magnetic
     * variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The true course, in degrees, for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    /** @inheritdoc */
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
        var _a, _b, _c;
        var _d;
        const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : (_d.calculated = {
            courseMagVar: 0,
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            distance: 0,
            distanceWithTransitions: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTransitions: 0,
            flightPath: [],
            ingress: [],
            ingressJoinIndex: -1,
            ingressToEgress: [],
            egressJoinIndex: -1,
            egress: [],
            endsInFallback: false
        });
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            state.isFallback = calcs.endsInFallback;
            return calcs;
        }
        try {
            this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
            this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
            resolveIngressToEgress && this.resolveIngressToEgress(calcs);
            calcs.endsInFallback = state.isFallback;
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
            vectors.length = 0;
            calcs.ingress.length = 0;
            calcs.ingressJoinIndex = 0;
            calcs.egress.length = 0;
            calcs.egressJoinIndex = -1;
            calcs.ingressToEgress.length = 0;
            calcs.endsInFallback = false;
            state.isFallback = false;
        }
        return calcs;
    }
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    resolveIngressToEgress(legCalc) {
        FlightPathUtils.resolveIngressToEgress(legCalc);
    }
}
/**
 * Calculates flight path vectors for legs with no path.
 */
class NoPathLegCalculator extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.courseMagVar = 0;
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.flightPath.length = 0;
        state.currentCourse = undefined;
        state.currentPosition = undefined;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            vectors.length = 0;
            state.isFallback = false;
            return;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            if (state.isFallback && state.currentCourse !== undefined) {
                vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
            }
            else {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            }
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            vectors.length = 0;
            return;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        let initialCourse;
        if (leg.course !== 0) {
            // If a course is defined on the leg, then honor it.
            initialCourse = leg.trueDegrees ? leg.course % 360 : MagVar.magneticToTrue(leg.course, startPoint);
        }
        else {
            if (state.currentCourse === undefined) {
                // If the current course from the previous leg is undefined, then attempt to select an initial course from
                // the definition of the previous leg, if one exists.
                const prevLeg = legs[calculateIndex - 1];
                switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) {
                    case LegType.CA:
                    case LegType.CF:
                    case LegType.CR:
                    case LegType.FA:
                    case LegType.FC:
                    case LegType.FD:
                    case LegType.FM:
                    case LegType.VA:
                    case LegType.VD:
                    case LegType.VM:
                    case LegType.VR:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.HA:
                        // If the previous leg defines a course, then use that course.
                        initialCourse = this.getLegTrueCourse(prevLeg.leg, startPoint);
                        break;
                    case LegType.IF:
                        // If the previous leg is an IF for a runway fix, then use runway heading as the initial course.
                        if (ICAO.isFacility(prevLeg.leg.fixIcao, FacilityType.RWY)) {
                            const runwayFix = this.facilityCache.get(prevLeg.leg.fixIcao);
                            if (runwayFix) {
                                initialCourse = runwayFix.runway.course;
                                break;
                            }
                        }
                    // eslint-disable-next-line no-fallthrough
                    default:
                        // If we can't select an initial course from the previous leg, then default to the course that puts us on a
                        // great-circle path from the start point to the terminator fix.
                        initialCourse = startPoint.bearingTo(terminatorPos);
                        // If the calculated course is NaN (only happens when the start and end points are coincident or antipodal),
                        // then just arbitrarily use true north.
                        if (isNaN(initialCourse)) {
                            initialCourse = 0;
                        }
                }
            }
            else {
                // If the current course from the previous leg is defined, use it.
                initialCourse = state.currentCourse;
            }
        }
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, startPoint, startPath, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), leg.turnDirection === LegTurnDirection.Left ? 'left' : leg.turnDirection === LegTurnDirection.Right ? 'right' : undefined);
        state.currentPosition.set(terminatorPos);
        if (vectorIndex > 0) {
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            vectors.length = vectorIndex;
            return;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec, FlightPathVectorFlags.Arc);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    /** @inheritdoc */
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, true);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.turnBuilder = new TurnToCourseBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
        this.interceptInfo = {
            circle: undefined,
            start: undefined,
            end: undefined
        };
        this.handleInvalidInterceptCache = {
            vec3: [new Float64Array(3), new Float64Array(3), new Float64Array(3)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)],
            intersection: [new Float64Array(3), new Float64Array(3)]
        };
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const interceptInfo = this.getInterceptPathInfo(legs, calculateIndex, state, this.interceptInfo);
        if (course === undefined || !interceptInfo.circle || !state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        const effectiveInterceptPathStartVec = interceptInfo.start
            ? GeoPoint.sphericalToCartesian(interceptInfo.start, this.vec3Cache[0])
            : interceptInfo.end
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.end, -Math.PI, this.vec3Cache[0], Math.PI)
                : undefined;
        const effectiveInterceptPathEndVec = interceptInfo.end
            ? GeoPoint.sphericalToCartesian(interceptInfo.end, this.vec3Cache[1])
            : interceptInfo.start
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.start, Math.PI, this.vec3Cache[1], Math.PI)
                : undefined;
        const effectiveInterceptPathAngularWidth = interceptInfo.start && interceptInfo.end
            ? interceptInfo.circle.angleAlong(interceptInfo.start, interceptInfo.end, Math.PI)
            : effectiveInterceptPathStartVec
                ? Math.PI
                : MathUtils.TWO_PI;
        const initialVec = state.currentPosition.toCartesian(this.vec3Cache[2]);
        const includeInitialTurn = this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1;
        const interceptPathStartVec = Vec3Math.copy(initialVec, this.vec3Cache[3]);
        let initialTurnVector = undefined;
        if (includeInitialTurn) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            initialTurnVector = vectors[vectorIndex - 1];
            GeoPoint.sphericalToCartesian(initialTurnVector.endLat, initialTurnVector.endLon, interceptPathStartVec);
        }
        const interceptPath = this.geoCircleCache[0].setAsGreatCircle(interceptPathStartVec, course);
        const startPath = this.geoCircleCache[1].set(interceptPath.center, interceptPath.radius);
        // If an initial turn exists, check if a fallback intercept is required because the end of the initial turn lies
        // past the path to intercept. If an initial turn does not exist, check if any fallback intercept is required.
        let fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, initialTurnVector !== undefined, false, this.vec3Cache[4]);
        if (initialTurnVector !== undefined) {
            if (fallbackInterceptVec === undefined) {
                // An initial turn exists and does not end past the path to intercept. Check if a fallback intercept is required
                // for another reason.
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, false, this.vec3Cache[4]);
            }
            else {
                // An initial turn exists and ends past the path to intercept. First check if the initial turn intersects the
                // path to intercept
                const turnCircle = FlightPathUtils.setGeoCircleFromVector(initialTurnVector, this.geoCircleCache[2]);
                const intersections = this.intersectionCache;
                const numIntersections = turnCircle.intersection(interceptInfo.circle, intersections);
                if (numIntersections > 1) {
                    // Order intersections such that the one closer to the turn end is at index 0.
                    if (interceptInfo.circle.radius > MathUtils.HALF_PI !== interceptInfo.circle.encircles(initialVec)) {
                        const temp = intersections[0];
                        intersections[0] = intersections[1];
                        intersections[1] = temp;
                    }
                }
                for (let i = 0; i < numIntersections; i++) {
                    const intersection = intersections[i];
                    if (FlightPathUtils.isPointAlongArc(turnCircle, initialVec, interceptPathStartVec, intersection)
                        && (!effectiveInterceptPathStartVec
                            || FlightPathUtils.isPointAlongArc(interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathAngularWidth, intersection))) {
                        // End the turn early at the intercept point
                        const distance = turnCircle.distanceAlong(initialVec, intersection, Math.PI);
                        if (distance > GeoCircle.ANGULAR_TOLERANCE) {
                            const intersectionPoint = this.geoPointCache[0].setFromCartesian(intersection);
                            initialTurnVector.distance = UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                            initialTurnVector.endLat = intersectionPoint.lat;
                            initialTurnVector.endLon = intersectionPoint.lon;
                            state.currentPosition.set(initialTurnVector.endLat, initialTurnVector.endLon);
                            state.currentCourse = FlightPathUtils.getVectorFinalCourse(initialTurnVector);
                        }
                        else {
                            vectorIndex--;
                        }
                        vectors.length = vectorIndex;
                        return;
                    }
                }
                // The initial turn does not intersect the path to intercept -> calculate a fallback intercept
                // without an initial turn (i.e. change the intercept path to start at the start of the leg).
                vectorIndex = 0;
                Vec3Math.copy(initialVec, interceptPathStartVec);
                interceptPath.setAsGreatCircle(interceptPathStartVec, course);
                startPath.setAsGreatCircle(interceptPathStartVec, startCourse);
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, true, this.vec3Cache[4]);
            }
        }
        if (fallbackInterceptVec === undefined) {
            vectorIndex += this.interceptBuilder.build(vectors, vectorIndex, interceptPathStartVec, course, interceptInfo.circle);
        }
        else {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, interceptPathStartVec, startPath, fallbackInterceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
    }
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    calculateFallbackIntercept(start, interceptPath, pathToInterceptCircle, pathToInterceptStart, pathToInterceptEnd, pathToInterceptAngularWidth, onlyHandleInitialPointPastIntercept, forceFallback, out) {
        if (pathToInterceptCircle.includes(start)) {
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, start)) {
                // Initial point already lies on the path to intercept.
                return forceFallback ? Vec3Math.copy(start, out) : undefined;
            }
        }
        // Determine if the starting position is "past" the path to intercept.
        let isInitialPosPastPath = false;
        const intersections = this.handleInvalidInterceptCache.intersection;
        const numIntersections = interceptPath.intersection(pathToInterceptCircle, intersections);
        let desiredIntersection;
        if (numIntersections === 2) {
            const nextIntersectionIndex = pathToInterceptCircle.encircles(start) ? 0 : 1;
            const prevIntersectionIndex = 1 - nextIntersectionIndex;
            const nextIntersection = intersections[nextIntersectionIndex];
            const prevIntersection = intersections[prevIntersectionIndex];
            // Define the desired intercept point as the one that requires the shortest distance traveled along the initial
            // path and path to intercept circle from the initial position to some point along the path to intercept. Then,
            // determine if the initial position lies before or after the desired intercept point, relative to the direction
            // of the initial path.
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI && pathToInterceptCircle.isGreatCircle()) {
                isInitialPosPastPath = interceptPath.angleAlong(start, nextIntersection, Math.PI) > MathUtils.HALF_PI + GeoCircle.ANGULAR_TOLERANCE;
            }
            else {
                const prevIntersectionInitialPathOffset = interceptPath.angleAlong(prevIntersection, start, Math.PI);
                const nextIntersectionInitialPathOffset = interceptPath.angleAlong(start, nextIntersection, Math.PI);
                const prevIntersectionInitialPathDistance = Math.min(prevIntersectionInitialPathOffset, MathUtils.TWO_PI - prevIntersectionInitialPathOffset);
                const nextIntersectionInitialPathDistance = Math.min(nextIntersectionInitialPathOffset, MathUtils.TWO_PI - nextIntersectionInitialPathOffset);
                let prevIntersectionInterceptPathDistance = 0;
                let nextIntersectionInterceptPathDistance = 0;
                if (pathToInterceptStart && pathToInterceptEnd) {
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, prevIntersection)) {
                        const prevIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptStart, Math.PI);
                        const prevIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptEnd, Math.PI);
                        prevIntersectionInterceptPathDistance = Math.min(prevIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathStartOffset, prevIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathEndOffset);
                    }
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, nextIntersection)) {
                        const nextIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptStart, Math.PI);
                        const nextIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptEnd, Math.PI);
                        nextIntersectionInterceptPathDistance = Math.min(nextIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathStartOffset, nextIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathEndOffset);
                    }
                }
                const prevIntersectionTotalDistance = prevIntersectionInitialPathDistance + prevIntersectionInterceptPathDistance;
                const nextIntersectionTotalDistance = nextIntersectionInitialPathDistance + nextIntersectionInterceptPathDistance;
                // Only consider the starting position past the path to intercept if the path to intercept has a defined start
                // and end (i.e. is not a DME circle) OR the distance to one of the two intercept points is greater than pi/2
                // great-arc radians.
                if ((pathToInterceptStart !== undefined && pathToInterceptEnd !== undefined)
                    || (prevIntersectionTotalDistance >= MathUtils.HALF_PI || nextIntersectionTotalDistance >= MathUtils.HALF_PI)) {
                    isInitialPosPastPath = prevIntersectionTotalDistance < nextIntersectionTotalDistance - GeoCircle.ANGULAR_TOLERANCE;
                }
            }
            desiredIntersection = isInitialPosPastPath ? prevIntersection : nextIntersection;
        }
        else if (numIntersections === 1) {
            const distanceToIntersection = interceptPath.angleAlong(start, intersections[0], Math.PI);
            isInitialPosPastPath = distanceToIntersection < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && distanceToIntersection > Math.PI + GeoCircle.ANGULAR_TOLERANCE;
            desiredIntersection = intersections[0];
        }
        if ((onlyHandleInitialPointPastIntercept && !isInitialPosPastPath)) {
            return undefined;
        }
        let needHandleFallback = isInitialPosPastPath;
        if (!desiredIntersection) {
            // The intercept course does not intersect with the path to intercept circle at all -> define the desired
            // intercept point as the point on the path to intercept circle closest to the start point.
            desiredIntersection = pathToInterceptCircle.closest(start, this.handleInvalidInterceptCache.vec3[0]);
            needHandleFallback = true;
        }
        let fallbackIntercept;
        if ((!pathToInterceptStart || !pathToInterceptEnd)
            || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, desiredIntersection)) {
            // The desired intercept point is within the bounds of the path to intercept -> only handle the fallback if we
            // need to (i.e. if the starting point is past the path to intercept, if the starting path does not intersect
            // the path to intercept, or fallback is forced)
            if (needHandleFallback || forceFallback) {
                fallbackIntercept = desiredIntersection;
            }
        }
        else {
            // The desired intercept point is not within the bounds of the path to intercept -> set the fallback intercept
            // point to the start or end of the path to intercept, whichever is closer to the desired intercept point.
            const angularOffset = pathToInterceptCircle.angleAlong(pathToInterceptStart, desiredIntersection, Math.PI);
            const distanceFromStart = Math.min(angularOffset, MathUtils.TWO_PI - angularOffset);
            const distanceFromEnd = Math.abs(angularOffset - pathToInterceptAngularWidth);
            fallbackIntercept = distanceFromStart <= distanceFromEnd ? pathToInterceptStart : pathToInterceptEnd;
        }
        return fallbackIntercept === undefined ? undefined : Vec3Math.copy(fallbackIntercept, out);
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDmeLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const dmeFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = dmeFacility === undefined ? 0 : this.getLegMagVar(leg.leg, dmeFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (dmeFacility) {
            this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
            out.circle = this.dmeCircle;
            out.start = undefined;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.radialCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const radialFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = radialFacility === undefined ? 0 : this.getLegMagVar(leg.leg, radialFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (radialFacility) {
            const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
                ? -radialFacility.magneticVariation
                : MagVar.get(radialFacility);
            this.radialCircle.setAsGreatCircle(radialFacility, leg.theta + magVar);
            out.circle = this.radialCircle;
            out.start = radialFacility;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.predictLegPathCache = {
            geoPoint: [new GeoPoint(0, 0)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0)]
        };
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        const leg = legs[calculateIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = state.currentPosition === undefined ? 0 : this.getLegMagVar(leg.leg, state.currentPosition);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        out.circle = undefined;
        out.start = undefined;
        out.end = undefined;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return out;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[0]);
                    if (terminator) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator));
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    if (facility) {
                        out.circle = FlightPathUtils.getTurnCircle(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = this.facilityCache.get(leg.fixIcao);
                    }
                    break;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    if (terminator && centerFacility) {
                        out.circle = FlightPathUtils.getTurnCircle(centerFacility, terminator.distance(centerFacility), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    if (origin) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin));
                        out.start = origin;
                    }
                    break;
                }
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDmeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (!pathStartPoint || !dmeFacility) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const dmeCircle = this.geoCircleCache[1].set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const interceptVec = this.vec3Cache[1];
        const intersections = this.intersectionCache;
        const numIntersections = path.intersection(dmeCircle, intersections);
        if (numIntersections === 0) {
            // The path along the leg's defined course does not intercept the DME circle -> define the intercept to be the
            // closest point on the DME circle to the initial fix.
            dmeCircle.closest(pathStartVec, interceptVec);
        }
        else {
            // The path along the leg's defined course intercepts the DME circle -> choose the first intercept when
            // proceeding along the path from the initial fix.
            const intersectionIndex = (numIntersections === 1 || dmeCircle.encircles(pathStartVec)) ? 0 : 1;
            Vec3Math.copy(intersections[intersectionIndex], interceptVec);
        }
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, interceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, interceptVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, interceptVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!pathStartPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const endVec = path.offsetDistanceAlong(pathStartVec, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN), this.vec3Cache[1], Math.PI);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, endVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, endVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            // We are in a fallback state -> plot a direct course to the terminator fix
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, undefined, FlightPathVectorFlags.Fallback);
            state.isFallback = false;
        }
        else {
            state.isFallback = false;
            const endCourse = this.getLegTrueCourse(leg, endPoint);
            const endVec = endPoint.toCartesian(this.vec3Cache[1]);
            const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
            if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
                // Begins at a discontinuity OR previous leg is a manual termination leg.
                // Default to a track with start arbitrarily placed 5 NM from the terminator fix.
                const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
            }
            else {
                const startVec = startPoint.toCartesian(this.vec3Cache[0]);
                const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
                const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
                const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
                const isStartEqualToEnd = startPoint.equals(endPoint);
                // A great circle defining the threshold of the terminator fix - everything to the LEFT of (i.e. encircled by)
                // this great circle is past the terminator fix as projected along the end path.
                const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
                if (!leg.flyOver
                    && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type)
                    && threshold.encircles(startVec, false)) {
                    // The start point is past the terminator threshold -> end the leg at the start point and set a fallback state
                    ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                    (_d = state.currentCourse) !== null && _d !== void 0 ? _d : (state.currentCourse = currentCourse);
                    state.isFallback = true;
                }
                else {
                    const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
                    if (pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE) {
                        // The start and end paths are anti-parallel (+/- 5 degrees), which means we need to execute a procedure turn to do a 180.
                        let desiredTurnDirection;
                        switch (leg.turnDirection) {
                            // If the leg defines a turn direction, respect it.
                            case LegTurnDirection.Left:
                                desiredTurnDirection = 'left';
                                break;
                            case LegTurnDirection.Right:
                                desiredTurnDirection = 'right';
                                break;
                            default: {
                                const endDistanceFromStartPath = startPath.distance(endVec);
                                if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                                    // If the end point lies on the start path, then we want to turn toward the end path after passing
                                    // the end point along the start path (defaulting to a right turn if the start and end paths are
                                    // exactly antiparallel).
                                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? 'left' : 'right';
                                }
                                else {
                                    // If the end point does not lie on the start path, then we want to turn toward the end point from
                                    // the start path.
                                    desiredTurnDirection = endDistanceFromStartPath < 0 ? 'left' : 'right';
                                }
                            }
                        }
                        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
                        // procTurnBuilder will only build vectors up to the point where the proc turn intercepts the end path.
                        // So we need to check if we need to add a vector to connect the intercept point to the end point.
                        if (vectorIndex > 0) {
                            const lastVector = vectors[vectorIndex - 1];
                            const interceptVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                            if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) { // ~60 meter tolerance
                                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector.endLat, lastVector.endLon), endPoint);
                            }
                        }
                    }
                    else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE
                        && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE
                            || (!isStartEqualToEnd
                                && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                                    || (((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))))) {
                        /*
                        * The start and end paths are parallel, so we can just connect the start and end with a track.
                        *
                        * OR the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                        * least one calculated vector. In this case we will simply create a track from the start to end and let turn
                        * anticipation handle the initial turn into the final course.
                        */
                        if (!isStartEqualToEnd) {
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
                        }
                    }
                    else {
                        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                                : undefined;
                        vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
                        const lastVector = vectors[vectorIndex - 1];
                        if (lastVector !== undefined
                            && Math.abs(FlightPathUtils.getVectorFinalCourse(lastVector) - endCourse) > 1
                            && !leg.flyOver
                            && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                            // We are allowed to use a fallback path which does not end at the defined terminator fix and a fallback
                            // direct course was calculated -> check if the direct course path crosses the terminator threshold at
                            // any point and if so, end the path where it crosses and set a fallback state.
                            const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                            let startTurnCircle;
                            let startTurnEnd;
                            /*
                             * The direct course builder can produce 0 to 2 vectors: an optional starting turn toward the target
                             * point and an optional great-circle path connecting the turn to the target point.
                             *
                             * We are not concerned with the case with zero vectors, because this means the start and end points are
                             * coincident.
                             *
                             * We are also not concerned with the case of the single great-circle vector, because this means that
                             * either the starting point and the entire path are behind the terminator threshold, or both are past
                             * the threshold, which would have been handled in another case above.
                             *
                             * Thus, we are left with only the cases where there is a single turn vector or a turn vector followed
                             * by a great-circle vector.
                             */
                            const isLastVectorGreatCircle = FlightPathUtils.isVectorGreatCircle(lastVector);
                            if (isLastVectorGreatCircle && vectors[vectorIndex - 2] !== undefined) {
                                const startTurnVector = vectors[vectorIndex - 2];
                                startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                                startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[2]);
                            }
                            else if (!isLastVectorGreatCircle) {
                                // If the direct course calculation produced only a single turn vector, it possibly reduced the radius
                                // of the starting turn below the minimum radius in order to build a valid path to the terminator.
                                // We always want the starting turn to respect the minimum turn radius, so we will define it ourselves.
                                startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPath.encircles(endVec) ? 'left' : 'right'), this.geoCircleCache[3]);
                                // If the direct course turn radius was reduced, then the terminator fix lies inside the starting turn
                                // circle of minimum radius. Therefore, the turn technically never ends because there is no point on
                                // the turn circle that either includes the terminator fix or is tangent to a great-circle path which
                                // includes the terminator fix.
                                if (Math.min(lastVector.radius, Math.PI - lastVector.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                                    startTurnEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                                }
                            }
                            if (startTurnCircle !== undefined) {
                                const intersections = this.intersectionCache;
                                const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                                if (intersectionCount === 1) {
                                    // The starting turn is tangent to the threshold, which means it is either entirely past the
                                    // threshold or entirely behind it.
                                    if (threshold.encircles(FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, this.vec3Cache[2]))) {
                                        // The entire starting turn lies beyond the threshold, which means the starting point must also
                                        // lie beyond the threshold -> end the leg immediately with no vectors and set the fallback state.
                                        vectorIndex = 0;
                                        ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                                        (_h = state.currentCourse) !== null && _h !== void 0 ? _h : (state.currentCourse = currentCourse);
                                        state.isFallback = true;
                                    }
                                }
                                else if (startTurnEnd === undefined || intersectionCount === 2) {
                                    // If we are in this case, then the starting point is guaranteed to be behind the terminator
                                    // threshold. Therefore, the next intersection of the starting turn circle with the threshold will
                                    // take the path past the threshold.
                                    const thresholdCrossing = intersections[0];
                                    const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                                    if (startTurnEnd === undefined
                                        || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                                        // The starting turn crosses the terminator threshold before the end of the turn -> end the turn
                                        // at the crossing point and set the fallback state.
                                        vectorIndex = 0;
                                        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                                        state.isFallback = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        const lastVector = vectors[vectorIndex - 1];
        if (lastVector !== undefined) {
            ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
];
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const originFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = originFacility === undefined ? 0 : MagVar.get(originFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            vectors.length = vectorIndex;
            return;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            vectors.length = vectorIndex;
            return;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            vectors.length = vectorIndex;
            return;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            vectors.length = vectorIndex;
            return;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        vectors.length = vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!startPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const normalizedEnd = startPoint.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, normalizedEnd);
        state.currentPosition = undefined;
        state.currentCourse = undefined;
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            const fixPosition = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
            if (fixPosition) {
                state.currentPosition = new GeoPoint(fixPosition.lat, fixPosition.lon);
            }
        }
        if (!state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const holdFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = holdFacility === undefined ? 0 : this.getLegMagVar(leg.leg, holdFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const calcs = legs[calculateIndex].calculated;
        const vectors = calcs.flightPath;
        const ingress = calcs.ingress;
        let vectorIndex = 0, ingressVectorIndex = 0;
        const holdPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            vectors.length = 0;
            ingress.length = 0;
            calcs.ingressJoinIndex = -1;
            return;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            ingressVectorIndex += this.greatCircleBuilder.build(ingress, ingressVectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const turnRadiusMeters = state.desiredHoldTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        const outboundTurnCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
        const turnRadiusRad = state.desiredHoldTurnRadius.asUnit(UnitType.GA_RADIAN);
        const outboundTurnCenter = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
        const outboundTurnEnd = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
        const oppositeCourse = NavMath.normalizeHeading(course + 180);
        const outboundEnd = outboundTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        const directionalEntryCourse = normalizedEntryCourse * turnDirectionSign;
        const isDirectEntry = directionalEntryCourse >= -70 && directionalEntryCourse <= 135;
        const skipRacetrack = leg.type === LegType.HF && !isDirectEntry;
        if (isDirectEntry) {
            // direct entry
            if (directionalEntryCourse > 0) {
                // The entry course is toward the outbound leg, so we just intercept the outbound leg directly, bypassing
                // the turn from the inbound to outbound leg.
                ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), outboundEnd, this.geoCircleCache[2].setAsGreatCircle(outboundTurnEnd, oppositeCourse), turnDirection, turnRadiusMeters, false, true, undefined, FlightPathVectorFlags.HoldDirectEntry);
                calcs.ingressJoinIndex = 1;
            }
            else if (BitFlags.isAny((_d = (_c = ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.AnticipatedTurn)) {
                // Don't erase turn anticipation for direct entries
                ingressVectorIndex = ingress.length;
            }
        }
        else if (directionalEntryCourse > 110) {
            // teardrop entry
            if (directionalEntryCourse > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse, FlightPathVectorFlags.HoldTeardropEntry | FlightPathVectorFlags.TurnToCourse);
                if (numTurnVectorsAdded > 0) {
                    ingressVectorIndex += numTurnVectorsAdded;
                    const turnVector = ingress[ingressVectorIndex - 1];
                    state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                    state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
                }
            }
            ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters, true, true, undefined, FlightPathVectorFlags.HoldTeardropEntry);
            if (skipRacetrack) {
                // If we skip the racetrack, remove the part of the hold entry that is coincident with the inbound leg
                const lastEntryVector = ingress[ingressVectorIndex - 1];
                if (lastEntryVector && FlightPathUtils.isVectorGreatCircle(lastEntryVector) && holdPos.equals(lastEntryVector.endLat, lastEntryVector.endLon)) {
                    if (UnitType.METER.convertTo(lastEntryVector.distance, UnitType.GA_RADIAN) > distance + GeoPoint.EQUALITY_TOLERANCE) {
                        const lastEntryVectorEnd = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
                        lastEntryVector.endLat = lastEntryVectorEnd.lat;
                        lastEntryVector.endLon = lastEntryVectorEnd.lon;
                        lastEntryVector.distance -= UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                    }
                    else {
                        ingressVectorIndex--;
                    }
                }
            }
            calcs.ingressJoinIndex = 0;
        }
        else if (directionalEntryCourse < -70) {
            // parallel entry
            const parallelCourse = course + 180;
            const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse, FlightPathVectorFlags.HoldParallelEntry | FlightPathVectorFlags.TurnToCourse);
            if (numTurnVectorsAdded > 0) {
                ingressVectorIndex += numTurnVectorsAdded;
                const turnVector = ingress[ingressVectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            }
            ingressVectorIndex += this.procTurnBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course, FlightPathVectorFlags.HoldParallelEntry);
            calcs.ingressJoinIndex = 0;
        }
        ingress.length = ingressVectorIndex;
        if (ingress.length === 0) {
            calcs.ingressJoinIndex = -1;
        }
        let inboundStart;
        if (skipRacetrack) {
            inboundStart = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
        }
        else {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, outboundTurnCenter, holdPos, outboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, outboundTurnEnd, outboundEnd, undefined, FlightPathVectorFlags.HoldOutboundLeg);
            const inboundTurnCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const inboundTurnCenter = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const inboundTurnEnd = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, inboundTurnCenter, outboundEnd, inboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            inboundStart = inboundTurnEnd;
        }
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, inboundStart, holdPos, undefined, FlightPathVectorFlags.HoldInboundLeg);
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        vectors.length = vectorIndex;
    }
}

/**
 * A flight path calculator for turns between legs.
 */
class FlightPathTurnCalculator {
    constructor() {
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired general turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     */
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
        var _a, _b, _c, _d, _e, _f;
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const fromLegCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
            const toLegCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
            if (fromLegCalc && toLegCalc) {
                const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
                const toVector = toLegCalc.flightPath[0];
                if (fromVector && toVector
                    && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))
                    && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                    if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
                        continue;
                    }
                    else if (toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                    else if (fromVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                }
            }
            if (fromLegCalc && BitFlags.isAll((_d = (_c = fromLegCalc.egress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
                fromLegCalc.egress.length = 0;
                fromLegCalc.egressJoinIndex = -1;
            }
            if (toLegCalc && BitFlags.isAll((_f = (_e = toLegCalc.ingress[0]) === null || _e === void 0 ? void 0 : _e.flags) !== null && _f !== void 0 ? _f : 0, FlightPathVectorFlags.LegToLegTurn)) {
                toLegCalc.ingress.length = 0;
                toLegCalc.ingressJoinIndex = -1;
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        if (trackAngleDiff > 175) {
            return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (isRestrictedByPrevTurn) {
            if (previousTanTheta === undefined) {
                // Check to see if there is a ingress transition on the from leg and if it shares a common flight path vector
                // with the one involved in the turn currently being calculated.
                if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
                    const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
                    restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
                }
            }
            else {
                // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
                // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
                // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
                // previous turn. This will maximize min(radius_current, radius_prev).
                const tanThetaRatio = previousTanTheta / tanTheta;
                const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
                const cosTotalD = Math.cos(totalD);
                let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
                if (prevTurnRestrictedD > totalD) {
                    prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
                }
                restrictedD = prevTurnRestrictedD;
            }
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            // prevent zero-length turns
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        // Let the course reversal "cut"
        let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
                }
            }
        }
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
        const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? 'left' : 'right';
        const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === 'left' ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
        toLegCalc.ingress.length = length;
        toLegCalc.ingressJoinIndex = 0;
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
            return toIndex;
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, FlightPathTurnCalculator.geoPointCache[2]);
        const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        // define the circles
        const arcCircle = FlightPathTurnCalculator.geoCircleCache[0].set(arcCenter, arcRadius);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[1]);
        const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
        const arcStartRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
        const arcEndRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // arc circle and track path are tangent
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                this.setEmptyTurn(fromLegCalc, toLegCalc);
                return toIndex;
            }
            else {
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90
                : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, FlightPathTurnCalculator.vector3Cache[0]);
            // if the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius))
                : Infinity;
            const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
            const trackLimitPoint = isArcFirst
                ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4])
                : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]);
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, (isArcFirst === isInside ? -1 : 1), FlightPathTurnCalculator.vector3Cache[1]), arcCircle.center, FlightPathTurnCalculator.vector3Cache[1]), Math.PI / 2);
            const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === 'left') ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            const arcAngularWidth = ((arcDirection === 'left' ? (arcStartRadial - arcEndRadial) : (arcEndRadial - arcStartRadial)) + 360) % 360;
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * (arcDirection === 'left' ? -1 : 1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, FlightPathTurnCalculator.geoPointCache[4]);
                const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
                        arcTurnRadiusLimit = (arcRadius - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[1]), FlightPathTurnCalculator.vector3Cache[1]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
        turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
        return toIndex;
    }
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyTurn(fromLegCalc, toLegCalc) {
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        toLegCalc.ingress.length = 0;
        toLegCalc.ingressJoinIndex = -1;
    }
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     */
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
        var _a, _b;
        var _c, _d;
        const egress = (_a = (_c = fromLegCalc.egress)[0]) !== null && _a !== void 0 ? _a : (_c[0] = FlightPathUtils.createEmptyCircleVector());
        const ingress = (_b = (_d = toLegCalc.ingress)[0]) !== null && _b !== void 0 ? _b : (_d[0] = FlightPathUtils.createEmptyCircleVector());
        fromLegCalc.egress.length = 1;
        toLegCalc.ingress.length = 1;
        fromLegCalc.egressJoinIndex = fromLegCalc.flightPath.length - 1;
        toLegCalc.ingressJoinIndex = 0;
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
        const egressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (fromLegCalc.flightPath[fromLegCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        const ingressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (toLegCalc.flightPath[toLegCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(egress, circle, start, middle, egressFlags);
        FlightPathUtils.setCircleVector(ingress, circle, middle, end, ingressFlags);
    }
}
FlightPathTurnCalculator.vector3Cache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
};

/**
 * Utility class for working with flight plans.
 */
class FlightPlanUtils {
    /**
     * Checks if a leg type is an "to altitude" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "heading to" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "hold" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "hold" leg type.
     */
    static isHoldLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a manual termination leg type that ends in a discontinuity.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a manual termination leg type that ends in a discontinuity.
     */
    static isManualDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a discontinuity leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a discontinuity leg type.
     */
    static isDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    /**
     * Gets the ICAO of the facility defining the terminator of a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The ICAO of the facility defining the terminator of the specified flight plan leg, or `undefined` if
     * the leg's terminator is not defined by a facility.
     */
    static getTerminatorIcao(leg) {
        switch (leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
                return leg.fixIcao;
            default:
                return undefined;
        }
    }
}
/** Array of "to altitude" leg types. */
FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
/** Array of "heading to" leg types. */
FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold" leg types. */
FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
/** Array of manual termination leg types that end in a discontinuity. */
FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
/** Array of discontinuity leg types. */
FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];

/**
 * Modes for calculating airplane speed for use in flight path calculations.
 */
var FlightPathAirplaneSpeedMode;
(function (FlightPathAirplaneSpeedMode) {
    /** The default airplane speed is always used. */
    FlightPathAirplaneSpeedMode["Default"] = "Default";
    /** Ground speed is used. */
    FlightPathAirplaneSpeedMode["GroundSpeed"] = "GroundSpeed";
    /** True airspeed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeed"] = "TrueAirspeed";
    /** True airspeed plus wind speed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
})(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader, options, bus) {
        this.facilityLoader = facilityLoader;
        this.bus = bus;
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.turnCalculator = new FlightPathTurnCalculator();
        this.state = new FlightPathStateClass();
        this.calculateQueue = [];
        this.isBusy = false;
        this.options = Object.assign({}, options);
        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
        this.bus.getSubscriber().on('flightpath_set_options').handle(newOptions => this.setOptions(newOptions));
    }
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    setOptions(newOptions) {
        for (const key in newOptions) {
            const option = newOptions[key];
            if (option !== undefined) {
                this.options[key] = option;
                switch (key) {
                    case 'bankAngle':
                        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
                        break;
                    case 'holdBankAngle':
                        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
                        break;
                    case 'courseReversalBankAngle':
                        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
                        break;
                    case 'turnAnticipationBankAngle':
                        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
                        break;
                }
            }
        }
    }
    /**
     * Builds a bank angle lookup table.
     * @param angle A constant bank angle, in degrees, or an array of bank angle (degrees) versus airplane speed (knots)
     * breakpoints.
     * @returns A bank angle lookup table.
     */
    buildBankAngleTable(angle) {
        if (typeof angle === 'number') {
            return new LerpLookupTable([[angle, 0]]);
        }
        else {
            return new LerpLookupTable(angle);
        }
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDmeLegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDmeLegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: calc = new NoPathLegCalculator(this.facilityCache),
            [LegType.ThruDiscontinuity]: calc
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        if (this.isBusy || this.calculateQueue.length > 0) {
            return new Promise((resolve, reject) => {
                this.calculateQueue.push(() => { this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count); });
            });
        }
        else {
            return new Promise((resolve, reject) => {
                this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count);
            });
        }
    }
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    async doCalculate(resolve, reject, legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        this.isBusy = true;
        try {
            initialIndex = Math.max(0, initialIndex);
            count = Math.max(0, Math.min(legs.length - initialIndex, count));
            this.state.updatePlaneState(this.options, this.bankAngleTable, this.holdBankAngleTable, this.courseReversalBankAngleTable, this.turnAnticipationBankAngleTable);
            // Because some facilities can be mutated, we always want to get the most up-to-date version from the facility loader
            this.facilityCache.clear();
            await this.loadFacilities(legs, initialIndex, count);
            this.initCurrentLatLon(legs, initialIndex);
            this.initCurrentCourse(legs, initialIndex);
            this.initIsFallback(legs, initialIndex);
            this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
            this.turnCalculator.computeTurns(legs, initialIndex, count, this.state.desiredTurnRadius.asUnit(UnitType.METER), this.state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), this.state.desiredTurnAnticipationTurnRadius.asUnit(UnitType.METER));
            this.resolveLegsIngressToEgress(legs, initialIndex, count);
            this.updateLegDistances(legs, initialIndex, count);
            this.isBusy = false;
            resolve();
        }
        catch (e) {
            this.isBusy = false;
            reject(e);
        }
        const nextInQueue = this.calculateQueue.shift();
        if (nextInQueue !== undefined) {
            nextInQueue();
        }
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (ICAO.isFacility(icao)) {
            facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                .then(facility => {
                this.facilityCache.set(icao, facility);
                return true;
            })
                .catch(() => false));
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) || FlightPlanUtils.isManualDiscontinuityLeg(leg.leg.type)) {
                break;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initIsFallback(legs, initialIndex) {
        var _a, _b, _c;
        this.state.isFallback = (_c = (_b = (_a = legs[Math.min(initialIndex, legs.length) - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endsInFallback) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        const definition = legs[calculateIndex];
        const calcs = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state, false);
        const start = calcs.flightPath[0];
        const end = calcs.flightPath[calcs.flightPath.length - 1];
        calcs.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                calcs.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        calcs.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        calcs.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        calcs.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        calcs.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            calcs.endLat = this.state.currentPosition.lat;
            calcs.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    resolveLegsIngressToEgress(legs, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const legCalc = legs[i].calculated;
            legCalc && FlightPathUtils.resolveIngressToEgress(legCalc);
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistances(legs, initialIndex, count) {
        var _a, _b, _c, _d, _e, _f;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            // Calculate distance without transitions
            calc.distance = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distance += calc.flightPath[j].distance;
            }
            calc.cumulativeDistance = calc.distance + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
            // Calculate distance with transitions
            calc.distanceWithTransitions = 0;
            const ingressLen = calc.ingress.length;
            for (let j = 0; j < ingressLen; j++) {
                calc.distanceWithTransitions += calc.ingress[j].distance;
            }
            const ingressToEgressLen = calc.ingressToEgress.length;
            for (let j = 0; j < ingressToEgressLen; j++) {
                calc.distanceWithTransitions += calc.ingressToEgress[j].distance;
            }
            const egressLen = calc.egress.length;
            for (let j = 0; j < egressLen; j++) {
                calc.distanceWithTransitions += calc.egress[j].distance;
            }
            calc.cumulativeDistanceWithTransitions = calc.distanceWithTransitions + ((_f = (_e = (_d = legs[i - 1]) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
    }
}
/**
 * An implementation of {@link FlightPathState}
 */
class FlightPathStateClass {
    constructor() {
        this.isFallback = false;
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
        this._desiredHoldTurnRadius = UnitType.METER.createNumber(0);
        this.desiredHoldTurnRadius = this._desiredHoldTurnRadius.readonly;
        this._desiredCourseReversalTurnRadius = UnitType.METER.createNumber(0);
        this.desiredCourseReversalTurnRadius = this._desiredCourseReversalTurnRadius.readonly;
        this._desiredTurnAnticipationTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnAnticipationTurnRadius = this._desiredTurnAnticipationTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     * @param bankAngleTable A lookup table for general turn bank angle, in degrees, versus airplane speed.
     * @param holdBankAngleTable A lookup table for hold turn bank angle, in degrees, versus airplane speed, in knots.
     * If not defined, the general turn bank angle table will be used instead.
     * @param courseReversalBankAngleTable A lookup table for course reversal turn bank angle, in degrees, versus
     * airplane speed, in knots. If not defined, the general turn bank angle table will be used instead.
     * @param turnAnticipationBankAngleTable A lookup table for turn anticipation bank angle, in degrees, versus airplane
     * speed, in knots. If not defined, the general turn bank angle table will be used instead.
     */
    updatePlaneState(options, bankAngleTable, holdBankAngleTable, courseReversalBankAngleTable, turnAnticipationBankAngleTable) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        switch (options.airplaneSpeedMode) {
            case FlightPathAirplaneSpeedMode.GroundSpeed:
                this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
                break;
            case FlightPathAirplaneSpeedMode.TrueAirspeed:
            case FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind: {
                const trueAirspeed = SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots);
                const windSpeed = options.airplaneSpeedMode === FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
                    ? SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', SimVarValueType.Knots)
                    : 0;
                this._planeSpeed.set(Math.max(trueAirspeed + windSpeed, options.defaultSpeed));
                break;
            }
            default:
                this._planeSpeed.set(options.defaultSpeed);
        }
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        const planeSpeedKnots = this._planeSpeed.asUnit(UnitType.KNOT);
        this._desiredTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(bankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        if (holdBankAngleTable) {
            this._desiredHoldTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(holdBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredHoldTurnRadius.set(this._desiredTurnRadius);
        }
        if (courseReversalBankAngleTable) {
            this._desiredCourseReversalTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(courseReversalBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredCourseReversalTurnRadius.set(this._desiredTurnRadius);
        }
        if (turnAnticipationBankAngleTable) {
            this._desiredTurnAnticipationTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(turnAnticipationBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredTurnAnticipationTurnRadius.set(this._desiredTurnRadius);
        }
    }
}

var LegEventType;
(function (LegEventType) {
    LegEventType["Added"] = "Added";
    LegEventType["Removed"] = "Removed";
    LegEventType["Changed"] = "Changed";
})(LegEventType || (LegEventType = {}));
var SegmentEventType;
(function (SegmentEventType) {
    SegmentEventType["Added"] = "Added";
    SegmentEventType["Removed"] = "Removed";
    SegmentEventType["Changed"] = "Changed";
    SegmentEventType["Inserted"] = "Inserted";
})(SegmentEventType || (SegmentEventType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex, calculator, onLegNameRequested) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length` if `reverse` is `true`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse = false, startIndex, endIndex) {
        return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
     * @yields This flight plan's legs in forward order.
     */
    *_legs(startIndex = 0, endIndex = this.length) {
        endIndex = Math.min(this.length, endIndex);
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.min(segment.legs.length, endIndex - segment.offset);
                if (end <= 0) {
                    return;
                }
                for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
     * @yields This flight plan's legs in reverse order.
     */
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
        endIndex = Math.max(-1, endIndex);
        for (let i = this.planSegments.length - 1; i > -1; i--) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.max(-1, endIndex - segment.offset);
                if (end >= segment.legs.length) {
                    return;
                }
                for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment);
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment);
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        const segment = this.tryGetSegment(segmentIndex);
        if (segment === null) {
            throw new Error(`Flight plan segment with ${segmentIndex === undefined ? 'active leg' : `segment index ${segmentIndex}`} could not be found.`);
        }
        else {
            return segment;
        }
    }
    /**
     * Attempts to get a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment, or `null` if it could not be found.
     */
    tryGetSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = {
            name: this.onLegNameRequested(leg),
            leg,
            flags,
            verticalData: {
                phase: VerticalFlightPhase.Descent,
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0,
                displayAltitude1AsFlightLevel: false,
                displayAltitude2AsFlightLevel: false,
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS,
            }
        };
        if (segmentLegIndex === undefined) {
            segment.legs.push(legDefinition);
            segmentLegIndex = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(segmentLegIndex, 0, legDefinition);
        }
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition);
        return legDefinition;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLeg(arg1, arg2) {
        const leg = this._tryGetLeg(arg1, arg2);
        if (leg) {
            return leg;
        }
        throw new Error(`Leg with ${arg2 === undefined ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    tryGetLeg(arg1, arg2) {
        return this._tryGetLeg(arg1, arg2);
    }
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    _tryGetLeg(arg1, arg2) {
        var _a, _b;
        if (arg2 === undefined) {
            const legIndex = arg1;
            for (const segment of this.segments()) {
                if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                    return segment.legs[legIndex - segment.offset];
                }
            }
            return null;
        }
        else {
            const segmentIndex = arg1;
            const segmentLegIndex = arg2;
            return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
        }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (segmentLegIndex === undefined) {
            legDefinition = segment.legs.pop();
            segmentLegIndex = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(segmentLegIndex, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition);
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(globalLegIndex, notify = true) {
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);
        notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalRunway = undefined;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        // We iterate of the keys of `details` because we need to be able to set fields to undefined
        // and we only want to overwrite fields that were in the `details` object
        for (const key of Object.keys(details)) {
            this.procedureDetails[key] = details[key];
        }
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex) {
        const segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex === -1) {
            return -1;
        }
        return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            const globalLegIndex = arg1;
            if (globalLegIndex >= 0) {
                segmentIndex = this.getSegmentIndex(globalLegIndex);
                if (segmentIndex >= 0) {
                    segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegVerticalData(arg1, arg2, arg3, arg4) {
        let notify = true;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let verticalData;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            verticalData = arg2;
            notify = arg3 !== undefined ? arg3 : notify;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            verticalData = arg3;
            notify = arg4 !== undefined ? arg4 : notify;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            Object.assign(leg.verticalData, verticalData);
            notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg);
        }
        else {
            console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData(key, data, notify = true) {
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = undefined, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        this.procedureDetails.arrivalRunway = arrivalRunway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @returns The copied flight plan.
     */
    copy(planIndex, copyCalcs = false) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        newPlan.copyFrom(this, copyCalcs);
        return newPlan;
    }
    /**
     * Copies a source flight plan into this one, overriding everything in this plan with everything from the source plan.
     * @param sourcePlan The plan to copy from.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     */
    copyFrom(sourcePlan, copyCalcs = false) {
        if (sourcePlan._originAirport !== undefined) {
            this.setOriginAirport(sourcePlan._originAirport, false);
        }
        else {
            this.removeOriginAirport();
        }
        if (sourcePlan._destinationAirport !== undefined) {
            this.setDestinationAirport(sourcePlan._destinationAirport, false);
        }
        else {
            this.removeDestinationAirport();
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        this.setProcedureDetails(Object.assign(new ProcedureDetails(), sourcePlan.procedureDetails), false);
        for (let i = 0; i < sourcePlan.planSegments.length; i++) {
            const segment = sourcePlan.planSegments[i];
            if (segment !== undefined) {
                this.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
                for (const leg of segment.legs) {
                    const newLeg = this.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
                    const legIndex = this.getLegIndexFromLeg(newLeg);
                    this.setLegVerticalData(legIndex, leg.verticalData);
                    copyCalcs && FlightPlan.copyLegCalculations(leg, newLeg);
                }
            }
        }
        this.setDirectToData(sourcePlan.directToData.segmentIndex, sourcePlan.directToData.segmentLegIndex);
        // Have to copy from the private fields, because the public ones are getters, which would be lost when stringified
        this.setLateralLeg(sourcePlan._activeLateralLeg);
        this.setVerticalLeg(sourcePlan._activeVerticalLeg);
        this.setCalculatingLeg(sourcePlan._activeCalculatingLeg);
        for (const key in this.userData) {
            this.deleteUserData(key);
        }
        for (const key in sourcePlan.userData) {
            this.setUserData(key, sourcePlan.userData[key], false);
        }
    }
    /**
     * Copies leg calcs from an existing leg to a new leg.
     * @param existingLeg The leg that we want to copy the calcs from.
     * @param newLeg The leg that we want to copy the calcs to.
     * @returns the newLeg with the copied calcs.
     */
    static copyLegCalculations(existingLeg, newLeg) {
        if (existingLeg.calculated !== undefined) {
            newLeg.calculated = {
                courseMagVar: existingLeg.calculated.courseMagVar,
                initialDtk: existingLeg.calculated.initialDtk,
                distance: existingLeg.calculated.distance,
                cumulativeDistance: existingLeg.calculated.cumulativeDistance,
                distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
                cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
                startLat: existingLeg.calculated.startLat,
                startLon: existingLeg.calculated.startLon,
                endLat: existingLeg.calculated.endLat,
                endLon: existingLeg.calculated.endLon,
                flightPath: existingLeg.calculated.flightPath.map(vector => Object.assign({}, vector)),
                ingress: existingLeg.calculated.ingress.map(vector => Object.assign({}, vector)),
                ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
                ingressToEgress: existingLeg.calculated.ingressToEgress.map(vector => Object.assign({}, vector)),
                egressJoinIndex: existingLeg.calculated.egressJoinIndex,
                egress: existingLeg.calculated.egress.map(vector => Object.assign({}, vector)),
                endsInFallback: existingLeg.calculated.endsInFallback
            };
        }
        return newLeg;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0,
    verticalAngle: 0,
}, partial);

/**
 * An implementation of {@link SubEventInterface}.
 */
class SubEvent {
    constructor() {
        this.subs = [];
        this.notifyDepth = 0;
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    on(handler, paused = false) {
        const sub = new HandlerSubscription(handler, undefined, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /** @inheritdoc */
    clear() {
        this.notifyDepth++;
        for (let i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
        }
        this.notifyDepth--;
        if (this.notifyDepth === 0) {
            this.subs.length = 0;
        }
    }
    /** @inheritdoc */
    notify(sender, data) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(sender, data);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`SubEvent: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
}

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(bus, calculator, onLegNameRequested = FlightPlanner.buildDefaultLegName) {
        this.bus = bus;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        this.flightPlanSynced = new SubEvent();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('fplsync_fplRequest').handle(data => !this.ignoreSync && this.onFlightPlanRequest(data));
        subscriber.on('fplsync_fplResponse').handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on('fplsync_fplCreated').handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on('fplsync_fplDeleted').handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on('fplsync_fplActiveLegChange').handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on('fplsync_fplLegChange').handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on('fplsync_fplSegmentChange').handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on('fplsync_fplCalculated').handle(data => !this.ignoreSync && this.onCalculated(data));
        subscriber.on('fplsync_fplOriginDestChanged').handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on('fplsync_fplProcDetailsChanged').handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on('fplsync_fplIndexChanged').handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on('fplsync_fplCopied').handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on('fplsync_fplUserDataSet').handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on('fplsync_fplUserDataDelete').handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on('fplsync_fplDirectToDataChanged').handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     * @param data The event data.
     */
    onFlightPlanRequest(data) {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplResponse', {
            uid: data.uid,
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplRequest', { uid: this.lastRequestUid = Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER) }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        if (data.uid !== this.lastRequestUid) {
            return;
        }
        this.lastRequestUid = undefined;
        for (let i = 0; i < data.flightPlans.length; i++) {
            // ignore bogus flight plans
            if (data.flightPlans[i].segmentCount === 0) {
                continue;
            }
            const newPlan = new FlightPlan(i, this.calculator, this.onLegNameRequested);
            newPlan.copyFrom(data.flightPlans[i], true);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
            // Make sure the newly loaded plans are calculated at least once from the beginning
            newPlan.calculate(0);
        }
        // Only process a plan index changed event if the plan actually exists.
        if (this.flightPlans[data.planIndex]) {
            this.onPlanIndexChanged(data);
        }
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: (segmentIndex, index, type, leg) => this.sendLegChanged(planIndex, segmentIndex, index, type, leg),
            onSegmentChanged: (segmentIndex, type, segment) => this.sendSegmentChanged(planIndex, segmentIndex, type, segment),
            onActiveLegChanged: (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => this.sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type),
            onCalculated: (index) => this.sendCalculated(planIndex, index),
            onOriginDestChanged: (type, airport) => this.sendOriginDestChanged(planIndex, type, airport),
            onProcedureDetailsChanged: (details) => this.sendProcedureDetailsChanged(planIndex, details),
            onUserDataSet: (key, data) => this.sendUserDataSet(planIndex, key, data),
            onUserDataDelete: (key) => this.sendUserDataDelete(planIndex, key),
            onDirectDataChanged: (directToData) => this.sendDirectToData(planIndex, directToData)
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, copyCalcs = false, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        const newPlan = sourcePlan.copy(targetPlanIndex, copyCalcs);
        newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
        this.flightPlans[targetPlanIndex] = newPlan;
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex, copyCalcs);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, data.copyCalcs, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     * @param copyCalcs Whether to leg calculations were copied.
     */
    sendPlanCopied(planIndex, targetPlanIndex, copyCalcs) {
        const data = { planIndex, targetPlanIndex, copyCalcs };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        const plan = this.getFlightPlan(data.planIndex);
        let localLeg;
        switch (data.type) {
            case LegEventType.Added: {
                localLeg = plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.flags, false);
                break;
            }
            case LegEventType.Removed: {
                const leg = plan.removeLeg(data.segmentIndex, data.legIndex, false);
                // We don't want to send the event locally if we didn't find a leg
                if (!leg) {
                    return;
                }
                localLeg = leg;
                break;
            }
            case LegEventType.Changed: {
                try {
                    localLeg = plan.getLeg(data.segmentIndex, data.legIndex);
                }
                catch (_a) {
                    // We don't want to send the event locally if we didn't find a leg
                    return;
                }
                plan.setLegVerticalData(data.segmentIndex, data.legIndex, data.leg.verticalData, false);
                break;
            }
        }
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg
        };
        this.sendEvent('fplLegChange', localData, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        var _a, _b;
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        let localSegment = undefined;
        switch (data.type) {
            case SegmentEventType.Added:
                localSegment = data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Inserted:
                localSegment = data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Removed:
                localSegment = (_a = plan.tryGetSegment(data.segmentIndex)) !== null && _a !== void 0 ? _a : undefined;
                plan.removeSegment(data.segmentIndex, false);
                break;
            case SegmentEventType.Changed:
                localSegment = data.segment === undefined ? undefined : (_b = plan.tryGetSegment(data.segmentIndex)) !== null && _b !== void 0 ? _b : undefined;
                if (localSegment === undefined) {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        // We need to send a reference to the local flight plan's copy of the segment with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            segment: localSegment
        };
        this.sendEvent('fplSegmentChange', localData, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    sendSegmentChanged(planIndex, index, type, segment) {
        const data = {
            planIndex, segmentIndex: index, type, segment
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) {
        const data = {
            segmentIndex, legIndex, planIndex,
            index, previousSegmentIndex, previousLegIndex, type
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    async onCalculated(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        await plan.calculate(data.index, false);
        if (this.flightPlans[data.planIndex] !== plan) {
            return;
        }
        this.sendEvent('fplCalculated', data, false);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    sendCalculated(planIndex, index) {
        const data = { planIndex, index };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    sendOriginDestChanged(planIndex, type, airport) {
        const data = { planIndex, type, airport };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        plan.setProcedureDetails(Object.assign(new ProcedureDetails(), data.details), false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    sendProcedureDetailsChanged(planIndex, details) {
        const data = { planIndex, details };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    sendUserDataSet(planIndex, key, userData) {
        const data = { planIndex, key, data: userData };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    sendUserDataDelete(planIndex, key) {
        const data = { planIndex, key, data: undefined };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    sendDirectToData(planIndex, directToData) {
        const data = { planIndex, directToData: directToData };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator, onLegNameRequested) {
        var _a;
        return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : (FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator, onLegNameRequested));
    }
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
}

/**
 * A collection of unique string waypoint type keys.
 */
var WaypointTypes;
(function (WaypointTypes) {
    WaypointTypes["Custom"] = "Custom";
    WaypointTypes["Airport"] = "Airport";
    WaypointTypes["NDB"] = "NDB";
    WaypointTypes["VOR"] = "VOR";
    WaypointTypes["Intersection"] = "Intersection";
    WaypointTypes["Runway"] = "Runway";
    WaypointTypes["User"] = "User";
    WaypointTypes["Visual"] = "Visual";
    WaypointTypes["FlightPlan"] = "FlightPlan";
    WaypointTypes["VNAV"] = "VNAV";
})(WaypointTypes || (WaypointTypes = {}));
/**
 * An abstract implementation of Waypoint.
 */
class AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(other) {
        return this.uid === other.uid;
    }
}
/**
 * A basic implementation of {@link FacilityWaypoint}.
 */
class BasicFacilityWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     * @param bus The event bus.
     */
    constructor(facility, bus) {
        super();
        this.bus = bus;
        /** @inheritdoc */
        this.isFacilityWaypoint = true;
        this._facility = Subject.create(facility);
        this._location = GeoPointSubject.createFromGeoPoint(new GeoPoint(facility.lat, facility.lon));
        this._type = BasicFacilityWaypoint.getType(facility);
        const facType = ICAO.getFacilityType(facility.icao);
        if (facType === FacilityType.VIS || facType === FacilityType.USR) {
            // These types of facilities can be mutated. So we need to listen to the event bus for change events and respond
            // accordingly.
            this.facChangeSub = this.bus.getSubscriber()
                .on(`facility_changed_${facility.icao}`)
                .handle(newFacility => {
                this._facility.set(newFacility);
                this._location.set(newFacility.lat, newFacility.lon);
            });
        }
    }
    /** @inheritdoc */
    get location() {
        return this._location;
    }
    /** @inheritdoc */
    get uid() {
        return this.facility.get().icao;
    }
    /** @inheritdoc */
    get type() {
        return this._type;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The facility associated with this waypoint.
     */
    get facility() {
        return this._facility;
    }
    /**
     * Gets a waypoint type from a facility.
     * @param facility A facility.
     * @returns The waypoint type corresponding to the facility.
     */
    static getType(facility) {
        switch (ICAO.getFacilityType(facility.icao)) {
            case FacilityType.Airport:
                return WaypointTypes.Airport;
            case FacilityType.Intersection:
                return WaypointTypes.Intersection;
            case FacilityType.NDB:
                return WaypointTypes.NDB;
            case FacilityType.RWY:
                return WaypointTypes.Runway;
            case FacilityType.USR:
                return WaypointTypes.User;
            case FacilityType.VIS:
                return WaypointTypes.Visual;
            case FacilityType.VOR:
                return WaypointTypes.VOR;
            default:
                return WaypointTypes.User;
        }
    }
}
/**
 * A utility class for working with FacilityWaypoint.
 */
class FacilityWaypointUtils {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isFacilityWaypoint(waypoint, facilityType) {
        if (waypoint.isFacilityWaypoint !== true) {
            return false;
        }
        return facilityType === undefined || FacilityUtils.isFacilityType(waypoint.facility.get(), facilityType);
    }
}
/**
 * A flight path waypoint.
 */
class FlightPathWaypoint extends AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg1, arg2, arg3, arg4, arg5) {
        super();
        if (typeof arg1 === 'number') {
            this._location = GeoPointSubject.create(new GeoPoint(arg1, arg2));
            this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg4}`;
            this.leg = arg3;
            this.ident = arg5;
        }
        else {
            this._location = arg1;
            this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg3}`;
            this.leg = arg2;
            this.ident = arg4;
        }
    }
    /** @inheritdoc */
    get location() {
        return this._location;
    }
    /** @inheritdoc */
    get uid() {
        return this._uid;
    }
    /** @inheritdoc */
    get type() { return WaypointTypes.FlightPlan; }
}
FlightPathWaypoint.UID_PREFIX = 'FLPTH';
/**
 * A VNAV waypoint.
 */
class VNavWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param uid A unique ID to assign to the VNAV waypoint.
     * @param ident This waypoint's ident string.
     */
    constructor(leg, distanceFromEnd, uid, ident) {
        super();
        this.ident = ident;
        this._uid = uid;
        this._location = GeoPointSubject.create(this.getWaypointLocation(leg, distanceFromEnd, new GeoPoint(0, 0)));
    }
    /** @inheritdoc */
    get type() { return WaypointTypes.VNAV; }
    /** @inheritdoc */
    get location() {
        return this._location;
    }
    /** @inheritdoc */
    get uid() {
        return this._uid;
    }
    /**
     * Sets this waypoint's location.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     */
    setLocation(leg, distanceFromEnd) {
        this._location.set(this.getWaypointLocation(leg, distanceFromEnd, VNavWaypoint.geoPointCache[0]));
    }
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param out The GeoPoint object to which to write the location.
     * @returns The waypoint's location.
     */
    getWaypointLocation(leg, distanceFromEnd, out) {
        var _a, _b;
        if (leg.calculated !== undefined) {
            const vectors = [...leg.calculated.ingress, ...leg.calculated.ingressToEgress, ...leg.calculated.egress];
            let vectorIndex = vectors.length - 1;
            while (vectorIndex >= 0) {
                const vector = vectors[vectorIndex];
                const vectorDistance = vector.distance;
                if (vectorDistance >= distanceFromEnd) {
                    const end = GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, VNavWaypoint.vec3Cache[0]);
                    return FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0])
                        .offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out, Math.PI);
                }
                else {
                    distanceFromEnd -= vectorDistance;
                }
                vectorIndex--;
            }
            if (vectors.length > 0) {
                out.set(vectors[0].startLat, vectors[0].startLon);
            }
            else {
                out.set((_a = leg.calculated.endLat) !== null && _a !== void 0 ? _a : 0, (_b = leg.calculated.endLon) !== null && _b !== void 0 ? _b : 0);
            }
        }
        return out;
    }
}
VNavWaypoint.vec3Cache = [new Float64Array(3)];
VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A default implementation of {@link FacilityWaypointCache}.
 */
class DefaultFacilityWaypointCache {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param size The maximum size of this cache.
     */
    constructor(bus, size) {
        this.bus = bus;
        this.size = size;
        this.cache = new Map();
    }
    /** @inheritdoc */
    get(facility) {
        const key = DefaultFacilityWaypointCache.getFacilityKey(facility);
        let existing = this.cache.get(key);
        if (!existing) {
            existing = new BasicFacilityWaypoint(facility, this.bus);
            this.addToCache(key, existing);
        }
        return existing;
    }
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param key The key of the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    addToCache(key, waypoint) {
        this.cache.set(key, waypoint);
        if (this.cache.size > this.size) {
            this.cache.delete(this.cache.keys().next().value);
        }
    }
    /**
     * Gets a FacilityWaypointCache instance.
     * @param bus The event bus.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache(bus) {
        var _a;
        return (_a = DefaultFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : (DefaultFacilityWaypointCache.INSTANCE = new DefaultFacilityWaypointCache(bus, 1000));
    }
    /**
     * Gets the cache key for a facility.
     * @param facility A facility.
     * @returns The cache key for the specified facility.
     */
    static getFacilityKey(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.Intersection) && ICAO.getFacilityType(facility.icao) !== FacilityType.Intersection) {
            return `mismatch.${facility.icao}`;
        }
        return facility.icao;
    }
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
var SubscribableSetEventType;
(function (SubscribableSetEventType) {
    /** A key was added. */
    SubscribableSetEventType["Added"] = "Added";
    /** A key was deleted. */
    SubscribableSetEventType["Deleted"] = "Deleted";
})(SubscribableSetEventType || (SubscribableSetEventType = {}));

/**
 * A pipe from an input subscribable set to an output mutable subscribable set. Each key added/removed notification
 * received by the pipe is used to add/remove keys to/from the output set.
 */
class SubscribableSetPipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let initialNotifyFunc;
        let onDestroy;
        if (typeof arg4 === 'function') {
            const toCast = to;
            const map = arg3;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(map(key));
                }
                else {
                    const mappedKey = map(key);
                    // Only delete the mapped key if no other key in the input set maps to the same key
                    for (const inputKey of set) {
                        if (map(inputKey) === mappedKey) {
                            return;
                        }
                    }
                    toCast.delete(mappedKey);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set();
                for (const key of fromSet) {
                    toAdd.add(map(key));
                }
                for (const key of toCast.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg4;
        }
        else {
            const toCast = to;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(key);
                }
                else {
                    toCast.delete(key);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set(fromSet);
                for (const key of to.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg3;
        }
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableSet {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableSet = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this set.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    notify(type, key) {
        const set = this.get();
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(set, type, key);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(set, type, key);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const set = this.get();
        for (const key of set) {
            sub.handler(set, SubscribableSetEventType.Added, key);
        }
    }
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class ArraySubject extends AbstractSubscribableArray {
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
        super();
        this.array = arr;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of this array. */
    get length() {
        return this.array.length;
    }
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
        return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index) {
        if (index === undefined || index > this.array.length - 1) {
            index = this.array.length;
            this.array.push(item);
        }
        else {
            this.array.splice(index, 0, item);
        }
        this.notify(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
        this.array.splice(index, 0, ...arr);
        this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
        const removedItem = this.array.splice(index, 1);
        this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
        const index = this.array.indexOf(item);
        if (index > -1) {
            this.removeAt(index);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
        this.clear();
        this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
        this.array.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
        return this.array;
    }
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template I The type of the input value.
 * @template T The type of the computed output value.
 */
class ComputedSubject {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
        this.computeFn = computeFn;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
        this.rawValue = value;
        this.value = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
        return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        this.rawValue = value;
        const compValue = this.computeFn(value);
        if (compValue !== this.value) {
            this.value = compValue;
            this.notify();
        }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
        return this.value;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
        return this.rawValue;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    this.notifySubscription(sub);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ComputedSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.value, this.rawValue);
    }
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
class ObjectSubject {
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    constructor(obj) {
        this.obj = obj;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.initialNotify.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create(v) {
        return new ObjectSubject(v);
    }
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get() {
        return this.obj;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, value) {
        if (typeof arg1 === 'object') {
            for (const prop in arg1) {
                if (prop in this.obj) {
                    this.set(prop, arg1[prop]);
                }
            }
        }
        else {
            const oldValue = this.obj[arg1];
            if (value !== oldValue) {
                this.obj[arg1] = value;
                this.notify(arg1, oldValue);
            }
        }
    }
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    notify(key, oldValue) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(this.obj, key, this.obj[key], oldValue);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ObjectSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        for (const key in this.obj) {
            const v = this.obj[key];
            sub.handler(this.obj, key, v, v);
        }
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A subscribable set whose keys can be freely added and removed.
 */
class SetSubject extends AbstractSubscribableSet {
    /**
     * Constructor.
     * @param initialKeys The keys with which to initialize this set. If not defined, this set will be initialized to the
     * empty set.
     */
    constructor(initialKeys) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableSet = true;
        this.backingSet = new Set(initialKeys);
    }
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not undefined, the new set will be initialized
     * to the empty set.
     * @returns A new SetSubject instance.
     */
    static create(initialKeys) {
        return new SetSubject(initialKeys);
    }
    /** @inheritdoc */
    get() {
        return this.backingSet;
    }
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys) {
        const toAdd = new Set(keys);
        for (const key of this.backingSet) {
            if (!toAdd.delete(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd) {
            this.add(key);
        }
    }
    /** @inheritdoc */
    add(key) {
        const oldSize = this.backingSet.size;
        this.backingSet.add(key);
        if (oldSize !== this.backingSet.size) {
            this.notify(SubscribableSetEventType.Added, key);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const wasDeleted = this.backingSet.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableSetEventType.Deleted, key);
        }
        return wasDeleted;
    }
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set. If not defined, the key will be added to this set if it is not already present and
     * removed if it is already present.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key, force) {
        const shouldAdd = force !== null && force !== void 0 ? force : !this.backingSet.has(key);
        if (shouldAdd) {
            this.add(key);
        }
        else {
            this.delete(key);
        }
        // Explicitly query the set again instead of just returning shouldAdd in case the key was manipulated in a handler
        // triggered by its addition/removal
        return this.backingSet.has(key);
    }
    /**
     * Removes all keys from this set.
     */
    clear() {
        for (const key of this.backingSet) {
            this.backingSet.delete(key);
            this.notify(SubscribableSetEventType.Deleted, key);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for electrical information.
 */
class ElectricalPublisher extends SimVarPublisher {
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ElectricalPublisher.simvars, bus, pacer);
        this.flightStarted = false;
        this.avBusList = ['elec_av1_bus', 'elec_av2_bus'];
        for (const topic of this.avBusList) {
            if (bus.getTopicSubscriberCount(topic)) {
                this.subscribed.add(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((event) => {
            if (this.avBusList.includes(event)) {
                this.subscribed.add(event);
            }
        });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.flightStarted = true;
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.flightStarted) {
            super.onUpdate();
            if (this.av1BusLogic && this.subscribed.has('elec_av1_bus')) {
                this.publish('elec_av1_bus', this.av1BusLogic.getValue() !== 0);
            }
            if (this.av2BusLogic && this.subscribed.has('elec_av2_bus')) {
                this.publish('elec_av2_bus', this.av2BusLogic.getValue() !== 0);
            }
        }
    }
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement) {
        this.av1BusLogic = logicElement;
    }
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement) {
        this.av2BusLogic = logicElement;
    }
}
ElectricalPublisher.simvars = new Map([
    ['elec_master_battery', { name: 'ELECTRICAL MASTER BATTERY:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_avionics_on', { name: 'CIRCUIT AVIONICS ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_navcom1_on', { name: 'CIRCUIT NAVCOM1 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom2_on', { name: 'CIRCUIT NAVCOM2 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom3_on', { name: 'CIRCUIT NAVCOM3 ON', type: SimVarValueType.Bool }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE:#index#', type: SimVarValueType.Volts, indexed: true }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_2_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:2', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_3_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:3', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_4_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:4', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_5_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:5', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_6_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:6', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_2_a', { name: 'ELECTRICAL GENALT BUS AMPS:2', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_3_a', { name: 'ELECTRICAL GENALT BUS AMPS:3', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_4_a', { name: 'ELECTRICAL GENALT BUS AMPS:4', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_5_a', { name: 'ELECTRICAL GENALT BUS AMPS:5', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_6_a', { name: 'ELECTRICAL GENALT BUS AMPS:6', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_ext_power_available', { name: 'EXTERNAL POWER AVAILABLE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_ext_power_on', { name: 'EXTERNAL POWER ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_switch', { name: 'APU GENERATOR SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_active', { name: 'APU GENERATOR ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_eng_gen_switch', { name: 'GENERAL ENG MASTER ALTERNATOR:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_on', { name: 'CIRCUIT ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_switch_on', { name: 'CIRCUIT SWITCH ON:#index#', type: SimVarValueType.Bool, indexed: true }],
]);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/** A publisher for Engine information. */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const isUsingAdvancedFuelSystem = SimVar.GetSimVarValue('NEW FUEL SYSTEM', SimVarValueType.Bool) !== 0;
        const totalUnusableFuelGal = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.GAL);
        const totalUnusableFuelLb = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.LBS);
        const nonIndexedSimVars = [
            ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
            ['fuel_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_usable_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelGal, 0) }],
            ['fuel_usable_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelLb, 0) }],
            ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main', { name: 'FUEL TANK LEFT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main_pct', { name: 'FUEL TANK LEFT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_right_main', { name: 'FUEL TANK RIGHT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right_main_pct', { name: 'FUEL TANK RIGHT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_center', { name: 'FUEL TANK CENTER QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_weight_per_gallon', { name: 'FUEL WEIGHT PER GALLON', type: SimVarValueType.LBS }],
            ['fuel_tank_selector_state_1', { name: 'FUEL TANK SELECTOR:1', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_2', { name: 'FUEL TANK SELECTOR:2', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_3', { name: 'FUEL TANK SELECTOR:3', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_4', { name: 'FUEL TANK SELECTOR:4', type: SimVarValueType.Number }],
            ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
            ['apu_pct', { name: 'APU PCT RPM', type: SimVarValueType.Percent }],
            ['apu_pct_starter', { name: 'APU PCT STARTER', type: SimVarValueType.Percent }],
            ['apu_switch', { name: 'APU SWITCH', type: SimVarValueType.Bool }],
            ['eng_starter_active', { name: 'GENERAL ENG STARTER ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
        ];
        const engineIndexedSimVars = [
            ['rpm', { name: 'GENERAL ENG RPM', type: SimVarValueType.RPM }],
            ['prop_rpm', { name: 'PROP RPM', type: SimVarValueType.RPM }],
            ['n1', { name: 'TURB ENG CORRECTED N1', type: SimVarValueType.Percent }],
            ['n2', { name: 'TURB ENG CORRECTED N2', type: SimVarValueType.Percent }],
            ['torque', { name: 'TURB ENG MAX TORQUE PERCENT', type: SimVarValueType.Percent }],
            ['fuel_flow', { name: 'ENG FUEL FLOW GPH', type: SimVarValueType.GPH }],
            ['recip_ff', { name: 'RECIP ENG FUEL FLOW', type: SimVarValueType.PPH }],
            ['oil_press', { name: 'ENG OIL PRESSURE', type: SimVarValueType.PSI }],
            ['oil_temp', { name: 'ENG OIL TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['itt', { name: 'TURB ENG ITT', type: SimVarValueType.Celsius }],
            ['egt', { name: 'ENG EXHAUST GAS TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['eng_hyd_press', { name: 'ENG HYDRAULIC PRESSURE', type: SimVarValueType.PSI }],
            ['eng_starter_on', { name: 'GENERAL ENG STARTER', type: SimVarValueType.Bool }],
            ['eng_combustion', { name: 'GENERAL ENG COMBUSTION', type: SimVarValueType.Bool }],
            ['eng_ignition_switch_state', { name: 'TURB ENG IGNITION SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_igniting', { name: 'TURB ENG IS IGNITING', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_on', { name: 'GENERAL ENG FUEL PUMP ON', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_switch_state', { name: 'GENERAL ENG FUEL PUMP SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_vibration', { name: 'ENG VIBRATION', type: SimVarValueType.Number }],
            ['eng_fuel_flow_switch', { name: 'FUELSYSTEM VALVE OPEN', type: SimVarValueType.Bool }],
            ['fuel_flow_pph', { name: 'ENG FUEL FLOW PPH', type: SimVarValueType.PPH }],
        ];
        const simvars = new Map(nonIndexedSimVars);
        // add engine-indexed simvars
        const engineCount = SimVar.GetSimVarValue('NUMBER OF ENGINES', SimVarValueType.Number);
        for (const [topic, simvar] of [...engineIndexedSimVars]) {
            // describe the indexed engine topics
            for (let i = 1; i <= engineCount; i++) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
        this.engineCount = engineCount;
        this.subscribed.add('fuel_flow_total');
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.subscribed.has('fuel_flow_total')) {
            let totalFuelFlow = 0;
            for (let i = 1; i <= this.engineCount; i++) {
                totalFuelFlow += SimVar.GetSimVarValue(`ENG FUEL FLOW GPH:${i}`, SimVarValueType.GPH);
            }
            this.publish('fuel_flow_total', totalFuelFlow);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Engine information.
 */
class WeightBalanceSimvarPublisher extends SimVarPublisher {
    /**
     * Create a WeightAndBalancePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['total_weight', { name: 'TOTAL WEIGHT', type: SimVarValueType.Pounds }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * Flight timer modes.
 */
var FlightTimerMode;
(function (FlightTimerMode) {
    FlightTimerMode[FlightTimerMode["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode[FlightTimerMode["CountingUp"] = 1] = "CountingUp";
})(FlightTimerMode || (FlightTimerMode = {}));
/**
 * A publisher for flight timer information.
 */
class FlightTimerPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, timerCount, pacer) {
        const simVars = new Map();
        const baseSimVars = [
            ['timer_mode', { name: 'L:WTFltTimer_Mode', type: SimVarValueType.Number }],
            ['timer_is_running', { name: 'L:WTFltTimer_Running', type: SimVarValueType.Bool }],
            ['timer_initial_value_ms', { name: 'L:WTFltTimer_Initial_Value', type: SimVarValueType.Number }],
            ['timer_value_ms', { name: 'L:WTFltTimer_Value', type: SimVarValueType.Number }]
        ];
        timerCount = Math.max(timerCount, 0);
        for (let i = 1; i <= timerCount; i++) {
            for (const [topic, simvar] of baseSimVars) {
                simVars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type
                });
            }
        }
        super(simVars, bus, pacer);
    }
}
/**
 * An instrument which manages zero or more flight timers. Requires the topics defined in {@link ClockEvents} to be
 * actively published to the event bus in order to function properly. All timers operate using simulation time and are
 * updated every instrument update cycle with up to millisecond precision.
 */
class FlightTimerInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     */
    constructor(bus, timerCount) {
        this.bus = bus;
        this.timers = {};
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), 0).pause();
        this.lastUpdateSimTime = this.simTime.get();
        this.timerCount = Math.max(timerCount, 0);
        for (let i = 1; i <= this.timerCount; i++) {
            this.timers[i] = new FlightTimer(bus, i);
        }
    }
    /** @inheritdoc */
    init() {
        this.simTime.resume();
        this.lastUpdateSimTime = this.simTime.get();
        for (let i = 1; i <= this.timerCount; i++) {
            this.timers[i].init(this.lastUpdateSimTime);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        const currentSimTime = this.simTime.get();
        for (let i = 1; i <= this.timerCount; i++) {
            this.timers[i].update(currentSimTime);
        }
        this.lastUpdateSimTime = currentSimTime;
    }
}
/**
 * A flight timer.
 */
class FlightTimer {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of this timer.
     */
    constructor(bus, index) {
        this.bus = bus;
        this.index = index;
        this.simVars = {
            mode: `L:WTFltTimer_Mode:${this.index}`,
            isRunning: `L:WTFltTimer_Running:${this.index}`,
            referenceTime: `L:WTFltTimer_Reference_Time:${this.index}`,
            referenceValue: `L:WTFltTimer_Reference_Value:${this.index}`,
            initialValue: `L:WTFltTimer_Initial_Value:${this.index}`,
            currentValue: `L:WTFltTimer_Value:${this.index}`
        };
        this.simTime = 0;
        this.mode = FlightTimerMode.CountingDown;
        this.isRunning = false;
        this.referenceTime = 0;
        this.referenceValue = 0;
        this.initialValue = 0;
        this.currentValue = 0;
    }
    /**
     * Initializes this timer. Once this timer is initialized, it will respond to timer control events.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     */
    init(time) {
        this.simTime = time;
        // Initialize state from simvars
        this.mode = SimVar.GetSimVarValue(this.simVars.mode, SimVarValueType.Number);
        this.isRunning = !!SimVar.GetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool);
        this.referenceTime = SimVar.GetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number);
        this.referenceValue = SimVar.GetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number);
        this.initialValue = SimVar.GetSimVarValue(this.simVars.initialValue, SimVarValueType.Number);
        this.currentValue = SimVar.GetSimVarValue(this.simVars.currentValue, SimVarValueType.Number);
        // Subscribe to control events
        const sub = this.bus.getSubscriber();
        sub.on(`timer_set_mode_${this.index}`).handle(mode => {
            this.mode = mode;
            this.referenceTime = this.simTime;
            this.referenceValue = this.currentValue;
            SimVar.SetSimVarValue(this.simVars.mode, SimVarValueType.Number, mode);
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
        });
        sub.on(`timer_set_initial_value_${this.index}`).handle(value => {
            this.initialValue = value;
            SimVar.SetSimVarValue(this.simVars.initialValue, SimVarValueType.Number, this.initialValue);
        });
        sub.on(`timer_set_value_${this.index}`).handle(value => {
            this.referenceTime = this.simTime;
            this.referenceValue = value;
            this.currentValue = value;
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
        });
        sub.on(`timer_start_${this.index}`).handle(() => {
            if (this.isRunning) {
                return;
            }
            this.isRunning = true;
            this.referenceTime = this.simTime;
            this.referenceValue = this.currentValue;
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
            SimVar.SetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool, 1);
        });
        sub.on(`timer_stop_${this.index}`).handle(() => {
            if (!this.isRunning) {
                return;
            }
            this.isRunning = false;
            SimVar.SetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool, 0);
        });
        sub.on(`timer_reset_${this.index}`).handle(() => {
            this.referenceTime = this.simTime;
            this.referenceValue = this.initialValue;
            this.currentValue = this.initialValue;
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
            SimVar.SetSimVarValue(this.simVars.currentValue, SimVarValueType.Number, this.currentValue);
        });
    }
    /**
     * Updates this timer's current value.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        this.simTime = time;
        if (!this.isRunning) {
            return;
        }
        const modeSign = this.mode === FlightTimerMode.CountingDown ? -1 : 1;
        const value = this.referenceValue + (time - this.referenceTime) * modeSign;
        this.currentValue = value;
        SimVar.SetSimVarValue(this.simVars.currentValue, SimVarValueType.Number, value);
    }
}

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * A publisher for global positioning and inertial data.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['zulu_time', { name: 'E:ZULU TIME', type: SimVarValueType.Seconds }],
            ['time_of_day', { name: 'E:TIME OF DAY', type: SimVarValueType.Number }],
            ['ground_speed', { name: 'GROUND VELOCITY', type: SimVarValueType.Knots }],
            ['inertial_vertical_speed', { name: 'VELOCITY WORLD Y', type: SimVarValueType.FPM }]
        ]), this.bus, this.pacer);
        this.needPublish = {
            'gps-position': false,
            'track_deg_true': false,
            'track_deg_magnetic': false,
            'magvar': false,
            'inertial_speed': false,
            'inertial_acceleration': false,
            'inertial_track_acceleration': false
        };
        for (const topic in this.needPublish) {
            this.needPublish[topic] = bus.getTopicSubscriberCount(topic) > 0;
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle(this.onTopicSubscribed.bind(this));
    }
    /**
     * Responds to when a topic is first subscribed to on the event bus.
     * @param topic The subscribed topic.
     */
    onTopicSubscribed(topic) {
        if (topic in this.needPublish) {
            this.needPublish[topic] = true;
            if (this.publishActive) {
                switch (topic) {
                    case 'gps-position':
                        this.publishPosition();
                        break;
                    case 'track_deg_true':
                        this.publishTrack(true, false, false);
                        break;
                    case 'track_deg_magnetic':
                        this.publishTrack(false, true, false);
                        break;
                    case 'magvar':
                        this.publishTrack(false, false, true);
                        break;
                    case 'inertial_speed':
                        this.publishInertialData(true, false, false);
                        break;
                    case 'inertial_acceleration':
                        this.publishInertialData(false, true, false);
                        break;
                    case 'inertial_track_acceleration':
                        this.publishInertialData(false, false, true);
                        break;
                }
            }
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        this.needPublish['gps-position'] && this.publishPosition();
        this.publishTrack(this.needPublish['track_deg_true'], this.needPublish['track_deg_magnetic'], this.needPublish['magvar']);
        this.publishInertialData(this.needPublish['inertial_speed'], this.needPublish['inertial_acceleration'], this.needPublish['inertial_track_acceleration']);
        this.simVarPublisher.onUpdate();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Meters);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the `track_deg_true`, `track_deg_magnetic`, and `magvar` topics.
     * @param publishTrue Whether to publish the `track_deg_true` topic.
     * @param publishMagnetic Whether to publish the `track_deg_magnetic` topic.
     * @param publishMagvar Whether to publish the `magvar` topic.
     */
    publishTrack(publishTrue, publishMagnetic, publishMagvar) {
        let trueTrack = 0;
        let magneticTrack = 0;
        let magvar = 0;
        if (publishTrue || publishMagnetic) {
            const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
            trueTrack = GNSSPublisher.getInstantaneousTrack(headingTrue);
        }
        if (publishMagvar || publishMagnetic) {
            magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
            if (publishMagnetic) {
                magneticTrack = NavMath.normalizeHeading(trueTrack - magvar);
            }
        }
        publishTrue && this.publish('track_deg_true', trueTrack);
        publishMagnetic && this.publish('track_deg_magnetic', magneticTrack);
        publishMagvar && this.publish('magvar', magvar);
    }
    /**
     * Publishes the `inertial_speed`, `inertial_acceleration`, and `inertial_track_acceleration` topics.
     * @param publishSpeed Whether to publish the `inertial_speed` topic.
     * @param publishAcceleration Whether to publish the `inertial_acceleration` topic.
     * @param publishTrackAcceleration Whether to publish the `inertial_track_acceleration` topic.
     */
    publishInertialData(publishSpeed, publishAcceleration, publishTrackAcceleration) {
        const velocityVec = this.vec3Cache[0];
        const accelerationVec = this.vec3Cache[1];
        let speed = 0;
        let acceleration = 0;
        if (publishSpeed || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('VELOCITY BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Z', SimVarValueType.MetersPerSecond), velocityVec);
            speed = Vec3Math.abs(velocityVec);
        }
        if (publishAcceleration || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('ACCELERATION BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Z', SimVarValueType.MetersPerSecond), accelerationVec);
            acceleration = Vec3Math.abs(accelerationVec);
        }
        publishSpeed && this.publish('inertial_speed', speed);
        publishAcceleration && this.publish('inertial_acceleration', acceleration);
        publishTrackAcceleration && this.publish('inertial_track_acceleration', speed === 0 ? acceleration : Vec3Math.dot(accelerationVec, velocityVec) / speed);
    }
    /**
     * Gets the instantaneous true track.
     * @param headingTrue The true heading, in degrees.
     * @returns The true track, in degrees.
     */
    static getInstantaneousTrack(headingTrue = 0) {
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(Math.atan2(velocityEW, velocityNS) * Avionics.Utils.RAD2DEG);
        }
        return track;
    }
}

/**
 * A heap which allocates instances of a resource.
 */
class ResourceHeap {
    /**
     * Constructor.
     * @param factory A function which creates new instances of this heap's resource.
     * @param destructor A function which destroys instances of this heap's resource.
     * @param onAllocated A function which is called when an instance of this heap's resource is allocated.
     * @param onFreed A function which is called when an instance of this heap's resource is freed.
     * @param initialSize The initial size of this heap. Defaults to `0`.
     * @param maxSize The maximum size of this heap. Defaults to `Number.MAX_SAFE_INTEGER`. This heap cannot allocate
     * more resources than its maximum size.
     * @param autoShrinkThreshold The size above which this heap will attempt to automatically reduce its size when
     * resources are freed. The heap will never reduce its size below this threshold. Defaults to
     * `Number.MAX_SAFE_INTEGER`.
     */
    constructor(factory, destructor, onAllocated, onFreed, initialSize = 0, maxSize = Number.MAX_SAFE_INTEGER, autoShrinkThreshold = Number.MAX_SAFE_INTEGER) {
        this.factory = factory;
        this.destructor = destructor;
        this.onAllocated = onAllocated;
        this.onFreed = onFreed;
        this.maxSize = maxSize;
        this.autoShrinkThreshold = autoShrinkThreshold;
        this.cache = [];
        this.numAllocated = 0;
        for (let i = 0; i < Math.min(initialSize, maxSize); i++) {
            this.cache.push(factory());
        }
    }
    /**
     * Allocates a resource instance from this heap. If this heap has an existing free resource available, one will be
     * returned. Otherwise, a new resource instance will be created, added to the heap, and returned.
     * @returns A resource.
     * @throws Error if this heap has reached its allocation limit.
     */
    allocate() {
        if (this.numAllocated >= this.maxSize) {
            throw new Error(`ResourceHeap: maximum number of allocations (${this.maxSize}) reached`);
        }
        let resource;
        if (this.numAllocated < this.cache.length) {
            resource = this.cache[this.numAllocated];
        }
        else {
            this.cache.push(resource = this.factory());
        }
        this.numAllocated++;
        if (this.onAllocated !== undefined) {
            this.onAllocated(resource);
        }
        return resource;
    }
    /**
     * Frees a resource instance allocated from this heap, allowing it to be re-used.
     * @param resource The resource to free.
     */
    free(resource) {
        const index = this.cache.indexOf(resource);
        if (index < 0 || index >= this.numAllocated) {
            return;
        }
        const freed = this.cache[index];
        this.numAllocated--;
        this.cache[index] = this.cache[this.numAllocated];
        this.cache[this.numAllocated] = freed;
        // If the heap size is over the auto-shrink threshold and the number of allocated instances drops to less than or
        // equal to half of the heap size, then reduce the size of the heap to the threshold, or 125% of the number of
        // allocated instances, whichever is greater.
        if (this.cache.length > this.autoShrinkThreshold && this.numAllocated <= this.cache.length / 2) {
            const newLength = Math.max(this.autoShrinkThreshold, this.numAllocated * 1.25);
            for (let i = newLength; i < this.cache.length; i++) {
                this.destructor(this.cache[i]);
            }
            this.cache.length = newLength;
        }
        if (this.onFreed !== undefined) {
            this.onFreed(resource);
        }
    }
}

/**
 * SBAS group names.
 */
var SBASGroupName;
(function (SBASGroupName) {
    /** Wide Area Augmentation System (USA). */
    SBASGroupName["WAAS"] = "WAAS";
    /** European Geostationary Navigation Overlay Service (EU). */
    SBASGroupName["EGNOS"] = "EGNOS";
    /** GPS Aided Geo Augmented Navigation System (India). */
    SBASGroupName["GAGAN"] = "GAGAN";
    /** Multi-functional Satellite Augmentation System (Japan). */
    SBASGroupName["MSAS"] = "MSAS";
})(SBASGroupName || (SBASGroupName = {}));
/**
 * An instrument that computes GPS satellite information.
 */
class GPSSatComputer {
    /**
     * Creates an instance of GPSSat.
     * @param index The index of this GPSSat.
     * @param bus An instance of the event bus.
     * @param ephemerisFile The HTTP path to the ephemeris file to use for computations.
     * @param sbasFile The HTTP path to the SBAS definitions file.
     * @param updateInterval The interval in milliseconds to update the satellite positions.
     * @param enabledSBASGroups The names of the SBAS satellite groups for which signal reception is enabled.
     * @param syncRole This system's sync role. A `primary` system will broadcast sync events through the event bus when
     * satellite positions are calculated, satellite states change, or the system is reset. A `replica` system will
     * listen for the aforementioned sync events on the event bus and set its state accordingly. A system with a sync
     * role of `none` does neither; it maintains its own independent state and does not sync it to other systems.
     */
    constructor(index, bus, ephemerisFile, sbasFile, updateInterval, enabledSBASGroups, syncRole = 'none') {
        this.index = index;
        this.bus = bus;
        this.ephemerisFile = ephemerisFile;
        this.sbasFile = sbasFile;
        this.updateInterval = updateInterval;
        this.syncRole = syncRole;
        this.publisher = this.bus.getPublisher();
        this.syncPublisher = this.bus.getPublisher();
        this.stateChangedTopic = `gps_system_state_changed_${this.index}`;
        this.satStateChangedTopic = `gps_sat_state_changed_${this.index}`;
        this.satPosCalcTopic = `gps_sat_pos_calculated_${this.index}`;
        this.sbasStateChangedTopic = `gps_system_sbas_state_changed_${this.index}`;
        this.pdopTopic = `gps_system_pdop_${this.index}`;
        this.hdopTopic = `gps_system_hdop_${this.index}`;
        this.vdopTopic = `gps_system_vdop_${this.index}`;
        this.satCalcSyncTopic = `gps_system_sync_sat_calc_${this.index}`;
        this.satStateSyncTopic = `gps_system_sync_sat_state_changed_${this.index}`;
        this.resetSyncTopic = `gps_system_sync_reset_${this.index}`;
        this.satStateRequestSyncTopic = `gps_system_sync_sat_state_request_${this.index}`;
        this.satStateResponseSyncTopic = `gps_system_sync_sat_state_response_${this.index}`;
        this.ephemerisData = {};
        this.sbasData = [];
        this.sbasServiceAreas = new Map();
        this.currentSbasGroupsInView = new Set();
        this.satellites = [];
        this.ppos = new GeoPoint(0, 0);
        this.pposVec = new Float64Array(2);
        this.vecHeap = new ResourceHeap(() => Vec3Math.create(), () => { });
        this.altitude = 0;
        this.previousSimTime = 0;
        this.previousUpdate = 0;
        this.simTime = 0;
        this._state = GPSSystemState.Searching;
        this._sbasState = GPSSystemSBASState.Disabled;
        this.dops = Vec3Math.create();
        this._pdop = -1;
        this._hdop = -1;
        this._vdop = -1;
        this.isInit = false;
        this.needAcquireAndUse = false;
        this.needSatCalc = false;
        this.pendingSatStateUpdates = new Map();
        this.enabledSBASGroups = 'isSubscribableSet' in enabledSBASGroups ? enabledSBASGroups : SetSubject.create(enabledSBASGroups);
        this.bus.getSubscriber().on('gps-position').handle(pos => {
            this.ppos.set(pos.lat, pos.long);
            Vec2Math.set(pos.lat, pos.long, this.pposVec);
            this.altitude = pos.alt;
        });
        this.bus.getSubscriber().on('simTime').handle(time => this.simTime = time);
    }
    /**
     * Gets the current GPS system state.
     * @returns The current GPS system state.
     */
    get state() {
        return this._state;
    }
    /**
     * Gets the current GPS system SBAS state.
     * @returns The current GPS system SBAS state.
     */
    get sbasState() {
        return this._sbasState;
    }
    /**
     * Gets this system's current position dilution of precision value (PDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current position dilution of precision value (PDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get pdop() {
        return this._pdop;
    }
    /**
     * Gets this system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get hdop() {
        return this._hdop;
    }
    /**
     * Gets this system's current vertical dilution of precision value (VDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current vertical dilution of precision value (VDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get vdop() {
        return this._vdop;
    }
    /**
     * Adds the defined SBAS satellites to the tracked satellites.
     */
    addSbasSatellites() {
        const tempVec = new Float64Array(3);
        const tempGeoPoint = new GeoPoint(0, 0);
        const orbitHeight = UnitType.KILOMETER.convertTo(35785, UnitType.GA_RADIAN);
        for (let i = 0; i < this.sbasData.length; i++) {
            const sbasDef = this.sbasData[i];
            this.sbasServiceAreas.set(sbasDef.group, sbasDef.coverage);
            for (const satDef of sbasDef.constellation) {
                const sat = new GPSSatellite(satDef.prn, sbasDef.group);
                tempGeoPoint.set(0, satDef.lon);
                const positionCartesian = Vec3Math.multScalar(tempGeoPoint.toCartesian(tempVec), orbitHeight, tempVec);
                sat.positionCartesian.set(positionCartesian);
                this.satellites.push(sat);
            }
        }
    }
    /** @inheritdoc */
    init() {
        // Publish initial state.
        this.publisher.pub(this.stateChangedTopic, this._state, false, true);
        this.publisher.pub(this.sbasStateChangedTopic, this._sbasState, false, true);
        this.publisher.pub(this.pdopTopic, this._pdop, false, true);
        this.publisher.pub(this.hdopTopic, this._hdop, false, true);
        this.publisher.pub(this.vdopTopic, this._vdop, false, true);
        this.loadEphemerisData().then(() => this.loadSbasData()).then(() => {
            this.isInit = true;
            // Setup sync logic.
            if (this.syncRole === 'replica') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satCalcSyncTopic).handle(() => { this.needSatCalc = true; });
                sub.on(this.satStateSyncTopic).handle(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                sub.on(this.resetSyncTopic).handle(() => { this.reset(); });
                sub.on(this.satStateResponseSyncTopic).handle(response => {
                    this.needSatCalc = true;
                    response.forEach(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                });
                // Request initial state.
                this.syncPublisher.pub(this.satStateRequestSyncTopic, undefined, true, false);
            }
            else if (this.syncRole === 'primary') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satStateRequestSyncTopic).handle(() => {
                    this.syncPublisher.pub(this.satStateResponseSyncTopic, this.satellites.map(sat => { return { prn: sat.prn, state: sat.state.get() }; }), true, false);
                });
            }
            if (this.needAcquireAndUse) {
                this.needAcquireAndUse = false;
                this.acquireAndUseSatellites();
            }
            else {
                this.reset();
            }
        });
    }
    /**
     * Loads the GPS ephemeris data file.
     */
    loadEphemerisData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.ephemerisData = JSON.parse(request.responseText);
                        for (const prn in this.ephemerisData) {
                            this.satellites.push(new GPSSatellite(parseInt(prn), undefined, this.ephemerisData[prn]));
                        }
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with ephemeris data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.ephemerisFile);
            request.send();
        });
    }
    /**
     * Loads the GPS SBAS data file.
     */
    loadSbasData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.sbasData = JSON.parse(request.responseText);
                        this.addSbasSatellites();
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with sbas data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.sbasFile);
            request.send();
        });
    }
    /**
     * Instantly acquires and starts using all satellites with sufficient signal strength. If signal strength allows,
     * SBAS satellites are instantly promoted to the {@link GPSSatelliteState.Acquired} state, and GPS satellites are
     * instantly promoted to the {@link GPSSatelliteState.InUse}/{@link GPSSatelliteState.InUseDiffApplied} state.
     *
     * If this system is not initialized, the operation will be delayed until just after initialization, unless `reset()`
     * is called between now and then.
     *
     * Has no effect if this system is a replica.
     */
    acquireAndUseSatellites() {
        if (this.syncRole === 'replica') {
            return;
        }
        if (this.isInit) {
            this.updateSatellites(0, true, true);
        }
        else {
            this.needAcquireAndUse = true;
        }
    }
    /**
     * Resets the GPSSatComputer system. This will set the of the system to {@link GPSSystemState.Searching} and the
     * state of every satellite to {@link GPSSatelliteState.None}.
     *
     * If this system is not initialized, this method has no effect other than to cancel any pending operations triggered
     * by previous calls to `acquireAndUseSatellites()`.
     */
    reset() {
        this.needAcquireAndUse = false;
        if (!this.isInit) {
            return;
        }
        this.satellites.forEach(sat => {
            const currentState = sat.state.get();
            sat.state.set(GPSSatelliteState.None);
            if (currentState !== GPSSatelliteState.None) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
            }
        });
        const currentState = this._state;
        this._state = GPSSystemState.Searching;
        if (currentState !== GPSSystemState.Searching) {
            this.publisher.pub(this.stateChangedTopic, GPSSystemState.Searching, false, true);
        }
        this.setDop(-1, -1, -1);
        if (this.syncRole === 'primary') {
            this.syncPublisher.pub(this.resetSyncTopic, undefined, true, false);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isInit) {
            return;
        }
        const deltaTime = this.simTime - this.previousSimTime;
        if (this.syncRole !== 'replica') {
            if (deltaTime < 0 || deltaTime > (this.updateInterval * 2)) {
                this.previousSimTime = this.simTime;
                this.previousUpdate = this.simTime;
                return;
            }
        }
        const shouldUpdatePositions = this.syncRole === 'replica'
            ? this.needSatCalc
            : this.simTime >= this.previousUpdate + this.updateInterval;
        this.needSatCalc = false;
        this.updateSatellites(deltaTime, shouldUpdatePositions, false);
    }
    /**
     * Updates the states and optionally the orbital positions of all satellites.
     * @param deltaTime The time elapsed, in milliseconds, since the last satellite update.
     * @param shouldUpdatePositions Whether to update the orbital positions of the satellites.
     * @param forceAcquireAndUse Whether to immediately force satellites to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} for SBAS satellites and {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} for GPS satellites) if signal strength is sufficient.
     */
    updateSatellites(deltaTime, shouldUpdatePositions, forceAcquireAndUse) {
        var _a, _b, _c, _d;
        let numAcquiring = 0;
        let numActiveSbas = 0;
        let shouldUpdateDop = shouldUpdatePositions;
        if (shouldUpdatePositions && this.syncRole === 'primary') {
            (_a = this.syncPublisher) === null || _a === void 0 ? void 0 : _a.pub(this.satCalcSyncTopic, undefined, true, false);
        }
        this.currentSbasGroupsInView.clear();
        const enabledSBASGroups = this.enabledSBASGroups.get();
        for (let i = 0; i < this.satellites.length; i++) {
            const sat = this.satellites[i];
            if (shouldUpdatePositions) {
                sat.computeSatellitePositions(this.simTime);
                sat.applyProjection(this.ppos, this.altitude);
            }
            sat.calculateSignalStrength(this.altitude);
            const updatedState = this.syncRole === 'replica'
                ? sat.forceUpdateState((_c = (_b = this.pendingSatStateUpdates.get(sat.prn)) === null || _b === void 0 ? void 0 : _b.state) !== null && _c !== void 0 ? _c : sat.state.get())
                : sat.updateState(deltaTime, this._state === GPSSystemState.DiffSolutionAcquired, forceAcquireAndUse);
            if (updatedState) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
                if (this.syncRole === 'primary') {
                    this.syncPublisher.pub(this.satStateSyncTopic, { prn: sat.prn, state: sat.state.get() }, true, false);
                }
                shouldUpdateDop = true;
            }
            const satState = sat.state.get();
            if (satState === GPSSatelliteState.Acquired || satState === GPSSatelliteState.DataCollected) {
                numAcquiring++;
                if (sat.sbasGroup !== undefined && enabledSBASGroups.has(sat.sbasGroup)) {
                    numActiveSbas++;
                    this.currentSbasGroupsInView.add(sat.sbasGroup);
                }
            }
        }
        this.pendingSatStateUpdates.clear();
        let withinSbasArea = false;
        for (const group of this.currentSbasGroupsInView) {
            const coverage = this.sbasServiceAreas.get(group);
            if (coverage !== undefined) {
                withinSbasArea = (_d = Vec2Math.pointWithinPolygon(coverage, this.pposVec)) !== null && _d !== void 0 ? _d : false;
            }
            if (withinSbasArea) {
                break;
            }
        }
        const newSBASState = withinSbasArea
            ? GPSSystemSBASState.Active
            : enabledSBASGroups.size === 0 ? GPSSystemSBASState.Disabled : GPSSystemSBASState.Inactive;
        let newSystemState = GPSSystemState.Searching;
        if (numAcquiring > 0) {
            newSystemState = GPSSystemState.Acquiring;
        }
        let pdop = this._pdop, hdop = this._hdop, vdop = this._vdop;
        if (shouldUpdateDop) {
            [pdop, hdop, vdop] = this.calculateDop(this.dops);
        }
        const is3dSolutionPossible = pdop >= 0;
        if (is3dSolutionPossible) {
            newSystemState = numActiveSbas > 0 && withinSbasArea ? GPSSystemState.DiffSolutionAcquired : GPSSystemState.SolutionAcquired;
        }
        if (this._state !== newSystemState) {
            this._state = newSystemState;
            this.publisher.pub(this.stateChangedTopic, newSystemState, false, true);
        }
        if (this._sbasState !== newSBASState) {
            this._sbasState = newSBASState;
            this.publisher.pub(this.sbasStateChangedTopic, newSBASState, false, true);
        }
        if (shouldUpdatePositions) {
            this.previousUpdate = this.simTime;
            this.publisher.pub(this.satPosCalcTopic, undefined, false, false);
        }
        this.setDop(pdop, hdop, vdop);
        this.previousSimTime = this.simTime;
    }
    /**
     * Gets the current satellites that are being tracked by this computer.
     * @returns The collection of current satellites.
     */
    get sats() {
        return this.satellites;
    }
    /**
     * Calculates the horizon zenith angle.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    calcHorizonAngle() {
        return Math.acos(6378100 / (6378100 + this.altitude));
    }
    /**
     * Calculates dilution of precision values (PDOP, HDOP, VDOP) for the current satellite constellation.
     * @param out The vector to which to write the results.
     * @returns Dilution of precision values for the current satellite constellation, as `[PDOP, HDOP, VDOP]`.
     */
    calculateDop(out) {
        Vec3Math.set(-1, -1, -1, out);
        const satsInUse = this.satellites.filter(sat => {
            const state = sat.state.get();
            return state === GPSSatelliteState.InUse || state === GPSSatelliteState.InUseDiffApplied;
        });
        if (satsInUse.length < 4) {
            return out;
        }
        // Get unit line-of-sight vectors for each satellite
        for (let i = 0; i < satsInUse.length; i++) {
            const [zenith, hour] = satsInUse[i].position.get();
            satsInUse[i] = Vec3Math.setFromSpherical(1, zenith, hour, this.vecHeap.allocate());
        }
        const satVecs = satsInUse;
        // First define line-of-sight matrix L composed of row vectors Si = [xi, yi, zi, 1], where xi, yi, zi are the
        // components of the unit line-of-sight vector for satellite i. Then compute the covariance matrix as C = (LᵀL)⁻¹.
        // P = LᵀL is guaranteed to be symmetric, so we need only compute the upper triangular part of the product.
        const P11 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[0], 0);
        const P12 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[1], 0);
        const P13 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[2], 0);
        const P14 = satVecs.reduce((sum, vec) => sum + vec[0], 0);
        const P22 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[1], 0);
        const P23 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[2], 0);
        const P24 = satVecs.reduce((sum, vec) => sum + vec[1], 0);
        const P33 = satVecs.reduce((sum, vec) => sum + vec[2] * vec[2], 0);
        const P34 = satVecs.reduce((sum, vec) => sum + vec[2], 0);
        const P44 = satVecs.length;
        for (let i = 0; i < satVecs.length; i++) {
            this.vecHeap.free(satVecs[i]);
        }
        // Perform block-wise inversion of LᵀL (which is 4x4, so neatly decomposes into four 2x2 matrices) with optimizations
        // presented in Ingemarsson, C and Gustafsson O, 2015.
        // P = [A  B]
        //     [Bᵀ D]
        // C = P⁻¹ = [E  F]
        //           [Fᵀ H]
        // Since we only care about the variance terms along the diagonal of C, we can skip calculating F.
        // V = A⁻¹ (A is symmetric, therefore V is also symmetric, so we only need to compute the upper triangular part)
        const detA = 1 / (P11 * P22 - P12 * P12);
        const V11 = P22 * detA;
        const V12 = -P12 * detA;
        const V22 = P11 * detA;
        // X = VB
        const X11 = V11 * P13 + V12 * P23;
        const X12 = V11 * P14 + V12 * P24;
        const X21 = V12 * P13 + V22 * P23;
        const X22 = V12 * P14 + V22 * P24;
        // H = (D - BᵀX)⁻¹ (H and D are symmetric, which means BᵀX is also symmetric)
        const Hi11 = P33 - (P13 * X11 + P23 * X21);
        const Hi12 = P34 - (P13 * X12 + P23 * X22);
        const Hi22 = P44 - (P14 * X12 + P24 * X22);
        const detHi = 1 / (Hi11 * Hi22 - Hi12 * Hi12);
        const H11 = Hi22 * detHi;
        const H12 = -Hi12 * detHi;
        const H22 = Hi11 * detHi;
        // Z = XH
        const Z11 = X11 * H11 + X12 * H12;
        const Z12 = X11 * H12 + X12 * H22;
        const Z21 = X21 * H11 + X22 * H12;
        const Z22 = X21 * H12 + X22 * H22;
        // E = V + ZXᵀ (We can skip calculating E12 and E21 since we only care about the diagonal)
        const E11 = V11 + Z11 * X11 + Z12 * X12;
        const E22 = V22 + Z21 * X21 + Z22 * X22;
        // Grab the variance terms var(x), var(y), var(z) along the diagonal of C
        const varX = E11;
        const varY = E22;
        const varZ = H11;
        if (!isFinite(varX) || !isFinite(varY) || !isFinite(varZ)) {
            return out;
        }
        const horizSumVar = varX + varY;
        const pdop = Math.sqrt(horizSumVar + varZ);
        const hdop = Math.sqrt(horizSumVar);
        const vdop = Math.sqrt(varZ);
        return Vec3Math.set(pdop, hdop, vdop, out);
    }
    /**
     * Sets this system's dilution of precision values, and if they are different from the current values, publishes the
     * new values to the event bus.
     * @param pdop The position DOP value to set.
     * @param hdop The horizontal DOP value to set.
     * @param vdop The vertical DOP valu to set.
     */
    setDop(pdop, hdop, vdop) {
        if (this._pdop !== pdop) {
            this._pdop = pdop;
            this.publisher.pub(this.pdopTopic, pdop, false, true);
        }
        if (this._hdop !== hdop) {
            this._hdop = hdop;
            this.publisher.pub(this.hdopTopic, hdop, false, true);
        }
        if (this._vdop !== vdop) {
            this._vdop = vdop;
            this.publisher.pub(this.vdopTopic, vdop, false, true);
        }
    }
}
/**
 * A tracked GPS satellite.
 */
class GPSSatellite {
    /**
     * Creates an instance of a GPSSatellite.
     * @param prn The GPS PRN number for this satellite.
     * @param sbasGroup Whether or not this satellite is a SBAS satellite.
     * @param ephemeris The ephemeris data to use for position calculation.
     */
    constructor(prn, sbasGroup, ephemeris) {
        this.prn = prn;
        this.sbasGroup = sbasGroup;
        this.ephemeris = ephemeris;
        this.stateChangeTime = (5 + (10 * Math.random())) * 1000;
        this.stateChangeTimeRemaining = 0;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        /** The current satellite state. */
        this.state = Subject.create(GPSSatelliteState.None);
        /** The current satellite position, in zenith angle radians and hour angle radians. */
        this.position = Vec2Subject.create(new Float64Array(2));
        /** The current satellite position, in cartesian coordinates. */
        this.positionCartesian = Vec3Subject.create(new Float64Array(3));
        /** The current satellite signal strength. */
        this.signalStrength = Subject.create(0);
        this.isApplyingDiffCorrections = false;
        this.hasComputedPosition = false;
    }
    /**
     * Computes the current satellite positions given the loaded ephemeris data.
     * @param simTime The current simulator time, in milliseconds UNIX epoch
     */
    computeSatellitePositions(simTime) {
        const record = this.ephemeris;
        if (record !== undefined) {
            const mu = 3.986005e14; //WGS84 gravitational constant for GPS user (meters3/sec2)
            const omegae_dot = 7.2921151467e-5; //WGS84 earth rotation rate (rad/sec)
            // Restore semi-major axis
            const a = record.sqrtA * record.sqrtA;
            // Computed mean motion
            const n0 = Math.sqrt(mu / (a * a * a));
            // Time from ephemeris reference epoch
            const now = simTime / 1000;
            const t = (now - (86400 * 3) + 1735) % 604800;
            let tk = t - record.toeTimeEphemeris;
            if (tk > 302400) {
                tk -= 604800;
            }
            else if (tk < -302400) {
                tk += 604800;
            }
            // Corrected mean motion
            const n = n0 + record.deltaN;
            // Mean anomaly
            const M = record.m0 + n * tk;
            // Initial guess of eccentric anomaly
            let E = M;
            let E_old;
            let dE;
            // Iterative computation of eccentric anomaly
            for (let i = 1; i < 20; i++) {
                E_old = E;
                E = M + record.eEccentricity * Math.sin(E);
                dE = E - E_old % (2.0 * Math.PI);
                if (Math.abs(dE) < 1e-12) {
                    // Necessary precision is reached, exit from the loop
                    break;
                }
            }
            const sek = Math.sin(E);
            const cek = Math.cos(E);
            const OneMinusecosE = 1.0 - record.eEccentricity * cek;
            const sq1e2 = Math.sqrt(1.0 - record.eEccentricity * record.eEccentricity);
            // Compute the true anomaly
            const tmp_Y = sq1e2 * sek;
            const tmp_X = cek - record.eEccentricity;
            const nu = Math.atan2(tmp_Y, tmp_X);
            // Compute angle phi (argument of Latitude)
            const phi = nu + record.omegaS;
            // Reduce phi to between 0 and 2*pi rad
            const s2pk = Math.sin(2.0 * phi);
            const c2pk = Math.cos(2.0 * phi);
            // Correct argument of latitude
            const u = phi + record.cuc * c2pk + record.cus * s2pk;
            const suk = Math.sin(u);
            const cuk = Math.cos(u);
            // Correct radius
            const r = a * OneMinusecosE + record.crc * c2pk + record.crs * s2pk;
            // Correct inclination
            const i = record.i0 + record.idot * tk + record.cic * c2pk + record.cis * s2pk;
            const sik = Math.sin(i);
            const cik = Math.cos(i);
            // Compute the angle between the ascending node and the Greenwich meridian
            const Omega_dot = record.omegaLDot - omegae_dot;
            const Omega = record.omegaL + Omega_dot * tk - omegae_dot * record.toeTimeEphemeris;
            const sok = Math.sin(Omega);
            const cok = Math.cos(Omega);
            //Compute satellite coordinates in Earth-fixed coordinates
            const xprime = r * cuk;
            const yprime = r * suk;
            const x = xprime * cok - yprime * cik * sok;
            const y = xprime * sok + yprime * cik * cok;
            const z = yprime * sik;
            this.positionCartesian.set(UnitType.METER.convertTo(x, UnitType.GA_RADIAN), UnitType.METER.convertTo(y, UnitType.GA_RADIAN), UnitType.METER.convertTo(z, UnitType.GA_RADIAN));
        }
    }
    /**
     * Applies a projection to the satellite cartesian coordinates to convert to zenith and hour angles.
     * @param ppos The current plane position.
     * @param altitude The current plane altitude in meters.
     */
    applyProjection(ppos, altitude) {
        const satPos = this.positionCartesian.get();
        const altRadians = UnitType.METER.convertTo(altitude, UnitType.GA_RADIAN);
        const pposCartesian = Vec3Math.multScalar(ppos.toCartesian(this.vec3Cache[0]), 1 + altRadians, this.vec3Cache[0]);
        const delta = Vec3Math.normalize(Vec3Math.sub(satPos, pposCartesian, this.vec3Cache[1]), this.vec3Cache[1]);
        const zenithAngle = Math.acos(Vec3Math.dot(delta, Vec3Math.normalize(pposCartesian, this.vec3Cache[2])));
        const satPos0 = Vec3Math.normalize(satPos, this.vec3Cache[1]);
        const northPole = Vec3Math.set(0, 0, 1, this.vec3Cache[2]);
        if (Math.abs(zenithAngle) < 1e-8 || Math.abs(zenithAngle - 180) < 1e-8) {
            this.position.set(zenithAngle, 0);
        }
        else {
            const A = Vec3Math.normalize(Vec3Math.cross(pposCartesian, northPole, this.vec3Cache[3]), this.vec3Cache[3]);
            const B = Vec3Math.normalize(Vec3Math.cross(pposCartesian, satPos0, this.vec3Cache[4]), this.vec3Cache[4]);
            const signBz = B[2] >= 0 ? 1 : -1;
            const hourAngle = Math.acos(Vec3Math.dot(A, B)) * signBz;
            this.position.set(zenithAngle, -hourAngle);
        }
        this.hasComputedPosition = true;
    }
    /**
     * Calculates the current signal strength.
     * @param altitude The current plane altitude in meters.
     */
    calculateSignalStrength(altitude) {
        if (this.hasComputedPosition) {
            const maxZenithAngle = GPSSatellite.calcHorizonAngle(altitude) + (Math.PI / 2);
            const signalStrength = Math.max(0, 1 - (this.position.get()[0] / maxZenithAngle));
            this.signalStrength.set(signalStrength);
        }
    }
    /**
     * Calculates the horizon zenith angle.
     * @param altitude The altitude, in meters.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    static calcHorizonAngle(altitude) {
        return Math.acos(6378100 / (6378100 + Math.max(altitude, 0)));
    }
    /**
     * Updates the state of the satellite.
     * @param deltaTime The amount of sim time that has passed, in milliseconds.
     * @param applyDiffCorrections Whether or not to apply differential corrections to this GPS satellite.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} if this is an SBAS satellite or {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} if this is a GPS satellite) if signal strength is sufficient.
     * @returns True if the satellite state changed, false otherwise.
     */
    updateState(deltaTime, applyDiffCorrections, forceAcquireAndUse) {
        const reachable = this.signalStrength.get() > 0.05;
        if (this.stateChangeTimeRemaining >= 0) {
            this.stateChangeTimeRemaining -= deltaTime;
        }
        if (forceAcquireAndUse) {
            this.isApplyingDiffCorrections = applyDiffCorrections;
            const state = this.state.get();
            if (reachable) {
                const targetState = this.sbasGroup === undefined
                    ? applyDiffCorrections ? GPSSatelliteState.InUseDiffApplied : GPSSatelliteState.InUse
                    : GPSSatelliteState.Acquired;
                if (state !== targetState) {
                    this.state.set(targetState);
                    return true;
                }
            }
            else {
                if (state !== GPSSatelliteState.Unreachable) {
                    this.state.set(GPSSatelliteState.Unreachable);
                    return true;
                }
            }
        }
        else {
            switch (this.state.get()) {
                case GPSSatelliteState.None:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    else {
                        this.state.set(GPSSatelliteState.Unreachable);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                case GPSSatelliteState.Unreachable:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.Acquired:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0 && this.sbasGroup === undefined) {
                        this.state.set(GPSSatelliteState.DataCollected);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.DataCollected:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0) {
                        this.state.set(GPSSatelliteState.InUse);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.InUse:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (applyDiffCorrections) {
                        if (this.isApplyingDiffCorrections && this.stateChangeTimeRemaining <= 0) {
                            this.state.set(GPSSatelliteState.InUseDiffApplied);
                            return true;
                        }
                        else if (!this.isApplyingDiffCorrections) {
                            this.isApplyingDiffCorrections = true;
                            this.stateChangeTimeRemaining = this.stateChangeTime;
                        }
                    }
                    break;
                case GPSSatelliteState.InUseDiffApplied:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (!applyDiffCorrections) {
                        this.isApplyingDiffCorrections = false;
                        this.state.set(GPSSatelliteState.InUse);
                        return true;
                    }
                    break;
            }
        }
        return false;
    }
    /**
     * Forces an update of this satellite's state to a specific value.
     * @param state The state to which to update this satellite.
     * @returns Whether the satellite's state was changed as a result of the forced update.
     */
    forceUpdateState(state) {
        this.stateChangeTimeRemaining = 0;
        this.isApplyingDiffCorrections = state === GPSSatelliteState.InUseDiffApplied;
        if (this.state.get() !== state) {
            this.state.set(state);
            return true;
        }
        else {
            return false;
        }
    }
}
/**
 * Possible state on GPS satellites.
 */
var GPSSatelliteState;
(function (GPSSatelliteState) {
    /** There is no current valid state. */
    GPSSatelliteState["None"] = "None";
    /** The satellite is out of view and cannot be reached. */
    GPSSatelliteState["Unreachable"] = "Unreachable";
    /** The satellite has been found and data is being downloaded. */
    GPSSatelliteState["Acquired"] = "Acquired";
    /** The satellite is faulty. */
    GPSSatelliteState["Faulty"] = "Faulty";
    /** The satellite has been found, data is downloaded, but is not presently used in the GPS solution. */
    GPSSatelliteState["DataCollected"] = "DataCollected";
    /** The satellite is being active used in the GPS solution. */
    GPSSatelliteState["InUse"] = "InUse";
    /** The satellite is being active used in the GPS solution and SBAS differential corrections are being applied. */
    GPSSatelliteState["InUseDiffApplied"] = "InUseDiffApplied";
})(GPSSatelliteState || (GPSSatelliteState = {}));
/**
 * Possible {@link GPSSatComputer} states.
 */
var GPSSystemState;
(function (GPSSystemState) {
    /** The GPS receiver is trying to locate satellites. */
    GPSSystemState["Searching"] = "Searching";
    /** The GPS receiver has found satellites and is acquiring a solution. */
    GPSSystemState["Acquiring"] = "Acquiring";
    /** A 3D solution has been acquired. */
    GPSSystemState["SolutionAcquired"] = "SolutionAcquired";
    /** A 3D solution using differential computations has been acquired. */
    GPSSystemState["DiffSolutionAcquired"] = "DiffSolutionAcquired";
})(GPSSystemState || (GPSSystemState = {}));
/**
 * Possible SBAS connection states.
 */
var GPSSystemSBASState;
(function (GPSSystemSBASState) {
    /** SBAS is disabled. */
    GPSSystemSBASState["Disabled"] = "Disabled";
    /** SBAS is enabled but not receiving differential corrections. */
    GPSSystemSBASState["Inactive"] = "Inactive";
    /** SBAS is enabled and is receiving differential corrections. */
    GPSSystemSBASState["Active"] = "Active";
})(GPSSystemSBASState || (GPSSystemSBASState = {}));

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/baseinstrument" />
/**
 * A publisher for VCockpit BaseInstrument events.
 */
class BaseInstrumentPublisher extends BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument, bus, pacer = undefined) {
        super(bus, pacer);
        this.instrument = instrument;
        this.lastGameState = undefined;
        this.lastIsPowered = undefined;
        this.lastScreenState = undefined;
        this.hasFlightStarted = false;
        instrument.addEventListener('mouseleave', (e) => {
            this.publish('vc_mouse_leave', e, false, false);
        });
        instrument.addEventListener('mouseenter', (e) => {
            this.publish('vc_mouse_enter', e, false, false);
        });
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isPublishing()) {
            return;
        }
        this.updateFromGameState(this.instrument.getGameState());
        this.updateFromPowered(this.instrument.isStarted); // Big hack here since there is no other way to get the isStarted state from BaseInstrument
        this.updateFromScreenState(this.instrument.screenState); // Another big hack
    }
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    updateFromGameState(gameState) {
        if (this.lastGameState === gameState) {
            return;
        }
        this.lastGameState = gameState;
        this.publish('vc_game_state', gameState);
        if (!this.hasFlightStarted && gameState === GameState.ingame) {
            this.publish('vc_flight_start', true);
        }
    }
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    updateFromPowered(isPowered) {
        if (this.lastIsPowered === isPowered) {
            return;
        }
        this.lastIsPowered = isPowered;
        this.publish('vc_powered', isPowered);
    }
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    updateFromScreenState(screenState) {
        if (this.lastScreenState === screenState) {
            return;
        }
        const lastScreenState = this.lastScreenState;
        this.lastScreenState = screenState;
        this.publish('vc_screen_state', { current: screenState, previous: lastScreenState });
    }
}

/** Minimums Modes */
var MinimumsMode;
(function (MinimumsMode) {
    MinimumsMode[MinimumsMode["OFF"] = 0] = "OFF";
    MinimumsMode[MinimumsMode["BARO"] = 1] = "BARO";
    MinimumsMode[MinimumsMode["RA"] = 2] = "RA";
    MinimumsMode[MinimumsMode["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
})(MinimumsMode || (MinimumsMode = {}));
/** A publisher for minimums simvar events. */
class MinimumsSimVarPublisher extends SimVarPublisher {
    /**
     * @inheritdoc
     */
    constructor(bus) {
        super(MinimumsSimVarPublisher.simvars, bus);
    }
}
MinimumsSimVarPublisher.simvars = new Map([
    ['decision_height_feet', { name: 'DECISION HEIGHT', type: SimVarValueType.Feet }],
    ['decision_altitude_feet', { name: 'DECISION ALTITUDE MSL', type: SimVarValueType.Feet }],
    ['minimums_mode', { name: 'L:WT_MINIMUMS_MODE', type: SimVarValueType.Number }]
]);

/**
 * A publisher for Pressurization information.
 */
class PressurizationPublisher extends SimVarPublisher {
    /**
     * Create an PressurizationPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(PressurizationPublisher.simvars, bus, pacer);
    }
    /**
     * Updates the ADC publisher.
     */
    onUpdate() {
        super.onUpdate();
    }
}
PressurizationPublisher.simvars = new Map([
    ['cabin_altitude', { name: 'PRESSURIZATION CABIN ALTITUDE', type: SimVarValueType.Feet }],
    ['cabin_altitude_rate', { name: 'PRESSURIZATION CABIN ALTITUDE RATE', type: SimVarValueType.FPM }],
    ['pressure_diff', { name: 'PRESSURIZATION PRESSURE DIFFERENTIAL', type: SimVarValueType.PSI }]
]);

/**
 * A simple timer for handling debounce.
 */
class DebounceTimer {
    constructor() {
        this.timer = null;
    }
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending() {
        return this.timer !== null;
    }
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action, delay) {
        this.clear();
        this.timer = setTimeout(() => {
            this.timer = null;
            action();
        }, delay);
    }
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear() {
        if (this.timer === null) {
            return;
        }
        clearTimeout(this.timer);
        this.timer = null;
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));
/** A publiher to poll transponder simvars. */
class XPDRSimVarPublisher extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus, pacer = undefined, transponderCount = 1) {
        const vars = [];
        for (let i = 0; i < transponderCount; i++) {
            vars.push([`xpdr_mode_${i + 1}`, { name: `TRANSPONDER STATE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_code_${i + 1}`, { name: `TRANSPONDER CODE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_ident_${i + 1}`, { name: `TRANSPONDER IDENT:${i + 1}`, type: SimVarValueType.Bool }]);
        }
        super(new Map(vars), bus, pacer);
    }
}
/** A transponder. */
class XPDRInstrument {
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus, transponderCount = 1) {
        this.bus = bus;
        this.transponderCount = transponderCount;
        this.identDebounceTimers = Array.from({ length: this.transponderCount }, () => new DebounceTimer());
        this.bus = bus;
        this.simVarPublisher = new XPDRSimVarPublisher(bus);
        this.controlSubscriber = bus.getSubscriber();
    }
    /** Initialize the instrument. */
    init() {
        this.simVarPublisher.startPublish();
        for (let i = 0; i < this.transponderCount; i++) {
            this.controlSubscriber.on(`publish_xpdr_code_${i + 1}`).handle(this.setXpdrCode.bind(this, i + 1));
            this.controlSubscriber.on(`publish_xpdr_mode_${i + 1}`).handle(this.setXpdrMode.bind(this, i + 1));
            this.controlSubscriber.on(`xpdr_send_ident_${i + 1}`).handle(this.sendIdent.bind(this, i + 1));
            // force standby on plane load when off
            if (this.getXpdrMode(i + 1) === XPDRMode.OFF) {
                this.setXpdrMode(i + 1, XPDRMode.STBY);
            }
        }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        // Currently, we just need to update our simvar publisher so it polls.
        this.simVarPublisher.onUpdate();
    }
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    setXpdrCode(index, code) {
        const bcdCode = Avionics.Utils.make_xpndr_bcd16(code);
        SimVar.SetSimVarValue(`K:${index}:XPNDR_SET`, 'Frequency BCD16', bcdCode);
    }
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    setXpdrMode(index, mode) {
        SimVar.SetSimVarValue(`TRANSPONDER STATE:${index}`, 'number', mode);
    }
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    getXpdrMode(index) {
        return SimVar.GetSimVarValue(`TRANSPONDER STATE:${index}`, 'number');
    }
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    sendIdent(index) {
        if (this.getXpdrMode(index) > XPDRMode.STBY) {
            SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_ON`, 'number', 1);
            this.identDebounceTimers[index - 1].schedule(() => {
                SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_OFF`, 'number', 0);
            }, 18000);
        }
    }
}

/**
 * A utility class for generating Promises that wait for certain conditions before they are fulfilled.
 */
class Wait {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    static awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    static awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    /**
     * Waits for a notification from a {@link Subscribable}, with an optional condition to end the wait based on the value
     * of the subscribable.
     * @param subscribable The subscribable to wait for.
     * @param predicate A function which evaluates whether the value of the subscribable satisfies the condition for the
     * wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive a notification from the subscribable at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the subscribable when a notification is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = subscribable.sub(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, false, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link Consumer}, with an optional condition to end the wait based on the value of the
     * consumed event.
     * @param consumer The event consumer to wait for.
     * @param predicate A function which evaluates whether the value of the consumed event satisfies the condition for
     * the wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive an event from the event consumer at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the consumed event when an event is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = consumer.handle(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link ReadonlySubEvent}, with an optional condition to end the wait based on the sender
     * and data of the event.
     * @param event The event to wait for.
     * @param predicate A function which evaluates whether the sender and data of the event satisfy the condition for
     * the wait to end. If not defined, any sender/data is considered satisfactory.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the data of the event when an event is received with a sender and data
     * that satisfy the condition for the wait to end.
     */
    static awaitSubEvent(event, predicate, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = event.on((sender, data) => {
                if (predicate === undefined || predicate(data, sender)) {
                    sub.destroy();
                    resolve(data);
                }
            }, true);
            sub.resume();
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
}

/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
class TrafficInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
        return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
        this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
        this.bus.getSubscriber()
            .on('simTime')
            .whenChanged()
            .handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
        const contact = new TrafficContactClass(entry.uId, 1000 / this.options.simTimeUpdateFreq * 5);
        this.tracked.set(contact.uid, contact);
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_added', contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_updated', contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
        this.tracked.forEach(contact => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uid);
                this.bus.pub('traffic_contact_removed', contact.uid, false, false);
            }
        });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy
            || Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_AIR_TRAFFIC'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
        }
        this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
        // noop
    }
}
/**
 * An aircraft contact that is being tracked. Each contact tracks its last reported position, altitude, and heading.
 * Successively updating these values will allow ground speed, ground track, and vertical speed to be calculated based
 * on changes in the values over time. The calculated values are exponentially smoothed to reduce artifacts from
 * potentially noisy data.
 */
class TrafficContactClass {
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
        this.uid = uid;
        this.contactTimeResetThreshold = contactTimeResetThreshold;
        // reported data
        this._lastPosition = new GeoPoint(NaN, NaN);
        this.lastPosition = this._lastPosition.readonly;
        this._lastAltitude = UnitType.FOOT.createNumber(NaN);
        this.lastAltitude = this._lastAltitude.readonly;
        this._lastHeading = NaN;
        this._lastContactTime = NaN;
        // computed data
        this._groundSpeed = UnitType.KNOT.createNumber(NaN);
        this.groundSpeed = this._groundSpeed.readonly;
        this._groundTrack = NaN;
        this._verticalSpeed = UnitType.FPM.createNumber(NaN);
        this.verticalSpeed = this._verticalSpeed.readonly;
        this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
        return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
        return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
        return this._groundTrack;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
        if (this.groundSpeed.isNaN()) {
            positionOut.set(NaN, NaN);
            altitudeOut.set(NaN);
            return;
        }
        const dt = simTime - this.lastContactTime;
        const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 3600000), UnitType.GA_RADIAN);
        this._lastPosition.offset(this._groundTrack, distance, positionOut);
        const deltaAlt = this._verticalSpeed.number * (dt / 60000);
        this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
        const dt = simTime - this._lastContactTime;
        if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
            this.reset(lat, lon, altitude, heading, simTime);
            return;
        }
        if (!isNaN(dt) && dt > 0) {
            this.updateComputedValues(dt / 1000, lat, lon, altitude);
        }
        this.setReportedValues(lat, lon, altitude, heading);
        if (this.areComputedValuesValid()) {
            this._lastContactTime = simTime;
        }
        else {
            this.reset(lat, lon, altitude, heading, simTime);
        }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
        this.setReportedValues(lat, lon, altitude, heading);
        this._groundSpeed.set(NaN);
        this._groundTrack = NaN;
        this._verticalSpeed.set(NaN);
        this.groundSpeedSmoother.reset();
        this.groundTrackSmoother.reset();
        this.verticalSpeedSmoother.reset();
        this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
        this._lastPosition.set(lat, lon);
        this._lastAltitude.set(altitude);
        this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
        const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
        const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
        const track = pos.bearingFrom(this._lastPosition);
        this.updateGroundSpeed(dt, distanceNM);
        this.updateGroundTrack(dt, track, distanceNM);
        this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
        const dtHours = dt / 3600;
        const speedKnots = distanceNM / dtHours;
        this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
        const last = this.groundTrackSmoother.last();
        if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
        }
        else {
            // if distance between current and last position is too small, computed ground track will be unreliable
            // (and if distance = 0 the track will be meaningless), so we just copy forward the last computed track,
            // or NaN if there is no previously computed track
            track = last === null ? NaN : last;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        this._groundTrack = (next + 360) % 360; // enforce range 0-359
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
        const dtMin = dt / 60;
        const deltaAltFeet = altitude - this._lastAltitude.number;
        const vsFPM = deltaAltFeet / dtMin;
        this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
        const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
        const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
        return isGroundSpeedValid && isVerticalSpeedValid;
    }
}
TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500; // knots
TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 10000; // fpm
TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852; // nautical miles
TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for fuel system information.
 */
class FuelSystemSimVarPublisher extends SimVarPublisher {
    /**
     * Create an FuelSystemSimvarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['fuel_system_valve_switch', { name: 'FUELSYSTEM VALVE SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_valve_open', { name: 'FUELSYSTEM VALVE OPEN:#index#', type: SimVarValueType.Number, indexed: true }],
            ['fuel_system_pump_switch', { name: 'FUELSYSTEM PUMP ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_engine_pressure', { name: 'FUELSYSTEM ENGINE PRESSURE:#index#', type: SimVarValueType.PSI, indexed: true }],
            ['fuel_system_line_pressure', { name: 'FUELSYSTEM LINE FUEL PRESSURE:#index#', type: SimVarValueType.PSI, indexed: true }],
            ['fuel_system_line_flow', { name: 'FUELSYSTEM LINE FUEL FLOW:#index#', type: SimVarValueType.GPH, indexed: true }],
            ['fuel_system_tank_quantity', { name: 'FUELSYSTEM TANK QUANTITY:#index#', type: SimVarValueType.GAL, indexed: true }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** The acceptable priority types for a given annunciation. */
var AnnunciationType;
(function (AnnunciationType) {
    AnnunciationType[AnnunciationType["Warning"] = 0] = "Warning";
    AnnunciationType[AnnunciationType["Caution"] = 1] = "Caution";
    AnnunciationType[AnnunciationType["Advisory"] = 2] = "Advisory";
    AnnunciationType[AnnunciationType["SafeOp"] = 3] = "SafeOp";
})(AnnunciationType || (AnnunciationType = {}));

/** A class that linearly drives a SimVar value towards a given set point. */
class LinearServo {
    /**
     * Creates an instance of a LinearServo.
     * @param rate The rate, in units per second, to drive the servo.
     */
    constructor(rate) {
        this.rate = rate;
    }
    /**
     * Drives the servo towards the set point.
     * @param currentValue The current value.
     * @param setValue The value to drive towards.
     * @returns The output value.
     */
    drive(currentValue, setValue) {
        if (this.currentTime === undefined) {
            this.currentTime = new Date().appTime();
            return currentValue;
        }
        const currentTime = new Date().appTime();
        const deltaTime = currentTime - this.currentTime;
        this.currentTime = currentTime;
        const deltaValue = setValue - currentValue;
        const maximumDrive = this.rate * (deltaTime / 1000);
        const output = Math.abs(deltaValue) > maximumDrive
            ? currentValue + (Math.sign(deltaValue) * maximumDrive)
            : setValue;
        return output;
    }
    /**
     * Resets the servo to initial state
     */
    reset() {
        this.currentTime = undefined;
    }
}

/**
 * Moderates access to a resource.
 */
class ResourceModerator {
    /**
     * Constructor.
     * @param resource This resource controlled by this moderator.
     */
    constructor(resource) {
        this.resource = resource;
        this.pendingConsumer = null;
        this.assignedConsumer = null;
        this.queuedConsumers = new SortedArray((a, b) => a.priority - b.priority);
    }
    /**
     * Makes a claim to this moderator's resource. If the resource is not currently owned, or the claiming consumer has
     * a higher priority than the current owner, access will attempt to pass to the claiming consumer. Otherwise, the
     * claiming consumer will enter a queue. After entering the queue, a consumer will gain access to the claimed
     * resource when all other consumers with a higher priority forfeit their claims to the resource.
     * @param consumer The consumer claiming the resource.
     */
    claim(consumer) {
        var _a;
        const consumerToDisplace = (_a = this.pendingConsumer) !== null && _a !== void 0 ? _a : this.assignedConsumer;
        if (consumerToDisplace === consumer) {
            return;
        }
        if (this.queuedConsumers.has(consumer)) {
            return;
        }
        if (consumerToDisplace === null || consumerToDisplace.priority < consumer.priority) {
            if (consumerToDisplace === null || consumerToDisplace === this.pendingConsumer) {
                if (consumerToDisplace) {
                    this.queuedConsumers.insert(consumerToDisplace);
                    this.pendingConsumer = null;
                }
                this.assignedConsumer = consumer;
                this.assignedConsumer.onAcquired(this.resource);
                return;
            }
            this.assignedConsumer = null;
            this.pendingConsumer = consumer;
            this.queuedConsumers.insert(consumerToDisplace);
            consumerToDisplace.onCeded(this.resource);
            if (this.pendingConsumer === consumer) {
                this.pendingConsumer = null;
                this.assignedConsumer = consumer;
                this.assignedConsumer.onAcquired(this.resource);
                return;
            }
            else {
                // Something has displaced the new pending consumer. Either something pre-empted it, in which case it is
                // now in the queue, or it forfeited its claim. In either case, there is nothing to do.
                return;
            }
        }
        this.queuedConsumers.insert(consumer);
    }
    /**
     * Forfeits a claim to this moderator's resource. If the consumer forfeiting its claim is the current owner of the
     * resource, it will immediately lose access to the resource, and access will attempt to pass to the next-highest
     * priority consumer with a claim to the resource. Otherwise, the forfeiting consumer will be removed from the queue
     * to gain access to the resource.
     * @param consumer The consumer that is forfeiting its claim.
     */
    forfeit(consumer) {
        var _a;
        if (this.pendingConsumer === consumer) {
            this.pendingConsumer = null;
            return;
        }
        if (this.assignedConsumer === null || this.assignedConsumer !== consumer) {
            this.queuedConsumers.remove(consumer);
            return;
        }
        const next = (_a = this.queuedConsumers.pop()) !== null && _a !== void 0 ? _a : null;
        this.pendingConsumer = next;
        this.assignedConsumer = null;
        consumer.onCeded(this.resource);
        if (next !== null && this.pendingConsumer === next) {
            this.pendingConsumer = null;
            this.assignedConsumer = next;
            this.assignedConsumer.onAcquired(this.resource);
        }
    }
}

/**
 * A manager for registering aural alerts. Alerts can be registered with an {@link AuralAlertSystem} through the
 * manager, which also handles registration requests from the alert system.
 */
class AuralAlertRegistrationManager {
    /**
     * Creates a new instance of AuralAlertRegistrationManager.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.registrations = new Map();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        this.requestSub = subscriber.on('aural_alert_request_all_registrations').handle(this.publishAllRegistrations.bind(this));
    }
    /**
     * Registers an aural alert.
     * @param definition The definition of the alert to register.
     */
    register(definition) {
        this.registrations.set(definition.uuid, definition);
        this.publishRegistration(definition);
    }
    /**
     * Publishes a registration event for an alert.
     * @param definition The definition of the alert to register.
     */
    publishRegistration(definition) {
        this.publisher.pub('aural_alert_register', definition, true);
    }
    /**
     * Publishes registration events for all currently registered alerts.
     */
    publishAllRegistrations() {
        for (const definition of this.registrations.values()) {
            this.publishRegistration(definition);
        }
    }
    /**
     * Destroys this manager.
     */
    destroy() {
        this.requestSub.destroy();
    }
}

/**
 * A system which manages and plays aural alerts using a priority queue system.
 *
 * The system collects registered alerts, and manages how they are played. Each alert belongs to a queue. Only one
 * alert from each queue can play simultaneously. Alerts are queued to be played when they become activated or triggered.
 * If two alerts are queued at the same time, the one with higher priority is played first. Alerts cannot interrupt an
 * already playing alert, regardless of their relative priorities.
 */
class AuralAlertSystem {
    /**
     * Creates a new AuralAlertSystem. The system is asleep when created.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.soundServerSub = this.bus.getSubscriber();
        this.controlSub = this.bus.getSubscriber();
        this.soundServerPublisher = this.bus.getPublisher();
        this.publisher = this.bus.getPublisher();
        this.registeredAlerts = new Map();
        this.queueToPacketKeyMap = new Map();
        this.packetKeyToQueueMap = new Map();
        this.queues = new Map();
        this.playing = new Map();
        this.activeAliasToUuid = new Map();
        this.triggeredAliasToUuid = new Map();
        this.activeSuffixedIdToId = new Map();
        this.idToActiveSuffixedIds = new Map();
        this.triggeredSuffixedIdToId = new Map();
        this.idToTriggeredSuffixedIds = new Map();
        this.activeAlerts = new Map();
        this.triggeredAlerts = new Map();
        this.isSoundServerInit = false;
        this.isAwake = false;
        this.controlSub.on('aural_alert_register').handle(this.onAlertRegistered.bind(this));
        this.publisher.pub('aural_alert_request_all_registrations', undefined, true, false);
        this.soundServerSub.on('sound_server_packet_ended').handle(this.onPacketEnded.bind(this));
        this.controlSub.on('aural_alert_activate').handle(this.activateAlert.bind(this));
        this.controlSub.on('aural_alert_deactivate').handle(this.deactivateAlert.bind(this));
        this.controlSub.on('aural_alert_trigger').handle(this.triggerAlert.bind(this));
        this.controlSub.on('aural_alert_untrigger').handle(this.untriggerAlert.bind(this));
        this.controlSub.on('aural_alert_kill').handle(this.killAlert.bind(this));
        this.controlSub.on('aural_alert_deactivate_all').handle(this.deactivateAllAlerts.bind(this));
        this.controlSub.on('aural_alert_untrigger_all').handle(this.untriggerAllAlerts.bind(this));
        this.controlSub.on('aural_alert_kill_all').handle(this.killAllAlerts.bind(this));
        // Hold all pending alerts in their queues until the sound server is initialized. Then, start dequeuing alerts.
        Wait.awaitConsumer(this.soundServerSub.on('sound_server_initialized'), init => init, true).then(() => {
            this.isSoundServerInit = true;
            for (const queue of this.queues.values()) {
                this.dequeueAlert(queue);
            }
        });
    }
    /**
     * Wakes this system. All active continuous alerts will be re-queued to play. While this system is awake, activation
     * of alerts will queue them to be played. Activation of any alerts that were already active when the system woke up
     * will not queue them to be played unless the alert was deactivated in the interim.
     */
    wake() {
        if (this.isAwake) {
            return;
        }
        this.isAwake = true;
        // Find all active alerts that are repeatable or continuous and re-queue them.
        for (const alert of this.activeAlerts.values()) {
            if (alert.repeat || alert.packet.continuous) {
                this.queueAlert(alert);
            }
        }
    }
    /**
     * Puts this system to sleep. Clears all triggered and queued alerts and stops all currently playing alerts at the
     * earliest opportunity. While this system is asleep, activating alerts will not queue them to be played and
     * triggering alerts has no effect.
     */
    sleep() {
        if (!this.isAwake) {
            return;
        }
        this.isAwake = false;
        // Clears all triggered alerts.
        this.triggeredAlerts.clear();
        this.triggeredAliasToUuid.clear();
        this.triggeredSuffixedIdToId.clear();
        this.idToTriggeredSuffixedIds.clear();
        // Clear all queued alerts.
        for (const queueEntry of this.queues.values()) {
            queueEntry.queue.clear();
        }
        // Kills all alerts that are currently playing.
        for (const playing of this.playing.values()) {
            this.soundServerPublisher.pub('sound_server_kill', playing.packet.key, true, false);
        }
    }
    /**
     * Responds to when an alert is registered.
     * @param alert The definition of the registered alert.
     */
    onAlertRegistered(alert) {
        this.registeredAlerts.set(alert.uuid, alert);
        !this.queues.has(alert.queue) && this.createQueue(alert.queue);
    }
    /**
     * Creates an alert queue entry.
     * @param queueName The name of the queue to create.
     * @returns The new queue entry.
     */
    createQueue(queueName) {
        const entry = {
            queue: new BinaryHeap(AuralAlertSystem.ALERT_COMPARATOR),
            debounceTimer: new DebounceTimer()
        };
        this.queues.set(queueName, entry);
        const packetKey = AuralAlertSystem.createPacketKey(queueName);
        this.queueToPacketKeyMap.set(queueName, packetKey);
        this.packetKeyToQueueMap.set(packetKey, queueName);
        return entry;
    }
    /**
     * Checks if an alias is unique. An alias is considered unique if and only if it does not match any registered
     * alert IDs and it does not match any active or triggered aliases assigned to other parent IDs.
     * @param uuid The parent ID of the alias.
     * @param alias The alias to check.
     * @returns Whether the specified alias is unique.
     */
    isAliasUnique(uuid, alias) {
        if (this.registeredAlerts.has(alias)) {
            return false;
        }
        const existingActive = this.activeAliasToUuid.get(alias);
        if (existingActive !== undefined && existingActive !== uuid) {
            return false;
        }
        const existingTriggered = this.triggeredAliasToUuid.get(alias);
        if (existingTriggered !== undefined && existingTriggered !== uuid) {
            return false;
        }
        return true;
    }
    /**
     * Checks if a suffixed ID is unique. A suffixed ID is considered unique if and only if it does not match any
     * registered alert IDs or aliases and it does not match any active or triggered suffixed IDs assigned to other
     * parent IDs.
     * @param id The parent ID of the suffix.
     * @param suffixedId The suffixed ID to check.
     * @returns Whether the specified suffixed ID is unique.
     */
    isSuffixedIdUnique(id, suffixedId) {
        if (this.registeredAlerts.has(suffixedId) || this.activeAliasToUuid.has(suffixedId) || this.triggeredAliasToUuid.has(suffixedId)) {
            return false;
        }
        const existingActive = this.activeSuffixedIdToId.get(suffixedId);
        if (existingActive !== undefined && existingActive !== id) {
            return false;
        }
        const existingTriggered = this.triggeredSuffixedIdToId.get(suffixedId);
        if (existingTriggered !== undefined && existingTriggered !== id) {
            return false;
        }
        return true;
    }
    /**
     * Activates an alert.
     * @param activation The ID of the alert to activate, or data describing the alert to activate.
     */
    activateAlert(activation) {
        let uuid;
        let alias;
        let queuedId;
        let suffixedId;
        let activationObject;
        if (typeof activation === 'string') {
            uuid = activation;
            alias = undefined;
            queuedId = uuid;
            suffixedId = undefined;
            activationObject = undefined;
        }
        else {
            uuid = activation.uuid;
            alias = activation.alias;
            queuedId = alias !== null && alias !== void 0 ? alias : uuid;
            suffixedId = activation.suffix === undefined ? undefined : `${queuedId}::${activation.suffix}`;
            activationObject = activation;
        }
        const alertDef = this.registeredAlerts.get(uuid);
        // If the alert is not registered, then do nothing.
        if (!alertDef) {
            return;
        }
        if (alias !== undefined && !this.isAliasUnique(uuid, alias)) {
            return;
        }
        if (suffixedId !== undefined && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
            return;
        }
        if (alias !== undefined) {
            this.activeAliasToUuid.set(alias, uuid);
        }
        this.activateSuffix(queuedId, suffixedId);
        // If the alert is already active, then do nothing.
        if (this.activeAlerts.has(queuedId)) {
            return;
        }
        const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
        this.activeAlerts.set(queuedId, queuedAlert);
        if (this.isAwake) {
            this.queueAlert(queuedAlert);
        }
    }
    /**
     * Activates an alert suffix.
     * @param id The ID of the suffix's parent alert.
     * @param suffixedId The suffixed ID to activate.
     */
    activateSuffix(id, suffixedId = id) {
        this.activeSuffixedIdToId.set(suffixedId, id);
        let suffixedIds = this.idToActiveSuffixedIds.get(id);
        if (!suffixedIds) {
            this.idToActiveSuffixedIds.set(id, suffixedIds = new Set());
        }
        suffixedIds.add(suffixedId);
    }
    /**
     * Triggers an alert.
     * @param activation The ID of the alert to trigger, or data describing the alert to trigger.
     */
    triggerAlert(activation) {
        if (!this.isAwake) {
            return;
        }
        let uuid;
        let alias;
        let queuedId;
        let suffixedId;
        let activationObject;
        if (typeof activation === 'string') {
            uuid = activation;
            alias = undefined;
            queuedId = uuid;
            suffixedId = undefined;
            activationObject = undefined;
        }
        else {
            uuid = activation.uuid;
            alias = activation.alias;
            queuedId = alias !== null && alias !== void 0 ? alias : uuid;
            suffixedId = activation.suffix === undefined ? undefined : `${queuedId}::${activation.suffix}`;
            activationObject = activation;
        }
        const alertDef = this.registeredAlerts.get(uuid);
        // If the alert is not registered, then do nothing.
        if (!alertDef) {
            return;
        }
        if (alias !== undefined && !this.isAliasUnique(uuid, alias)) {
            return;
        }
        if (suffixedId !== undefined && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
            return;
        }
        if (alias !== undefined) {
            this.triggeredAliasToUuid.set(alias, uuid);
        }
        this.triggerSuffix(queuedId, suffixedId);
        // If a triggered instance of this alert is already playing, then do nothing.
        const existing = this.triggeredAlerts.get(queuedId);
        if (existing && this.playing.get(existing.definition.queue) === existing) {
            return;
        }
        const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
        this.triggeredAlerts.set(queuedId, queuedAlert);
        this.queueAlert(queuedAlert);
    }
    /**
     * Triggers an alert suffix.
     * @param id The ID of the suffix's parent alert.
     * @param suffixedId The suffixed ID to trigger.
     */
    triggerSuffix(id, suffixedId = id) {
        this.triggeredSuffixedIdToId.set(suffixedId, id);
        let suffixedIds = this.idToTriggeredSuffixedIds.get(id);
        if (!suffixedIds) {
            this.idToTriggeredSuffixedIds.set(id, suffixedIds = new Set());
        }
        suffixedIds.add(suffixedId);
    }
    /**
     * Creates an alert to be queued.
     * @param definition The definition of the alert.
     * @param activation Data describing the alert to activate. If not defined, the alert will be activated according
     * to its definition.
     * @returns The queued alert.
     */
    createQueuedAlert(definition, activation) {
        var _a, _b, _c, _d, _e;
        return {
            definition,
            id: (_a = activation === null || activation === void 0 ? void 0 : activation.alias) !== null && _a !== void 0 ? _a : definition.uuid,
            repeat: (_b = activation === null || activation === void 0 ? void 0 : activation.repeat) !== null && _b !== void 0 ? _b : definition.repeat,
            packet: {
                key: this.queueToPacketKeyMap.get(definition.queue),
                sequence: (_c = activation === null || activation === void 0 ? void 0 : activation.sequence) !== null && _c !== void 0 ? _c : definition.sequence,
                continuous: (_d = activation === null || activation === void 0 ? void 0 : activation.continuous) !== null && _d !== void 0 ? _d : definition.continuous,
                timeout: (_e = activation === null || activation === void 0 ? void 0 : activation.timeout) !== null && _e !== void 0 ? _e : definition.timeout
            },
            timestamp: Date.now()
        };
    }
    /**
     * Queues an alert to be played.
     * @param alert The alert to queue.
     */
    queueAlert(alert) {
        var _a;
        const queueName = alert.definition.queue;
        const queueEntry = (_a = this.queues.get(queueName)) !== null && _a !== void 0 ? _a : this.createQueue(queueName);
        queueEntry.queue.insert(alert);
        if (this.isSoundServerInit) {
            const playing = this.playing.get(queueName);
            if (!playing) {
                // If nothing is currently playing, then wait one frame before we start dequeuing so that alerts that are
                // activated on the same frame are correctly prioritized.
                if (!queueEntry.debounceTimer.isPending()) {
                    queueEntry.debounceTimer.schedule(this.dequeueAlert.bind(this, queueEntry), 0);
                }
            }
        }
    }
    /**
     * Dequeues the next activated or triggered alert from a queue and starts playing it. If this system is asleep, then
     * the queue will be cleared instead and no alert will be played.
     * @param entry The queue entry.
     */
    dequeueAlert(entry) {
        if (this.isAwake) {
            // Find the next alert in the queue that is active or triggered.
            let next = undefined;
            while (entry.queue.size > 0) {
                next = entry.queue.removeMin();
                // We need to compare the dequeued alert with the one in the active/triggered alerts map by reference instead
                // of just comparing their IDs because the alert could have been deactivated and activated or triggered again
                // while it was queued. The map contains the queued alert object from the most recent activation, so that is
                // the one we want to play.
                if (this.activeAlerts.get(next.id) === next
                    || this.triggeredAlerts.get(next.id) === next) {
                    break;
                }
                else {
                    next = undefined;
                }
            }
            if (next) {
                this.playing.set(next.definition.queue, next);
                this.soundServerPublisher.pub('sound_server_interrupt', next.packet, true, false);
            }
        }
        else {
            entry.queue.clear();
        }
    }
    /**
     * Deactivates an alert. Deactivating an alert will prevent queued activated instances of it from playing. In
     * addition, if an activated instance of the alert is currently playing and is continuous, it will be prevented from
     * looping.
     * @param id The (optionally suffixed) ID of the alert to deactivate.
     */
    deactivateAlert(id) {
        var _a;
        const deactivatedId = this.deactivateSuffix(id);
        if (deactivatedId === undefined) {
            return;
        }
        // Check if the deactivated ID is an alias by retrieving it from the alias map. If it's not in the map, then we
        // assume it is not an alias.
        const deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
        // If the deactivated ID was an alias, remove it from the alias map.
        if (deactivatedUuid !== deactivatedId) {
            this.activeAliasToUuid.delete(deactivatedId);
        }
        const alertDef = this.registeredAlerts.get(deactivatedUuid);
        if (alertDef) {
            const playing = this.playing.get(alertDef.queue);
            if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
                this.soundServerPublisher.pub('sound_server_stop', playing.packet.key, true, false);
            }
        }
    }
    /**
     * Deactivates an alert suffix.
     * @param suffixedId The suffixed ID to deactivate.
     * @returns The ID of the alert that was deactivated as a result of deactivating the suffix, or `undefined` if no
     * alert was deactivated.
     */
    deactivateSuffix(suffixedId) {
        const id = this.activeSuffixedIdToId.get(suffixedId);
        if (id === undefined) {
            return undefined;
        }
        this.activeSuffixedIdToId.delete(suffixedId);
        const suffixedIds = this.idToActiveSuffixedIds.get(id);
        if (!suffixedIds) {
            this.activeAlerts.delete(id);
            return id;
        }
        else {
            suffixedIds.delete(suffixedId);
            if (suffixedIds.size === 0) {
                this.activeAlerts.delete(id);
                return id;
            }
            else {
                return undefined;
            }
        }
    }
    /**
     * Untriggers an alert. Untriggering an alert will prevent queued triggered instances of it from playing. In
     * addition, if a triggered instance of the alert is currently playing and is continuous, it will be prevented from
     * looping.
     * @param uuid The (optionally suffixed) ID of the alert to untrigger.
     */
    untriggerAlert(uuid) {
        var _a;
        const untriggeredId = this.untriggerSuffix(uuid);
        if (untriggeredId === undefined) {
            return;
        }
        // Check if the untriggered ID is an alias by retrieving it from the alias map. If it's not in the map, then we
        // assume it is not an alias.
        const untriggeredUuid = (_a = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _a !== void 0 ? _a : untriggeredId;
        // If the untriggered ID was an alias, remove it from the alias map.
        if (untriggeredUuid !== untriggeredId) {
            this.triggeredAliasToUuid.delete(untriggeredId);
        }
        const alertDef = this.registeredAlerts.get(untriggeredUuid);
        if (alertDef) {
            const playing = this.playing.get(alertDef.queue);
            if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing) {
                this.soundServerPublisher.pub('sound_server_stop', playing.packet.key, true, false);
            }
        }
    }
    /**
     * Untriggers an alert suffix.
     * @param suffixedId The suffixed ID to untrigger.
     * @returns The ID of the alert that was untriggered as a result of deactivating the suffix, or `undefined` if no
     * alert was untriggered.
     */
    untriggerSuffix(suffixedId) {
        const id = this.triggeredSuffixedIdToId.get(suffixedId);
        if (id === undefined) {
            return undefined;
        }
        this.triggeredSuffixedIdToId.delete(suffixedId);
        const suffixedIds = this.idToTriggeredSuffixedIds.get(id);
        if (!suffixedIds) {
            this.triggeredAlerts.delete(id);
            return id;
        }
        else {
            suffixedIds.delete(suffixedId);
            if (suffixedIds.size === 0) {
                this.triggeredAlerts.delete(id);
                return id;
            }
            else {
                return undefined;
            }
        }
    }
    /**
     * Kills an alert. Killing an alert will deactivate and untrigger it. In addition, if the alert is currently playing,
     * it will be stopped at the earliest opportunity.
     * @param uuid The (optionally suffixed) ID of the alert to kill.
     */
    killAlert(uuid) {
        var _a, _b;
        const deactivatedId = this.deactivateSuffix(uuid);
        const untriggeredId = this.untriggerSuffix(uuid);
        let deactivatedUuid = undefined;
        let untriggeredUuid = undefined;
        if (deactivatedId !== undefined) {
            // Check if the deactivated ID is an alias by retrieving it from the alias map. If it's not in the map, then we
            // assume it is not an alias.
            deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
            // If the deactivated ID was an alias, remove it from the alias map.
            if (deactivatedUuid !== deactivatedId) {
                this.activeAliasToUuid.delete(deactivatedId);
            }
        }
        if (untriggeredId !== undefined) {
            // Check if the untriggered ID is an alias by retrieving it from the alias map. If it's not in the map, then we
            // assume it is not an alias.
            untriggeredUuid = (_b = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _b !== void 0 ? _b : untriggeredId;
            // If the untriggered ID was an alias, remove it from the alias map.
            if (untriggeredUuid !== untriggeredId) {
                this.triggeredAliasToUuid.delete(untriggeredId);
            }
        }
        const deactivatedAlertDef = deactivatedUuid === undefined ? undefined : this.registeredAlerts.get(deactivatedUuid);
        const untriggeredAlertDef = untriggeredUuid === undefined ? undefined : this.registeredAlerts.get(untriggeredUuid);
        let killedPacketKey = undefined;
        if (deactivatedAlertDef) {
            const playing = this.playing.get(deactivatedAlertDef.queue);
            if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
                this.soundServerPublisher.pub('sound_server_kill', playing.packet.key, true, false);
                killedPacketKey = playing.packet.key;
            }
        }
        if (untriggeredAlertDef) {
            const playing = this.playing.get(untriggeredAlertDef.queue);
            if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing && killedPacketKey !== playing.packet.key) {
                this.soundServerPublisher.pub('sound_server_kill', playing.packet.key, true, false);
            }
        }
    }
    /**
     * Deactivates all alerts. This will stop all queued activated alerts from playing and prevent all currently playing
     * activated continuous alerts from looping.
     */
    deactivateAllAlerts() {
        this.activeAlerts.clear();
        this.activeAliasToUuid.clear();
        this.activeSuffixedIdToId.clear();
        this.idToActiveSuffixedIds.clear();
        for (const playing of this.playing.values()) {
            if (this.triggeredAlerts.get(playing.id) !== playing) {
                this.soundServerPublisher.pub('sound_server_stop', playing.packet.key, true, false);
            }
        }
    }
    /**
     * Untriggers all alerts. This will stop all queued triggered alerts from playing and prevent all currently playing
     * triggered continuous alerts from looping.
     */
    untriggerAllAlerts() {
        this.triggeredAlerts.clear();
        this.triggeredAliasToUuid.clear();
        this.triggeredSuffixedIdToId.clear();
        this.idToTriggeredSuffixedIds.clear();
        for (const playing of this.playing.values()) {
            if (this.activeAlerts.get(playing.id) !== playing) {
                this.soundServerPublisher.pub('sound_server_stop', playing.packet.key, true, false);
            }
        }
    }
    /**
     * Kills all alerts. This deactivates and untriggers all alerts, stopping all queued alerts from playing and stopping
     * all currently playing alerts at the earliest opportunity.
     */
    killAllAlerts() {
        this.activeAlerts.clear();
        this.triggeredAlerts.clear();
        this.activeAliasToUuid.clear();
        this.triggeredAliasToUuid.clear();
        this.activeSuffixedIdToId.clear();
        this.idToActiveSuffixedIds.clear();
        this.triggeredSuffixedIdToId.clear();
        this.idToTriggeredSuffixedIds.clear();
        for (const playing of this.playing.values()) {
            this.soundServerPublisher.pub('sound_server_kill', playing.packet.key, true, false);
        }
    }
    /**
     * Responds to when a sound packet stops playing.
     * @param key The key of the stopped packet.
     */
    onPacketEnded(key) {
        const queueName = this.packetKeyToQueueMap.get(key);
        if (queueName === undefined) {
            return;
        }
        const queueEntry = this.queues.get(queueName);
        if (!queueEntry) {
            this.packetKeyToQueueMap.delete(key);
            this.queueToPacketKeyMap.delete(queueName);
            return;
        }
        const finishedAlert = this.playing.get(queueName);
        if (finishedAlert) {
            // Check if the alert that finished playing was triggered. If so, remove the alert from the triggered list as well
            // as all of its triggered suffixes.
            if (this.triggeredAlerts.get(finishedAlert.id) === finishedAlert) {
                this.triggeredAlerts.delete(finishedAlert.id);
                if (finishedAlert.id !== finishedAlert.definition.uuid) {
                    this.triggeredAliasToUuid.delete(finishedAlert.id);
                }
                const suffixedIds = this.idToTriggeredSuffixedIds.get(finishedAlert.id);
                if (suffixedIds) {
                    for (const suffixedId of suffixedIds) {
                        this.triggeredSuffixedIdToId.delete(suffixedId);
                    }
                    this.idToTriggeredSuffixedIds.delete(finishedAlert.id);
                }
            }
            // Requeue the alert if it is repeatable and is still active.
            if (finishedAlert.repeat && this.activeAlerts.get(finishedAlert.id) === finishedAlert) {
                this.queueAlert(finishedAlert);
            }
        }
        // Remove the alert that finished playing.
        this.playing.delete(queueName);
        this.dequeueAlert(queueEntry);
    }
    /**
     * Creates a sound packet key for a queue.
     * @param queue The name of the queue.
     * @returns A sound packet key for the specified queue.
     */
    static createPacketKey(queue) {
        return `$$aural-alert-system-queue-${queue}$$`;
    }
}
AuralAlertSystem.ALERT_COMPARATOR = (a, b) => {
    const priorityDiff = b.definition.priority - a.definition.priority;
    // If same priority, bias toward older alerts so that repeatable alerts of the same priority don't constantly
    // preempt one another.
    if (priorityDiff === 0) {
        return a.timestamp - b.timestamp;
    }
    else {
        return priorityDiff;
    }
};

/**
 * Binds the state of an aural alert to the displayed state of a CAS alert and transports the aural alert state to
 * {@link AuralAlertSystem}.
 */
class CasAuralAlertTransporter {
    /**
     * Creates a new instance of CasAuralAlertTransporter.
     * @param bus The event bus.
     * @param auralUuid The ID of this transporter's aural alert.
     * @param auralActivation A function which generates activation data for this transporter's aural alert. If the
     * function returns `undefined` or is itself not defined, the aural alert will be activated using its default
     * registered parameters.
     * @param casUuid The ID of the CAS alert to which to bind this transporter's aural alert.
     * @param casPriority The priority level of the CAS alert to which to bind this transporter's aural alert.
     * @param casSuffix The suffix, if any, of the CAS alert to which to bind this transporter's aural alert.
     * @param includeAcknowledged Whether to activate this transporter's aural alert when the bound CAS alert is
     * acknowledged.
     * @param casSystem The CAS system. If not defined, the initialization of the aural alert's state cannot be
     * guaranteed to be correct unless the transporter is created before the CAS alert can be activated.
     * @returns A new instance of CasAuralAlertTransporter.
     */
    constructor(bus, auralUuid, auralActivation, casUuid, casPriority, casSuffix, includeAcknowledged, casSystem) {
        var _a;
        this.auralUuid = auralUuid;
        this.auralActivation = auralActivation;
        this.casUuid = casUuid;
        this.casPriority = casPriority;
        this.casSuffix = casSuffix;
        this.includeAcknowledged = includeAcknowledged;
        this.publisher = bus.getPublisher();
        const sub = bus.getSubscriber();
        if (casSystem) {
            // Find out of the bound CAS alert is already displayed
            const filter = casSuffix === undefined
                ? message => {
                    return message.uuid === casUuid
                        && message.priority === casPriority
                        && (message.suffixes === undefined || message.suffixes.length === 0)
                        && (this.includeAcknowledged || !message.acknowledged);
                }
                : message => {
                    return message.uuid === casUuid
                        && message.priority === casPriority
                        && (message.suffixes !== undefined && message.suffixes.includes(casSuffix))
                        && (this.includeAcknowledged || (message.acknowledgedSuffixes !== undefined && message.acknowledgedSuffixes.includes(casSuffix)));
                };
            if (casSystem.casActiveMessageSubject.getArray().find(filter)) {
                this.publisher.pub('aural_alert_activate', (_a = (this.auralActivation && this.auralActivation())) !== null && _a !== void 0 ? _a : this.auralUuid, true, false);
            }
        }
        this.subs = [
            sub.on('cas_alert_displayed').handle(this.onAlertDisplayed.bind(this)),
            sub.on('cas_alert_hidden').handle(this.onAlertHidden.bind(this))
        ];
        if (!this.includeAcknowledged) {
            this.subs.push(sub.on('cas_alert_acknowledged').handle(this.onAlertAcknowledged.bind(this)));
        }
    }
    /**
     * Responds to when a CAS alert is displayed.
     * @param alert Data describing the displayed alert.
     */
    onAlertDisplayed(alert) {
        var _a;
        if (alert.uuid === this.casUuid && alert.priority === this.casPriority && alert.suffix === this.casSuffix && (this.includeAcknowledged || !alert.acknowledged)) {
            this.publisher.pub('aural_alert_activate', (_a = (this.auralActivation && this.auralActivation())) !== null && _a !== void 0 ? _a : this.auralUuid, true, false);
        }
    }
    /**
     * Responds to when a CAS alert is hidden.
     * @param alert Data describing the hidden alert.
     */
    onAlertHidden(alert) {
        if (alert.uuid === this.casUuid && alert.priority === this.casPriority && alert.suffix === this.casSuffix) {
            this.publisher.pub('aural_alert_deactivate', this.auralUuid, true, false);
        }
    }
    /**
     * Responds to when a CAS alert is acknowledged.
     * @param alert Data describing the acknowledged alert.
     */
    onAlertAcknowledged(alert) {
        // This method is only called if includeAcknowledged is false, so if the alert matches we always want to deactivate the aural.
        if (alert.uuid === this.casUuid && alert.priority === this.casPriority && alert.suffix === this.casSuffix) {
            this.publisher.pub('aural_alert_deactivate', this.auralUuid, true, false);
        }
    }
    /**
     * Destroys this transporter. Once destroyed, it will no longer automatically manage the state of its aural alert.
     */
    destroy() {
        this.subs.forEach(sub => { sub.destroy(); });
    }
    /**
     * Creates a new instance of CasAuralAlertTransporter, which will automatically activate and deactivate an aural
     * alert based on whether a bound CAS alert is being displayed as a message.
     * @param bus The event bus.
     * @param auralUuid The ID of the transporter's aural alert.
     * @param auralActivation A function which generates activation data for the transporter's aural alert. If the
     * function returns `undefined` or is itself not defined, the aural alert will be activated using its default
     * registered parameters.
     * @param casUuid The ID of the CAS alert to which to bind the transporter's aural alert.
     * @param casPriority The priority level of the CAS alert to which to bind the transporter's aural alert.
     * @param casSuffix The suffix, if any, of the CAS alert to which to bind the transporter's aural alert.
     * @param includeAcknowledged Whether to activate the transporter's aural alert when the bound CAS alert is
     * acknowledged.
     * @param casSystem The CAS system. If not defined, the transporter should be created before its bound CAS alert
     * can be activated. Otherwise the initialization of the aural alert's state cannot be guaranteed to be correct.
     * @returns A new instance of CasAuralAlertTransporter.
     */
    static create(bus, auralUuid, auralActivation, casUuid, casPriority, casSuffix, includeAcknowledged, casSystem) {
        return new CasAuralAlertTransporter(bus, auralUuid, auralActivation, casUuid, casPriority, casSuffix, includeAcknowledged, casSystem);
    }
}

/**
 * A server which plays and manages sounds. Commands to start or stop playing sounds can be sent to the server via the
 * event bus.
 *
 * The server plays sounds as _packets_. Each sound packet consists of a string key and zero or more _sound atoms_ that
 * are played in sequence. Each sound atom represents a single playable sound file from within the sim. Sound packets
 * can be played as a one-shot or be looped continuously. Only one packet with a given key can be played at a time.
 * Queueing of packets with the same key is supported.
 */
class SoundServer {
    /**
     * Creates a new instance of SoundServer.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.controlSub = this.bus.getSubscriber();
        this.publisher = this.bus.getPublisher();
        this.active = new Map();
        this.queued = new Map();
        this.publisher.pub('sound_server_initialized', false, true, true);
        this.init();
    }
    /**
     * Waits until the sim has entered the in-game state and initializes this server. Once initialized, this server will
     * respond to commands over the event bus.
     */
    async init() {
        // Wait for game to reach "ingame" state. THEN wait a short duration and wait again for game to reach "ingame"
        // state because during load the game will go from loading -> ingame -> briefing.
        await Wait.awaitSubscribable(GameStateProvider.get(), state => state === GameState.ingame, true);
        await Wait.awaitDelay(500);
        await Wait.awaitSubscribable(GameStateProvider.get(), state => state === GameState.ingame, true);
        this.controlSub.on('sound_server_play').handle(this.playPacket.bind(this));
        this.controlSub.on('sound_server_queue').handle(this.queuePacket.bind(this));
        this.controlSub.on('sound_server_interrupt').handle(this.interruptPacket.bind(this));
        this.controlSub.on('sound_server_stop').handle(this.stopPacket.bind(this));
        this.controlSub.on('sound_server_kill').handle(this.killPacket.bind(this));
        this.controlSub.on('sound_server_stop_all').handle(this.stopAllPackets.bind(this));
        this.controlSub.on('sound_server_kill_all').handle(this.killAllPackets.bind(this));
        this.controlSub.on('sound_server_play_sound').handle(this.playSound.bind(this));
        this.controlSub.on('sound_server_start_sound').handle(this.startSound.bind(this));
        this.controlSub.on('sound_server_stop_sound').handle(this.stopPacket.bind(this));
        this.publisher.pub('sound_server_initialized', true, true, true);
    }
    /**
     * A callback method that responds to when the sim notifies the JS instrument that a sound file has stopped playing.
     * This method needs to be manually called for `SoundServer` to function properly.
     * @param id The ID of the sound file that stopped playing.
     */
    onSoundEnd(id) {
        // Create a copy of the active entries because the map can be mutated while we are iterating.
        const activeEntries = Array.from(this.active.values());
        for (let i = 0; i < activeEntries.length; i++) {
            const entry = activeEntries[i];
            const entrySoundPlaying = entry.sequence[entry.currentIndexPlaying];
            if (!entrySoundPlaying) {
                this.cleanupPacket(entry);
            }
            else if (Name_Z.compare(entrySoundPlaying, id)) {
                this.advancePacket(entry);
            }
        }
    }
    /**
     * Plays a sound packet if and only if there is no currently playing packet with the same key.
     * @param packet The packet to play.
     */
    playPacket(packet) {
        if (!this.active.get(packet.key)) {
            this.queuePacket(packet);
        }
    }
    /**
     * Plays a sound packet at the earliest opportunity. If there is no currently playing packet with the same key, it
     * will begin playing immediately. Otherwise, all queued packets with the same key are cleared, the existing packet
     * will be stopped the next time one of its sound atoms finishes playing, and the new packet will begin playing at
     * that time.
     * @param packet The packet to play.
     */
    interruptPacket(packet) {
        const active = this.active.get(packet.key);
        if (active) {
            active.alive = false;
        }
        this.queued.delete(packet.key);
        this.queuePacket(packet);
    }
    /**
     * Queues a sound packet. The queued packet will immediately start playing if there is no currently playing packet
     * with the same key. Otherwise it will be queued to play once all currently playing and previously queued packets
     * with the same key have finished playing.
     * @param packet The packet to queue.
     */
    queuePacket(packet) {
        var _a;
        const sequence = SoundServer.getSoundSequence(packet);
        const entry = {
            key: packet.key,
            sequence,
            continuous: packet.continuous,
            currentIndexPlaying: 0,
            timeout: (_a = packet.timeout) !== null && _a !== void 0 ? _a : SoundServer.DEFAULT_TIMEOUT,
            alive: true,
            timer: new DebounceTimer(),
            timeoutCallback: () => { this.cleanupPacket(entry); }
        };
        if (this.active.get(packet.key)) {
            let queue = this.queued.get(entry.key);
            if (!queue) {
                this.queued.set(entry.key, queue = []);
            }
            queue.push(entry);
        }
        else {
            this.startPacket(entry);
        }
    }
    /**
     * Stops a continuous packet from looping the next time its sequence finishes and clears any packets queued behind
     * it.
     * @param key The key of the packet to stop.
     */
    stopPacket(key) {
        this.queued.delete(key);
        const active = this.active.get(key);
        if (active) {
            active.continuous = false;
        }
    }
    /**
     * Stops a packet from playing the next time one of its sound atoms finishes playing and clears any packets queued
     * behind it.
     * @param key The key of the packet to kill.
     */
    killPacket(key) {
        this.queued.delete(key);
        const active = this.active.get(key);
        if (active) {
            active.alive = false;
        }
    }
    /**
     * Stops all currently playing continuous packets from looping the next time their sequences finish and clears all
     * queued packets.
     */
    stopAllPackets() {
        this.queued.clear();
        for (const entry of this.active.values()) {
            entry.continuous = false;
        }
    }
    /**
     * Stops all packets from playing the next time one of their sound atoms finishes playing and clears all queued
     * packets.
     */
    killAllPackets() {
        this.queued.clear();
        for (const entry of this.active.values()) {
            entry.alive = false;
        }
    }
    /**
     * Plays a non-continuous sound packet consisting of a single sound atom and whose key matches the ID of the sound
     * atom.
     * @param id The ID of the sound atom to play.
     */
    playSound(id) {
        this.playPacket({ key: id, sequence: id, continuous: false });
    }
    /**
     * Plays a continuous sound packet consisting of a single sound atom and whose key matches the ID of the sound atom.
     * @param id The ID of the sound atom to play.
     */
    startSound(id) {
        this.playPacket({ key: id, sequence: id, continuous: true });
    }
    /**
     * Starts playing a packet from the beginning of its sequence.
     * @param entry The entry of the packet to start playing.
     */
    startPacket(entry) {
        this.active.set(entry.key, entry);
        this.publisher.pub('sound_server_packet_started', entry.key, true, false);
        if (entry.sequence.length === 0) {
            this.cleanupPacket(entry);
        }
        else {
            Coherent.call('PLAY_INSTRUMENT_SOUND', entry.sequence[0].originalStr);
            entry.currentIndexPlaying = 0;
            entry.timer.schedule(entry.timeoutCallback, entry.timeout);
        }
    }
    /**
     * Attempts to advance a packet to the next sound atom in its sequence. If the end of the sequence is reached, the
     * packet will loop to the beginning if it is continuous. Otherwise it will finish playing.
     * @param entry The entry of the packet to advance.
     */
    advancePacket(entry) {
        if (!entry.alive) {
            this.cleanupPacket(entry);
            return;
        }
        let nextSoundToPlayIndex = entry.currentIndexPlaying + 1;
        if (nextSoundToPlayIndex >= entry.sequence.length) {
            // We have reached the end of the sequence. If the packet is continuous, loop to the beginning. Otherwise, end the packet.
            if (entry.continuous) {
                nextSoundToPlayIndex = 0;
                entry.timer.schedule(entry.timeoutCallback, entry.timeout);
            }
            else {
                this.cleanupPacket(entry);
                return;
            }
        }
        const soundToPlay = entry.sequence[nextSoundToPlayIndex];
        Coherent.call('PLAY_INSTRUMENT_SOUND', soundToPlay.originalStr);
        entry.currentIndexPlaying = nextSoundToPlayIndex;
    }
    /**
     * Finishes playing a packet and automatically starts playing the packet queued behind the finished packet, if one
     * exists.
     * @param entry The entry of the packet to finish.
     */
    cleanupPacket(entry) {
        entry.alive = false;
        entry.timer.clear();
        const deleted = this.active.delete(entry.key);
        if (!deleted) {
            return;
        }
        this.publisher.pub('sound_server_packet_ended', entry.key, true, false);
        // Dequeue the next packet, if any.
        const queue = this.queued.get(entry.key);
        if (queue) {
            const next = queue.shift();
            if (queue.length === 0) {
                this.queued.delete(entry.key);
            }
            if (next) {
                this.startPacket(next);
            }
        }
    }
    /**
     * Gets a sound atom sequence as an array of `Name_Z` objects from a sound packet.
     * @param packet The packet defining the sound atom sequence.
     * @returns The sound atom sequence defined by a packet, as an array of `Name_Z` objects.
     */
    static getSoundSequence(packet) {
        const sequence = [];
        if (typeof packet.sequence === 'string') {
            if (packet.sequence !== '') {
                sequence.push(new Name_Z(packet.sequence));
            }
        }
        else {
            for (let i = 0; i < packet.sequence.length; i++) {
                if (packet.sequence[i] !== '') {
                    sequence.push(new Name_Z(packet.sequence[i]));
                }
            }
        }
        return sequence;
    }
}
SoundServer.DEFAULT_TIMEOUT = 10000;
/**
 * A controller which provides a convenient interface with which to send commands to {@link SoundServer}.
 */
class SoundServerController {
    /**
     * Creates a new instance of SoundServerController.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.publisher = bus.getPublisher();
        this.subscriber = bus.getSubscriber();
    }
    /**
     * Waits for the sound server to finish initialization.
     * @returns A Promise which fulfills with a value of `true` when the sound server finishes initialization.
     */
    awaitInitialized() {
        return Wait.awaitConsumer(this.subscriber.on('sound_server_initialized'), init => init, true);
    }
    /**
     * Requests a sound packet to be played if there is no existing packet with the same key currently being played.
     * @param packet The sound packet to play.
     */
    play(packet) {
        this.publisher.pub('sound_server_play', packet, true, false);
    }
    /**
     * Requests a sound packet to be queued. If there is no existing packet with the same key currently being played, the
     * packet will begin playing immediately. Otherwise, the new packet will begin playing after the existing packet and
     * any other queued packets with the same key are finished playing.
     * @param packet The sound packet to queue.
     */
    queue(packet) {
        this.publisher.pub('sound_server_queue', packet, true, false);
    }
    /**
     * Requests a sound packet to be played at the earliest opportunity. If there is no existing packet with the same key
     * currently being played, the packet will begin playing immediately. Otherwise, the existing packet will be stopped
     * the next time one of its sound atoms finishes playing, any queued packets with the same key will be discarded, and
     * the new packet will begin playing at that time.
     * @param packet The sound packet to play.
     */
    interrupt(packet) {
        this.publisher.pub('sound_server_interrupt', packet, true, false);
    }
    /**
     * Requests that a continuous sound packet stop playing instead of looping the next time its sequence finishes. This
     * also prevents any queued packets with the same key from
     * playing.
     * @param key The key of the sound packet to stop.
     */
    stop(key) {
        this.publisher.pub('sound_server_stop', key, true, false);
    }
    /**
     * Requests that a sound packet stop playing at the earliest opportunity (the next time one of its sound atoms
     * finishes playing). This also prevents any queued packets with the same key from playing.
     * @param key The key of the sound packet to kill.
     */
    kill(key) {
        this.publisher.pub('sound_server_kill', key, true, false);
    }
    /**
     * Requests that all currently playing continuous sound packets stop playing instead of looping the next time their
     * sequences finish. This also clears all queued packets.
     */
    stopAll() {
        this.publisher.pub('sound_server_stop_all', undefined, true, false);
    }
    /**
     * Requests that all currently playing sound packets stop playing at the earliest opportunity (the next time one of
     * their sound atoms finishes playing). This also clears all queued packets.
     */
    killAll() {
        this.publisher.pub('sound_server_kill_all', undefined, true, false);
    }
    /**
     * Requests a single sound atom to be played non-continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: false })`.
     * @param id The ID of the sound atom to play.
     */
    playSound(id) {
        this.publisher.pub('sound_server_play_sound', id, true, false);
    }
    /**
     * Requests a single sound atom to be played continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: true })`.
     * @param id The ID of the sound atom to play.
     */
    startSound(id) {
        this.publisher.pub('sound_server_start_sound', id, true, false);
    }
}

/** Collection of string utility functions. */
class StringUtils {
    /**
     * Replaces all `'0'` characters in a string with the slashed zero character.
     * @param text The string to convert.
     * @returns A string identical to the input string except with all `'0'` characters converted to the slashed zero
     * character.
     */
    static useZeroSlash(text) {
        return text === null || text === void 0 ? void 0 : text.replace(StringUtils.ZERO_REGEX, '0̸');
    }
    /**
     * Replaces all `'.'` characters in a string with the zero width decimal character.
     * @param text The string to convert.
     * @returns A string identical to the input string except with all `'.'` characters converted to the zero width decimal
     * character.
     */
    static useZeroWidthDecimal(text) {
        return text === null || text === void 0 ? void 0 : text.replace(StringUtils.DECIMAL_REGEX, StringUtils.ZERO_WIDTH_DECIMAL);
    }
    /**
     * Removes leading whitespace and line terminator characters from a string.
     * @param str The string to trim.
     * @returns A new string representing `str` with all leading whitespace and line terminator characters removed.
     */
    static trimStart(str) {
        return str.replace(StringUtils.TRIM_START_REGEX, '');
    }
    /**
     * Removes trailing whitespace and line terminator characters from a string.
     * @param str The string to trim.
     * @returns A new string representing `str` with all trailing whitespace and line terminator characters removed.
     */
    static trimEnd(str) {
        return str.replace(StringUtils.TRIM_END_REGEX, '');
    }
}
StringUtils.DIRECT_TO = 'Ð';
StringUtils.DEGREE = '°';
StringUtils.EN_DASH = '–';
StringUtils.ZERO_WIDTH_DECIMAL = '·';
StringUtils.RIGHT_POINTING_ISOSCELES_RIGHT_TRIANGLE = '🞂';
StringUtils.LEFT_POINTING_ISOSCELES_RIGHT_TRIANGLE = '🞀';
StringUtils.RIGHT_POINTING_TRIANGLE_CENTRED = '⯈';
StringUtils.LEFT_POINTING_TRIANGLE_CENTRED = '⯇';
StringUtils.UP_POINTING_TRIANGLE_CENTRED = '⯅';
StringUtils.DOWN_POINTING_TRIANGLE_CENTRED = '⯆';
StringUtils.ZERO_REGEX = /0/g;
StringUtils.DECIMAL_REGEX = /\./g;
StringUtils.TRIM_START_REGEX = /^\s+/;
StringUtils.TRIM_END_REGEX = /\s+$/;

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        /** The context on this component, if any. */
        this.context = undefined;
        /** The type of context for this component, if any. */
        this.contextType = undefined;
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterRender(node) { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    getContext(context) {
        if (this.context !== undefined && this.contextType !== undefined) {
            const index = this.contextType.indexOf(context);
            return this.context[index];
        }
        throw new Error('Could not find the provided context type.');
    }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
class Context {
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue) {
        this.defaultValue = defaultValue;
        /**
         * The provider component that can be set to a specific context value.
         * @param props The props of the provider component.
         * @returns A new context provider.
         */
        this.Provider = (props) => new ContextProvider(props, this);
    }
}
/**
 * A provider component that can be set to a specific context value.
 */
class ContextProvider extends DisplayComponent {
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props, parent) {
        super(props);
        this.parent = parent;
    }
    /** @inheritdoc */
    render() {
        var _a;
        const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
        return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true
    };
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props) {
        return props.children;
    }
    FSComponent.Fragment = Fragment;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (key === 'class' && typeof prop === 'object' && 'isSubscribableSet' in prop) {
                            // Bind CSS classes to a subscribable set
                            prop.sub((set, eventType, modifiedKey) => {
                                if (eventType === SubscribableSetEventType.Added) {
                                    element.classList.add(modifiedKey);
                                }
                                else {
                                    element.classList.remove(modifiedKey);
                                }
                            }, true);
                        }
                        else if (typeof prop === 'object' && 'isSubscribable' in prop) {
                            if (key === 'style' && prop instanceof ObjectSubject) {
                                // Bind CSS styles to an object subject.
                                prop.sub((v, style, newValue) => {
                                    element.style.setProperty(style.toString(), newValue);
                                }, true);
                            }
                            else {
                                // Bind an attribute to a subscribable.
                                prop.sub((v) => {
                                    element.setAttribute(key, v);
                                }, true);
                            }
                        }
                        else if (key === 'class' && typeof prop === 'object') {
                            // Bind CSS classes to an object of key value pairs where the values can be boolean | Subscribable<boolean>
                            for (const className in prop) {
                                if (className.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[className];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub((showClass) => {
                                        element.classList.toggle(className, !!showClass);
                                    }, true);
                                }
                                else {
                                    element.classList.toggle(className, !!value);
                                }
                            }
                        }
                        else if (key === 'style' && typeof prop === 'object') {
                            // Bind styles to an object of key value pairs
                            for (const style in prop) {
                                if (style.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[style];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub(newValue => {
                                        element.style.setProperty(style, newValue !== null && newValue !== void 0 ? newValue : '');
                                    }, true);
                                }
                                else {
                                    element.style.setProperty(style, value !== null && value !== void 0 ? value : '');
                                }
                            }
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            if (typeof type === 'function' && type.name === Fragment.name) {
                let childNodes = type(props);
                //Handle the case where the single fragment children is an array of nodes passsed down from above
                while (childNodes !== null && childNodes.length === 1 && Array.isArray(childNodes[0])) {
                    childNodes = childNodes[0];
                }
                vnode = {
                    instance: null,
                    props,
                    children: childNodes
                };
            }
            else {
                let instance;
                const pluginSystem = (window._pluginSystem);
                try {
                    instance = type(props);
                }
                catch (_a) {
                    let pluginInstance = undefined;
                    if (pluginSystem !== undefined) {
                        pluginInstance = pluginSystem.onComponentCreating(type, props);
                    }
                    if (pluginInstance !== undefined) {
                        instance = pluginInstance;
                    }
                    else {
                        instance = new type(props);
                    }
                }
                if (props !== null && props.ref !== null && props.ref !== undefined) {
                    props.ref.instance = instance;
                }
                if (instance.contextType !== undefined) {
                    instance.context = instance.contextType.map(c => Subject.create(c.defaultValue));
                }
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentCreated(instance);
                }
                vnode = {
                    instance,
                    props,
                    children: [instance.render()]
                };
            }
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'object') {
                        if ('isSubscribable' in child) {
                            const node = {
                                instance: child,
                                children: null,
                                props: null,
                                root: undefined,
                            };
                            child.sub((v) => {
                                if (node.root !== undefined) {
                                    // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                    node.root.nodeValue = (v === '' || v === null || v === undefined)
                                        ? ' '
                                        : v.toString();
                                }
                            });
                            vnodes.push(node);
                        }
                        else {
                            vnodes.push(child);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            if (element !== null) {
                insertNode(node, position, element);
            }
        }
        else if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance !== null && componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (position === RenderPosition.After) {
                for (let i = node.children.length - 1; i >= 0; i--) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            else {
                for (let i = 0; i < node.children.length; i++) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            const instance = node.instance;
            if (instance instanceof ContextProvider) {
                visitNodes(node, (n) => {
                    if (n === undefined || n === null) {
                        return false;
                    }
                    const nodeInstance = n.instance;
                    if (nodeInstance !== null && nodeInstance.contextType !== undefined) {
                        const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
                        if (contextSlot >= 0) {
                            if (nodeInstance.context === undefined) {
                                nodeInstance.context = [];
                            }
                            nodeInstance.context[contextSlot].set(instance.props.value);
                        }
                        if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            if (componentInstance !== null && componentInstance.onAfterRender !== undefined) {
                const pluginSystem = (window._pluginSystem);
                componentInstance.onAfterRender(node);
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentRendered(node);
                }
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string'
            || (typeof node.instance === 'object'
                && node.instance !== null &&
                'isSubscribable' in node.instance)) {
            let toRender;
            if (typeof node.instance === 'string') {
                toRender = node.instance;
            }
            else {
                toRender = node.instance.get();
                if (toRender === '') {
                    toRender = ' '; // prevent disappearing text node
                }
            }
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', toRender);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', toRender);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', toRender);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else if (Array.isArray(node)) {
            if (position === RenderPosition.After) {
                for (let i = node.length - 1; i >= 0; i--) {
                    render(node[i], element, position);
                }
            }
            else {
                for (let i = 0; i < node.length; i++) {
                    render(node[i], element, position);
                }
            }
        }
        else {
            render(node, element, position);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext(defaultValue) {
        return new Context(defaultValue);
    }
    FSComponent.createContext = createContext;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     */
    function visitNodes(node, visitor) {
        if (node === undefined || node === null) {
            return;
        }
        const stopVisitation = visitor(node);
        if (!stopVisitation && node.children !== undefined && node.children !== null) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (Array.isArray(child)) {
                    for (let childIndex = 0; childIndex < child.length; childIndex++) {
                        visitNodes(child[childIndex], visitor);
                    }
                }
                else {
                    visitNodes(child, visitor);
                }
            }
        }
        return;
    }
    FSComponent.visitNodes = visitNodes;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @param filter A function which filters parsed classes. For each class, the function should return `true` if the
     * class should be included in the output array and `false` otherwise.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString, filter) {
        return classString.split(' ').filter(str => str !== '' && (filter === undefined || filter(str)));
    }
    FSComponent.parseCssClassesFromString = parseCssClassesFromString;
    // eslint-disable-next-line jsdoc/require-jsdoc
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
        const reservedClassSet = new Set(reservedClasses);
        if (classesToSubscribe.isSubscribableSet === true) {
            return bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet);
        }
        else {
            return bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet);
        }
    }
    FSComponent.bindCssClassSet = bindCssClassSet;
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet) {
        if (reservedClassSet.size === 0) {
            return classesToSubscribe.sub((set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
        else {
            return classesToSubscribe.sub((set, type, key) => {
                if (reservedClassSet.has(key)) {
                    return;
                }
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
    }
    /**
     * Binds a {@link MutableSubscribableSet} to a record of CSS classes. CSS classes toggled in the record will also be
     * added to and removed from the bound set, with the exception of a set of reserved classes. The presence or absence
     * of any of the reserved classes in the bound set is not affected by the subscribed record.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A record of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscriptions to the CSS class record.
     */
    function bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet) {
        const subs = [];
        for (const cssClass in classesToSubscribe) {
            if (reservedClassSet.has(cssClass)) {
                continue;
            }
            const value = classesToSubscribe[cssClass];
            if (typeof value === 'object') {
                subs.push(value.sub(setToBind.toggle.bind(setToBind, cssClass), true));
            }
            else if (value === true) {
                setToBind.add(cssClass);
            }
            else {
                setToBind.delete(cssClass);
            }
        }
        return subs;
    }
    /**
     * Adds CSS classes to a {@link ToggleableClassNameRecord}.
     * @param record The CSS class record to which to add the new classes. The record will be mutated as classes are
     * added.
     * @param classesToAdd The CSS classes to add to the record, as a space-delimited class string, an iterable of
     * individual class names, or a {@link ToggleableClassNameRecord}.
     * @param allowOverwrite Whether to allow the new classes to overwrite existing entries in the CSS class record.
     * Defaults to `true`.
     * @param filter A function which filters the classes to add. For each class, the function should return `true` if
     * the class should be included in the record and `false` otherwise.
     * @returns The mutated CSS class record, after the new classes have been added.
     */
    function addCssClassesToRecord(record, classesToAdd, allowOverwrite = true, filter) {
        if (classesToAdd === '') {
            return record;
        }
        if (typeof classesToAdd === 'string') {
            classesToAdd = FSComponent.parseCssClassesFromString(classesToAdd, filter);
            filter = undefined;
        }
        if (typeof classesToAdd[Symbol.iterator] === 'function') {
            for (const cssClass of classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = true;
                }
            }
        }
        else {
            for (const cssClass in classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = classesToAdd[cssClass];
                }
            }
        }
        return record;
    }
    FSComponent.addCssClassesToRecord = addCssClassesToRecord;
    /**
     * Traverses a VNode tree in depth-first order and destroys the first {@link DisplayComponent} encountered in each
     * branch of the tree.
     * @param root The root of the tree to traverse.
     */
    function shallowDestroy(root) {
        FSComponent.visitNodes(root, node => {
            if (node !== root && node.instance instanceof DisplayComponent) {
                node.instance.destroy();
                return true;
            }
            return false;
        });
    }
    FSComponent.shallowDestroy = shallowDestroy;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));
FSComponent.Fragment;

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
 */
class BingComponent extends DisplayComponent {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(...arguments);
        this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
        this.isListenerRegistered = false;
        this.imgRef = FSComponent.createRef();
        this.uid = 0;
        this._isBound = false;
        this._isAwake = true;
        this.isDestroyed = false;
        this.pos = new LatLong(0, 0);
        this.radius = 10;
        this.resolution = (_a = this.props.resolution) !== null && _a !== void 0 ? _a : Vec2Subject.create(Vec2Math.create(BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION));
        this.earthColors = (_b = this.props.earthColors) !== null && _b !== void 0 ? _b : ArraySubject.create(ArrayUtils.create(2, () => BingComponent.hexaToRGBColor('#000000')));
        this.earthColorsElevationRange = (_c = this.props.earthColorsElevationRange) !== null && _c !== void 0 ? _c : Vec2Subject.create(Vec2Math.create(0, 30000));
        this.skyColor = (_d = this.props.skyColor) !== null && _d !== void 0 ? _d : Subject.create(BingComponent.hexaToRGBColor('#000000'));
        this.reference = (_e = this.props.reference) !== null && _e !== void 0 ? _e : Subject.create(EBingReference.SEA);
        this.wxrMode = (_f = this.props.wxrMode) !== null && _f !== void 0 ? _f : Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 });
        this.wxrColors = (_g = this.props.wxrColors) !== null && _g !== void 0 ? _g : ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
        this.isoLines = (_h = this.props.isoLines) !== null && _h !== void 0 ? _h : Subject.create(false);
        this.wxrColorsArray = [];
        this.wxrRateArray = [];
        this.resolutionHandler = (resolution) => {
            Coherent.call('SET_MAP_RESOLUTION', this.uid, resolution[0], resolution[1]);
            // The sim ignores position/radius updates within a certain number of frames of sending a resolution change, so we
            // will keep trying to send pending updates for a few frames after any resolution change.
            this.positionRadiusInhibitFramesRemaining = BingComponent.POSITION_RADIUS_INHIBIT_FRAMES;
            if (!this.positionRadiusInhibitTimer.isPending()) {
                this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
            }
        };
        this.earthColorsHandler = () => {
            const colors = this.earthColors.getArray();
            if (colors.length < 2) {
                return;
            }
            Coherent.call('SET_MAP_HEIGHT_COLORS', this.uid, colors);
        };
        this.earthColorsElevationRangeHandler = () => {
            const colors = this.earthColors.getArray();
            if (colors.length < 2) {
                return;
            }
            // The way the map assigns colors to elevations is as follows:
            // ----------------------------------------------------------------------------------
            // - altitude range = MIN to MAX
            // - colors = array of length N >= 2 (colors[0] is the water color)
            // - STEP = (MAX - MIN) / N
            // - colors[i] is assigned to elevations from MIN + STEP * i to MIN + STEP * (i + 1)
            // - colors[1] is also assigned to all elevations < MIN + STEP
            // - colors[N - 1] is also assigned to all elevations > MIN + STEP * N
            // ----------------------------------------------------------------------------------
            const range = this.earthColorsElevationRange.get();
            const terrainColorCount = colors.length - 1;
            const desiredElevationStep = (range[1] - range[0]) / Math.max(terrainColorCount - 1, 1);
            const requiredMin = range[0] - desiredElevationStep;
            const requiredMax = range[1] + desiredElevationStep;
            Coherent.call('SET_MAP_ALTITUDE_RANGE', this.uid, requiredMin, requiredMax);
        };
        this.skyColorHandler = (color) => {
            Coherent.call('SET_MAP_CLEAR_COLOR', this.uid, color);
        };
        this.referenceHandler = (reference) => {
            const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
            this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, flags);
        };
        this.wxrModeHandler = (wxrMode) => {
            Coherent.call('SHOW_MAP_WEATHER', this.uid, wxrMode.mode, wxrMode.arcRadians);
        };
        this.wxrColorsHandler = () => {
            const array = this.wxrColors.getArray();
            if (array.length === 0) {
                return;
            }
            this.wxrColorsArray.length = array.length;
            this.wxrRateArray.length = array.length;
            for (let i = 0; i < array.length; i++) {
                this.wxrColorsArray[i] = array[i][0];
                this.wxrRateArray[i] = array[i][1];
            }
            Coherent.call('SET_MAP_WEATHER_RADAR_COLORS', this.uid, this.wxrColorsArray, this.wxrRateArray);
        };
        this.isoLinesHandler = (showIsolines) => {
            Coherent.call('SHOW_MAP_ISOLINES', this.uid, showIsolines);
        };
        this.setCurrentMapParamsTimer = null;
        this.positionRadiusInhibitFramesRemaining = 0;
        this.isPositionRadiusPending = false;
        this.positionRadiusInhibitTimer = new DebounceTimer();
        this.processPendingPositionRadius = () => {
            if (this.isPositionRadiusPending) {
                Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
            }
            if (--this.positionRadiusInhibitFramesRemaining > 0) {
                this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
            }
            else {
                this.isPositionRadiusPending = false;
            }
        };
        /**
         * A callback called when the listener is fully bound.
         * @param binder The binder from the listener.
         * @param uid The unique ID of the bound map.
         */
        this.onListenerBound = (binder, uid) => {
            if (this.isDestroyed) {
                return;
            }
            if (binder.friendlyName === this.props.id) {
                // console.log('Bing map listener bound.');
                this.binder = binder;
                this.uid = uid;
                if (this._isBound) {
                    return;
                }
                this._isBound = true;
                Coherent.call('SHOW_MAP', uid, true);
                const pause = !this._isAwake;
                this.earthColorsSub = this.earthColors.sub(() => {
                    this.earthColorsHandler();
                    this.earthColorsElevationRangeHandler();
                }, true, pause);
                this.earthColorsElevationRangeSub = this.earthColorsElevationRange.sub(this.earthColorsElevationRangeHandler, true, pause);
                this.skyColorSub = this.skyColor.sub(this.skyColorHandler, true, pause);
                this.referenceSub = this.reference.sub(this.referenceHandler, true, pause);
                this.wxrModeSub = this.wxrMode.sub(this.wxrModeHandler, true, pause);
                this.wxrColorsSub = this.wxrColors.sub(this.wxrColorsHandler, true, pause);
                this.resolutionSub = this.resolution.sub(this.resolutionHandler, true, pause);
                this.isoLinesSub = this.isoLines.sub(this.isoLinesHandler, true, pause);
                // Only when not SVT, send in initial map params (even if we are asleep), because a bing instance that doesn't
                // have params initialized causes GPU perf issues.
                if (this.modeFlags !== 4) {
                    Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
                }
                this.props.onBoundCallback && this.props.onBoundCallback(this);
            }
        };
        /**
         * A callback called when the map image is updated.
         * @param uid The unique ID of the bound map.
         * @param imgSrc The img tag src attribute to assign to the bing map image.
         */
        this.onMapUpdate = (uid, imgSrc) => {
            if (this.binder !== undefined && this.uid === uid && this.imgRef.instance !== null) {
                if (this.imgRef.instance.src !== imgSrc) {
                    this.imgRef.instance.src = imgSrc;
                }
            }
        };
        /**
         * Calls the position and radius set function to set map parameters.
         */
        this.setCurrentMapParams = () => {
            this.setPositionRadius(this.pos, this.radius);
        };
    }
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound() {
        return this._isBound;
    }
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake() {
        return this._isAwake;
    }
    /** @inheritdoc */
    onAfterRender() {
        if (window['IsDestroying']) {
            this.destroy();
            return;
        }
        const gameStateSubscribable = GameStateProvider.get();
        const gameState = gameStateSubscribable.get();
        if (gameState === GameState.briefing || gameState === GameState.ingame) {
            this.registerListener();
        }
        else {
            this.gameStateSub = gameStateSubscribable.sub(state => {
                var _a;
                if (this.isDestroyed) {
                    return;
                }
                if (state === GameState.briefing || state === GameState.ingame) {
                    (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.registerListener();
                }
            });
        }
        window.addEventListener('OnDestroy', this.destroy.bind(this));
    }
    /**
     * Registers this component's Bing map listener.
     */
    registerListener() {
        var _a;
        if (((_a = this.props.delay) !== null && _a !== void 0 ? _a : 0) > 0) {
            setTimeout(() => {
                if (this.isDestroyed) {
                    return;
                }
                this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered.bind(this));
            }, this.props.delay);
        }
        else {
            this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered.bind(this));
        }
    }
    /**
     * A callback called when this component's Bing map listener is registered.
     */
    onListenerRegistered() {
        if (this.isDestroyed || this.isListenerRegistered) {
            return;
        }
        this.mapListener.on('MapBinded', this.onListenerBound);
        this.mapListener.on('MapUpdated', this.onMapUpdate);
        this.isListenerRegistered = true;
        this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, this.modeFlags);
    }
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this._isAwake = true;
        if (!this._isBound) {
            return;
        }
        this.setCurrentMapParams();
        // Only when not SVT, periodically send map params to Coherent in case another BingComponent binds to the same
        // bing instance and sends in the initial params set and overrides our params.
        if (this.modeFlags !== 4) {
            this.setCurrentMapParamsTimer = setInterval(this.setCurrentMapParams, 200);
        }
        (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.resume(true);
        (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.resume(true);
        (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.resume(true);
        (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.resume(true);
    }
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this._isAwake = false;
        if (!this._isBound) {
            return;
        }
        if (this.setCurrentMapParamsTimer !== null) {
            clearInterval(this.setCurrentMapParamsTimer);
        }
        (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.pause();
        (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.pause();
        (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.pause();
        (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.pause();
    }
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos, radius) {
        this.pos = pos;
        this.radius = Math.max(radius, 10); // Not sure if bad things happen when radius is 0, so we just clamp it to 10 meters.
        if (this._isBound && this._isAwake) {
            if (this.positionRadiusInhibitFramesRemaining > 0) {
                this.isPositionRadiusPending = true;
            }
            else {
                Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
            }
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.imgRef, src: '', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;', class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        this.isDestroyed = true;
        this._isBound = false;
        if (this.setCurrentMapParamsTimer !== null) {
            clearInterval(this.setCurrentMapParamsTimer);
        }
        (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.earthColorsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.earthColorsElevationRangeSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.skyColorSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.referenceSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.wxrModeSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.wxrColorsSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.resolutionSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.isoLinesSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.mapListener) === null || _k === void 0 ? void 0 : _k.off('MapBinded', this.onListenerBound);
        (_l = this.mapListener) === null || _l === void 0 ? void 0 : _l.off('MapUpdated', this.onMapUpdate);
        (_m = this.mapListener) === null || _m === void 0 ? void 0 : _m.trigger('JS_UNBIND_BINGMAP', this.props.id);
        this.isListenerRegistered = false;
        this.imgRef.instance.src = '';
        (_o = this.imgRef.instance.parentNode) === null || _o === void 0 ? void 0 : _o.removeChild(this.imgRef.instance);
        super.destroy();
    }
    /**
     * Resets the img element's src attribute.
     */
    resetImgSrc() {
        const imgRef = this.imgRef.getOrDefault();
        if (imgRef !== null) {
            const currentSrc = imgRef.src;
            imgRef.src = '';
            imgRef.src = currentSrc;
        }
    }
    /**
     * Converts an HTML hex color string to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGB value equivalent of the specified hex color string, as `R + G * 256 + B * 256^2`.
     */
    static hexaToRGBColor(hexColor) {
        const hexStringColor = hexColor;
        let offset = 0;
        if (hexStringColor[0] === '#') {
            offset = 1;
        }
        const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
        const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
        const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
        return BingComponent.rgbColor(r, g, b);
    }
    /**
     * Converts a numerical RGB value to an HTML hex color string.
     * @param rgb The numerical RGB value to convert, as `R + G * 256 + B * 256^2`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGB value.
     */
    static rgbToHexaColor(rgb, poundPrefix = true) {
        const b = Math.floor((rgb % (256 * 256 * 256)) / (256 * 256));
        const g = Math.floor((rgb % (256 * 256)) / 256);
        const r = rgb % 256;
        return `${poundPrefix ? '#' : ''}${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
    /**
     * Converts RGB color components to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns The numerical RGB value of the specified components, as `R + G * 256 + B * 256^2`.
     */
    static rgbColor(r, g, b) {
        return 256 * 256 * b + 256 * g + r;
    }
    /**
     * Converts an HTML hex color string to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGBA value equivalent of the specified hex color string, as
     * `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static hexaToRGBAColor(hexColor) {
        const hexStringColor = hexColor;
        let offset = 0;
        if (hexStringColor[0] === '#') {
            offset = 1;
        }
        const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
        const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
        const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
        const a = parseInt(hexStringColor.substr(6 + offset, 2), 16);
        return BingComponent.rgbaColor(r, g, b, a);
    }
    /**
     * Converts a numerical RGBA value to an HTML hex color string.
     * @param rgba The numerical RGBA value to convert, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGBA value.
     */
    static rgbaToHexaColor(rgba, poundPrefix = true) {
        const a = Math.floor((rgba % (256 * 256 * 256 * 256)) / (256 * 256 * 256));
        const b = Math.floor((rgba % (256 * 256 * 256)) / (256 * 256));
        const g = Math.floor((rgba % (256 * 256)) / 256);
        const r = rgba % 256;
        return `${poundPrefix ? '#' : ''}${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}${a.toString(16).padStart(2, '0')}`;
    }
    /**
     * Converts RGBA color components to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @param a The alpha component, from 0 to 255.
     * @returns The numerical RGBA value of the specified components, as `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static rgbaColor(r, g, b, a) {
        return 256 * 256 * 256 * a + 256 * 256 * b + 256 * g + r;
    }
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @param minElevation The minimum elevation to which to assign a color, in feet. Defaults to 0.
     * @param maxElevation The maximum elevation to which to assign a color, in feet. Defaults to 30000.
     * @param stepCount The number of terrain color steps. Defaults to 61.
     * @returns a full Bing component earth colors array.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createEarthColorsArray(waterColor, terrainColors, minElevation = 0, maxElevation = 30000, stepCount = 61) {
        const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
        const curve = new Avionics.Curve();
        curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
        for (let i = 0; i < terrainColors.length; i++) {
            curve.add(terrainColors[i].elev, terrainColors[i].color);
        }
        const elevationStep = (maxElevation - minElevation) / Math.max(stepCount - 1, 1);
        for (let i = 0; i < stepCount; i++) {
            const color = curve.evaluate(minElevation + i * elevationStep);
            earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
        }
        return earthColors;
    }
}
/** The default resolution of the Bing Map along both horizontal and vertical axes, in pixels. */
BingComponent.DEFAULT_RESOLUTION = 1024;
BingComponent.DEFAULT_WEATHER_COLORS = [
    [BingComponent.hexaToRGBAColor('#00000000'), 0.5],
    [BingComponent.hexaToRGBAColor('#004d00ff'), 2.75],
    [BingComponent.hexaToRGBAColor('#cb7300ff'), 12.5],
    [BingComponent.hexaToRGBAColor('#ff0000ff'), 12.5]
];
BingComponent.POSITION_RADIUS_INHIBIT_FRAMES = 10;

/**
 * The item position to focus a component's children when performing a focus operation.
 */
var FocusPosition;
(function (FocusPosition) {
    /** The component's most recently focused descendants will be focused. */
    FocusPosition["MostRecent"] = "MostRecent";
    /** The first focus-able child at each node in the descendant tree will be focused. */
    FocusPosition["First"] = "First";
    /** The last focus-able child at each node in the descendant tree will be focused. */
    FocusPosition["Last"] = "Last";
    /** No child components will be focused. */
    FocusPosition["None"] = "None";
})(FocusPosition || (FocusPosition = {}));
/**
 * A strategy to focus a component's children as part of a blur reconciliation operation.
 */
var BlurReconciliation;
(function (BlurReconciliation) {
    /** The component's first focus-able child will be focused. */
    BlurReconciliation["First"] = "First";
    /** The component's last focus-able child will be focused. */
    BlurReconciliation["Last"] = "Last";
    /**
     * The component's next focus-able child after the child that was blurred will be focused. If no such child exists,
     * then the last focus-able child before the child that was blurred will be focused.
     */
    BlurReconciliation["Next"] = "Next";
    /**
     * The component's last focus-able child before the child that was blurred will be focused. If no such child exists,
     * then the next focus-able child after the child that was blurred will be focused.
     */
    BlurReconciliation["Prev"] = "Prev";
    /** No child components will be focused. */
    BlurReconciliation["None"] = "None";
})(BlurReconciliation || (BlurReconciliation = {}));
/**
 * An abstract implementation of a component that forms the base of a Garmin-like UI control system. Subclasses should
 * implement an appropriate event handler interface (using the utility type `UiControlEventHandlers<Events>`) and have
 * their props implement the corresponding prop event handler interface (using the utility type
 * `UiControlPropEventHandlers<Events>`).
 * @template E An event definition type for events supported by this control.
 * @template P The component prop type for this control.
 */
class HardwareUiControl extends DisplayComponent {
    /**
     * Creates an instance of a HardwareUiControl.
     * @param props The props for this component.
     */
    constructor(props) {
        super(props);
        this.focusedIndex = -1;
        this._isDisabled = false;
        this._isFocused = false;
        this._isIsolated = false;
        this._UICONTROL_ = true;
        this._isIsolated = this.props.isolateScroll !== undefined && this.props.isolateScroll;
    }
    /**
     * Gets the current number of registered child controls.
     * @returns The current number of registered child controls.
     */
    get length() {
        if (this.registeredControls !== undefined) {
            return this.registeredControls.length;
        }
        return 0;
    }
    /**
     * Gets whether or not the control is currently disabled.
     * @returns True if disabled, false otherwise.
     */
    get isDisabled() {
        return this._isDisabled;
    }
    /**
     * Gets whether or not the control is currently focused.
     * @returns True if disabled, false otherwise.
     */
    get isFocused() {
        return this._isFocused;
    }
    /**
     * Gets whether or not the control is currently in scroll isolation.
     * @returns True if currently in scroll isolation, false otherwise.
     */
    get isIsolated() {
        return this._isIsolated;
    }
    /**
     * An event called when the control receives focus.
     * @param source The control that emitted this event.
     */
    onFocused(source) {
        this.props.onFocused && this.props.onFocused(source);
    }
    /**
     * An event called when the control is blurred.
     * @param source The control that emitted this event.
     */
    onBlurred(source) {
        this.props.onBlurred && this.props.onBlurred(source);
    }
    /**
     * An event called when the control is enabled.
     * @param source The control that emitted this event.
     */
    onEnabled(source) {
        this.props.onEnabled && this.props.onEnabled(source);
    }
    /**
     * An event called when the control is disabled.
     * @param source The control that emitted this event.
     */
    onDisabled(source) {
        this.props.onDisabled && this.props.onDisabled(source);
    }
    /**
     * An event called when a control is registered with this control.
     * @param source The control that emitted this event.
     */
    onRegistered(source) {
        this.props.onRegistered && this.props.onRegistered(source);
    }
    /**
     * An event called when a control is unregistered from this control.
     * @param source The control that emitted this event.
     */
    onUnregistered(source) {
        this.props.onUnregistered && this.props.onUnregistered(source);
    }
    /**
     * Gets the focus position to apply when this control is focused from a scroll.
     * @param direction The direction of the scroll.
     * @returns The focus position to apply when this control is focused from a scroll.
     */
    getFocusPositionOnScroll(direction) {
        if (this.props.getFocusPositionOnScroll) {
            return this.props.getFocusPositionOnScroll(direction);
        }
        return direction === 'forward' ? FocusPosition.First : FocusPosition.Last;
    }
    /**
     * An event called when the control is scrolled.
     * @param direction The direction that is being requested to scroll.
     * @returns True if this control handled this event, false otherwise.
     */
    onScroll(direction) {
        if (this.registeredControls !== undefined && this.registeredControls.length > 0) {
            const delta = direction === 'forward' ? 1 : -1;
            for (let i = this.focusedIndex + delta; direction === 'forward' ? i < this.registeredControls.length : i >= 0; i += delta) {
                const controlToFocus = this.registeredControls[i];
                if (controlToFocus.focus(controlToFocus.getFocusPositionOnScroll(direction))) {
                    this.onAfterScroll(controlToFocus, i);
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * An event called when a scroll operation has completed.
     * @param control The control that was scrolled to.
     * @param index The index of the control in the collection of registered controls.
     */
    onAfterScroll(control, index) {
        this.props.onAfterScroll && this.props.onAfterScroll(control, index);
    }
    /**
     * Scrolls the currently focused control in the supplied direction.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    scroll(direction) {
        if (!this.isFocused) {
            return false;
        }
        const controlToScroll = this.getFocusedComponentPath()[0];
        if (controlToScroll !== undefined) {
            return controlToScroll.tryPerformScroll(direction);
        }
        else {
            return this.tryPerformScroll(direction);
        }
    }
    /**
     * Attempts to perform a scroll operation on the control, propagating the operation
     * upward in the tree if the control does not handle the operation.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    tryPerformScroll(direction) {
        let handled = false;
        if (this.props.onScroll !== undefined) {
            handled = this.props.onScroll(direction);
        }
        else {
            handled = this.onScroll(direction);
        }
        if (!handled) {
            const currentlyIsolated = this.isFocused && this.isIsolated;
            if (this.parent !== undefined && !currentlyIsolated) {
                return this.parent.tryPerformScroll(direction);
            }
            else if (currentlyIsolated) {
                return true;
            }
        }
        return handled;
    }
    /**
     * Triggers an event on this control. The event will first be routed to the deepest focused descendent of this
     * control and will propagate up the control tree until it is handled or there are no more controls to which to
     * propagate.
     * @param event The event to trigger.
     * @param source The source of the event. Defaults to this if not supplied.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    triggerEvent(event, source, ...args) {
        const canListen = this.isFocused || this.parent === undefined;
        if (!canListen) {
            return false;
        }
        const focusedControl = this.getFocusedComponentPath()[0];
        if (focusedControl !== undefined) {
            return focusedControl.propagateEvent(event, focusedControl, args);
        }
        return false;
    }
    /**
     * Propagates an event up the control tree.
     * @param event The event to propagate.
     * @param source The source of the event.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    propagateEvent(event, source, args) {
        const handler = this[`on${event}`];
        const propHandler = this.props[`on${event}`];
        // Class-defined handlers get priority over prop-defined handlers
        // Prop-defined handlers are not called if a class-defined handler exists -> this is to allow subclasses to
        // restrict which events get sent to prop-defined handlers if they choose.
        const stopPropagation = (!!handler && handler.call(this, source, ...args)) || (!!propHandler && propHandler(source, ...args));
        if (!stopPropagation && this.parent !== undefined) {
            return this.parent.propagateEvent(event, this.parent, args);
        }
        return stopPropagation;
    }
    /**
     * Validates that the control can be focused by checking if any ancestors in the
     * control tree are disabled.
     * @returns True if there are no disabled ancestors, false otherwise.
     */
    canBeFocused() {
        let canFocus = true;
        if (!this._isDisabled) {
            if (this.parent !== undefined) {
                canFocus = this.parent.canBeFocused();
            }
        }
        else {
            canFocus = false;
        }
        return canFocus;
    }
    /**
     * Brings focus to the control. Focusing the control will also blur the currently
     * focused control, if any.
     * @param focusPosition The focus position to activate for descendents of this control.
     * @returns Whether this control was successfully focused.
     */
    focus(focusPosition) {
        if (!this.canBeFocused()) {
            return false;
        }
        const focusStack = this.buildFocusPath(focusPosition);
        if (focusStack.length === 0) {
            return false;
        }
        // Top of the stack is always 'this', and will be repeated by getFocusRootPath() if we don't remove it
        focusStack.pop();
        this.getDeepestFocusedAncestorPath(focusStack);
        const focusRoot = focusStack[focusStack.length - 1];
        const blurStack = focusRoot.getFocusedComponentPath();
        if (blurStack.length > 0) {
            // Top of the blur stack is the deepest common ancestor of the old focused leaf and this control.
            // This ancestor will be focused after this operation, so we need to remove it from the blur stack.
            blurStack.pop();
            for (let i = 0; i < blurStack.length; i++) {
                blurStack[i]._isFocused = false;
            }
        }
        // Top of the focus stack is the deepest common ancestor of the old focused leaf and this control, OR the root of
        // the control tree if nothing in the tree is focused -> either way, the control will be focused after this
        // operation, so if the control is already focused, we need to remove it from the focus stack.
        if (focusRoot.isFocused) {
            focusStack.pop();
        }
        for (let i = 0; i < focusStack.length; i++) {
            const control = focusStack[i];
            const parent = control.parent;
            control._isFocused = true;
            if (parent !== undefined && parent.registeredControls !== undefined) {
                parent.focusedIndex = parent.registeredControls.indexOf(control);
            }
        }
        while (blurStack.length > 0) {
            const control = blurStack.pop();
            if (control !== undefined) {
                control.onBlurred(control);
            }
        }
        while (focusStack.length > 0) {
            const control = focusStack.pop();
            if (control !== undefined) {
                control.onFocused(control);
            }
        }
        return true;
    }
    /**
     * Gets the path from this control to the deepest descendent control that is focused. If this control is not focused,
     * then the path is empty.
     * @param path The stack of control nodes defining the path to the currently
     * focused descendent control.
     * @returns A stack of nodes that defines the path to the deepest focused descendent
     * node, in order of deepest descendent first.
     */
    getFocusedComponentPath(path) {
        if (path === undefined) {
            path = [];
        }
        if (!this._isFocused) {
            return path;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let currentControl = this;
        while (currentControl !== undefined) {
            path.splice(0, 0, currentControl);
            if (currentControl.registeredControls !== undefined) {
                currentControl = currentControl.registeredControls.find(c => c.isFocused);
            }
            else {
                currentControl = undefined;
            }
        }
        return path;
    }
    /**
     * Gets the path from this control to its deepest ancestor that is focused (including itself). If none of this
     * control's ancestors are focused, the path will contain this control and all of its ancestors up to and including
     * the root of its control tree.
     * @param path An array in which to store the path.
     * @returns A stack of controls that defines the path from this control to its deepest focused ancestor, ordered
     * from descendents to ancestors (the control at the shallowest tree depth is located at the top of the stack).
     */
    getDeepestFocusedAncestorPath(path) {
        if (path === undefined) {
            path = [];
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let currentControl = this;
        while (currentControl !== undefined) {
            path.push(currentControl);
            if (currentControl !== this && currentControl.isFocused) {
                break;
            }
            currentControl = currentControl.parent;
        }
        return path;
    }
    /**
     * Builds the path of controls to focus from this control downward in children based on the provided default focus
     * position. If this control cannot be focused, the path will be empty.
     * @param focusPosition The focus position to use to build the path.
     * @param focusStack The stack in which to store the path.
     * @returns A stack of components that defines the path from the deepest descendent to focus to this control if this
     * control were to be focused with the specified focus position, ordered from descendents to ancestors (the control
     * at the shallowest tree depth is located at the top of the stack).
     */
    buildFocusPath(focusPosition, focusStack) {
        var _a;
        if (focusStack === undefined) {
            focusStack = [];
        }
        if (this._isDisabled) {
            return focusStack;
        }
        //focusStack.splice(0, 0, currentControl);
        const originalStackDepth = focusStack.length;
        const childControls = this.registeredControls;
        if (childControls !== undefined) {
            switch (focusPosition) {
                case FocusPosition.MostRecent:
                    // Attempt to focus the most recent focused child. If this fails, fall back to FocusPosition.First.
                    (_a = childControls[this.focusedIndex]) === null || _a === void 0 ? void 0 : _a.buildFocusPath(FocusPosition.MostRecent, focusStack);
                    if (focusStack.length > originalStackDepth) {
                        break;
                    }
                // eslint-disable-next-line no-fallthrough
                case FocusPosition.First:
                    for (let i = 0; i < childControls.length; i++) {
                        childControls[i].buildFocusPath(FocusPosition.First, focusStack);
                        if (focusStack.length > originalStackDepth) {
                            break;
                        }
                    }
                    break;
                case FocusPosition.Last:
                    for (let i = childControls.length - 1; i >= 0; i--) {
                        childControls[i].buildFocusPath(FocusPosition.Last, focusStack);
                        if (focusStack.length > originalStackDepth) {
                            break;
                        }
                    }
                    break;
            }
        }
        // If this control requires child focus, make sure a child was able to be focused before adding this control to the stack.
        if (!this.props.requireChildFocus || focusStack.length > originalStackDepth) {
            focusStack.push(this);
        }
        return focusStack;
    }
    /**
     * Blurs, or removes focus, from the component.
     */
    blur() {
        var _a, _b;
        if (!this._isFocused) {
            return;
        }
        let indexInParent = -1;
        if (this.parent) {
            indexInParent = (_b = (_a = this.parent.registeredControls) === null || _a === void 0 ? void 0 : _a.indexOf(this)) !== null && _b !== void 0 ? _b : -1;
        }
        const blurStack = this.getFocusedComponentPath();
        for (let i = 0; i < blurStack.length; i++) {
            blurStack[i]._isFocused = false;
        }
        while (blurStack.length > 0) {
            const control = blurStack.pop();
            if (control !== undefined) {
                control.onBlurred(control);
            }
        }
        if (this.parent && indexInParent >= 0) {
            this.parent.handleNoFocusedChild(indexInParent, this);
        }
    }
    /**
     * Handles the case where this control is left focused with no focused child control after a child control is
     * blurred.
     * @param indexBlurred The index of the child control that was blurred. If the child is no longer registered, then
     * this is the index of the child prior to being unregistered.
     * @param childBlurred The child control that was blurred.
     */
    handleNoFocusedChild(indexBlurred, childBlurred) {
        var _a;
        if (!this._isFocused || this.getFocusedIndex() >= 0) {
            return;
        }
        const reconciliation = this.reconcileChildBlur(indexBlurred, childBlurred);
        if (this.registeredControls) {
            if (typeof reconciliation === 'number') {
                const controlToFocus = (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[reconciliation];
                controlToFocus === null || controlToFocus === void 0 ? void 0 : controlToFocus.focus(FocusPosition.First);
            }
            else {
                switch (reconciliation) {
                    case BlurReconciliation.First:
                        this.focus(FocusPosition.First);
                        break;
                    case BlurReconciliation.Last:
                        this.focus(FocusPosition.Last);
                        break;
                    case BlurReconciliation.Next:
                        for (let i = Math.max(indexBlurred + (this.registeredControls[indexBlurred] === childBlurred ? 1 : 0), 0); i < this.registeredControls.length; i++) {
                            if (this.registeredControls[i].focus(FocusPosition.First)) {
                                break;
                            }
                        }
                        for (let i = Math.min(indexBlurred - 1, this.registeredControls.length - 1); i >= 0; i--) {
                            if (this.registeredControls[i].focus(FocusPosition.First)) {
                                break;
                            }
                        }
                        break;
                    case BlurReconciliation.Prev:
                        for (let i = Math.min(indexBlurred - 1, this.registeredControls.length - 1); i >= 0; i--) {
                            if (this.registeredControls[i].focus(FocusPosition.Last)) {
                                break;
                            }
                        }
                        for (let i = Math.max(indexBlurred + (this.registeredControls[indexBlurred] === childBlurred ? 1 : 0), 0); i < this.registeredControls.length; i++) {
                            if (this.registeredControls[i].focus(FocusPosition.Last)) {
                                break;
                            }
                        }
                        break;
                }
            }
        }
        if (this.props.requireChildFocus && this.getFocusedIndex() < 0) {
            this.blur();
        }
    }
    /**
     * Reconciles the focus state of this control's children when this control is focused with no focused children after
     * a child has been blurred.
     * @param index The index of the child control that was blurred. If the child is no longer registered, then this is
     * the index of the child prior to being unregistered.
     * @param child The child control that was blurred.
     * @returns The index of the child control to focus.
     */
    reconcileChildBlur(index, child) {
        var _a;
        if (this.props.reconcileChildBlur) {
            return this.props.reconcileChildBlur(index, child);
        }
        if (((_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[index]) !== child) {
            return BlurReconciliation.Next;
        }
        else {
            return -1;
        }
    }
    /**
     * Sets the component to be disabled, removing the ability for the component to scroll. Setting
     * a component to disabled will also blur the component and its children, if necessary.
     * @param isDisabled Whether or not the component is disabled.
     */
    setDisabled(isDisabled) {
        this._isDisabled = isDisabled;
        if (isDisabled) {
            this.blur();
            this.onDisabled(this);
        }
        else {
            this.onEnabled(this);
        }
    }
    /**
     * Registers a child control with this control.
     * @param control The control to register.
     * @param index The index at which to register the control. If none is provided,
     * the control will be registered at the end of the collection of child controls.
     */
    register(control, index) {
        if (this.registeredControls === undefined) {
            this.registeredControls = [];
        }
        if (index !== undefined) {
            this.registeredControls.splice(index, 0, control);
            if (this.focusedIndex >= index) {
                this.focusedIndex++;
            }
        }
        else {
            this.registeredControls.push(control);
        }
        control.setParent(this);
        control.onRegistered(control);
    }
    /**
     * Unregisters a child control with this control.
     * @param item The child control or index of a child control to unregister. If a
     * child control is provided, it will attempt to be located in the control's
     * child registry and then removed. If an index is provided, the child control
     * at that registered index will be removed.
     */
    unregister(item) {
        if (this.registeredControls !== undefined) {
            let index = -1;
            if (typeof item === 'number') {
                index = item;
            }
            else {
                index = this.registeredControls.indexOf(item);
            }
            if (index >= 0 && index < this.length) {
                const controlToRemove = this.registeredControls[index];
                const isRemovedControlFocused = controlToRemove._isFocused;
                this.registeredControls.splice(index, 1);
                controlToRemove.parent = undefined;
                if (isRemovedControlFocused) {
                    controlToRemove.blur();
                    this.handleNoFocusedChild(index, controlToRemove);
                }
                else {
                    if (this.focusedIndex === index) {
                        this.focusedIndex = -1;
                    }
                    else if (this.focusedIndex > index) {
                        this.focusedIndex--;
                    }
                }
                this.focusedIndex = Math.min(this.focusedIndex, this.registeredControls.length - 1);
                if (controlToRemove.length > 0) {
                    controlToRemove.clearRegistered();
                }
                controlToRemove.onUnregistered(controlToRemove);
                if (this.length === 0) {
                    this.registeredControls = undefined;
                }
            }
        }
    }
    /**
     * Clears the list of registered components.
     */
    clearRegistered() {
        if (this.registeredControls !== undefined) {
            const registeredControls = this.registeredControls;
            this.registeredControls = undefined;
            this.focusedIndex = -1;
            for (let i = 0; i < registeredControls.length; i++) {
                const controlToRemove = registeredControls[i];
                controlToRemove.parent = undefined;
                if (controlToRemove._isFocused) {
                    controlToRemove.blur();
                }
                if (controlToRemove.length > 0) {
                    controlToRemove.clearRegistered();
                }
                registeredControls[i].onUnregistered(registeredControls[i]);
            }
            // Only call this once for the last child removed to prevent multiple sequential, redundant reconciliations.
            this.handleNoFocusedChild(0, registeredControls[registeredControls.length - 1]);
        }
    }
    /**
     * Gets the current focused index in the registered controls collection.
     * @returns The index of the focused control in the collection of registered controls.
     */
    getFocusedIndex() {
        var _a, _b;
        return ((_b = (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[this.focusedIndex]) === null || _b === void 0 ? void 0 : _b._isFocused) ? this.focusedIndex : -1;
    }
    /**
     * Gets the most recent focused index (including the current focused index, if one exists) in the registered controls
     * collection.
     * @returns The index of the most recently focused control in the collection of registered controls.
     */
    getMostRecentFocusedIndex() {
        return this.focusedIndex;
    }
    /**
     * Sets the current most recently focused child control index. If this control is focused and has children
     * that have focus, this will also switch child focus to the new index.
     * @param index The index of the child control to set most recent focus for.
     * @param focusPosition The focus position to focus the child for, if required.
     */
    setFocusedIndex(index, focusPosition = FocusPosition.MostRecent) {
        var _a;
        if (this.isFocused && this.length > 0 && ((_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.findIndex(c => c.isFocused)) !== -1) {
            const child = this.getChild(index);
            if (child !== undefined) {
                child.focus(focusPosition);
            }
        }
        else if (this.length > 0 && index >= 0 && index < this.length) {
            this.focusedIndex = index;
        }
    }
    /**
     * Gets a child control at the specified index.
     * @param index The index of the child control to get.
     * @returns The specified child control.
     */
    getChild(index) {
        if (this.registeredControls !== undefined) {
            return this.registeredControls[index];
        }
        return undefined;
    }
    /**
     * Gets the index of a specified child control within the registered
     * child controls collection.
     * @param child The child to get the index of.
     * @returns The index of the child, or -1 if not found.
     */
    indexOf(child) {
        if (this.registeredControls !== undefined) {
            return this.registeredControls.indexOf(child);
        }
        return -1;
    }
    /**
     * Sets the parent of this control.
     * @param parent The parent to set.
     */
    setParent(parent) {
        this.parent = parent;
    }
    /**
     * Sets whether or not this control is in scroll isolation. While scroll isolation
     * is enabled, scroll events will not propagate to the control's parent when the
     * control has focus.
     * @param isolated Whether or not the control is isolated.
     */
    setIsolated(isolated) {
        this._isIsolated = isolated;
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        FSComponent.visitNodes(thisNode, (node) => {
            const instance = node.instance;
            if (instance !== this && (instance === null || instance === void 0 ? void 0 : instance._UICONTROL_)) {
                this.register(node.instance);
                return true;
            }
            return false;
        });
    }
    /**
     * Renders the control.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null, this.props.children));
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.props.onDestroyed && this.props.onDestroyed(this);
    }
}

/** Scroll utils */
class ScrollUtils {
    /**
     * Scrolls the container to make sure an element is in view.
     * @param el The element to scroll into view in the container.
     * @param container The container to scroll.
     * @param pinDirection The end of the container which the element should be pinned to.
     */
    static ensureInView(el, container, pinDirection = 'none') {
        const cHeight = container.offsetHeight;
        const eHeight = el.offsetHeight;
        if (eHeight > cHeight) {
            return;
        }
        const cTop = container.scrollTop;
        const cBottom = cTop + cHeight;
        try {
            const eTop = ScrollUtils.findOffsetTopRelativeToAncestor(el, container);
            const eBottom = eTop + eHeight;
            if (!this.isElementInViewport(cTop, cBottom, eTop, eBottom) || pinDirection !== 'none') {
                if ((eTop < cTop) || pinDirection === 'top') {
                    container.scrollTop -= (cTop - eTop);
                }
                else if ((eBottom > cBottom) || pinDirection === 'bottom') {
                    container.scrollTop += (eBottom - cBottom);
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Finds the offsetTop of an element relative to one of its ancestors.
     * @param element An element.
     * @param ancestor An ancestor of `element`.
     * @returns the offsetTop of the element relative to the ancestor.
     * @throws Error if the offsetTop could not be calculated.
     */
    static findOffsetTopRelativeToAncestor(element, ancestor) {
        const ancestorParent = ancestor.offsetParent;
        let top = element.offsetTop;
        while (element.offsetParent !== ancestorParent) {
            if (!(element.offsetParent instanceof HTMLElement)) {
                throw new Error('Element\'s offset ancestry does not directly lead to the specified ancestor');
            }
            element = element.offsetParent;
            top += element.offsetTop;
        }
        return top - ancestor.offsetTop;
    }
    /**
     * Checks if an element is visible.
     * @param cTop The top coordinate of the scroll container.
     * @param cBottom The bottom coordinate of the scroll container.
     * @param eTop The top coordinate of the element.
     * @param eBottom The bottom coordinate of the element.
     * @returns A boolean.
     */
    static isElementInViewport(cTop, cBottom, eTop, eBottom) {
        return eTop >= cTop && eBottom <= cBottom;
    }
}

/**
 * A component that displays a collection of UiControls in a list format.
 */
class HardwareUiControlList extends HardwareUiControl {
    /**
     * Creates an instance of a ControlList.
     * @param props The props on the ControlList component.
     */
    constructor(props) {
        super(props);
        this.el = FSComponent.createRef();
        this.itemsContainer = FSComponent.createRef();
        /**
         * Sorts the registered controls by the provided ordering comparison function.
         * @param a The first control to compare.
         * @param b The second control to compare.
         * @returns Negative if the first control is less than, zero if equal, positive if greater than.
         */
        this.sortControls = (a, b) => {
            if (this.controlToDataMap !== undefined && this.props.orderBy !== undefined) {
                const aData = this.controlToDataMap.get(a);
                const bData = this.controlToDataMap.get(b);
                if (aData !== undefined && bData !== undefined) {
                    return this.props.orderBy(aData, bData);
                }
            }
            return 0;
        };
        if (props.orderBy !== undefined) {
            this.dataToControlMap = new Map();
            this.controlToElementMap = new Map();
            this.controlToDataMap = new Map();
            this.currentControlOrder = [];
        }
    }
    /** @inheritdoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.itemSize !== undefined && this.props.numItems !== undefined) {
            const listSizePx = (this.props.itemSize * this.props.numItems).toFixed(4);
            this.el.instance.style.height = listSizePx;
            this.itemsContainer.instance.style.height = listSizePx;
        }
        this.renderList();
        this.props.data.sub(this.onDataChanged.bind(this));
    }
    /**
     * A callback fired when the array subject data changes.
     * @param index The index of the change.
     * @param type The type of change.
     * @param data The item that was changed.
     */
    onDataChanged(index, type, data) {
        switch (type) {
            case SubscribableArrayEventType.Added:
                this.onDataAdded(index, data);
                break;
            case SubscribableArrayEventType.Removed:
                this.onDataRemoved(index, data);
                break;
            case SubscribableArrayEventType.Cleared:
                this.onDataCleared();
                break;
        }
    }
    /**
     * An event called when data is added to the subscription.
     * @param index The index that the data was added at.
     * @param data The data that was added.
     */
    onDataAdded(index, data) {
        if (data !== undefined) {
            const currentItemElement = this.itemsContainer.instance.children.item(index);
            if (Array.isArray(data)) {
                for (let i = 0; i < data.length; i++) {
                    const dataItem = data[i];
                    const indexToAdd = index + i;
                    this.addDataItem(dataItem, indexToAdd, currentItemElement);
                }
            }
            else {
                this.addDataItem(data, index, currentItemElement);
            }
        }
        this.updateOrder();
    }
    /**
     * Adds a data item to the control list and performs the required rendering and
     * ordering operations.
     * @param dataItem The data item to add to the list.
     * @param indexToAdd The index to add the item at.
     * @param currentItemElement The current DOM element that resides at the location to add to.
     */
    addDataItem(dataItem, indexToAdd, currentItemElement) {
        const controlNode = this.props.renderItem(dataItem, indexToAdd);
        const control = controlNode.instance;
        //Nefariously monkey-patch the onFocused handler to get notified when the item is focused,
        //regardless of the underlying implementation or overrides
        const originalOnFocused = control.onFocused.bind(control);
        control.onFocused = (source) => {
            this.onItemFocused();
            originalOnFocused && originalOnFocused(source);
        };
        const element = this.renderToDom(controlNode, indexToAdd, currentItemElement);
        this.register(controlNode.instance, indexToAdd >= 0 ? indexToAdd : undefined);
        if (element !== null && controlNode.instance !== null) {
            this.addToOrderTracking(controlNode.instance, dataItem, element);
        }
    }
    /**
     * An event called when data is removed from the subscription.
     * @param index The index that the data was removed at.
     * @param data The data that was removed;
     */
    onDataRemoved(index, data) {
        if (index >= 0 && index < this.length) {
            if (Array.isArray(data)) {
                for (let i = 0; i < data.length; i++) {
                    const dataItem = data[i];
                    this.removeDataItem(dataItem, index);
                }
            }
            else if (data !== undefined) {
                this.removeDataItem(data, index);
            }
            this.updateOrder();
        }
    }
    /**
     * Removes a data item from the control list.
     * @param data The data item to remove.
     * @param index The index of the data that was removed.
     */
    removeDataItem(data, index) {
        if (this.dataToControlMap !== undefined && this.registeredControls !== undefined) {
            const control = this.dataToControlMap.get(data);
            if (control !== undefined) {
                index = this.registeredControls.indexOf(control);
            }
        }
        let control;
        if (this.registeredControls !== undefined) {
            control = this.registeredControls[index];
        }
        this.unregister(index);
        this.removeDomNode(index);
        this.removeFromOrderTracking(data);
        control === null || control === void 0 ? void 0 : control.destroy();
    }
    /**
     * An event called when the data is cleared in the subscription.
     */
    onDataCleared() {
        let controls;
        if (this.registeredControls !== undefined) {
            controls = [...this.registeredControls];
        }
        this.clearRegistered();
        this.itemsContainer.instance.innerHTML = '';
        this.clearOrderTracking();
        if (controls !== undefined) {
            for (let i = 0; i < controls.length; i++) {
                controls[i].destroy();
            }
        }
        if (this.props.onItemSelected) {
            this.props.onItemSelected(null, null, -1);
        }
    }
    /**
     * Adds a data item to element order tracking information.
     * @param control The index to add the data item at.
     * @param data The data to add tracking information for.
     * @param element The DOM element to associate with this data item.
     */
    addToOrderTracking(control, data, element) {
        if (this.controlToElementMap !== undefined && this.dataToControlMap !== undefined && this.controlToDataMap !== undefined) {
            this.dataToControlMap.set(data, control);
            this.controlToElementMap.set(control, element);
            this.controlToDataMap.set(control, data);
        }
    }
    /**
     * Removes a data item from element order tracking information.
     * @param data The data item to remove order tracking information for.
     */
    removeFromOrderTracking(data) {
        if (this.controlToElementMap !== undefined && this.dataToControlMap !== undefined && this.controlToDataMap !== undefined) {
            const control = this.dataToControlMap.get(data);
            if (control !== undefined) {
                this.dataToControlMap.delete(data);
                this.controlToElementMap.delete(control);
                this.controlToDataMap.delete(control);
            }
        }
    }
    /**
     * Clears all data item element order tracking information.
     */
    clearOrderTracking() {
        if (this.controlToElementMap !== undefined && this.dataToControlMap !== undefined && this.controlToDataMap !== undefined) {
            this.dataToControlMap.clear();
            this.controlToElementMap.clear();
            this.controlToDataMap.clear();
        }
    }
    /**
     * Updates the order of data items in the list by the props supplied
     * comparison function, if one exists.
     */
    updateOrder() {
        if (this.controlToElementMap !== undefined && this.dataToControlMap !== undefined && this.controlToDataMap !== undefined) {
            const itemsContainer = this.itemsContainer.instance;
            if (this.registeredControls !== undefined) {
                const selectedControl = this.getChild(this.getFocusedIndex());
                this.registeredControls.sort(this.sortControls);
                if (!this.orderUnchanged()) {
                    for (let i = 0; i < this.registeredControls.length; i++) {
                        const element = this.controlToElementMap.get(this.registeredControls[i]);
                        if (element !== undefined) {
                            itemsContainer.appendChild(element);
                        }
                    }
                    this.currentControlOrder = [...this.registeredControls];
                    if (selectedControl !== undefined) {
                        this.focusedIndex = this.registeredControls.indexOf(selectedControl);
                        this.ensureIndexInView(this.focusedIndex);
                    }
                }
            }
        }
    }
    /**
     * Checks whether or not the control order is the same as it was previously.
     * @returns True if the order is the same, false otherwise.
     */
    orderUnchanged() {
        if (this.registeredControls !== undefined && this.currentControlOrder !== undefined) {
            if (this.registeredControls.length === this.currentControlOrder.length) {
                return this.registeredControls.every((control, i) => this.currentControlOrder && control === this.currentControlOrder[i]);
            }
            return false;
        }
        return true;
    }
    /**
     * Removes a dom node from the collection at the specified index.
     * @param index The index to remove.
     */
    removeDomNode(index) {
        const child = this.itemsContainer.instance.childNodes.item(index);
        this.itemsContainer.instance.removeChild(child);
    }
    /**
     * Adds a list rendered dom node to the collection.
     * @param node Item to render and add.
     * @param index The index to add at.
     * @param el The element to add to.
     * @returns The created DOM element.
     */
    renderToDom(node, index, el) {
        if (el !== null) {
            node && el && FSComponent.renderBefore(node, el);
            return el.previousElementSibling;
        }
        else {
            el = this.itemsContainer.instance;
            node && el && FSComponent.render(node, el);
            return this.itemsContainer.instance.lastElementChild;
        }
    }
    /**
     * Scrolls to an item.
     * @param index is the index of the list item to scroll to.
     * @param focusPosition The focus position to apply to children of the item being scrolled to.
     */
    scrollToIndex(index, focusPosition = FocusPosition.First) {
        const control = this.getChild(index);
        if (control !== undefined) {
            control.focus(focusPosition);
        }
    }
    /**
     * Ensures an indexed list item is in view.
     * @param index The index of the list item.
     * @param pinDirection The end of the container which the element should be pinned to.
     */
    ensureIndexInView(index, pinDirection = 'none') {
        var _a, _b;
        const el = this.getElement(index);
        const container = (_b = (_a = this.props.scrollContainer) === null || _a === void 0 ? void 0 : _a.getOrDefault()) !== null && _b !== void 0 ? _b : this.itemsContainer.getOrDefault();
        if (el && container && !this.props.disableContainerScroll) {
            ScrollUtils.ensureInView(el, container, pinDirection);
        }
    }
    /**
     * Gets an element at the specified data/control index.
     * @param index The data/control index to get the element for.
     * @returns The request HTML element.
     */
    getElement(index) {
        var _a;
        return (_a = this.itemsContainer.instance.children[index]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets the data object related to the selected DOM element.
     * @param index The index of the data to get.
     * @returns The selected item, if found.
     */
    getData(index) {
        var _a;
        const control = this.getChild(index);
        if (this.controlToDataMap !== undefined && control !== undefined) {
            return (_a = this.controlToDataMap.get(control)) !== null && _a !== void 0 ? _a : null;
        }
        if (index > -1) {
            return this.props.data.get(index);
        }
        return null;
    }
    /**
     * Get the selected HTMLElement.
     * @returns The selected element, if found.
     */
    getSelectedElement() {
        var _a;
        return (_a = this.itemsContainer.instance.children[this.getSelectedIndex()]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets the index of the currently selected element.
     * @returns Selected element index. Returns -1 if nothing found.
     */
    getSelectedIndex() {
        if (this.length > 0) {
            return this.getFocusedIndex();
        }
        return -1;
    }
    /**
     * Gets the instance of the node at the specified index.
     * @param index The index to get the instance for.
     * @returns The node instance of specified type.
     */
    getChildInstance(index) {
        const child = this.getChild(index);
        if (child !== undefined) {
            return child;
        }
        return null;
    }
    /** @inheritdoc */
    onBlurred(source) {
        if (this.props.onItemSelected) {
            this.props.onItemSelected(null, null, -1);
        }
        super.onBlurred(source);
    }
    /**
     * Responds to when a list item is focused.
     */
    onItemFocused() {
        const index = this.getFocusedIndex();
        this.ensureIndexInView(index);
        if (this.props.onItemSelected) {
            const control = this.getChild(index);
            if (control !== undefined && control.isFocused) {
                let data = this.props.data.get(index);
                if (this.controlToDataMap !== undefined) {
                    data = this.controlToDataMap.get(control);
                }
                if (data !== undefined) {
                    this.props.onItemSelected(data, control, index);
                }
            }
        }
    }
    /**
     * Renders the complete list of data items as control components.
     */
    renderList() {
        this.itemsContainer.instance.textContent = '';
        this.onDataAdded(0, this.props.data.getArray());
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: `ui-control-list ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`, ref: this.el },
            FSComponent.buildComponent("div", { ref: this.itemsContainer, class: 'ui-control-list-content' }),
            !this.props.hideScrollbar && this.renderScrollbar()));
    }
}

/**
 * A base component for map layers.
 */
class MapLayer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._isVisible = true;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
        return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
        if (this._isVisible === val) {
            return;
        }
        this._isVisible = val;
        this.onVisibilityChanged(val);
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        // noop
    }
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached() {
        // noop
    }
}

/**
 * The different types of map projection changes.
 */
var MapProjectionChangeType;
(function (MapProjectionChangeType) {
    MapProjectionChangeType[MapProjectionChangeType["Target"] = 1] = "Target";
    MapProjectionChangeType[MapProjectionChangeType["Center"] = 2] = "Center";
    MapProjectionChangeType[MapProjectionChangeType["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType[MapProjectionChangeType["Range"] = 8] = "Range";
    MapProjectionChangeType[MapProjectionChangeType["RangeEndpoints"] = 16] = "RangeEndpoints";
    MapProjectionChangeType[MapProjectionChangeType["ScaleFactor"] = 32] = "ScaleFactor";
    MapProjectionChangeType[MapProjectionChangeType["Rotation"] = 64] = "Rotation";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedSize"] = 128] = "ProjectedSize";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedResolution"] = 256] = "ProjectedResolution";
})(MapProjectionChangeType || (MapProjectionChangeType = {}));
/**
 * A geographic projection model for a map. MapProjection uses a mercator projection.
 */
class MapProjection {
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth, projectedHeight) {
        // settable parameters
        this.target = new GeoPoint(0, 0);
        this.targetProjectedOffset = new Float64Array(2);
        this.targetProjected = new Float64Array(2);
        this.range = 1; // great-arc radians
        this.rangeEndpoints = new Float64Array([0.5, 0, 0.5, 1]); // [relX1, relY1, relX2, relY2]
        this.projectedSize = new Float64Array(2);
        // computed parameters
        this.center = new GeoPoint(0, 0);
        this.centerProjected = new Float64Array(2);
        this.projectedRange = 0; // projected distance between the range endpoints in pixels
        this.widthRange = 0; // great-arc radians
        this.heightRange = 0; // great-arc radians
        this.oldParameters = {
            target: new GeoPoint(0, 0),
            center: new GeoPoint(0, 0),
            targetProjected: new Float64Array(2),
            range: 1,
            rangeEndpoints: new Float64Array(4),
            scaleFactor: 1,
            rotation: 0,
            projectedSize: new Float64Array(2),
            projectedResolution: 0
        };
        this.queuedParameters = Object.assign({}, this.oldParameters);
        this.updateQueued = false;
        this.changeListeners = [];
        Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
        this.geoProjection = new MercatorProjection();
        Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
        this.targetProjected.set(this.centerProjected);
        this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
        this.recompute();
    }
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns This map projection's GeoProjection instance.
     */
    getGeoProjection() {
        return this.geoProjection;
    }
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns The target geographic point of this projection.
     */
    getTarget() {
        return this.target.readonly;
    }
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns The projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset() {
        return this.targetProjectedOffset;
    }
    /**
     * Gets the projected location of the target of this projection.
     * @returns The projected location of the target of this projection.
     */
    getTargetProjected() {
        return this.targetProjected;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured between the projection's two range endpoints.
     * @returns The range of this projection, in great-arc radians.
     */
    getRange() {
        return this.range;
    }
    /**
     * Gets the endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     * @returns The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`.
     */
    getRangeEndpoints() {
        return this.rangeEndpoints;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the center-left to the center-right of
     * the projected window.
     * @returns The range of this projection's projected window width, in great-arc radians.
     */
    getWidthRange() {
        return this.widthRange;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the top-center to the bottom-center of
     * the projected window.
     * @returns The range of this projection's projected window height, in great-arc radians.
     */
    getHeightRange() {
        return this.heightRange;
    }
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor() {
        return this.geoProjection.getScaleFactor();
    }
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns The post-projected rotation angle of this projection.
     */
    getRotation() {
        return this.geoProjection.getPostRotation();
    }
    /**
     * Gets the size of the projected window, in pixels.
     * @returns The size of the projected window.
     */
    getProjectedSize() {
        return this.projectedSize;
    }
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns The geographic point located at the center of this projection's projected window.
     */
    getCenter() {
        return this.center.readonly;
    }
    /**
     * Gets the center of this projection's projected window.
     * @returns The center of this projection's projected window.
     */
    getCenterProjected() {
        return this.centerProjected;
    }
    /**
     * Gets the average resolution, in great-arc radians per pixel, of the projected map along a line between the range
     * endpoints.
     * @returns The average resolution of the projected map along a line between the range endpoints.
     */
    getProjectedResolution() {
        return this.range / this.projectedRange;
    }
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected The projected location of the hypothetical center point to use for the calculation.
     * @returns The true range of this projection given the hypothetical projected center point.
     */
    calculateRangeAtCenter(centerProjected) {
        const endpoints = this.rangeEndpoints;
        const projectedWidth = this.projectedSize[0];
        const projectedHeight = this.projectedSize[1];
        const endpoint1 = MapProjection.tempVec2_3;
        endpoint1[0] = centerProjected[0] + projectedWidth * (endpoints[0] - 0.5);
        endpoint1[1] = centerProjected[1] + projectedHeight * (endpoints[1] - 0.5);
        const endpoint2 = MapProjection.tempVec2_4;
        endpoint2[0] = centerProjected[0] + projectedWidth * (endpoints[2] - 0.5);
        endpoint2[1] = centerProjected[1] + projectedHeight * (endpoints[3] - 0.5);
        const top = this.geoProjection.invert(endpoint1, MapProjection.tempGeoPoint_1);
        const bottom = this.geoProjection.invert(endpoint2, MapProjection.tempGeoPoint_2);
        return top.distance(bottom);
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
        const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
        if (!isFinite(currentTargetProjected[0] + currentTargetProjected[1])) {
            // Check if we can potentially fix the geo projection by resetting its scale factor and center to defaults.
            const translation = this.geoProjection.getTranslation();
            if (isFinite(this.target.lat)
                && isFinite(this.target.lon)
                && isFinite(this.geoProjection.getPostRotation())
                && isFinite(translation[0])
                && isFinite(translation[1])) {
                this.geoProjection.setScaleFactor(MapProjection.DEFAULT_SCALE_FACTOR);
                this.geoProjection.setCenter(MapProjection.tempGeoPoint_1.set(0, 0));
                this.geoProjection.setPreRotation(Vec3Math.set(0, 0, 0, MapProjection.vec3Cache[0]));
            }
            else {
                return;
            }
        }
        const currentCenterProjected = MapProjection.tempVec2_2;
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        let ratio = currentRange / this.range;
        if (!isFinite(ratio) || ratio === 0) {
            return;
        }
        // iteratively find the appropriate scale factor (empiric testing shows this typically takes less than 4 iterations
        // to converge)
        let lastScaleFactor = this.geoProjection.getScaleFactor();
        let iterCount = 0;
        let ratioError = Math.abs(ratio - 1);
        let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
        while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER
            && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE
            && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
            this.geoProjection.setScaleFactor(ratio * lastScaleFactor);
            this.geoProjection.project(this.target, currentTargetProjected);
            currentCenterProjected.set(currentTargetProjected);
            currentCenterProjected[0] -= this.targetProjectedOffset[0];
            currentCenterProjected[1] -= this.targetProjectedOffset[1];
            currentRange = this.calculateRangeAtCenter(currentCenterProjected);
            const newRatio = currentRange / this.range;
            const ratioDelta = newRatio - ratio;
            // Check to see if the ratio between current range and target range is invalid, did not change, or changed in the
            // direction opposite to what we were expecting. If so, this means that our range measurements are close to the
            // poles and range no longer monotonically increases with decreasing scale factor and vice versa. If we continue
            // iteration, we will likely push our scale factor to 0 or infinity. Therefore, we halt immediately and settle
            // for using the scale factor before we applied the most recent correction.
            if (!isFinite(ratio)
                || ratio < 1 && ratioDelta <= 0
                || ratio > 1 && ratioDelta >= 0) {
                this.geoProjection.setScaleFactor(lastScaleFactor);
            }
            lastScaleFactor = this.geoProjection.getScaleFactor();
            ratio = newRatio;
            const newRatioError = Math.abs(ratio - 1);
            deltaRatioError = Math.abs(newRatioError - ratioError);
            ratioError = newRatioError;
        }
        // calculate the center point of the projection
        this.invert(currentCenterProjected, this.center);
        this.geoProjection.setCenter(this.center);
        // set the projection's pre-rotation to avoid anti-meridian wrapping issues
        const preRotation = Vec3Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, 0, MapProjection.vec3Cache[0]);
        this.geoProjection.setPreRotation(preRotation);
        const width = this.projectedSize[0];
        const height = this.projectedSize[1];
        this.projectedRange = Math.hypot((this.rangeEndpoints[2] - this.rangeEndpoints[0]) * width, (this.rangeEndpoints[3] - this.rangeEndpoints[1]) * height);
        const left = Vec2Math.set(0, height / 2, MapProjection.tempVec2_1);
        const right = Vec2Math.set(width, height / 2, MapProjection.tempVec2_2);
        this.widthRange = this.geoDistance(left, right);
        const top = Vec2Math.set(width / 2, 0, MapProjection.tempVec2_1);
        const bottom = Vec2Math.set(width / 2, height, MapProjection.tempVec2_2);
        this.heightRange = this.geoDistance(top, bottom);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
        // save old values
        this.storeParameters(this.oldParameters);
        parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
        parameters.target && this.target.set(parameters.target);
        parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
        parameters.range !== undefined && (this.range = parameters.range);
        parameters.rangeEndpoints && this.rangeEndpoints.set(parameters.rangeEndpoints);
        parameters.rotation !== undefined && this.geoProjection.setPostRotation(parameters.rotation);
        let changeFlags = this.computeChangeFlags(this.oldParameters);
        if (changeFlags !== 0) {
            this.recompute();
            changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
            if (changeFlags !== 0) {
                this.notifyChangeListeners(changeFlags);
            }
        }
    }
    /**
     * Sets the projection parameters to be applied when applyQueued() is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters) {
        Object.assign(this.queuedParameters, parameters);
        this.updateQueued = true;
    }
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued() {
        if (this.updateQueued) {
            this.updateQueued = false;
            this.set(this.queuedParameters);
            for (const key in this.queuedParameters) {
                delete this.queuedParameters[key];
            }
        }
    }
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    setProjectedSize(size) {
        this.projectedSize.set(size);
        Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
        this.geoProjection.setTranslation(this.centerProjected);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    setTargetProjectedOffset(offset) {
        this.targetProjectedOffset.set(offset);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
        record.target.set(this.target);
        record.center.set(this.center);
        record.targetProjected.set(this.targetProjected);
        record.range = this.range;
        record.rangeEndpoints.set(this.rangeEndpoints);
        record.scaleFactor = this.geoProjection.getScaleFactor();
        record.rotation = this.getRotation();
        record.projectedSize.set(this.projectedSize);
        record.projectedResolution = this.getProjectedResolution();
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
        return (oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target)
            | (Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected)
            | (oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range)
            | (VecNMath.equals(oldParameters.rangeEndpoints, this.rangeEndpoints) ? 0 : MapProjectionChangeType.RangeEndpoints)
            | (oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation)
            | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize);
    }
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    computeDerivedChangeFlags(oldParameters) {
        return (oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center)
            | (oldParameters.scaleFactor === this.geoProjection.getScaleFactor() ? 0 : MapProjectionChangeType.ScaleFactor)
            | (oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point, out) {
        return this.geoProjection.project(point, out);
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns The inverted point.
     */
    invert(vec, out) {
        return this.geoProjection.invert(vec, out);
    }
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point The point to check.
     * @param bounds The bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point, bounds) {
        let left;
        let top;
        let right;
        let bottom;
        if (bounds) {
            left = bounds[0];
            top = bounds[1];
            right = bounds[2];
            bottom = bounds[3];
        }
        else {
            left = 0;
            top = 0;
            right = this.projectedSize[0];
            bottom = this.projectedSize[1];
        }
        if (!(point instanceof Float64Array)) {
            point = this.project(point, MapProjection.tempVec2_2);
        }
        const x = point[0];
        const y = point[1];
        return x >= left && x <= right && y >= top && y <= bottom;
    }
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The geographic great-circle distance between the points.
     */
    geoDistance(point1, point2) {
        if (point1 instanceof Float64Array) {
            point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
        }
        if (point2 instanceof Float64Array) {
            point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
        }
        return point1.distance(point2);
    }
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The projected Euclidean distance between two points.
     */
    projectedDistance(point1, point2) {
        if (!(point1 instanceof Float64Array)) {
            point1 = this.project(point1, MapProjection.tempVec2_1);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = this.project(point2, MapProjection.tempVec2_2);
        }
        return Vec2Math.distance(point1, point2);
    }
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    notifyChangeListeners(changeFlags) {
        for (let i = 0; i < this.changeListeners.length; i++) {
            this.changeListeners[i](this, changeFlags);
        }
    }
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to register.
     */
    addChangeListener(listener) {
        this.changeListeners.push(listener);
    }
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener The listener to remove.
     * @returns Whether the listener was successfully removed.
     */
    removeChangeListener(listener) {
        const index = this.changeListeners.lastIndexOf(listener);
        if (index >= 0) {
            this.changeListeners.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
}
MapProjection.DEFAULT_SCALE_FACTOR = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
MapProjection.SCALE_FACTOR_MAX_ITER = 20;
MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
MapProjection.tempVec2_1 = new Float64Array(2);
MapProjection.tempVec2_2 = new Float64Array(2);
MapProjection.tempVec2_3 = new Float64Array(2);
MapProjection.tempVec2_4 = new Float64Array(2);
MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);
MapProjection.vec3Cache = [Vec3Math.create()];

/**
 * A component which displays a map. A map projects geographic coordinates onto a planar pixel grid. Each map component
 * maintains a MapProjection instance which handles the details of the projection. MapLayer objects added to the map
 * as children determine what is drawn on the map.
 */
class MapComponent extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.layerEntries = [];
        this.lastUpdateTime = 0;
        this._isAwake = true;
        this.updateCycleHandler = this.update.bind(this);
        this.projectedSize = 'isSubscribable' in this.props.projectedSize ? this.props.projectedSize : Subject.create(this.props.projectedSize);
        const initialSize = this.projectedSize.get();
        if (this.props.projection !== undefined) {
            this.props.projection.set({ projectedSize: new Float64Array(initialSize) });
        }
        this.mapProjection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new MapProjection(initialSize[0], initialSize[1]);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize() {
        return this.mapProjection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this map is awake.
     */
    get isAwake() {
        return this._isAwake;
    }
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep() {
        this.setAwakeState(false);
    }
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake() {
        this.setAwakeState(true);
    }
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
        if (this._isAwake === isAwake) {
            return;
        }
        this._isAwake = isAwake;
        this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        var _a;
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.projectedSizeSub = this.projectedSize.sub(size => {
            this.mapProjection.set({ projectedSize: size });
        });
        (_a = this.props.updateFreq) === null || _a === void 0 ? void 0 : _a.sub(freq => {
            var _a;
            (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.updateCycleSub = this.props.bus.getSubscriber()
                .on('realTime')
                .whenChanged()
                .atFrequency(freq)
                .handle(this.updateCycleHandler);
        }, true);
        this.attachLayers(thisNode);
    }
    /**
     * Scans this component's VNode sub-tree for MapLayer components and attaches them when found. Only the top-most
     * level of MapLayer components are attached; layers that are themselves children of other layers are not attached.
     * @param thisNode This component's VNode.
     */
    attachLayers(thisNode) {
        FSComponent.visitNodes(thisNode, node => {
            if (node.instance instanceof MapLayer) {
                this.attachLayer(node.instance);
                return true;
            }
            return false;
        });
    }
    /**
     * This method is called when the map is awakened.
     */
    onWake() {
        this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this map's layers.
     */
    wakeLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onWake();
        }
    }
    /**
     * This method is called when the map is put to sleep.
     */
    onSleep() {
        this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this map's layers.
     */
    sleepLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onSleep();
        }
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onMapProjectionChanged(mapProjection, changeFlags);
        }
    }
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
        if (this.layerEntries.findIndex(entry => entry.layer === layer) >= 0) {
            return;
        }
        const entry = new LayerEntry(layer);
        this.layerEntries.push(entry);
        entry.attach();
    }
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    detachLayer(layer) {
        const index = this.layerEntries.findIndex(entry => entry.layer === layer);
        if (index >= 0) {
            const entry = this.layerEntries[index];
            entry.detach();
            this.layerEntries.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Updates this map.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (!this._isAwake) {
            return;
        }
        this.onUpdated(time, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
        this.updateLayers(time, elapsed);
    }
    /**
     * Updates this map's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateLayers(time, elapsed) {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].update(time);
        }
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.projectedSizeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].destroy();
        }
    }
}
/**
 * An entry for a map layer.
 */
class LayerEntry {
    /**
     * Constructor.
     * @param layer This entry's map layer.
     */
    constructor(layer) {
        this.layer = layer;
        this.updatePeriod = 0;
        this.lastUpdated = 0;
    }
    /**
     * Attaches this layer entry.
     */
    attach() {
        var _a, _b;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
            const clamped = Math.max(0, freq);
            this.updatePeriod = clamped === 0 ? 0 : 1000 / clamped;
        }, true);
        this.layer.onAttached();
    }
    /**
     * Updates this layer entry.
     * @param currentTime The current time as a UNIX timestamp.
     */
    update(currentTime) {
        if (currentTime - this.lastUpdated >= this.updatePeriod) {
            this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
            this.lastUpdated = currentTime;
        }
    }
    /**
     * Detaches this layer entry.
     */
    detach() {
        var _a;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.layer.onDetached();
    }
    /**
     * Destroys this layer entry. This will detach this entry's layer and destroy it.
     */
    destroy() {
        this.detach();
        this.layer.destroy();
    }
}

/**
 * A model for maps. Specific functionality is added by adding one or more modules to the model. Each module added to
 * the model is assigned a name which is used to retrieve it from the model.
 */
class MapModel {
    constructor() {
        this.modules = new Map();
    }
    /**
     * Gets a module instance from the model and assigns it
     * to the provided type.
     * @param nameOrModule The module to get or the name of the module.
     * @returns The requested map data module.
     * @throws An error if
     */
    getModule(nameOrModule) {
        if (typeof nameOrModule === 'string') {
            return this.modules.get(nameOrModule);
        }
        else if (typeof nameOrModule === 'function') {
            return this.modules.get(nameOrModule.name);
        }
        throw new Error('Invalid type supplied: must be a string key or a module constructor.');
    }
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule(name, module) {
        if (this.modules.has(name)) {
            return;
        }
        this.modules.set(name, module);
    }
}

/**
 * An abstract implementation of a map text label.
 */
class AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this.text = SubscribableUtils.toSubscribable(text, true);
        this.priority = SubscribableUtils.toSubscribable(priority, true);
        this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
        this.font = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.font) !== null && _b !== void 0 ? _b : '', true);
        this.fontSize = SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _c !== void 0 ? _c : 10, true);
        this.fontStr = MappedSubject.create(([s, f]) => {
            return `${s}px ${f}`;
        }, this.fontSize, this.font);
        this.fontColor = SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _d !== void 0 ? _d : 'white', true);
        this.fontOutlineWidth = SubscribableUtils.toSubscribable((_e = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _e !== void 0 ? _e : 0, true);
        this.fontOutlineColor = SubscribableUtils.toSubscribable((_f = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _f !== void 0 ? _f : 'black', true);
        this.showBg = SubscribableUtils.toSubscribable((_g = options === null || options === void 0 ? void 0 : options.showBg) !== null && _g !== void 0 ? _g : false, true);
        this.bgColor = SubscribableUtils.toSubscribable((_h = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _h !== void 0 ? _h : 'black', true);
        this.bgPadding = SubscribableUtils.toSubscribable((_j = options === null || options === void 0 ? void 0 : options.bgPadding) !== null && _j !== void 0 ? _j : VecNMath.create(4), true);
        this.bgBorderRadius = SubscribableUtils.toSubscribable((_k = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _k !== void 0 ? _k : 0, true);
        this.bgOutlineWidth = SubscribableUtils.toSubscribable((_l = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _l !== void 0 ? _l : 0, true);
        this.bgOutlineColor = SubscribableUtils.toSubscribable((_m = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _m !== void 0 ? _m : 'white', true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
        if (this.fontSize.get() !== 0) {
            this.setTextStyle(context);
            const width = context.measureText(this.text.get()).width;
            const height = this.fontSize.get();
            const showBg = this.showBg.get();
            const bgPadding = this.bgPadding.get();
            const bgOutlineWidth = this.bgOutlineWidth.get();
            const bgExtraWidth = showBg ? bgPadding[1] + bgPadding[3] + bgOutlineWidth * 2 : 0;
            const bgExtraHeight = showBg ? bgPadding[0] + bgPadding[2] + bgOutlineWidth * 2 : 0;
            const anchor = this.anchor.get();
            const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
            const centerX = pos[0] - (anchor[0] - 0.5) * (width + bgExtraWidth);
            const centerY = pos[1] - (anchor[1] - 0.5) * (height + bgExtraHeight);
            if (showBg) {
                this.drawBackground(context, centerX, centerY, width, height);
            }
            this.drawText(context, centerX, centerY);
        }
    }
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    setTextStyle(context) {
        context.font = this.fontStr.get();
        context.textBaseline = 'middle';
        context.textAlign = 'center';
    }
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    drawText(context, centerX, centerY) {
        const text = this.text.get();
        const fontOutlineWidth = this.fontOutlineWidth.get();
        if (fontOutlineWidth > 0) {
            context.lineWidth = fontOutlineWidth * 2;
            context.strokeStyle = this.fontOutlineColor.get();
            context.strokeText(text, centerX, centerY);
        }
        context.fillStyle = this.fontColor.get();
        context.fillText(text, centerX, centerY);
    }
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    drawBackground(context, centerX, centerY, width, height) {
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        const bgBorderRadius = this.bgBorderRadius.get();
        const backgroundLeft = centerX - width / 2 - (bgPadding[3] + bgOutlineWidth);
        const backgroundTop = centerY - height / 2 - (bgPadding[0] + bgOutlineWidth);
        const backgroundWidth = width + (bgPadding[1] + bgPadding[3] + 2 * bgOutlineWidth);
        const backgroundHeight = height + (bgPadding[0] + bgPadding[2] + 2 * bgOutlineWidth);
        let isRounded = false;
        if (bgBorderRadius > 0) {
            isRounded = true;
            this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, bgBorderRadius);
        }
        if (bgOutlineWidth > 0) {
            context.lineWidth = bgOutlineWidth * 2;
            context.strokeStyle = this.bgOutlineColor.get();
            if (isRounded) {
                context.stroke();
            }
            else {
                context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
            }
        }
        context.fillStyle = this.bgColor.get();
        if (isRounded) {
            context.fill();
        }
        else {
            context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
    }
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    loadBackgroundPath(context, left, top, width, height, radius) {
        const right = left + width;
        const bottom = top + height;
        context.beginPath();
        context.moveTo(left + radius, top);
        context.lineTo(right - radius, top);
        context.arcTo(right, top, right, top + radius, radius);
        context.lineTo(right, bottom - radius);
        context.arcTo(right, bottom, right - radius, bottom, radius);
        context.lineTo(left + radius, bottom);
        context.arcTo(left, bottom, left, bottom - radius, radius);
        context.lineTo(left, top + radius);
        context.arcTo(left, top, left + radius, top, radius);
    }
}
AbstractMapTextLabel.tempVec2 = new Float64Array(2);
/**
 * A text label associated with a specific geographic location.
 */
class MapLocationTextLabel extends AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, options) {
        var _a;
        super(text, priority, options);
        this.location = SubscribableUtils.toSubscribable(location, true);
        this.offset = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
    }
    /** @inheritdoc */
    getPosition(mapProjection, out) {
        mapProjection.project(this.location.get(), out);
        Vec2Math.add(out, this.offset.get(), out);
        return out;
    }
}

/**
 * A cullable (hides labels that collide with other labels) text label associated with a specific geographic location.
 */
class MapCullableLocationTextLabel extends MapLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param alwaysShow Whether this label is immune to culling, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, alwaysShow, options) {
        super(text, priority, location, options);
        /** @inheritdoc */
        this.bounds = new Float64Array(4);
        /** @inheritdoc */
        this.invalidation = new SubEvent();
        this.subs = [];
        this.alwaysShow = SubscribableUtils.toSubscribable(alwaysShow, true);
        this.subs.push(this.priority.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.alwaysShow.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.location.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.text.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.fontSize.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.anchor.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.offset.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.bgPadding.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.bgOutlineWidth.sub(() => { this.invalidation.notify(this); }));
    }
    /** @inheritdoc */
    updateBounds(mapProjection) {
        const fontSize = this.fontSize.get();
        const anchor = this.anchor.get();
        const width = 0.6 * fontSize * this.text.get().length;
        const height = fontSize;
        const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
        let left = pos[0] - anchor[0] * width;
        let right = left + width;
        let top = pos[1] - anchor[1] * height;
        let bottom = top + height;
        if (this.showBg.get()) {
            const bgPadding = this.bgPadding.get();
            const bgOutlineWidth = this.bgOutlineWidth.get();
            left -= (bgPadding[3] + bgOutlineWidth);
            right += (bgPadding[1] + bgOutlineWidth);
            top -= (bgPadding[0] + bgOutlineWidth);
            bottom += (bgPadding[2] + bgOutlineWidth);
        }
        this.bounds[0] = left;
        this.bounds[1] = top;
        this.bounds[2] = right;
        this.bounds[3] = bottom;
    }
    /**
     * Destroys this label.
     */
    destroy() {
        for (const sub of this.subs) {
            sub.destroy();
        }
    }
}
/**
 * Manages a set of MapCullableTextLabels. Colliding labels will be culled based on their render priority. Labels with
 * lower priorities will be culled before labels with higher priorities.
 */
class MapCullableTextLabelManager {
    /**
     * Creates an instance of the MapCullableTextLabelManager.
     * @param cullingEnabled Whether or not culling of labels is enabled.
     */
    constructor(cullingEnabled = true) {
        this.cullingEnabled = cullingEnabled;
        this.registered = new Map();
        this._visibleLabels = [];
        this.needUpdate = false;
        this.lastScaleFactor = 1;
        this.lastRotation = 0;
        this.invalidationHandler = () => { this.needUpdate = true; };
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels() {
        return this._visibleLabels;
    }
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label) {
        if (this.registered.has(label)) {
            return;
        }
        this.registered.set(label, label.invalidation.on(this.invalidationHandler));
        this.needUpdate = true;
    }
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label) {
        const sub = this.registered.get(label);
        if (sub === undefined) {
            return;
        }
        sub.destroy();
        this.registered.delete(label);
        this.needUpdate = true;
    }
    /**
     * Sets whether or not text label culling is enabled.
     * @param enabled Whether or not culling is enabled.
     */
    setCullingEnabled(enabled) {
        this.cullingEnabled = enabled;
        this.needUpdate = true;
    }
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection) {
        if (!this.needUpdate) {
            const scaleFactorRatio = mapProjection.getScaleFactor() / this.lastScaleFactor;
            if (scaleFactorRatio < MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD && scaleFactorRatio > 1 / MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD) {
                const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
                if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
                    return;
                }
            }
        }
        const labelArray = Array.from(this.registered.keys())
            .sort(MapCullableTextLabelManager.SORT_FUNC);
        if (this.cullingEnabled) {
            this._visibleLabels = [];
            const len = labelArray.length;
            for (let i = 0; i < len; i++) {
                labelArray[i].updateBounds(mapProjection);
            }
            const collisionArray = [];
            for (let i = 0; i < len; i++) {
                const label = labelArray[i];
                let show = true;
                if (!label.alwaysShow.get()) {
                    const len2 = collisionArray.length;
                    for (let j = 0; j < len2; j++) {
                        const other = collisionArray[j];
                        if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                            show = false;
                            break;
                        }
                    }
                }
                if (show) {
                    collisionArray.push(label.bounds);
                    this._visibleLabels.push(label);
                }
            }
        }
        else {
            this._visibleLabels = labelArray;
        }
        this.lastScaleFactor = mapProjection.getScaleFactor();
        this.lastRotation = mapProjection.getRotation();
        this.needUpdate = false;
    }
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    static doesCollide(a, b) {
        return a[0] < b[2]
            && a[2] > b[0]
            && a[1] < b[3]
            && a[3] > b[1];
    }
}
MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD = 1.2;
MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;
MapCullableTextLabelManager.SORT_FUNC = (a, b) => {
    const alwaysShowA = a.alwaysShow.get();
    const alwaysShowB = b.alwaysShow.get();
    if (alwaysShowA && !alwaysShowB) {
        return -1;
    }
    else if (alwaysShowB && !alwaysShowA) {
        return 1;
    }
    else {
        return b.priority.get() - a.priority.get();
    }
};

/**
 * An abstract implementation of MapWaypointIcon which supports an arbitrary anchor point and offset.
 */
class AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon, or a subscribable which provides it. Icons with higher
     * priorities should be rendered above those with lower priorities.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, size, options) {
        var _a, _b;
        this.waypoint = waypoint;
        this.priority = SubscribableUtils.toSubscribable(priority, true);
        this.size = SubscribableUtils.toSubscribable(size, true);
        this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(0.5, 0.5), true);
        this.offset = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.offset) !== null && _b !== void 0 ? _b : Vec2Math.create(), true);
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const size = this.size.get();
        const offset = this.offset.get();
        const anchor = this.anchor.get();
        const projected = mapProjection.project(this.waypoint.location.get(), MapWaypointImageIcon.tempVec2);
        const left = projected[0] + offset[0] - anchor[0] * size[0];
        const top = projected[1] + offset[1] - anchor[1] * size[1];
        this.drawIconAt(context, mapProjection, left, top);
    }
}
AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
/**
 * A waypoint icon with an image as the icon's graphic source.
 */
class MapWaypointImageIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, size, options) {
        super(waypoint, priority, size, options);
        this.img = img;
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, left, top) {
        const size = this.size.get();
        context.drawImage(this.img, left, top, size[0], size[1]);
    }
}

/**
 * A renderer that draws waypoints to a map. For the renderer to draw a waypoint, the waypoint must first be registered
 * with the renderer. Waypoints may be registered under multiple render roles. Each render role is represented as a bit
 * flag. During each render cycle, a specific role is chosen for each waypoint by a selector function. Once the role is
 * chosen, the waypoint will be rendered in that role.
 */
class MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     * @param selectRoleToRender A function which selects roles under which to render waypoints. Defaults to
     * {@link MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR}.
     */
    constructor(textManager, selectRoleToRender = MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR) {
        this.textManager = textManager;
        this.selectRoleToRender = selectRoleToRender;
        this.registered = new Map();
        this.toCleanUp = new Set();
        /**
         * This renderer's render role definitions. Waypoints assigned to be rendered under a role or combination of roles
         * with no definition will not be rendered.
         */
        this.roleDefinitions = new Map();
        /**
         * An event to subscribe to, fired when waypoints are added to the renderer.
         */
        this.onWaypointAdded = new SubEvent();
        /**
         * An event to subscribe to, fired when waypoints are removed from the render.
         */
        this.onWaypointRemoved = new SubEvent();
    }
    /**
     * Checks whether a render role has been added to this renderer.
     * @param role The render role to check.
     * @returns Whether the render role has been added to this renderer.
     */
    hasRenderRole(role) {
        return this.roleDefinitions.has(role);
    }
    /**
     * Adds a render role to this renderer. If the role has already been added to this renderer, this method does
     * nothing.
     * @param role The render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @returns Whether the render role was successfully added.
     */
    addRenderRole(role, def) {
        if (this.roleDefinitions.has(role)) {
            return false;
        }
        this.roleDefinitions.set(role, Object.assign({}, def !== null && def !== void 0 ? def : MapWaypointRenderer.NULL_ROLE_DEF));
        return true;
    }
    /**
     * Removes a render role from this renderer.
     * @param role The render role to remove.
     * @returns Whether the render role was successfully removed.
     */
    removeRenderRole(role) {
        return this.roleDefinitions.delete(role);
    }
    /**
     * Gets the definition for a render role.
     * @param role A render role.
     * @returns The definition for the specified render role, or undefined if no such role has been added to this
     * renderer.
     */
    getRenderRoleDefinition(role) {
        return this.roleDefinitions.get(role);
    }
    /**
     * Gets an iterable of render roles added to this renderer. The iterable will return the roles in the order in which
     * they were added.
     * @returns An iterable of render roles added to this renderer.
     */
    renderRoles() {
        return this.roleDefinitions.keys();
    }
    /**
     * Removes all render roles from this renderer.
     */
    clearRenderRoles() {
        this.roleDefinitions.clear();
    }
    /**
     * Sets the factory to use to create waypoint icons for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     * @returns Whether the factory was set.
     */
    setIconFactory(role, factory) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.iconFactory = factory;
        return true;
    }
    /**
     * Sets the factory to use to create waypoint labels for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint label factory.
     * @returns Whether the factory was set.
     */
    setLabelFactory(role, factory) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.labelFactory = factory;
        return true;
    }
    /**
     * Sets the canvas rendering context for a render role. If the render role has not been added to this renderer, this
     * method does nothing.
     * @param role A render role.
     * @param context A canvas 2D rendering context.
     * @returns Whether the context was set.
     */
    setCanvasContext(role, context) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.canvasContext = context;
        return true;
    }
    /**
     * Sets the handler that determines if a waypoint should visible for a render role. If the render role has not been
     * added to this renderer, this method does nothing.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     * @returns Whether the handler was set.
     */
    setVisibilityHandler(role, handler) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.visibilityHandler = handler;
        return true;
    }
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint, role) {
        if (!waypoint) {
            return false;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return false;
        }
        if (role === undefined) {
            return true;
        }
        return entry.isAllRoles(role);
    }
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        let entry = this.registered.get(waypoint.uid);
        if (!entry) {
            entry = new MapWaypointRendererEntry(waypoint, this.textManager, this.roleDefinitions, this.selectRoleToRender);
            this.registered.set(waypoint.uid, entry);
            this.onWaypointAdded.notify(this, waypoint);
        }
        entry.addRole(role, sourceId);
    }
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return;
        }
        entry.removeRole(role, sourceId);
        if (entry.roles === 0) {
            this.deleteEntry(entry);
            this.onWaypointRemoved.notify(this, waypoint);
        }
    }
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    deleteEntry(entry) {
        this.registered.delete(entry.waypoint.uid);
        this.toCleanUp.add(entry);
    }
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection) {
        var _a;
        this.toCleanUp.forEach(entry => {
            entry.destroy();
        });
        this.toCleanUp.clear();
        const entriesToDrawIcon = [];
        this.registered.forEach(entry => {
            entry.update();
            if (entry.icon) {
                entriesToDrawIcon.push(entry);
            }
        });
        const projectedSize = mapProjection.getProjectedSize();
        for (const roleDef of this.roleDefinitions.values()) {
            const context = roleDef.canvasContext;
            if (context) {
                context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
            }
        }
        entriesToDrawIcon.sort(MapWaypointRenderer.ENTRY_SORT_FUNC);
        const len2 = entriesToDrawIcon.length;
        for (let i = 0; i < len2; i++) {
            const entry = entriesToDrawIcon[i];
            const icon = entry.icon;
            const context = (_a = this.roleDefinitions.get(entry.lastRenderedRole)) === null || _a === void 0 ? void 0 : _a.canvasContext;
            if (context) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                icon.draw(context, mapProjection);
            }
        }
    }
    /**
     * Gets the nearest waypoint currently registered in the renderer.
     * @param pos The position to get the closest waypoint to.
     * @param first A predicate that will search the list of closest waypoints for a match, and return the first one found.
     * @returns The nearest waypoint, or undefined if none found.
     */
    getNearestWaypoint(pos, first) {
        var _a, _b;
        const ordered = [...this.registered.values()].sort((a, b) => this.orderByDistance(a.waypoint, b.waypoint, pos))
            .filter(w => {
            const roleDef = this.getRenderRoleDefinition(w.lastRenderedRole);
            if (roleDef !== undefined) {
                return roleDef.visibilityHandler(w.waypoint);
            }
            return false;
        });
        if (first !== undefined) {
            return (_a = ordered.find(entry => first(entry.waypoint))) === null || _a === void 0 ? void 0 : _a.waypoint;
        }
        return (_b = ordered[0]) === null || _b === void 0 ? void 0 : _b.waypoint;
    }
    /**
     * Orders waypoints by their distance to the plane PPOS.
     * @param a The first waypoint.
     * @param b The second waypoint.
     * @param pos The position to compare against.
     * @returns The comparison order number.
     */
    orderByDistance(a, b, pos) {
        const aDist = a.location.get().distance(pos);
        const bDist = b.location.get().distance(pos);
        return aDist - bDist;
    }
}
/** A null render role definition. Icons rendered under this role are never visible. */
MapWaypointRenderer.NULL_ROLE_DEF = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
};
/**
 * Sorts waypoint entries such that those with icons of higher priority are sorted after those with icons of lower
 * priority.
 * @param a The first waypoint entry to sort.
 * @param b The second waypoint entry to sort.
 * @returns A negative number if the first entry is to be sorted before the second, a positive number if the second
 * entry is to be sorted before the first, and zero if the entries' relative sorting order does not matter.
 */
MapWaypointRenderer.ENTRY_SORT_FUNC = (a, b) => {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return a.icon.priority.get() - b.icon.priority.get();
};
/**
 * The default render role selector. For each waypoint entry, iterates through all possible render roles in the order
 * they were originally added to the renderer and selects the first role under which the entry is registered and is
 * visible.
 * @param entry A waypoint entry.
 * @param roleDefinitions A map from all possible render roles to their definitions.
 * @returns The role under which the waypoint entry should be rendered, or 0 if the entry should not be rendered
 * under any role.
 */
MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR = (entry, roleDefinitions) => {
    for (const role of roleDefinitions.keys()) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (entry.isAllRoles(role) && roleDefinitions.get(role).visibilityHandler(entry.waypoint)) {
            return role;
        }
    }
    return 0;
};
/**
 * An entry for a waypoint registered with {@link MapWaypointRenderer}.
 */
class MapWaypointRendererEntry {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this entry.
     * @param textManager The text manager to which to register this entry's labels.
     * @param roleDefinitions A map of all valid render roles to their definitions.
     * @param selectRoleToRender A function to use to select roles under which to render this entry.
     */
    constructor(waypoint, textManager, roleDefinitions, selectRoleToRender) {
        this.waypoint = waypoint;
        this.textManager = textManager;
        this.roleDefinitions = roleDefinitions;
        this.selectRoleToRender = selectRoleToRender;
        this.registrations = {};
        this._roles = 0;
        this._icon = null;
        this._label = null;
        this._lastRenderedRole = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The render role(s) assigned to this entry. */
    get roles() {
        return this._roles;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastRenderedRole() {
        return this._lastRenderedRole;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint icon. */
    get icon() {
        return this._icon;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint label. */
    get label() {
        return this._label;
    }
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAny(toCompare, roles);
    }
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return toCompare === roles;
    }
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAll(toCompare, roles);
    }
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            var _a;
            var _b, _c;
            ((_a = (_b = this.registrations)[_c = 1 << index]) !== null && _a !== void 0 ? _a : (_b[_c] = new Set())).add(sourceId);
        }, true);
        this._roles = this._roles | roles;
    }
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            const role = 1 << index;
            const registrations = this.registrations[role];
            if (registrations) {
                registrations.delete(sourceId);
                if (registrations.size === 0) {
                    this._roles = this._roles & ~role;
                }
            }
        }, true);
    }
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    prepareRender(showRole, iconFactory, labelFactory) {
        var _a, _b;
        if (showRole === this._lastRenderedRole) {
            return;
        }
        this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(showRole, this.waypoint)) !== null && _a !== void 0 ? _a : null;
        const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(showRole, this.waypoint)) !== null && _b !== void 0 ? _b : null;
        if (this._label && this._label !== label) {
            this.textManager.deregister(this._label);
        }
        if (label && label !== this._label) {
            this.textManager.register(label);
        }
        this._label = label;
        this._lastRenderedRole = showRole;
    }
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     */
    update() {
        var _a, _b;
        const showRole = this.selectRoleToRender(this, this.roleDefinitions);
        const roleDef = this.roleDefinitions.get(showRole);
        const iconFactory = (_a = roleDef === null || roleDef === void 0 ? void 0 : roleDef.iconFactory) !== null && _a !== void 0 ? _a : null;
        const labelFactory = (_b = roleDef === null || roleDef === void 0 ? void 0 : roleDef.labelFactory) !== null && _b !== void 0 ? _b : null;
        this.prepareRender(showRole, iconFactory, labelFactory);
    }
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy() {
        if (this._label) {
            this.textManager.deregister(this._label);
        }
    }
}

/**
 * A path stream which does nothing on any input.
 */
class NullPathStream {
    /**
     * Does nothing.
     */
    beginPath() {
        // noop
    }
    /**
     * Does nothing.
     */
    moveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    lineTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    bezierCurveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    quadraticCurveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    arc() {
        // noop
    }
    /**
     * Does nothing.
     */
    closePath() {
        // noop
    }
}
/** An instance of a {@link NullPathStream}. */
NullPathStream.INSTANCE = new NullPathStream();
/**
 * An abstract implementation of a path stream which sends a transformed version of its input to be consumed by another
 * stream.
 */
class AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     */
    constructor(consumer) {
        this.consumer = consumer;
    }
    /** @inheritdoc */
    getConsumer() {
        return this.consumer;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        this.consumer = consumer;
    }
}

/**
 * Bitflags describing the relative location of a point with respect to a rectangular bounding box.
 */
var Outcode;
(function (Outcode) {
    Outcode[Outcode["Inside"] = 0] = "Inside";
    Outcode[Outcode["Left"] = 1] = "Left";
    Outcode[Outcode["Top"] = 2] = "Top";
    Outcode[Outcode["Right"] = 4] = "Right";
    Outcode[Outcode["Bottom"] = 8] = "Bottom";
})(Outcode || (Outcode = {}));
/**
 * A path stream which performs clipping to an axis-aligned rectangular bounding box before sending the clipped path
 * to another stream. Clipping is only supported for path segments added via the `lineTo()` and `arc()` methods. Path
 * segments added via `bezierCurveTo()` and `quadraticCurveTo()` will be passed to the consumer stream unclipped.
 */
class ClippedPathStream extends AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param bounds A subscribable which provides the clipping bounds for this stream, as `[left, top, right, bottom]`.
     * Whenever the clipping bounds change, the state of this stream will be reset, as if `beginPath()` were called.
     */
    constructor(consumer, bounds) {
        super(consumer);
        this.bounds = bounds;
        this.boundsHandler = this.onBoundsChanged.bind(this);
        this.boundsLines = [
            new Float64Array(3),
            new Float64Array(3),
            new Float64Array(3),
            new Float64Array(3)
        ];
        this.isBoundingRectNonZero = false;
        this.firstPoint = new Float64Array([NaN, NaN]);
        this.prevPoint = new Float64Array([NaN, NaN]);
        this.prevPointOutcode = 0;
        bounds.sub(this.boundsHandler, true);
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
        this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
            return;
        }
        if (isNaN(this.firstPoint[0])) {
            Vec2Math.set(x, y, this.firstPoint);
        }
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
        if (this.prevPointOutcode === 0) {
            this.consumer.moveTo(x, y);
        }
    }
    /** @inheritdoc */
    lineTo(x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        const outcode = this.getOutcode(x, y);
        if ((this.prevPointOutcode | outcode) === 0) {
            // Both the previous point and current point are within bounds.
            this.consumer.lineTo(x, y);
        }
        else if ((this.prevPointOutcode & outcode) === 0) {
            // One or both of the previous point and current point are out of bounds, and the line connecting them may
            // cross through the bounding rect
            const bounds = this.bounds.get();
            const line = ClippedPathStream.getLineCoordinates(this.prevPoint[0], this.prevPoint[1], x, y, ClippedPathStream.vec3Cache[1]);
            let entryPoint, exitPoint;
            const outcodeOr = this.prevPointOutcode | outcode;
            if ((outcodeOr & ~(Outcode.Left | Outcode.Right)) === 0 || (outcodeOr & ~(Outcode.Top | Outcode.Bottom)) === 0) {
                // The connecting line does not cross zones diagonally -> no need to check if the intersection of the line and
                // boundary falls outside the bounds of the orthogonal axis.
                // find entry point
                for (let i = 0; i < 4; i++) {
                    if (this.prevPointOutcode & (1 << i)) {
                        entryPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
                        break;
                    }
                }
                // find exit point
                for (let i = 0; i < 4; i++) {
                    if (outcode & (1 << i)) {
                        exitPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
                        break;
                    }
                }
            }
            else {
                // The connecting line crosses zones diagonally -> we need to check if the intersection of the line and each
                // boundary falls outside the bounds of the orthogonal axis.
                // find entry point
                for (let i = 0; i < 4; i++) {
                    if (this.prevPointOutcode & (1 << i)) {
                        const boundsAxisIndex = (i + 1) % 2;
                        const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
                        if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                            entryPoint = intersection;
                            break;
                        }
                    }
                }
                // find exit point
                for (let i = 0; i < 4; i++) {
                    if (outcode & (1 << i)) {
                        const boundsAxisIndex = (i + 1) % 2;
                        const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
                        if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                            exitPoint = intersection;
                            break;
                        }
                    }
                }
            }
            if (entryPoint) {
                this.consumer.moveTo(entryPoint[0], entryPoint[1]);
            }
            if (exitPoint) {
                this.consumer.lineTo(exitPoint[0], exitPoint[1]);
            }
            else if (outcode === Outcode.Inside) {
                this.consumer.lineTo(x, y);
            }
        }
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = outcode;
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        if (this.prevPointOutcode !== Outcode.Inside) {
            this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
        }
        this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        if (this.prevPointOutcode !== Outcode.Inside) {
            this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
        }
        this.consumer.quadraticCurveTo(cpx, cpy, x, y);
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        if (radius === 0 || startAngle === endAngle) {
            return;
        }
        const pi2 = 2 * Math.PI;
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
            // Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
            // doesn't match the counterClockwise flag.
            const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
            endAngle = startAngle + angleDiff * directionSign;
        }
        // Clamp to 2pi because we don't need to draw anything past a full circle.
        const angularWidth = Math.min(pi2, (endAngle - startAngle) * directionSign);
        const bounds = this.bounds.get();
        const radiusSq = radius * radius;
        const startPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[2]), Vec2Math.setFromPolar(radius, startAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[2]);
        const startPointOutcode = this.getOutcode(startPoint[0], startPoint[1]);
        const endPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[3]), Vec2Math.setFromPolar(radius, endAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[3]);
        const endPointOutcode = this.getOutcode(endPoint[0], endPoint[1]);
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(startPoint[0], startPoint[1]);
        }
        else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
            this.lineTo(startPoint[0], startPoint[1]);
        }
        // find all intersections of the arc circle with the clipping bounds; there can be up to 8 (two for each boundary
        // line)
        const intersections = ClippedPathStream.intersectionCache;
        let intersectionCount = 0;
        for (let i = 0; i < 4; i++) {
            const axisCoordIndex = i % 2;
            const crossAxisCoordIndex = (i + 1) % 2;
            const centerAxisCoord = i % 2 === 0 ? x : y;
            const centerCrossAxisCoord = i % 2 === 0 ? y : x;
            const deltaToBound = bounds[i] - centerAxisCoord;
            if (Math.abs(deltaToBound) < radius) {
                const crossAxisBoundMin = bounds[crossAxisCoordIndex];
                const crossAxisBoundMax = bounds[crossAxisCoordIndex + 2];
                //const radialOffset = Math.acos(deltaToBound / radius);
                const crossAxisOffset = Math.sqrt(radiusSq - deltaToBound * deltaToBound);
                let intersectionRadialOffset;
                {
                    const intersectionCrossAxisCoord = centerCrossAxisCoord + crossAxisOffset;
                    if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
                        const intersection = intersections[intersectionCount];
                        intersection.point[axisCoordIndex] = bounds[i];
                        intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
                        const radial = axisCoordIndex * Math.PI / 2 + (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : (intersectionRadialOffset = Math.acos(deltaToBound / radius))) * (axisCoordIndex === 0 ? 1 : -1);
                        intersection.radial = (radial + pi2) % pi2; // [0, 2 * pi)
                        intersectionCount++;
                    }
                }
                {
                    const intersectionCrossAxisCoord = centerCrossAxisCoord - crossAxisOffset;
                    if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
                        const intersection = intersections[intersectionCount];
                        intersection.point[axisCoordIndex] = bounds[i];
                        intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
                        const radial = axisCoordIndex * Math.PI / 2 - (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : (intersectionRadialOffset = Math.acos(deltaToBound / radius))) * (axisCoordIndex === 0 ? 1 : -1);
                        intersection.radial = (radial + pi2) % pi2; // [0, 2 * pi)
                        intersectionCount++;
                    }
                }
            }
        }
        // Begin at the start radial, then in order (either clockwise or counterclockwise depending on the arc direction)
        // iterate through the intersection points. At each intersection, move to the point if we are currently out of
        // bounds or path an arc from the last visited radial to the point if we are inbounds. Every time we visit an
        // intersection we go from out of bounds to in bounds and vice versa. Stop when the radial to the intersection
        // is past the end radial of the arc.
        let isOutside = startPointOutcode !== Outcode.Inside;
        const startAngleNormalized = ((startAngle % pi2) + pi2) % pi2; // [0, 2 * pi)
        let lastRadial = startAngleNormalized;
        let intersectionStartIndex = -1;
        let minAngularDiff = Infinity;
        for (let i = 0; i < intersectionCount; i++) {
            const angularDiff = ((intersections[i].radial - startAngleNormalized) * directionSign + pi2) % pi2;
            if (angularDiff < minAngularDiff) {
                intersectionStartIndex = i;
                minAngularDiff = angularDiff;
            }
        }
        if (intersectionStartIndex >= 0) {
            for (let i = 0; i < intersectionCount; i++) {
                const index = (intersectionStartIndex + intersectionCount + i * directionSign) % intersectionCount;
                const intersection = intersections[index];
                if (((intersection.radial - startAngleNormalized) * directionSign + pi2) % pi2 >= angularWidth) {
                    break;
                }
                if (isOutside) {
                    this.consumer.moveTo(intersection.point[0], intersection.point[1]);
                }
                else {
                    const segmentAngularWidth = ((intersection.radial - lastRadial) * directionSign + pi2) % pi2;
                    this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
                }
                isOutside = !isOutside;
                lastRadial = intersection.radial;
            }
        }
        const endAngleNormalized = (startAngleNormalized + angularWidth * directionSign + pi2) % pi2; // [0, 2 * pi)
        if (!isOutside) {
            const segmentAngularWidth = ((endAngleNormalized - lastRadial) * directionSign + pi2) % pi2;
            this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
            if (Math.abs((endAngleNormalized - endAngle) % pi2) > 1e-14) {
                // This can happen if we clamped the angular width to 2pi -> we need to move the current point to the actual
                // end point to keep the state of the consumer stream consistent with ours.
                this.consumer.moveTo(endPoint[0], endPoint[1]);
            }
        }
        Vec2Math.copy(endPoint, this.prevPoint);
        this.prevPointOutcode = endPointOutcode;
    }
    /** @inheritdoc */
    closePath() {
        if (!isNaN(this.firstPoint[0])) {
            this.lineTo(this.firstPoint[0], this.firstPoint[1]);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        Vec2Math.set(NaN, NaN, this.firstPoint);
        Vec2Math.set(NaN, NaN, this.prevPoint);
        this.prevPointOutcode = 0;
    }
    /**
     * Gets the Cohen-Sutherland outcode for a point.
     * @param x The x-coordinate of the query point.
     * @param y The y-coordinate of the query point.
     * @returns The outcode for the point.
     */
    getOutcode(x, y) {
        const bounds = this.bounds.get();
        let code = 0;
        if (x < bounds[0]) {
            code |= Outcode.Left;
        }
        else if (x > bounds[2]) {
            code |= Outcode.Right;
        }
        if (y < bounds[1]) {
            code |= Outcode.Top;
        }
        else if (y > bounds[3]) {
            code |= Outcode.Bottom;
        }
        return code;
    }
    /**
     * Handles clipping bounds change events.
     */
    onBoundsChanged() {
        const bounds = this.bounds.get();
        Vec3Math.set(1, 0, -bounds[0], this.boundsLines[0]);
        Vec3Math.set(0, 1, -bounds[1], this.boundsLines[1]);
        Vec3Math.set(1, 0, -bounds[2], this.boundsLines[2]);
        Vec3Math.set(0, 1, -bounds[3], this.boundsLines[3]);
        this.isBoundingRectNonZero = bounds[0] < bounds[2] && bounds[1] < bounds[3];
        this.beginPath();
    }
    /**
     * Destroys this stream.
     */
    destroy() {
        this.bounds.unsub(this.boundsHandler);
    }
    /**
     * Gets the line coordinate vector for a line passing through two points.
     * @param x1 The x-coordinate of the first point on the line.
     * @param y1 The y-coordinate of the first point on the line.
     * @param x2 The x-coordinate of the second point on the line.
     * @param y2 The y-coordinate of the second point on the line.
     * @param out A Float64Array object to which to write the result.
     * @returns The line coordinate vector of the line passing through the two points.
     */
    static getLineCoordinates(x1, y1, x2, y2, out) {
        const a = y1 - y2;
        const b = x2 - x1;
        const c = -(a * x1 + b * y1);
        return Vec3Math.set(a, b, c, out);
    }
    /**
     * Finds the intersection point between two lines in 2D Euclidean space.
     * @param line1 The line coordinate vector of the first line.
     * @param line2 The line coordinate vector of the second line.
     * @param out A Float64Array object to which to write the result.
     * @returns The intersection point of the two lines, or undefined if the two lines are parallel.
     */
    static findLineLineIntersection(line1, line2, out) {
        const cross = Vec3Math.cross(line1, line2, ClippedPathStream.vec3Cache[0]);
        const w = cross[2];
        if (w === 0) {
            return undefined;
        }
        return Vec2Math.set(cross[0] / w, cross[1] / w, out);
    }
}
ClippedPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
ClippedPathStream.vec3Cache = [new Float64Array(3), new Float64Array(3)];
ClippedPathStream.intersectionCache = Array.from({ length: 8 }, () => {
    return { point: new Float64Array(2), radial: 0 };
});

/**
 * A path stream which transforms a path stream in geographic spherical coordinates to one in projected planar
 * coordinates.
 */
class GeoProjectionPathStream extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
        super(consumer);
        this.projection = projection;
        this.firstPoint = new GeoPoint(NaN, NaN);
        this.prevPoint = new GeoPoint(NaN, NaN);
        this.prevPointProjected = new Float64Array(2);
        this.resampleHandler = this.onResampled.bind(this);
        if (arg1 instanceof GeoCircleResampler) {
            this.resampler = arg1;
        }
        else {
            this.resampler = new GeoCircleResampler(arg1, arg2, arg3);
        }
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
        return this.projection;
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
        this.projection = projection;
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
        this.consumer.beginPath();
    }
    /**
     * Moves to a specified point.
     * @param lon The longitude of the point to which to move, in degrees.
     * @param lat The latitude of the point to which to move, in degrees.
     */
    moveTo(lon, lat) {
        if (!(isFinite(lon) && isFinite(lat))) {
            return;
        }
        if (isNaN(this.firstPoint.lat)) {
            this.firstPoint.set(lat, lon);
        }
        this.prevPoint.set(lat, lon);
        const projected = this.projection.project(this.prevPoint, this.prevPointProjected);
        this.consumer.moveTo(projected[0], projected[1]);
    }
    /**
     * Paths a great-circle arc from the current point to a specified point.
     * @param lon The longitude of the end point, in degrees.
     * @param lat The latitude of the end point, in degrees.
     * @throws Error if the specified point is antipodal to the last pathed point.
     */
    lineTo(lon, lat) {
        if (!(isFinite(lon) && isFinite(lat))) {
            return;
        }
        if (!isNaN(this.prevPoint.lat) && this.prevPoint.equals(lat, lon)) {
            return;
        }
        if (isNaN(this.prevPoint.lat)) {
            this.moveTo(lon, lat);
            return;
        }
        const point = GeoProjectionPathStream.geoPointCache[0].set(lat, lon);
        const circle = GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint, point);
        if (!isFinite(circle.center[0])) {
            throw new Error(`Cannot unambiguously path a great circle from ${this.prevPoint.lat} lat, ${this.prevPoint.lon} lon to ${lat} lat, ${lon} lon`);
        }
        this.resampler.resample(this.projection, circle, this.prevPoint, point, this.resampleHandler);
        this.prevPoint.set(lat, lon);
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    bezierCurveTo() {
        throw new Error('GeodesicResamplerStream: bezierCurveTo() is not supported');
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    quadraticCurveTo() {
        throw new Error('GeodesicResamplerStream: quadraticCurveTo() is not supported');
    }
    /**
     * Paths a small-circle arc.
     * @param lon The longitude of the center of the circle containing the arc, in degrees.
     * @param lat The latitude of the center of the circle containing the arc, in degrees.
     * @param radius The radius of the arc, in great-arc radians.
     * @param startAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the start of the arc; otherwise the longitude, in degrees, of the start
     * of the arc.
     * @param endAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the end of the arc; otherwise the longitude, in degrees, of the end of
     * the arc.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(lon, lat, radius, startAngle, endAngle, counterClockwise) {
        if (!(isFinite(lon) && isFinite(lat) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        if (radius === 0 || Math.abs(startAngle - endAngle) <= GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
            return;
        }
        if (MathUtils.diffAngle(startAngle * Avionics.Utils.DEG2RAD, endAngle * Avionics.Utils.DEG2RAD, false) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Since we early return above if startAngle and endAngle are equal, hitting this case means they are a multiple
            // of 360 degrees apart. The resampler will interpret them as being the same point and won't draw a full circle
            // so we will split the arc into two.
            const midAngle = startAngle + 180 * Math.sign(endAngle - startAngle);
            this.arc(lon, lat, radius, startAngle, midAngle, counterClockwise);
            this.arc(lon, lat, radius, midAngle, endAngle, counterClockwise);
            return;
        }
        const center = GeoProjectionPathStream.geoPointCache[1].set(lat, lon);
        const start = GeoProjectionPathStream.geoPointCache[2];
        const end = GeoProjectionPathStream.geoPointCache[3];
        if (Math.abs(lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
            // The center of the arc circle is one of the poles
            const circleLat = Math.sign(lat) * (MathUtils.HALF_PI - radius) * Avionics.Utils.RAD2DEG;
            start.set(circleLat, startAngle);
            end.set(circleLat, endAngle);
        }
        else {
            center.offset(startAngle, radius, start);
            center.offset(endAngle, radius, end);
        }
        if (isNaN(start.lat) || isNaN(start.lon) || isNaN(end.lat) || isNaN(end.lon)) {
            return;
        }
        if (isNaN(this.prevPoint.lat)) {
            this.moveTo(start.lon, start.lat);
        }
        else if (!start.equals(this.prevPoint)) {
            this.lineTo(start.lon, start.lat);
        }
        const circle = GeoProjectionPathStream.geoCircleCache[0].set(center, radius);
        if (!counterClockwise) {
            circle.reverse();
        }
        this.resampler.resample(this.projection, circle, start, end, this.resampleHandler);
        this.prevPoint.set(end);
    }
    /**
     * Paths a great-circle arc from the current point to the first point defined by the current path.
     */
    closePath() {
        if (!isNaN(this.firstPoint.lat)) {
            this.lineTo(this.firstPoint.lon, this.firstPoint.lat);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        this.firstPoint.set(NaN, NaN);
        this.prevPoint.set(NaN, NaN);
    }
    /**
     * Handles resampled points.
     * @param vector A vector which describes the projected path terminating at the resampled point.
     */
    onResampled(vector) {
        switch (vector.type) {
            case 'start':
                return;
            case 'line':
                this.consumer.lineTo(vector.projected[0], vector.projected[1]);
                break;
            case 'arc':
                this.consumer.arc(vector.projectedArcCenter[0], vector.projectedArcCenter[1], vector.projectedArcRadius, vector.projectedArcStartAngle, vector.projectedArcEndAngle, vector.projectedArcStartAngle > vector.projectedArcEndAngle);
                break;
        }
        Vec2Math.copy(vector.projected, this.prevPointProjected);
    }
}
GeoProjectionPathStream.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GeoProjectionPathStream.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A {@link TransformingPathStream} which applies an affine transformation to its input.
 *
 * The types of transformation supported by this class are:
 * * Translation.
 * * Uniform scaling.
 * * Rotation.
 */
class AffineTransformPathStream extends AbstractTransformingPathStream {
    constructor() {
        super(...arguments);
        this.transform = new Transform2D();
        this.concatCache = [];
        this.scale = 1;
        this.rotation = 0;
    }
    /**
     * Adds a translation to this stream's transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the translation before this stream's current transformation.
     * * `'after'` - Applies the translation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addTranslation(x, y, order = 'after') {
        const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
        if (order === 'before') {
            this.concatCache[0] = translation;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = translation;
        }
        Transform2D.concat(this.transform, this.concatCache);
        return this;
    }
    /**
     * Adds a uniform scaling to this stream's transformation.
     * @param factor The scaling factor.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the scaling before this stream's current transformation.
     * * `'after'` - Applies the scaling after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addScale(factor, order = 'after') {
        const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
        if (order === 'before') {
            this.concatCache[0] = scale;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = scale;
        }
        Transform2D.concat(this.transform, this.concatCache);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Adds a rotation to this stream's transformation.
     * @param angle The rotation angle, in radians.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the rotation before this stream's current transformation.
     * * `'after'` - Applies the rotation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addRotation(angle, order = 'after') {
        const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
        if (order === 'before') {
            this.concatCache[0] = rotation;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = rotation;
        }
        Transform2D.concat(this.transform, this.concatCache);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Resets this stream's transformation to the identity transformation.
     * @returns This stream, after its transformation has been changed.
     */
    resetTransform() {
        this.transform.toIdentity();
        this.updateScaleRotation();
        return this;
    }
    /** @inheritdoc */
    beginPath() {
        this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.moveTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.lineTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        const cp1Transformed = this.applyTransform(cp1x, cp1y);
        cp1x = cp1Transformed[0];
        cp1y = cp1Transformed[1];
        const cp2Transformed = this.applyTransform(cp2x, cp2y);
        cp2x = cp2Transformed[0];
        cp2y = cp2Transformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        const cpTransformed = this.applyTransform(cpx, cpy);
        cpx = cpTransformed[0];
        cpy = cpTransformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        const transformed = this.applyTransform(x, y);
        this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.consumer.closePath();
    }
    /**
     * Updates this stream's cached scale and rotation values from its transformation.
     */
    updateScaleRotation() {
        const params = this.transform.getParameters();
        this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
        this.rotation = Math.atan2(params[3], params[0]);
    }
    /**
     * Applies this stream's transformation to a point.
     * @param x The x-coordinate of the point to transform.
     * @param y The y-coordinate of the point to transform.
     * @returns The transformed point.
     */
    applyTransform(x, y) {
        const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
        return this.transform.apply(vec, vec);
    }
}
AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
AffineTransformPathStream.transformCache = [new Transform2D()];

/**
 * A stack of {@link TransformingPathStream}s. Inputs are passed through the entire stack from top to bottom before the
 * final transformed output is sent to a consuming stream.
 */
class TransformingPathStreamStack extends AbstractTransformingPathStream {
    constructor() {
        super(...arguments);
        this.stack = [];
    }
    /**
     * Adds a transforming path stream to the top of this stack.
     * @param stream A transforming path stream.
     */
    push(stream) {
        var _a;
        stream.setConsumer((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer);
        this.stack.push(stream);
    }
    /**
     * Removes the top-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    pop() {
        const removed = this.stack.pop();
        removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
        return removed;
    }
    /**
     * Adds a transforming path stream to the bottom of this stack.
     * @param stream A transforming path stream.
     */
    unshift(stream) {
        const displaced = this.stack[0];
        displaced === null || displaced === void 0 ? void 0 : displaced.setConsumer(stream);
        stream.setConsumer(this.consumer);
        this.stack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shift() {
        var _a;
        const removed = this.stack.shift();
        removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
        (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(this.consumer);
        return removed;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        var _a;
        (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(consumer);
        super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.stack[this.stack.length - 1].closePath();
    }
}

/**
 * A stack of {@link TransformingPathStream}s which transforms an input in spherical geographic coordinates to planar
 * projected coordinates. The stack contains two sub-stacks: a pre-projected stack which transforms the path before
 * it is projected, and a post-projected stack which transforms the projected path before it is sent to the consumer.
 * Transforming streams can be added to the top and bottom of each sub-stack. The input will be passed through each
 * stream in the pre-projected stack from top to bottom, then projected, then passed through each stream in the post-
 * projected stack from top to bottom, and the final transformed output will be passed to the consumer.
 */
class GeoProjectionPathStreamStack extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
        super(consumer);
        this.postStack = new TransformingPathStreamStack(consumer);
        if (arg1 instanceof GeoCircleResampler) {
            this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1);
        }
        else {
            this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1, arg2, arg3);
        }
        this.preStack = new TransformingPathStreamStack(this.projectionStream);
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
        return this.projectionStream.getProjection();
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
        this.projectionStream.setProjection(projection);
    }
    /**
     * Adds a transforming path stream to the top of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    pushPreProjected(stream) {
        this.preStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPreProjected() {
        return this.preStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPreProjected(stream) {
        this.preStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPreProjected() {
        return this.preStack.shift();
    }
    /**
     * Adds a transforming path stream to the top of the post-projected stack.
     * @param stream A transforming path stream.
     */
    pushPostProjected(stream) {
        this.postStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the post-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPostProjected() {
        return this.postStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the post-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPostProjected(stream) {
        this.postStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the post-projected stack. The removed stream will have its consumer set
     * to {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPostProjected() {
        return this.postStack.shift();
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        this.postStack.setConsumer(consumer);
        super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
        this.preStack.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        this.preStack.moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        this.preStack.lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.preStack.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        this.preStack.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        this.preStack.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.preStack.closePath();
    }
}

/**
 * Renders arcs along geo circles to a path stream stack.
 */
class GeoCirclePathRenderer {
    /**
     * Renders an arc along a geo circle to a path stream stack.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param streamStack The path stream stack to which to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath = false) {
        if (!continuePath) {
            streamStack.beginPath();
            streamStack.moveTo(startLon, startLat);
        }
        if (circle.isGreatCircle()) {
            const startPoint = GeoPoint.sphericalToCartesian(startLat, startLon, GeoCirclePathRenderer.vec3Cache[0]);
            const distance = circle.distanceAlong(startPoint, GeoCirclePathRenderer.geoPointCache[0].set(endLat, endLon), Math.PI);
            if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
                const midPoint = circle.offsetDistanceAlong(startPoint, distance / 2, GeoCirclePathRenderer.geoPointCache[0], Math.PI);
                const midLat = midPoint.lat;
                const midLon = midPoint.lon;
                streamStack.lineTo(midLon, midLat);
                streamStack.lineTo(endLon, endLat);
            }
            else {
                streamStack.lineTo(endLon, endLat);
            }
        }
        else {
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, GeoCirclePathRenderer.geoPointCache[0]);
            const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
            const isCenterPole = Math.abs(turnCenter.lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG;
            let startAngle, endAngle;
            if (isCenterPole) {
                startAngle = startLon;
                endAngle = endLon;
            }
            else {
                startAngle = turnCenter.bearingTo(startLat, startLon);
                endAngle = turnCenter.bearingTo(endLat, endLon);
            }
            streamStack.arc(turnCenter.lon, turnCenter.lat, FlightPathUtils.getTurnRadiusFromCircle(circle), startAngle, endAngle, turnDirection === 'left');
        }
    }
}
GeoCirclePathRenderer.NORTH_POLE_VEC = new Float64Array([0, 0, 1]);
GeoCirclePathRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
GeoCirclePathRenderer.vec3Cache = [new Float64Array(3)];

/**
 * Renders arcs along geo circles as curved lines.
 */
class GeoCircleLineRenderer {
    constructor() {
        this.pathRenderer = new GeoCirclePathRenderer();
    }
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     * @param lineCap The line cap style to use. Defaults to `'butt'`.
     */
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, width, style, dash, outlineWidth = 0, outlineStyle = 'black', lineCap = 'butt') {
        this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack);
        if (outlineWidth > 0) {
            context.lineWidth = width + (outlineWidth * 2);
            context.strokeStyle = outlineStyle;
            context.lineCap = lineCap;
            context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
            context.stroke();
        }
        context.lineWidth = width;
        context.strokeStyle = style;
        context.lineCap = lineCap;
        context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
        context.stroke();
    }
}
GeoCircleLineRenderer.EMPTY_DASH = [];

/**
 * Renders flight plan paths one leg at a time in either forward or reverse order. Optionally forces the rendering of
 * the active flight plan leg to be last.
 */
class AbstractFlightPathPlanRenderer {
    /**
     * Constructor.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in
     * a first-to-last fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(renderOrder = 'forward', renderActiveLegLast = true) {
        this.renderOrder = renderOrder;
        this.renderActiveLegLast = renderActiveLegLast;
    }
    /**
     * Renders a flight plan path to a canvas.
     * @param plan The flight plan to render.
     * @param startIndex The global index of the first flight plan leg to render, inclusive. Defaults to `0`.
     * @param endIndex The global index of the last flight plan leg to render, inclusive. Defaults to `plan.length - 1`.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param args Additional arguments.
     */
    render(plan, startIndex, endIndex, context, streamStack, ...args) {
        startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0);
        endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = plan.length - 1);
        const activeLegIndex = plan.activeLateralLeg < plan.length ? plan.activeLateralLeg : -1;
        const activeLeg = plan.activeLateralLeg < plan.length ? plan.getLeg(plan.activeLateralLeg) : undefined;
        const isReverse = this.renderOrder === 'reverse';
        if (isReverse) {
            const oldEndIndex = endIndex;
            endIndex = startIndex;
            startIndex = oldEndIndex;
        }
        let index = startIndex;
        const delta = isReverse ? -1 : 1;
        for (const leg of plan.legs(isReverse, startIndex)) {
            if ((index - endIndex) * delta > 0) {
                break;
            }
            if (this.renderActiveLegLast && index === activeLegIndex) {
                index += delta;
                continue;
            }
            this.renderLeg(leg, plan, activeLeg, index, activeLegIndex, context, streamStack, ...args);
            index += delta;
        }
        if (this.renderActiveLegLast && activeLeg) {
            this.renderLeg(activeLeg, plan, activeLeg, activeLegIndex, activeLegIndex, context, streamStack, ...args);
        }
    }
}

/**
 * Parts of a flight plan leg path to render.
 */
var FlightPathLegRenderPart;
(function (FlightPathLegRenderPart) {
    /** None. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["None"] = 0] = "None";
    /** The ingress transition. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Ingress"] = 1] = "Ingress";
    /** The base path. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Base"] = 2] = "Base";
    /** The egress transition. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Egress"] = 4] = "Egress";
    /** The entire leg path. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["All"] = 7] = "All";
})(FlightPathLegRenderPart || (FlightPathLegRenderPart = {}));
/**
 * Renders flight plan leg paths one vector at a time, optionally excluding the ingress and/or egress transition
 * vectors.
 */
class AbstractFlightPathLegRenderer {
    constructor() {
        this.tempVector = FlightPathUtils.createEmptyCircleVector();
    }
    /**
     * Renders a flight plan leg path to a canvas.
     * @param leg The flight plan leg to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param partsToRender The parts of the leg to render, as a combination of {@link FlightPathLegRenderPart}
     * values.
     * @param args Additional arguments.
     */
    render(leg, context, streamStack, partsToRender, ...args) {
        const legCalc = leg.calculated;
        if (!legCalc || !BitFlags.isAny(partsToRender, FlightPathLegRenderPart.Ingress | FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Egress)) {
            return;
        }
        const excludeIngress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Ingress);
        const excludeBase = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Base);
        const excludeEgress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Egress);
        let mainVectors = legCalc.ingressToEgress;
        let mainVectorStartIndex = 0;
        let mainVectorEndIndex = legCalc.ingressToEgress.length;
        if (excludeIngress || excludeEgress) {
            mainVectors = legCalc.flightPath;
            mainVectorEndIndex = excludeEgress || legCalc.egressJoinIndex < 0 || legCalc.egress.length === 0 ? legCalc.flightPath.length : legCalc.egressJoinIndex;
        }
        if (!excludeIngress) {
            for (let i = 0; i < legCalc.ingress.length; i++) {
                this.renderVector(legCalc.ingress[i], true, false, leg, context, streamStack, ...args);
            }
            if (excludeEgress && !excludeBase) {
                mainVectorStartIndex = Math.max(0, legCalc.ingressJoinIndex);
                const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
                const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
                if (lastIngressVector && ingressJoinVector) {
                    const ingressEnd = AbstractFlightPathLegRenderer.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
                    const vectorEnd = AbstractFlightPathLegRenderer.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
                    if (!ingressEnd.equals(vectorEnd)) {
                        const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
                        FlightPathUtils.setCircleVector(this.tempVector, ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
                        this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
                    }
                    mainVectorStartIndex++;
                }
            }
        }
        if (!excludeBase) {
            const len = Math.min(mainVectorEndIndex, mainVectors.length);
            for (let i = mainVectorStartIndex; i < len; i++) {
                this.renderVector(mainVectors[i], false, false, leg, context, streamStack, ...args);
            }
        }
        if (!excludeEgress) {
            if (excludeIngress && !excludeBase) {
                const firstEgressVector = legCalc.egress[0];
                const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
                if (firstEgressVector && egressJoinVector) {
                    const egressStart = AbstractFlightPathLegRenderer.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                    const egressJoinVectorStart = AbstractFlightPathLegRenderer.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                    if (!egressStart.equals(egressJoinVectorStart)) {
                        const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
                        FlightPathUtils.setCircleVector(this.tempVector, egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                        this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
                    }
                }
            }
            for (let i = 0; i < legCalc.egress.length; i++) {
                this.renderVector(legCalc.egress[i], false, true, leg, context, streamStack, ...args);
            }
        }
    }
}
AbstractFlightPathLegRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
AbstractFlightPathLegRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * Renders flight path vectors as a curved line.
 */
class FlightPathVectorLineRenderer {
    constructor() {
        this.renderer = new GeoCircleLineRenderer();
    }
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     * @param lineCap The line cap style to use. Defaults to `'butt'`.
     */
    render(vector, context, streamStack, width, style, dash, outlineWidth, outlineStyle, lineCap = 'butt') {
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorLineRenderer.geoCircleCache[0]);
        this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, width, style, dash, outlineWidth, outlineStyle, lineCap);
    }
}
FlightPathVectorLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * Map own airplane icon orientations.
 */
var MapOwnAirplaneIconOrientation;
(function (MapOwnAirplaneIconOrientation) {
    MapOwnAirplaneIconOrientation["HeadingUp"] = "HeadingUp";
    MapOwnAirplaneIconOrientation["TrackUp"] = "TrackUp";
    MapOwnAirplaneIconOrientation["MapUp"] = "MapUp";
})(MapOwnAirplaneIconOrientation || (MapOwnAirplaneIconOrientation = {}));
/**
 * A module describing properties of the own airplane icon.
 */
class MapOwnAirplaneIconModule {
    constructor() {
        /** Whether to show the airplane icon. */
        this.show = Subject.create(true);
        /** The orientation of the airplane icon. */
        this.orientation = Subject.create(MapOwnAirplaneIconOrientation.HeadingUp);
    }
}

/**
 * A module describing the state of the own airplane.
 */
class MapOwnAirplanePropsModule {
    constructor() {
        /** The airplane's position. */
        this.position = GeoPointSubject.create(new GeoPoint(0, 0));
        /** The airplane's true heading, in degrees. */
        this.hdgTrue = Subject.create(0);
        /** The airplane's turn rate, in degrees per second. */
        this.turnRate = Subject.create(0);
        /** The airplane's indicated altitude. */
        this.altitude = NumberUnitSubject.create(UnitType.FOOT.createNumber(0));
        /** The airplane's vertical speed. */
        this.verticalSpeed = NumberUnitSubject.create(UnitType.FPM.createNumber(0));
        /** The airplane's true ground track, in degrees. */
        this.trackTrue = Subject.create(0);
        /** The airplane's ground speed. */
        this.groundSpeed = NumberUnitSubject.create(UnitType.KNOT.createNumber(0));
        /** Whether the airplane is on the ground. */
        this.isOnGround = Subject.create(true);
        /** The magnetic variation at the airplane's position. */
        this.magVar = Subject.create(0);
    }
}

/**
 * A module describing the state of the autopilot.
 */
class MapAutopilotPropsModule {
    constructor() {
        /** The altitude preselector setting. */
        this.selectedAltitude = NumberUnitSubject.create(UnitType.FOOT.createNumber(0));
    }
}

/**
 * A module describing the display of airspaces.
 */
class MapAirspaceModule {
    /**
     * Constructor.
     * @param showTypes A map of this module's airspace show types to their associated nearest boundary search filter
     * bitflags.
     */
    constructor(showTypes) {
        this.showTypes = showTypes;
        this.show = {};
        for (const type in showTypes) {
            this.show[type] = Subject.create(false);
        }
    }
}

/**
 * An abstract implementation of {@link CssTransform}
 */
class AbstractCssTransform {
    /**
     * Constructor.
     * @param initialParams The transform's initial parameters.
     */
    constructor(initialParams) {
        this.params = new Float64Array(initialParams);
        this.cachedParams = new Float64Array(initialParams);
    }
    /** @inheritdoc */
    resolve() {
        if (this.stringValue !== undefined && VecNMath.equals(this.params, this.cachedParams)) {
            return this.stringValue;
        }
        VecNMath.copy(this.params, this.cachedParams);
        this.stringValue = this.buildString(this.params);
        return this.stringValue;
    }
}
/**
 * A CSS `matrix` transform.
 */
class CssMatrixTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    constructor() {
        super(CssMatrixTransform.DEFAULT_PARAMS);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewY, skewX, scaleY, translateX, translateY) {
        let scaleX;
        if (typeof arg1 === 'number') {
            scaleX = arg1;
        }
        else {
            [scaleX, skewX, skewY, scaleY, translateX, translateY] = arg1.getParameters();
        }
        this.params[0] = scaleX;
        this.params[1] = skewY;
        this.params[2] = skewX;
        this.params[3] = scaleY;
        this.params[4] = translateX;
        this.params[5] = translateY;
    }
    /** @inheritdoc */
    buildString(params) {
        return `matrix(${params.join(', ')})`;
    }
}
CssMatrixTransform.DEFAULT_PARAMS = [1, 0, 0, 1, 0, 0];
/**
 * A CSS `rotate` transform.
 */
class CssRotateTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
        super(CssRotateTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's rotation angle.
     * @param angle The angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(angle, precision = 0) {
        this.params[0] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `rotate(${params[0]}${this.unit})`;
    }
}
CssRotateTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `rotate3d` transform.
 */
class CssRotate3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
        super(CssRotate3dTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's rotation.
     * @param x The x component of the rotation axis vector.
     * @param y The y component of the rotation axis vector.
     * @param z The z component of the rotation axis vector.
     * @param angle The rotation angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, y, z, angle, precision = 0) {
        this.params[0] = x;
        this.params[1] = y;
        this.params[2] = z;
        this.params[3] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `rotate3d(${params[0]}, ${params[1]}, ${params[2]}, ${params[3]}${this.unit})`;
    }
}
CssRotate3dTransform.DEFAULT_PARAMS = [0, 0, 1, 0];
/**
 * A CSS `translateX` transform.
 */
class CssTranslateXTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateXTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param x The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(x, precision = 0) {
        this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateX(${params[0]}${this.unit})`;
    }
}
CssTranslateXTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translateY` transform.
 */
class CssTranslateYTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateYTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param y The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(y, precision = 0) {
        this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateY(${params[0]}${this.unit})`;
    }
}
CssTranslateYTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translateZ` transform.
 */
class CssTranslateZTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateZTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param z The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(z, precision = 0) {
        this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateZ(${params[0]}${this.unit})`;
    }
}
CssTranslateZTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translate` transform.
 */
class CssTranslateTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX) {
        super(CssTranslateTransform.DEFAULT_PARAMS);
        this.unitX = unitX;
        this.unitY = unitY;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translate(${params[0]}${this.unitX}, ${params[1]}${this.unitY})`;
    }
}
CssTranslateTransform.DEFAULT_PARAMS = [0, 0];
/**
 * A CSS `translate3d` transform.
 */
class CssTranslate3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     * @param unitZ The unit to use for this transform's z translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX, unitZ = unitX) {
        super(CssTranslate3dTransform.DEFAULT_PARAMS);
        this.unitX = unitX;
        this.unitY = unitY;
        this.unitZ = unitZ;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param z The z translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     * @param precisionZ The precision with which to set the z translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
        this.params[2] = precisionZ === 0 ? z : MathUtils.round(z, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translate3d(${params[0]}${this.unitX}, ${params[1]}${this.unitY}, ${params[2]}${this.unitZ})`;
    }
}
CssTranslate3dTransform.DEFAULT_PARAMS = [0, 0, 0];
/**
 * A CSS `scaleX` transform.
 */
class CssScaleXTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleXTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, precision = 0) {
        this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleX(${params[0]})`;
    }
}
CssScaleXTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scaleY` transform.
 */
class CssScaleYTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleYTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param y The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(y, precision = 0) {
        this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleY(${params[0]})`;
    }
}
CssScaleYTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scaleZ` transform.
 */
class CssScaleZTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleZTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param z The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(z, precision = 0) {
        this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleZ(${params[0]})`;
    }
}
CssScaleZTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scale` transform.
 */
class CssScaleTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scale(${params[0]}, ${params[1]})`;
    }
}
CssScaleTransform.DEFAULT_PARAMS = [1, 1];
/**
 * A CSS `scale3d` transform.
 */
class CssScale3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScale3dTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param z The z scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     * @param precisionZ The precision with which to set the z scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
        this.params[2] = precisionZ === 0 ? z : MathUtils.round(y, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scale3d(${params[0]}, ${params[1]}, ${params[2]})`;
    }
}
CssScale3dTransform.DEFAULT_PARAMS = [1, 1, 1];
/**
 * A concatenated chain of CSS transforms.
 */
class CssTransformChain {
    /**
     * Creates a new chain of CSS transforms.
     * @param transforms The individual child transforms that will constitute the new transform chain. The order of
     * the children passed to the constructor determines the order of concatenation. Concatenation follows the standard
     * CSS transform convention: for a concatenation of transforms `[A, B, C]`, the resulting transformation is
     * equivalent to the one produced by multiplying the transformation matrices in the order `(A * B) * C`.
     */
    constructor(...transforms) {
        this.stringValues = [];
        this.transforms = transforms;
    }
    /**
     * Gets one of this chain's child transforms.
     * @param index The index of the child to get.
     * @returns The child transform at the specified index in this chain.
     * @throws RangeError if `index` is out of bounds.
     */
    getChild(index) {
        if (index < 0 || index >= this.transforms.length) {
            throw new RangeError();
        }
        return this.transforms[index];
    }
    /** @inheritdoc */
    resolve() {
        let needRebuildString = false;
        for (let i = 0; i < this.transforms.length; i++) {
            const stringValue = this.transforms[i].resolve();
            if (this.stringValues[i] !== stringValue) {
                this.stringValues[i] = stringValue;
                needRebuildString = true;
            }
        }
        if (needRebuildString || this.chainedStringValue === undefined) {
            this.chainedStringValue = this.stringValues.join(' ');
        }
        return this.chainedStringValue;
    }
}
/**
 * A subscribable subject whose value is a CSS transform string resolved from a {@link CssTransform}.
 */
class CssTransformSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param transform The new subject's CSS transform.
     */
    constructor(transform) {
        super();
        this._transform = transform;
        this.stringValue = transform.resolve();
        this.transform = transform;
    }
    /** @inheritdoc */
    get() {
        return this.stringValue;
    }
    /**
     * Resolves this subject's CSS transform to a CSS transform string, and sets this subject's value to the resolved
     * string. If this changes this subject's value, subscribers will be notified.
     */
    resolve() {
        const stringValue = this._transform.resolve();
        if (stringValue !== this.stringValue) {
            this.stringValue = stringValue;
            this.notify();
        }
    }
    /**
     * Creates a new instance of {@link CssTransformSubject} whose value is resolved from a CSS transform.
     * @param transform A CSS transform.
     * @returns A new instance of {@link CssTransformSubject} whose value is resolved from the specified CSS transform.
     */
    static create(transform) {
        return new CssTransformSubject(transform);
    }
}
/**
 * A utility class for building CSS transforms.
 */
class CssTransformBuilder {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     * @returns A new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    static matrix() {
        return new CssMatrixTransform();
    }
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate` transform, initialized to zero rotation.
     */
    static rotate(unit) {
        return new CssRotateTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     */
    static rotate3d(unit) {
        return new CssRotate3dTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateX` transform, initialized to zero translation.
     */
    static translateX(unit) {
        return new CssTranslateXTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateY` transform, initialized to zero translation.
     */
    static translateY(unit) {
        return new CssTranslateYTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateZ` transform, initialized to zero translation.
     */
    static translateZ(unit) {
        return new CssTranslateZTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @returns A new instance of a CSS `translate` transform, initialized to zero translation.
     */
    static translate(unitX, unitY) {
        return new CssTranslateTransform(unitX, unitY);
    }
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @param unitZ The unit to use for the new transform's z translation.
     * @returns A new instance of a CSS `translate3d` transform, initialized to zero translation.
     */
    static translate3d(unitX, unitY, unitZ) {
        return new CssTranslate3dTransform(unitX, unitY, unitZ);
    }
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    static scaleX() {
        return new CssScaleXTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    static scaleY() {
        return new CssScaleYTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    static scaleZ() {
        return new CssScaleZTransform();
    }
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    static scale() {
        return new CssScaleTransform();
    }
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    static scale3d() {
        return new CssScale3dTransform();
    }
    /**
     * Concatenates zero or more CSS transformations.
     * @param transforms The individual transforms to concatentate. The order of the transforms passed to the function
     * determines the order of concatenation. Concatenation follows the standard CSS transform convention: for a
     * concatenation of transforms `[A, B, C]`, the resulting transformation is equivalent to the one produced by
     * multiplying the transformation matrices in the order `(A * B) * C`.
     * @returns A new {@link CssTransformChain} object representing the concatenation of the specified transforms.
     */
    static concat(...transforms) {
        return new CssTransformChain(...transforms);
    }
}

/**
 * A utility class for creating number formatters.
 *
 * Each number formatter is a function which generates output strings from input numeric values. The formatting
 * behavior of a formatter is defined by its options. Please refer to the {@link NumberFormatterOptions} type
 * documentation for more information on each individual option.
 */
class NumberFormatter {
    /**
     * Formats a number to a string.
     * @param number The number to format.
     * @param opts Options describing how to format the number.
     * @returns The formatted string representation of the specified number.
     */
    static formatNumber(number, opts) {
        if (isNaN(number)) {
            return opts.nanString;
        }
        const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
        const sign = number < 0 ? -1 : 1;
        const abs = Math.abs(number);
        let rounded = abs;
        if (precision !== 0) {
            rounded = roundFunc(abs / precision) * precision;
        }
        if (cache) {
            if (opts.cachedString !== undefined && opts.cachedNumber === rounded) {
                return opts.cachedString;
            }
            opts.cachedNumber = rounded;
        }
        const signText = sign === -1
            ? useMinusSign ? '−' : '-'
            : '+';
        let formatted;
        if (precision != 0) {
            const precisionString = `${precision}`;
            const decimalIndex = precisionString.indexOf('.');
            if (decimalIndex >= 0) {
                formatted = rounded.toFixed(precisionString.length - decimalIndex - 1);
            }
            else {
                formatted = `${rounded}`;
            }
        }
        else {
            formatted = `${abs}`;
        }
        let decimalIndex = formatted.indexOf('.');
        if (!forceDecimalZeroes && decimalIndex >= 0) {
            formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, '');
            if (formatted.indexOf('.') == formatted.length - 1) {
                formatted = formatted.substring(0, formatted.length - 1);
            }
        }
        decimalIndex = formatted.indexOf('.');
        if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
            const shift = Math.max(maxDigits - decimalIndex, 0);
            const shiftPrecision = Math.pow(0.1, shift);
            formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
        }
        if (pad === 0) {
            formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, '.');
        }
        else if (pad > 1) {
            decimalIndex = formatted.indexOf('.');
            if (decimalIndex < 0) {
                decimalIndex = formatted.length;
            }
            formatted = formatted.padStart(pad + formatted.length - decimalIndex, '0');
        }
        if (showCommas) {
            const parts = formatted.split('.');
            parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ',');
            formatted = parts.join('.');
        }
        formatted = ((forceSign || signText !== '+') ? signText : '') + formatted;
        if (cache) {
            opts.cachedString = formatted;
        }
        return formatted;
    }
    /**
     * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
     * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
     * more information on each individual option.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `precision = 0`
     * * `round = 0`
     * * `maxDigits = Infinity`
     * * `forceDecimalZeroes = true`
     * * `pad = 1`
     * * `showCommas = false`
     * * `useMinusSign = false`
     * * `forceSign = false`
     * * `nanString = 'NaN'`
     * * `cache = false`
     * @returns A function which formats numeric values to strings.
     */
    static create(options) {
        const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
        optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
        return (number) => {
            return NumberFormatter.formatNumber(number, optsToUse);
        };
    }
}
NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: 'NaN',
    cache: false
};
NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
};
NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;

/**
 * A path stream which builds SVG path strings from its input path commands.
 */
class SvgPathStream {
    /**
     * Constructor.
     * @param precision The precision of this stream. All coordinates will be rounded to this stream's precision when
     * building the SVG path string. A value of `0` indicates infinite precision. Defaults to `0`.
     */
    constructor(precision = 0) {
        this.svgPath = '';
        this.firstPoint = new Float64Array([NaN, NaN]);
        this.prevPoint = new Float64Array([NaN, NaN]);
        this.precision = precision;
        this.formatter = NumberFormatter.create({ precision, forceDecimalZeroes: false });
    }
    /**
     * Gets the SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     * @returns The SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     */
    getSvgPath() {
        return this.svgPath.trim();
    }
    /**
     * Gets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @returns The precision of this stream.
     */
    getPrecision() {
        return this.precision;
    }
    /**
     * Sets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @param precision The precision of this stream. Negative numbers will be converted to their absolute values.
     */
    setPrecision(precision) {
        this.precision = Math.abs(precision);
        this.formatter = NumberFormatter.create({ precision: this.precision, forceDecimalZeroes: false });
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (isNaN(this.firstPoint[0])) {
            Vec2Math.set(x, y, this.firstPoint);
        }
        this.svgPath += `M ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `L ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `C ${this.formatter(cp1x)} ${this.formatter(cp1y)} ${this.formatter(cp2x)} ${this.formatter(cp2y)} ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `Q ${this.formatter(cpx)} ${this.formatter(cpy)} ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
            // Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
            // doesn't match the counterClockwise flag.
            const angleDiff = counterClockwise ? MathUtils.diffAngle(endAngle, startAngle) : MathUtils.diffAngle(startAngle, endAngle);
            endAngle = startAngle + angleDiff * directionSign;
        }
        // Clamp to 2pi because we don't need to draw anything past a full circle.
        const angularWidth = Math.min(MathUtils.TWO_PI, (endAngle - startAngle) * directionSign);
        if (angularWidth === MathUtils.TWO_PI) {
            // SVG arc commands cannot draw a full circle, so we need to split the circle into two half circles
            const midAngle = startAngle + Math.PI * directionSign;
            this.arc(x, y, radius, startAngle, midAngle, counterClockwise);
            this.arc(x, y, radius, midAngle, startAngle, counterClockwise);
            return;
        }
        const startPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[0]);
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(startPoint[0], startPoint[1]);
        }
        else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
            this.lineTo(startPoint[0], startPoint[1]);
        }
        const endPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[1]), Vec2Math.setFromPolar(radius, endAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[1]);
        const radiusString = this.formatter(radius);
        this.svgPath += `A ${radiusString} ${radiusString} 0 ${angularWidth > Math.PI ? 1 : 0} ${counterClockwise ? 0 : 1} ${this.formatter(endPoint[0])} ${this.formatter(endPoint[1])} `;
        Vec2Math.copy(endPoint, this.prevPoint);
    }
    /** @inheritdoc */
    closePath() {
        if (!isNaN(this.firstPoint[0])) {
            this.lineTo(this.firstPoint[0], this.firstPoint[1]);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        Vec2Math.set(NaN, NaN, this.firstPoint);
        Vec2Math.set(NaN, NaN, this.prevPoint);
        this.svgPath = '';
    }
}
SvgPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];

/**
 * A collection of common keys used by the MapSystem API.
 */
class MapSystemKeys {
}
MapSystemKeys.TargetControl = 'targetControlModerator';
MapSystemKeys.RotationControl = 'rotationControlModerator';
MapSystemKeys.RangeControl = 'rangeControlModerator';
MapSystemKeys.ClockUpdate = 'clockUpdate';
MapSystemKeys.OwnAirplaneProps = 'ownAirplaneProps';
MapSystemKeys.AutopilotProps = 'autopilotProps';
MapSystemKeys.AltitudeArc = 'altitudeArc';
MapSystemKeys.TerrainColors = 'terrainColors';
MapSystemKeys.Weather = 'weather';
MapSystemKeys.FollowAirplane = 'followAirplane';
MapSystemKeys.Rotation = 'rotation';
MapSystemKeys.OwnAirplaneIcon = 'ownAirplaneIcon';
MapSystemKeys.OwnAirplaneIconOrientation = 'ownAirplaneIconOrientation';
MapSystemKeys.TextLayer = 'text';
MapSystemKeys.TextManager = 'textManager';
MapSystemKeys.Bing = 'bing';
MapSystemKeys.WaypointRenderer = 'waypointRenderer';
MapSystemKeys.IconFactory = 'iconFactory';
MapSystemKeys.LabelFactory = 'labelFactory';
MapSystemKeys.NearestWaypoints = 'nearestWaypoints';
MapSystemKeys.FlightPlan = 'flightPlan';
MapSystemKeys.FlightPlanner = 'flightPlanner';
MapSystemKeys.FlightPathRenderer = 'flightPathRenderer';
MapSystemKeys.Airspace = 'airspace';
MapSystemKeys.AirspaceManager = 'airspaceRenderManager';
MapSystemKeys.Traffic = 'traffic';
MapSystemKeys.DataIntegrity = 'dataIntegrity';

/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
class MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
        this.canvas = canvas;
        this.context = context;
        this.isDisplayed = isDisplayed;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset() {
        const width = this.canvas.width;
        this.canvas.width = 0;
        this.canvas.width = width;
    }
}
/**
 * A layer which uses a canvas to draw graphics.
 */
class MapCanvasLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.displayCanvasRef = FSComponent.createRef();
        this.width = 0;
        this.height = 0;
        this.displayCanvasContext = null;
        this.isInit = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display() {
        if (!this._display) {
            throw new Error('MapCanvasLayer: attempted to access display before it was initialized');
        }
        return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer() {
        if (!this._buffer) {
            throw new Error('MapCanvasLayer: attempted to access buffer before it was initialized');
        }
        return this._buffer;
    }
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay() {
        return this._display;
    }
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer() {
        return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
        return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
        return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
        if (width === this.width) {
            return;
        }
        this.width = width;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
        if (height === this.height) {
            return;
        }
        this.height = height;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
        if (!this.isInit || !this.props.useBuffer) {
            return;
        }
        this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.displayCanvasContext = this.displayCanvasRef.instance.getContext('2d');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        if (this.isInit) {
            this.updateCanvasVisibility();
        }
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.initCanvasInstances();
        this.isInit = true;
        this.updateCanvasVisibility();
        this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
        this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
        if (this.props.useBuffer) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            this._buffer = this.createCanvasInstance(canvas, context, false);
        }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
        const displayCanvas = this.display.canvas;
        displayCanvas.width = this.width;
        displayCanvas.height = this.height;
        displayCanvas.style.width = `${this.width}px`;
        displayCanvas.style.height = `${this.height}px`;
        if (this._buffer) {
            const bufferCanvas = this._buffer.canvas;
            bufferCanvas.width = this.width;
            bufferCanvas.height = this.height;
        }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', width: '0', height: '0', style: 'position: absolute;' }));
    }
}

/**
 * A canvas map layer whose size and position is synced with the map projection window.
 */
class MapSyncedCanvasLayer extends MapCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        this.setWidth(projectedSize[0]);
        this.setHeight(projectedSize[1]);
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = '0px';
        displayCanvas.style.top = '0px';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
    }
}

/**
 * A map layer which displays an altitude intercept arc.
 */
class MapAltitudeArcLayer extends MapLayer {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(...arguments);
        this.layerRef = FSComponent.createRef();
        this.arcAngularWidth = ((_a = this.props.arcAngularWidth) !== null && _a !== void 0 ? _a : MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
        this.arcRadius = (_b = this.props.arcRadius) !== null && _b !== void 0 ? _b : MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;
        this.strokeWidth = (_c = this.props.strokeWidth) !== null && _c !== void 0 ? _c : MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;
        this.strokeStyle = (_d = this.props.strokeStyle) !== null && _d !== void 0 ? _d : MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;
        this.strokeLineCap = (_e = this.props.strokeLineCap) !== null && _e !== void 0 ? _e : MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP;
        this.outlineWidth = (_f = this.props.outlineWidth) !== null && _f !== void 0 ? _f : MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;
        this.outlineStyle = (_g = this.props.outlineStyle) !== null && _g !== void 0 ? _g : MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;
        this.outlineLineCap = (_h = this.props.outlineLineCap) !== null && _h !== void 0 ? _h : MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP;
        this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.autopilotModule = this.props.model.getModule(MapSystemKeys.AutopilotProps);
        this.vsPrecisionFpm = ('isSubscribable' in this.props.verticalSpeedPrecision)
            ? this.vsPrecisionMap = this.props.verticalSpeedPrecision.map(v => v.asUnit(UnitType.FPM))
            : Subject.create(this.props.verticalSpeedPrecision.asUnit(UnitType.FPM));
        this.vsThresholdFpm = ('isSubscribable' in this.props.verticalSpeedThreshold)
            ? this.vsThresholdMap = this.props.verticalSpeedThreshold.map(v => v.asUnit(UnitType.FPM))
            : Subject.create(this.props.verticalSpeedThreshold.asUnit(UnitType.FPM));
        this.altDevThresholdFeet = ('isSubscribable' in this.props.altitudeDeviationThreshold)
            ? this.altDevThresholdMap = this.props.altitudeDeviationThreshold.map(v => v.asUnit(UnitType.FOOT))
            : Subject.create(this.props.altitudeDeviationThreshold.asUnit(UnitType.FOOT));
        this.vsFpm = this.ownAirplanePropsModule.verticalSpeed.map(vs => vs.asUnit(UnitType.FPM));
        this.vsFpmQuantized = MappedSubject.create(([vsFpm, precision]) => {
            return Math.round(vsFpm / precision) * precision;
        }, this.vsFpm, this.vsPrecisionFpm);
        this.projectedPlanePosition = Vec2Subject.create(Vec2Math.create());
        this.projectPlanePositionHandler = () => {
            const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapAltitudeArcLayer.vec2Cache[0]);
            this.projectedPlanePosition.set(projected);
        };
        this.isArcVisibleDynamic = MappedSubject.create(([vsFpm, alt, selectedAlt, vsThreshold, altDevThresholdFeet]) => {
            if (Math.abs(vsFpm) < vsThreshold) {
                return false;
            }
            const altDevFeet = selectedAlt.asUnit(UnitType.FOOT) - alt.asUnit(UnitType.FOOT);
            return Math.abs(altDevFeet) >= altDevThresholdFeet && altDevFeet * vsFpm > 0;
        }, this.vsFpmQuantized, this.ownAirplanePropsModule.altitude, this.autopilotModule.selectedAltitude, this.vsThresholdFpm, this.altDevThresholdFeet).pause();
        this.projectedArcPosition = Vec2Subject.create(Vec2Math.create());
        this.projectedArcAngle = Subject.create(0);
        this.needUpdate = false;
        this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a;
        (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(isVisible);
        if (isVisible) {
            this.needUpdate = true;
        }
    }
    /** @inheritdoc */
    onAttached() {
        var _a, _b;
        this.layerRef.instance.onAttached();
        this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
        const scheduleUpdate = () => { this.needUpdate = true; };
        const altitudeArcModule = this.props.model.getModule(MapSystemKeys.AltitudeArc);
        const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
        this.isArcVisibleStatic = MappedSubject.create(([show, isGpsValid, isAdcValid]) => {
            return show && isGpsValid && isAdcValid;
        }, altitudeArcModule.show, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true));
        const isArcVisibleDynamicSub = this.isArcVisibleDynamic.sub(isVisible => { this.setVisible(isVisible); }, false, true);
        this.isArcVisibleStatic.sub(isVisible => {
            if (isVisible) {
                this.isArcVisibleDynamic.resume();
                isArcVisibleDynamicSub.resume(true);
            }
            else {
                this.isArcVisibleDynamic.pause();
                isArcVisibleDynamicSub.pause();
                this.setVisible(false);
            }
        }, true);
        this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));
        this.vsFpmQuantized.sub(scheduleUpdate);
        this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate, true));
        this.layerRef.instance.setVisible(this.isVisible());
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.layerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.projectPlanePositionHandler();
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const track = this.ownAirplanePropsModule.trackTrue.get();
        const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
        const altitude = this.ownAirplanePropsModule.altitude.get();
        const selectedAltitude = this.autopilotModule.selectedAltitude.get();
        const vsFpm = this.vsFpmQuantized.get();
        const timeToAltitudeMinute = (selectedAltitude.asUnit(UnitType.FOOT) - altitude.asUnit(UnitType.FOOT)) / vsFpm;
        const distanceToAltitudeFeet = groundSpeed.asUnit(UnitType.FPM) * timeToAltitudeMinute;
        const distancePx = UnitType.FOOT.convertTo(distanceToAltitudeFeet, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - MathUtils.HALF_PI;
        const projectedPlanePos = this.projectedPlanePosition.get();
        const projectedArcPos = Vec2Math.add(Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapAltitudeArcLayer.vec2Cache[0]), projectedPlanePos, MapAltitudeArcLayer.vec2Cache[0]);
        this.projectedArcPosition.set(projectedArcPos);
        this.projectedArcAngle.set(projectedTrackAngle);
        this.layerRef.instance.onUpdated();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        const props = {
            ref: this.layerRef,
            model: this.props.model,
            mapProjection: this.props.mapProjection,
            arcAngularWidth: this.arcAngularWidth,
            arcRadius: this.arcRadius,
            strokeWidth: this.strokeWidth,
            strokeStyle: this.strokeStyle,
            strokeLineCap: this.strokeLineCap,
            outlineWidth: this.outlineWidth,
            outlineStyle: this.outlineStyle,
            outlineLineCap: this.outlineLineCap,
            projectedArcPosition: this.projectedArcPosition,
            projectedArcAngle: this.projectedArcAngle
        };
        return this.props.renderMethod === 'canvas'
            ? (FSComponent.buildComponent(MapAltitudeArcCanvasLayer, Object.assign({}, props))) : (FSComponent.buildComponent(MapAltitudeArcSvgLayer, Object.assign({}, props)));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e;
        (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.vsPrecisionMap) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.vsThresholdMap) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.altDevThresholdMap) === null || _d === void 0 ? void 0 : _d.destroy();
        this.vsFpm.destroy();
        (_e = this.isArcVisibleStatic) === null || _e === void 0 ? void 0 : _e.destroy();
        this.isArcVisibleDynamic.destroy();
        this.subscriptions.forEach(sub => sub.destroy());
        super.destroy();
    }
}
MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH = 60; // degrees
MapAltitudeArcLayer.DEFAULT_ARC_RADIUS = 64; // px
MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH = 2; // px
MapAltitudeArcLayer.DEFAULT_STROKE_STYLE = 'cyan';
MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP = 'butt';
MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH = 1; // px
MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE = '#505050';
MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP = 'butt';
MapAltitudeArcLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A map layer which draws an altitude intercept arc using canvas.
 */
class MapAltitudeArcCanvasLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
        this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
        this.canvasLayerRef = FSComponent.createRef();
        this.subscriptions = [];
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a, _b;
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
        const scheduleUpdate = () => { this.needUpdate = true; };
        this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const arcPos = this.props.projectedArcPosition.get();
        const display = this.canvasLayerRef.instance.display;
        display.clear();
        // Do not draw the arc if it is out of bounds.
        const projectedSize = this.props.mapProjection.getProjectedSize();
        const arcX = arcPos[0];
        const arcY = arcPos[1];
        const twiceRadius = this.props.arcRadius * 2;
        if (arcX <= -twiceRadius
            || arcX >= projectedSize[0] + twiceRadius
            || arcY <= -twiceRadius
            || arcY >= projectedSize[1] + twiceRadius) {
            return;
        }
        display.context.beginPath();
        const projectedArcAngle = this.props.projectedArcAngle.get();
        const center = Vec2Math.add(Vec2Math.setFromPolar(-this.props.arcRadius, projectedArcAngle, MapAltitudeArcCanvasLayer.vec2Cache[0]), arcPos, MapAltitudeArcCanvasLayer.vec2Cache[0]);
        const arcStart = Vec2Math.add(Vec2Math.setFromPolar(this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, MapAltitudeArcCanvasLayer.vec2Cache[1]), center, MapAltitudeArcCanvasLayer.vec2Cache[1]);
        display.context.moveTo(arcStart[0], arcStart[1]);
        display.context.arc(center[0], center[1], this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, projectedArcAngle + this.arcHalfAngularWidth);
        if (this.props.outlineWidth > 0) {
            display.context.lineWidth = this.totalArcThickness;
            display.context.strokeStyle = this.props.outlineStyle;
            display.context.lineCap = this.props.outlineLineCap;
            display.context.stroke();
        }
        if (this.props.strokeWidth > 0) {
            display.context.lineWidth = this.props.strokeWidth;
            display.context.strokeStyle = this.props.strokeStyle;
            display.context.lineCap = this.props.strokeLineCap;
            display.context.stroke();
        }
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.subscriptions.forEach(sub => sub.destroy());
        super.destroy();
    }
}
MapAltitudeArcCanvasLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A map layer which draws an altitude intercept arc using SVG.
 */
class MapAltitudeArcSvgLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
        this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
        this.width = this.props.arcRadius * (1 - Math.cos(this.arcHalfAngularWidth)) + this.totalArcThickness + 2;
        this.height = 2 * this.props.arcRadius * Math.sin(Math.min(this.arcHalfAngularWidth, MathUtils.HALF_PI)) + this.totalArcThickness + 2;
        this.svgStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': `${(this.totalArcThickness / 2 + 1) - this.width}px`,
            'top': `${-this.height / 2}px`,
            'width': `${this.width}px`,
            'height': `${this.height}px`,
            'transform': 'translate3d(0px, 0px, 0px) rotate(0rad)',
            'transform-origin': `${this.width - (this.totalArcThickness / 2 + 1)}px ${this.height / 2}px`
        });
        this.svgTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('rad'));
        this.needUpdate = false;
        this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            this.svgStyle.set('display', 'none');
        }
    }
    /** @inheritdoc */
    onAttached() {
        const scheduleUpdate = () => { this.needUpdate = true; };
        this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const arcPos = this.props.projectedArcPosition.get();
        // Hide the arc if it is out of bounds.
        const projectedSize = this.props.mapProjection.getProjectedSize();
        const arcX = arcPos[0];
        const arcY = arcPos[1];
        const twiceRadius = this.props.arcRadius * 2;
        if (arcX <= -twiceRadius
            || arcX >= projectedSize[0] + twiceRadius
            || arcY <= -twiceRadius
            || arcY >= projectedSize[1] + twiceRadius) {
            this.svgStyle.set('display', 'none');
        }
        else {
            this.svgStyle.set('display', '');
            this.svgTransform.getChild(0).set(arcX, arcY, 0, 0.1);
            this.svgTransform.getChild(1).set(this.props.projectedArcAngle.get(), 1e-4);
            this.svgStyle.set('transform', this.svgTransform.resolve());
        }
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        const svgPathStream = new SvgPathStream(0.01);
        const transformPathStream = new AffineTransformPathStream(svgPathStream);
        // Top of the arc is at (0, 0), so the center is at (-radius, 0).
        transformPathStream.beginPath();
        transformPathStream
            .addRotation(-this.arcHalfAngularWidth)
            .addTranslation(-this.props.arcRadius, 0);
        transformPathStream.moveTo(this.props.arcRadius, 0);
        transformPathStream.arc(0, 0, this.props.arcRadius, 0, this.props.arcAngularWidth);
        const path = svgPathStream.getSvgPath();
        return (FSComponent.buildComponent("svg", { viewBox: `${(this.totalArcThickness / 2 + 1) - this.width} ${-this.height / 2} ${this.width} ${this.height}`, style: this.svgStyle },
            FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.outlineStyle, "stroke-width": this.totalArcThickness, "stroke-linecap": this.props.outlineLineCap }),
            FSComponent.buildComponent("path", { d: path, fill: 'none', stroke: this.props.strokeStyle, "stroke-width": this.props.strokeWidth, "stroke-linecap": this.props.strokeLineCap })));
    }
    /** @inheritdoc */
    destroy() {
        this.subscriptions.forEach(sub => sub.destroy());
        super.destroy();
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
class MapBingLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.bingRef = FSComponent.createRef();
        this.wrapperStyle = ObjectSubject.create({
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'display': '',
            'transform': ''
        });
        this.resolution = Vec2Subject.create(Vec2Math.create(1024, 1024));
        this.rotationTransform = CssTransformBuilder.rotate('rad');
        /** The length of this layer's diagonal, in pixels. */
        this.size = 0;
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.wrapperStyle.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        if (this.props.wxrMode !== undefined) {
            this.props.wxrMode.sub(() => {
                this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
                this.needUpdate = true;
            });
        }
    }
    /** @inheritdoc */
    onWake() {
        this.bingRef.instance.wake();
    }
    /** @inheritdoc */
    onSleep() {
        this.bingRef.instance.sleep();
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        let offsetX, offsetY;
        if (this.props.wxrMode && this.props.wxrMode.get().mode === EWeatherRadar.HORIZONTAL) {
            const offsetSize = new Float64Array([projectedSize[0], projectedSize[1]]);
            const offset = this.props.mapProjection.getTargetProjectedOffset();
            offsetSize[0] += offset[0];
            offsetSize[1] += offset[1];
            this.size = this.getSize(offsetSize);
            offsetX = ((projectedSize[0] - this.size) / 2) + offset[0];
            offsetY = ((projectedSize[1] - this.size) / 2) + offset[1];
        }
        else {
            this.size = this.getSize(projectedSize);
            offsetX = (projectedSize[0] - this.size) / 2;
            offsetY = (projectedSize[1] - this.size) / 2;
        }
        this.wrapperStyle.set('left', `${offsetX}px`);
        this.wrapperStyle.set('top', `${offsetY}px`);
        this.wrapperStyle.set('width', `${this.size}px`);
        this.wrapperStyle.set('height', `${this.size}px`);
        this.resolution.set(this.size, this.size);
    }
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * We get the length of the hypotenuse so that the map edges won't show when rotating.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    getSize(projectedSize) {
        return Vec2Math.abs(projectedSize);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.ProjectedSize | MapProjectionChangeType.TargetProjected)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
        if (this.bingRef.instance.isBound()) {
            this.needUpdate = true;
        }
    }
    /**
     * A callback which is called when the Bing component is bound.
     */
    onBingBound() {
        this.needUpdate = true;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updatePositionRadius();
        this.needUpdate = false;
    }
    /**
     * Resets the underlying Bing component's img src attribute.
     */
    resetImgSrc() {
        this.bingRef.instance.resetImgSrc();
    }
    /**
     * Updates the Bing map center position and radius.
     */
    updatePositionRadius() {
        const center = this.props.mapProjection.getCenter();
        const radius = this.calculateDesiredRadius(this.props.mapProjection);
        this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
        if (!this.props.wxrMode || (this.props.wxrMode && this.props.wxrMode.get().mode !== EWeatherRadar.HORIZONTAL)) {
            this.rotationTransform.set(this.props.mapProjection.getRotation(), 1e-3);
        }
        else {
            this.rotationTransform.set(0);
        }
        this.wrapperStyle.set('transform', this.rotationTransform.resolve());
    }
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    calculateDesiredRadius(mapProjection) {
        const scaleFactor = mapProjection.getScaleFactor();
        const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
        const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
        return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        return (FSComponent.buildComponent("div", { style: this.wrapperStyle, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' },
            FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, onBoundCallback: this.onBingBound.bind(this), resolution: this.resolution, mode: (_b = this.props.mode) !== null && _b !== void 0 ? _b : EBingMode.PLANE, earthColors: this.props.earthColors, earthColorsElevationRange: this.props.earthColorsElevationRange, reference: this.props.reference, wxrMode: this.props.wxrMode, wxrColors: this.props.wxrColors, isoLines: this.props.isoLines, delay: this.props.delay })));
    }
}

/**
 * Implementation of MapCachedCanvasLayerReference.
 */
class MapCachedCanvasLayerReferenceClass {
    constructor() {
        this._center = new GeoPoint(0, 0);
        this._scaleFactor = 1;
        this._rotation = 0;
    }
    /** @inheritdoc */
    get center() {
        return this._center.readonly;
    }
    /** @inheritdoc */
    get scaleFactor() {
        return this._scaleFactor;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /**
     * Syncs this reference with the current state of a map projection.
     * @param mapProjection The map projection with which to sync.
     */
    syncWithMapProjection(mapProjection) {
        this._center.set(mapProjection.getCenter());
        this._scaleFactor = mapProjection.getScaleFactor();
        this._rotation = mapProjection.getRotation();
    }
    /**
     * Syncs this reference with another reference.
     * @param reference - the reference with which to sync.
     */
    syncWithReference(reference) {
        this._center.set(reference.center);
        this._scaleFactor = reference.scaleFactor;
        this._rotation = reference.rotation;
    }
}
/**
 * Implementation of MapCachedCanvasLayerTransform.
 */
class MapCachedCanvasLayerTransformClass {
    constructor() {
        this._scale = 0;
        this._rotation = 0;
        this._translation = new Float64Array(2);
        this._margin = 0;
        this._marginRemaining = 0;
    }
    /** @inheritdoc */
    get scale() {
        return this._scale;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /** @inheritdoc */
    get translation() {
        return this._translation;
    }
    /** @inheritdoc */
    get margin() {
        return this._margin;
    }
    /** @inheritdoc */
    get marginRemaining() {
        return this._marginRemaining;
    }
    /**
     * Updates this transform given the current map projection and a reference.
     * @param mapProjection The current map projection.
     * @param reference The reference to use.
     * @param referenceMargin The reference margin, in pixels.
     */
    update(mapProjection, reference, referenceMargin) {
        this._scale = mapProjection.getScaleFactor() / reference.scaleFactor;
        this._rotation = mapProjection.getRotation() - reference.rotation;
        mapProjection.project(reference.center, this._translation);
        Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
        this._margin = referenceMargin * this._scale;
        this._marginRemaining = this._margin - Math.max(Math.abs(this._translation[0]), Math.abs(this._translation[1]));
    }
    /**
     * Copies another transform's parameters to this one.
     * @param other The other transform.
     */
    copyFrom(other) {
        this._scale = other.scale;
        this._rotation = other.rotation;
        this._translation.set(other.translation);
        this._margin = other.margin;
    }
}
/**
 * An implementation of MapCachedCanvasLayerCanvasInstance.
 */
class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @param getReferenceMargin A function which gets this canvas instance's reference margin, in pixels. The reference
     * margin is the maximum amount of translation allowed without invalidation at a scale factor of 1.
     */
    constructor(canvas, context, isDisplayed, getReferenceMargin) {
        super(canvas, context, isDisplayed);
        this.getReferenceMargin = getReferenceMargin;
        this._reference = new MapCachedCanvasLayerReferenceClass();
        this._transform = new MapCachedCanvasLayerTransformClass();
        this._isInvalid = false;
        this._geoProjection = new MercatorProjection();
        this.canvasTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.scale(), CssTransformBuilder.translate('px'), CssTransformBuilder.rotate('rad')));
        this.canvasTransform.sub(transform => { this.canvas.style.transform = transform; }, true);
    }
    /** @inheritdoc */
    get reference() {
        return this._reference;
    }
    /** @inheritdoc */
    get transform() {
        return this._transform;
    }
    /** @inheritdoc */
    get isInvalid() {
        return this._isInvalid;
    }
    /** @inheritdoc */
    get geoProjection() {
        return this._geoProjection;
    }
    /** @inheritdoc */
    syncWithMapProjection(mapProjection) {
        const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
        this._reference.syncWithMapProjection(mapProjection);
        this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
        this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
        this._isInvalid = false;
        if (this.isDisplayed) {
            this.transformCanvasElement();
        }
    }
    /** @inheritdoc */
    syncWithCanvasInstance(other) {
        this._reference.syncWithReference(other.reference);
        this._geoProjection.copyParametersFrom(other.geoProjection);
        this._transform.copyFrom(other.transform);
        this._isInvalid = other.isInvalid;
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     */
    updateTransform(mapProjection) {
        this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
        if (!this._isInvalid) {
            const scaleFactorRatio = mapProjection.getScaleFactor() / this._reference.scaleFactor;
            this._isInvalid = scaleFactorRatio >= MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD
                || scaleFactorRatio <= 1 / MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD
                || this._transform.marginRemaining < 0;
        }
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Transforms this instance's canvas element.
     */
    transformCanvasElement() {
        const transform = this.transform;
        const offsetX = transform.translation[0] / transform.scale;
        const offsetY = transform.translation[1] / transform.scale;
        this.canvasTransform.transform.getChild(0).set(transform.scale, transform.scale, 0.001);
        this.canvasTransform.transform.getChild(1).set(offsetX, offsetY, 0.1);
        this.canvasTransform.transform.getChild(2).set(transform.rotation, 1e-4);
        this.canvasTransform.resolve();
    }
    /** @inheritdoc */
    invalidate() {
        this._isInvalid = true;
        this.clear();
    }
}
MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD = 1.2;
MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
/**
 * A canvas map layer whose image can be cached and transformed as the map projection changes.
 */
class MapCachedCanvasLayer extends MapCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.size = 0;
        this.referenceMargin = 0;
        this.needUpdateTransforms = false;
        this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize() {
        return this.size;
    }
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale factor of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin() {
        return this.referenceMargin;
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed, this.getReferenceMargin.bind(this));
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        const projectedWidth = projectedSize[0];
        const projectedHeight = projectedSize[1];
        const diag = Math.hypot(projectedWidth, projectedHeight);
        this.size = diag * this.props.overdrawFactor;
        this.referenceMargin = (this.size - diag) / 2;
        this.setWidth(this.size);
        this.setHeight(this.size);
        const posX = (projectedWidth - this.size) / 2;
        const posY = (projectedHeight - this.size) / 2;
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = `${posX}px`;
        displayCanvas.style.top = `${posY}px`;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        var _a;
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
            this.display.invalidate();
            (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.invalidate();
        }
        this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        if (!this.needUpdateTransforms) {
            return;
        }
        this.updateTransforms();
    }
    /**
     * Updates this layer's canvas instances' transforms.
     */
    updateTransforms() {
        var _a;
        const mapProjection = this.props.mapProjection;
        this.display.updateTransform(mapProjection);
        (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.updateTransform(mapProjection);
        this.needUpdateTransforms = false;
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A layer which draws an own airplane icon. The icon is positioned at the projected location of the airplane and is
 * rotated to match the airplane's heading.
 */
class MapOwnAirplaneLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.imageFilePath = SubscribableUtils.isSubscribable(this.props.imageFilePath)
            ? this.props.imageFilePath.map(SubscribableMapFunctions.identity())
            : this.props.imageFilePath;
        this.style = ObjectSubject.create({
            display: '',
            position: 'absolute',
            left: '0px',
            top: '0px',
            width: '0px',
            height: '0px',
            transform: 'translate3d(0, 0, 0) rotate(0deg)',
            'transform-origin': '50% 50%'
        });
        this.ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        this.ownAirplaneIconModule = this.props.model.getModule('ownAirplaneIcon');
        this.iconSize = SubscribableUtils.toSubscribable(this.props.iconSize, true);
        this.iconAnchor = SubscribableUtils.toSubscribable(this.props.iconAnchor, true);
        this.iconOffset = Vec2Math.create();
        this.visibilityBounds = VecNMath.create(4);
        this.iconTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('deg'));
        this.isGsAboveTrackThreshold = this.ownAirplanePropsModule.groundSpeed.map(gs => gs.asUnit(UnitType.KNOT) >= 5).pause();
        this.showIcon = true;
        this.isInsideVisibilityBounds = true;
        this.planeRotation = 0;
        this.needUpdateVisibility = false;
        this.needUpdatePositionRotation = false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    /** @inheritdoc */
    onAttached() {
        this.showSub = this.ownAirplaneIconModule.show.sub(show => {
            this.needUpdateVisibility = true;
            this.needUpdatePositionRotation = this.showIcon = show && this.isVisible();
        });
        this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
            this.needUpdatePositionRotation = this.showIcon;
        });
        this.headingSub = this.ownAirplanePropsModule.hdgTrue.sub(hdg => {
            this.planeRotation = hdg;
            this.needUpdatePositionRotation = this.showIcon;
        }, false, true);
        this.trackSub = this.ownAirplanePropsModule.trackTrue.sub(track => {
            this.planeRotation = track;
            this.needUpdatePositionRotation = this.showIcon;
        }, false, true);
        this.trackThresholdSub = this.isGsAboveTrackThreshold.sub(isAboveThreshold => {
            if (isAboveThreshold) {
                this.headingSub.pause();
                this.trackSub.resume(true);
            }
            else {
                this.trackSub.pause();
                this.headingSub.resume(true);
            }
        }, false, true);
        this.iconSizeSub = this.iconSize.sub(size => {
            this.style.set('width', `${size}px`);
            this.style.set('height', `${size}px`);
            this.updateOffset();
        }, true);
        this.iconAnchorSub = this.iconAnchor.sub(() => {
            this.updateOffset();
        });
        this.orientationSub = this.ownAirplaneIconModule.orientation.sub(orientation => {
            switch (orientation) {
                case MapOwnAirplaneIconOrientation.HeadingUp:
                    this.isGsAboveTrackThreshold.pause();
                    this.trackThresholdSub.pause();
                    this.trackSub.pause();
                    this.headingSub.resume(true);
                    break;
                case MapOwnAirplaneIconOrientation.TrackUp:
                    this.headingSub.pause();
                    this.trackSub.pause();
                    this.isGsAboveTrackThreshold.resume();
                    this.trackThresholdSub.resume(true);
                    break;
                default:
                    this.needUpdatePositionRotation = this.showIcon;
                    this.isGsAboveTrackThreshold.pause();
                    this.trackThresholdSub.pause();
                    this.headingSub.pause();
                    this.trackSub.pause();
                    this.planeRotation = 0;
            }
        }, true);
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = true;
    }
    /**
     * Updates the icon's offset from the projected position of the airplane.
     */
    updateOffset() {
        const anchor = this.iconAnchor.get();
        this.iconOffset.set(anchor);
        Vec2Math.multScalar(this.iconOffset, -this.iconSize.get(), this.iconOffset);
        this.style.set('left', `${this.iconOffset[0]}px`);
        this.style.set('top', `${this.iconOffset[1]}px`);
        this.style.set('transform-origin', `${anchor[0] * 100}% ${anchor[1] * 100}%`);
        this.updateVisibilityBounds();
    }
    /**
     * Updates the boundaries within the map's projected window that define a region such that if the airplane's
     * projected position falls outside of it, the icon is not visible and therefore does not need to be updated.
     */
    updateVisibilityBounds() {
        const size = this.iconSize.get();
        // Find the maximum possible protrusion of the icon from its anchor point, defined as the distance from the
        // anchor point to the farthest point within the bounds of the icon. This farthest point is always one of the
        // four corners of the icon.
        const maxProtrusion = Math.max(Math.hypot(this.iconOffset[0], this.iconOffset[1]), // top left corner
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1]), // top right corner
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1] + size), // bottom right corner
        Math.hypot(this.iconOffset[0], this.iconOffset[1] + size));
        const boundsOffset = maxProtrusion + 50; // Add some additional buffer
        const projectedSize = this.props.mapProjection.getProjectedSize();
        this.visibilityBounds[0] = -boundsOffset;
        this.visibilityBounds[1] = -boundsOffset;
        this.visibilityBounds[2] = projectedSize[0] + boundsOffset;
        this.visibilityBounds[3] = projectedSize[1] + boundsOffset;
        this.needUpdatePositionRotation = this.showIcon;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateVisibilityBounds();
        }
        this.needUpdatePositionRotation = this.showIcon;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (this.needUpdatePositionRotation) {
            this.updateIconPositionRotation();
            this.needUpdatePositionRotation = false;
            this.needUpdateVisibility = false;
        }
        else if (this.needUpdateVisibility) {
            this.updateIconVisibility();
            this.needUpdateVisibility = false;
        }
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
        this.style.set('display', this.isInsideVisibilityBounds && this.showIcon ? '' : 'none');
    }
    /**
     * Updates the airplane icon's projected position and rotation.
     */
    updateIconPositionRotation() {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.vec2Cache[0]);
        this.isInsideVisibilityBounds = this.props.mapProjection.isInProjectedBounds(projected, this.visibilityBounds);
        // If the projected position of the icon is far enough out of bounds that the icon is not visible, do not bother to
        // update the icon.
        if (this.isInsideVisibilityBounds) {
            let rotation;
            switch (this.ownAirplaneIconModule.orientation.get()) {
                case MapOwnAirplaneIconOrientation.HeadingUp:
                case MapOwnAirplaneIconOrientation.TrackUp:
                    rotation = this.planeRotation + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
                    break;
                default:
                    rotation = 0;
            }
            this.iconTransform.getChild(0).set(projected[0], projected[1], 0, 0.1);
            this.iconTransform.getChild(1).set(rotation, 0.1);
            this.style.set('transform', this.iconTransform.resolve());
        }
        this.updateIconVisibility();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { src: this.imageFilePath, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: this.style }));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (SubscribableUtils.isSubscribable(this.imageFilePath)) {
            this.imageFilePath.destroy();
        }
        this.isGsAboveTrackThreshold.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.positionSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.headingSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.trackSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.trackThresholdSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.iconSizeSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.iconAnchorSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.orientationSub) === null || _h === void 0 ? void 0 : _h.destroy();
        super.destroy();
    }
}
MapOwnAirplaneLayer.vec2Cache = [Vec2Math.create()];

/**
 * A layer which displays text which can be culled to avoid overlap.
 */
class MapCullableTextLayer extends MapSyncedCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        this.props.manager.update(this.props.mapProjection);
        this.redrawLabels();
    }
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    redrawLabels() {
        const labels = this.props.manager.visibleLabels;
        const display = this.display;
        display.clear();
        for (let i = labels.length - 1; i >= 0; i--) {
            labels[i].draw(display.context, this.props.mapProjection);
        }
    }
}

/**
 * A layer which draws airspaces.
 */
class MapAirspaceLayer extends MapLayer {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.clipBoundsSub = VecNSubject.createFromVector(new Float64Array(4));
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), async () => {
            this.searchSession = new NearestLodBoundarySearchSession(this.props.lodBoundaryCache, await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary), 0.5);
            this.isAttached && this.scheduleSearch(0, true);
        });
        this.searchedAirspaces = new Map();
        this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;
        this.renderTimeBudget = (_b = this.props.renderTimeBudget) !== null && _b !== void 0 ? _b : MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;
        this.activeRenderProcess = null;
        this.renderTaskQueueHandler = {
            renderTimeBudget: this.renderTimeBudget,
            // eslint-disable-next-line jsdoc/require-jsdoc
            onStarted() {
                // noop
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
                return timeElapsed < this.renderTimeBudget;
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            onPaused: this.onRenderPaused.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onFinished: this.onRenderFinished.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onAborted: this.onRenderAborted.bind(this)
        };
        this.searchDebounceTimer = 0;
        this.isSearchScheduled = false;
        this.needRefilter = false;
        this.isSearchBusy = false;
        this.lastDesiredSearchRadius = 0; // meters
        this.lastSearchRadius = 0; // meters
        this.isRenderScheduled = false;
        this.isBackgroundRenderScheduled = false;
        this.isDisplayInvalidated = true;
        this.isAttached = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
        this.updateClipBounds();
        this.clippedPathStream = new ClippedPathStream(this.canvasLayerRef.instance.buffer.context, this.clipBoundsSub);
        this.props.maxSearchRadius.sub(radius => {
            const radiusMeters = radius.asUnit(UnitType.METER);
            if (radiusMeters < this.lastSearchRadius || radiusMeters > this.lastDesiredSearchRadius) {
                this.scheduleSearch(0, false);
            }
        });
        this.props.maxSearchItemCount.sub(() => { this.scheduleSearch(0, false); });
        this.initModuleListeners();
        this.isAttached = true;
        this.searchSession && this.scheduleSearch(0, true);
    }
    /**
     * Initializes this layer's airspace module property listeners.
     */
    initModuleListeners() {
        const airspaceModule = this.props.model.getModule('airspace');
        for (const type of Object.values(airspaceModule.show)) {
            type.sub(this.onAirspaceTypeShowChanged.bind(this));
        }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateClipBounds();
        }
    }
    /**
     * Updates this layer's canvas clipping bounds.
     */
    updateClipBounds() {
        const size = this.canvasLayerRef.instance.getSize();
        this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER, -MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER);
    }
    /**
     * Schedules a search. If a search was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     * @param refilter Whether to update the search's boundary class filter.
     */
    scheduleSearch(delay, refilter) {
        if (!this.searchSession) {
            return;
        }
        this.searchDebounceTimer = delay;
        this.isSearchScheduled = true;
        this.needRefilter || (this.needRefilter = refilter);
    }
    /**
     * Schedules a render to be executed during the next update cycle.
     */
    scheduleRender() {
        this.isRenderScheduled = true;
    }
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     * @param refilter Whether to update the search's boundary class filter.
     */
    async searchAirspaces(refilter) {
        this.isSearchBusy = true;
        const center = this.props.mapProjection.getCenter();
        const drawableDiag = this.canvasLayerRef.instance.display.canvas.width * Math.SQRT2;
        this.lastDesiredSearchRadius = UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution() * drawableDiag / 2, UnitType.METER);
        this.lastSearchRadius = Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER), this.lastDesiredSearchRadius);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const session = this.searchSession;
        refilter && session.setFilter(this.getBoundaryFilter());
        const results = await session.searchNearest(center.lat, center.lon, this.lastSearchRadius, this.props.maxSearchItemCount.get());
        for (let i = 0; i < results.added.length; i++) {
            const airspace = results.added[i];
            this.searchedAirspaces.set(airspace.facility.id, airspace);
        }
        for (let i = 0; i < results.removed.length; i++) {
            this.searchedAirspaces.delete(results.removed[i]);
        }
        this.isSearchBusy = false;
        this.scheduleRender();
    }
    /**
     * Gets the boundary class filter based on the current airspace type visibility settings.
     * @returns The boundary class filter based on the current airspace type visibility settings.
     */
    getBoundaryFilter() {
        const module = this.props.model.getModule('airspace');
        const show = module.show;
        let filter = 0;
        for (const type in show) {
            if (show[type].get()) {
                filter |= module.showTypes[type];
            }
        }
        return filter;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
        this.updateFromInvalidation();
        this.updateScheduledRender();
        this.updateScheduledSearch(elapsed);
    }
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    updateFromInvalidation() {
        const canvasLayer = this.canvasLayerRef.instance;
        const display = canvasLayer.display;
        const buffer = canvasLayer.buffer;
        const needBackgroundRender = !this.isBackgroundRenderScheduled
            && !this.activeRenderProcess
            && (display.transform.marginRemaining / display.transform.margin <= MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD);
        const shouldScheduleSearch = needBackgroundRender
            || display.isInvalid
            || (buffer.isInvalid && this.activeRenderProcess);
        this.isBackgroundRenderScheduled || (this.isBackgroundRenderScheduled = needBackgroundRender);
        if (display.isInvalid) {
            this.isDisplayInvalidated = true;
            this.isBackgroundRenderScheduled = false;
            display.clear();
            display.syncWithMapProjection(this.props.mapProjection);
        }
        if (buffer.isInvalid) {
            if (this.activeRenderProcess) {
                this.activeRenderProcess.abort();
                this.cleanUpRender();
            }
            buffer.clear();
            buffer.syncWithMapProjection(this.props.mapProjection);
        }
        if (shouldScheduleSearch) {
            this.scheduleSearch(this.searchDebounceDelay, false);
        }
    }
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledSearch(elapsed) {
        if (!this.isSearchScheduled) {
            return;
        }
        this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
        if (this.searchDebounceTimer === 0 && !this.isSearchBusy) {
            this.searchAirspaces(this.needRefilter);
            this.isSearchScheduled = false;
            this.needRefilter = false;
        }
    }
    /**
     * Executes a render if one is scheduled.
     */
    updateScheduledRender() {
        if (!this.isRenderScheduled) {
            return;
        }
        this.startRenderProcess();
        this.isRenderScheduled = false;
        this.isBackgroundRenderScheduled = false;
    }
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     */
    startRenderProcess() {
        const canvasLayer = this.canvasLayerRef.instance;
        if (this.activeRenderProcess) {
            this.activeRenderProcess.abort();
        }
        const buffer = canvasLayer.buffer;
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection);
        this.props.airspaceRenderManager.clearRegisteredAirspaces();
        for (const airspace of this.searchedAirspaces.values()) {
            if (this.isAirspaceInBounds(airspace, buffer)) {
                this.props.airspaceRenderManager.registerAirspace(airspace);
            }
        }
        const lod = this.selectLod(this.props.mapProjection.getProjectedResolution());
        this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection, buffer.context, this.renderTaskQueueHandler, lod, this.clippedPathStream);
        this.activeRenderProcess.start();
    }
    /**
     * Checks whether an airspace is within the projected bounds of a cached canvas instance.
     * @param airspace An airspace.
     * @param canvas A cached canvas instance.
     * @returns Whether the airspace is within the projected bounds of the cached canvas instance.
     */
    isAirspaceInBounds(airspace, canvas) {
        const corner = MapAirspaceLayer.geoPointCache[0];
        const cornerProjected = MapAirspaceLayer.vec2Cache[0];
        let minX, maxX, minY, maxY;
        canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.topLeft.long), cornerProjected);
        minX = maxX = cornerProjected[0];
        minY = maxY = cornerProjected[1];
        canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.bottomRight.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.bottomRight.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.topLeft.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        const width = canvas.canvas.width;
        const height = canvas.canvas.height;
        return minX < width
            && maxX > 0
            && minY < height
            && maxY > 0;
    }
    /**
     * Selects an LOD level based on projected map resolution.
     * @param resolution A projected map resolution, in great-arc radians per pixel.
     * @returns An LOD level based on the projected map resolution.
     */
    selectLod(resolution) {
        const thresholds = this.props.lodBoundaryCache.lodDistanceThresholds;
        let i = thresholds.length - 1;
        while (i >= 0) {
            if (resolution * 2 >= thresholds[i]) {
                break;
            }
            i--;
        }
        return i;
    }
    /**
     * Cleans up the active render process.
     */
    cleanUpRender() {
        this.canvasLayerRef.instance.buffer.reset();
        this.activeRenderProcess = null;
    }
    /**
     * Renders airspaces from the buffer to the display.
     */
    renderAirspacesToDisplay() {
        const display = this.canvasLayerRef.instance.display;
        const buffer = this.canvasLayerRef.instance.buffer;
        display.clear();
        display.syncWithCanvasInstance(buffer);
        this.canvasLayerRef.instance.copyBufferToDisplay();
    }
    /**
     * This method is called when the airspace render process pauses.
     */
    onRenderPaused() {
        if (this.isDisplayInvalidated) {
            this.renderAirspacesToDisplay();
        }
    }
    /**
     * This method is called when the airspace render process finishes.
     */
    onRenderFinished() {
        this.renderAirspacesToDisplay();
        this.cleanUpRender();
        this.isDisplayInvalidated = false;
    }
    /**
     * This method is called when the airspace render process is aborted.
     */
    onRenderAborted() {
        this.cleanUpRender();
    }
    /**
     * This method is called when an airspace show property changes.
     */
    onAirspaceTypeShowChanged() {
        this.scheduleSearch(0, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }));
    }
}
MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY = 500; // milliseconds
MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET = 0.2; // milliseconds per frame
MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD = 0.1; // relative to total margin
MapAirspaceLayer.CLIP_BOUNDS_BUFFER = 10; // number of pixels from edge of canvas to extend the clipping bounds, in pixels
MapAirspaceLayer.geoPointCache = [new GeoPoint(0, 0)];
MapAirspaceLayer.vec2Cache = [new Float64Array(2)];

/**
 * An abstract implementation of a map layer which displays waypoints (airports, navaids, and intersections) within a
 * search radius.
 */
class MapNearestWaypointsLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : 500;
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
        this.searchRadius = 0;
        this.searchMargin = 0;
        this.userFacilityHasChanged = false;
        /** A set of the ICAOs of all waypoints that should be rendered. */
        this.icaosToRender = new Set();
        /** A map of rendered waypoints from their ICAOs. */
        this.cachedRenderedWaypoints = new Map();
        this.isInit = false;
        this.facilityRepoSubs = [];
    }
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    onFacilityLoaderInitialized() {
        Promise.all([
            this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection),
            this.facLoader.startNearestSearchSession(FacilitySearchType.User)
        ]).then((value) => {
            const [airportSession, vorSession, ndbSession, intSession, userSession] = value;
            this.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
        });
    }
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     * @param userSession The user facility search session.
     */
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession) {
        const callback = this.processSearchResults.bind(this);
        this.facilitySearches = {
            [FacilitySearchType.Airport]: new MapNearestWaypointsLayerSearch(airportSession, callback),
            [FacilitySearchType.Vor]: new MapNearestWaypointsLayerSearch(vorSession, callback),
            [FacilitySearchType.Ndb]: new MapNearestWaypointsLayerSearch(ndbSession, callback),
            [FacilitySearchType.Intersection]: new MapNearestWaypointsLayerSearch(intSession, callback),
            [FacilitySearchType.User]: new MapNearestWaypointsLayerSearch(userSession, callback)
        };
        const sub = this.props.bus.getSubscriber();
        // Watch for changes to user facilities so that we can trigger search refreshes to ensure that the layer does not
        // display outdated user waypoints.
        this.facilityRepoSubs.push(sub.on('facility_added').handle(fac => {
            if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
                this.userFacilityHasChanged = true;
            }
        }), sub.on('facility_changed').handle(fac => {
            if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
                this.userFacilityHasChanged = true;
            }
        }), sub.on('facility_removed').handle(fac => {
            if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
                this.userFacilityHasChanged = true;
            }
        }));
        this.props.onSessionsStarted && this.props.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
        if (this.isInit) {
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.canvasLayerRef.instance.onAttached();
        this.doInit();
        this.isInit = true;
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
    }
    /**
     * Initializes this layer.
     */
    doInit() {
        this.initWaypointRenderer();
        this.updateSearchRadius();
    }
    /**
     * Gets the search center for the waypoint searches on this layer.
     * @returns The waypoint search center geo point.
     */
    getSearchCenter() {
        return this.props.getSearchCenter ? this.props.getSearchCenter(this.props.mapProjection) : this.props.mapProjection.getCenter();
    }
    /**
     * Initializes this layer's waypoint renderer.
     */
    initWaypointRenderer() {
        this.props.initRenderer && this.props.initRenderer(this.props.waypointRenderer, this.canvasLayerRef.instance);
    }
    /** Forces a refresh of all the waypoints. */
    refreshWaypoints() {
        this.tryRefreshAllSearches(undefined, undefined, true);
        this.cachedRenderedWaypoints.forEach(w => {
            this.props.deregisterWaypoint(w, this.props.waypointRenderer);
        });
        this.cachedRenderedWaypoints.forEach(w => {
            this.props.registerWaypoint(w, this.props.waypointRenderer);
        });
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.RangeEndpoints | MapProjectionChangeType.ProjectedSize)) {
            this.updateSearchRadius();
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
        else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
    }
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    updateSearchRadius() {
        let mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
        //Limit lower end of radius so that even at high zooms the surrounding area waypoints are captured.
        mapHalfDiagRange = Math.max(mapHalfDiagRange, UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
        this.searchRadius = mapHalfDiagRange * MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
        this.searchMargin = mapHalfDiagRange * (MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        var _a;
        // If a user facility was added, changed, or removed, schedule a user waypoint search refresh so that we always
        // have the latest user facility data.
        if (this.userFacilityHasChanged) {
            const search = (_a = this.facilitySearches) === null || _a === void 0 ? void 0 : _a[FacilitySearchType.User];
            if (search !== undefined) {
                this.userFacilityHasChanged = false;
                this.scheduleSearchRefresh(FacilitySearchType.User, search, this.getSearchCenter(), this.searchRadius);
            }
        }
        this.updateSearches(elapsed);
    }
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSearches(elapsed) {
        if (!this.facilitySearches) {
            return;
        }
        this.facilitySearches[FacilitySearchType.Airport].update(elapsed);
        this.facilitySearches[FacilitySearchType.Vor].update(elapsed);
        this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);
        this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);
        this.facilitySearches[FacilitySearchType.User].update(elapsed);
    }
    /**
     * Attempts to refresh all of the nearest facility searches. Searches will only be refreshed if the desired search
     * radius is different from the last refreshed search radius or the desired search center is outside of the margin
     * of the last refreshed search center.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshAllSearches(center, radius, force) {
        center !== null && center !== void 0 ? center : (center = this.getSearchCenter());
        radius !== null && radius !== void 0 ? radius : (radius = this.searchRadius);
        this._tryRefreshAllSearches(center, radius, force);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if the desired search radius is different
     * from the last refreshed search radius or the desired search center is outside of the margin of the last refreshed
     * search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshSearch(type, center, radius, force) {
        center !== null && center !== void 0 ? center : (center = this.getSearchCenter());
        radius !== null && radius !== void 0 ? radius : (radius = this.searchRadius);
        this._tryRefreshSearch(type, center, radius, force);
    }
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    _tryRefreshAllSearches(center, radius, force) {
        this._tryRefreshSearch(FacilitySearchType.Airport, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.Vor, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.Ndb, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.Intersection, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.User, center, radius, force);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if `this.shouldRefreshSearch()` returns
     * true and and the desired search radius is different from the last refreshed search radius or the desired search
     * center is outside of the margin of the last refreshed search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    _tryRefreshSearch(type, center, radius, force) {
        const search = this.facilitySearches && this.facilitySearches[type];
        if (!search || (!force && !this.shouldRefreshSearch(type, center, radius))) {
            return;
        }
        const radiusLimit = this.props.searchRadiusLimit ? this.props.searchRadiusLimit(type, center, radius) : undefined;
        if (radiusLimit !== undefined && isFinite(radiusLimit)) {
            radius = Math.min(radius, Math.max(0, radiusLimit));
        }
        if (force || search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            this.scheduleSearchRefresh(type, search, center, radius);
        }
    }
    /**
     * Checks whether one of this layer's searches should be refreshed.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @returns Whether the search should be refreshed.
     */
    shouldRefreshSearch(type, center, radius) {
        return this.props.shouldRefreshSearch ? this.props.shouldRefreshSearch(type, center, radius) : true;
    }
    /**
     * Schedules a refresh of this one of this layer's searches.
     * @param type The type of nearest search to refresh.
     * @param search The search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    scheduleSearchRefresh(type, search, center, radius) {
        const itemLimit = this.props.searchItemLimit ? this.props.searchItemLimit(type, center, radius) : 100;
        search.scheduleRefresh(center, radius, itemLimit, this.searchDebounceDelay);
    }
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are
     * deregistered.
     * @param results Nearest facility search results.
     */
    processSearchResults(results) {
        if (!results) {
            return;
        }
        const numAdded = results.added.length;
        for (let i = 0; i < numAdded; i++) {
            const icao = results.added[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.registerIcao(icao);
        }
        const numRemoved = results.removed.length;
        for (let i = 0; i < numRemoved; i++) {
            const icao = results.removed[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.deregisterIcao(icao);
        }
    }
    /**
     * Registers an ICAO string with this layer. Once an ICAO is registered, its corresponding facility is drawn to this
     * layer using a waypoint renderer.
     * @param icao The ICAO string to register.
     */
    async registerIcao(icao) {
        this.icaosToRender.add(icao);
        try {
            const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
            if (!this.icaosToRender.has(icao)) {
                return;
            }
            this.registerWaypointWithRenderer(this.props.waypointRenderer, facility);
        }
        catch (_a) {
            // noop
        }
    }
    /**
     * Registers a facility with this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to register.
     */
    registerWaypointWithRenderer(renderer, facility) {
        const waypoint = this.props.waypointForFacility(facility);
        this.cachedRenderedWaypoints.set(facility.icao, waypoint);
        this.props.registerWaypoint(waypoint, renderer);
    }
    /**
     * Deregisters an ICAO string from this layer.
     * @param icao The ICAO string to deregister.
     */
    async deregisterIcao(icao) {
        this.icaosToRender.delete(icao);
        try {
            const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
            if (this.icaosToRender.has(icao)) {
                return;
            }
            this.deregisterWaypointWithRenderer(this.props.waypointRenderer, facility);
        }
        catch (_a) {
            if (this.icaosToRender.has(icao)) {
                return;
            }
            // If we can't find the facility from the ICAO, it could be that the facility has been removed, in which case
            // we grab the cached waypoint (the waypoint that was most recently registered with the renderer under the
            // removed ICAO) and deregister it.
            const cachedWaypoint = this.cachedRenderedWaypoints.get(icao);
            if (cachedWaypoint !== undefined) {
                this.cachedRenderedWaypoints.delete(icao);
                this.props.deregisterWaypoint(cachedWaypoint, this.props.waypointRenderer);
            }
        }
    }
    /**
     * Deregisters a facility from this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to deregister.
     */
    deregisterWaypointWithRenderer(renderer, facility) {
        const waypoint = this.props.waypointForFacility(facility);
        this.cachedRenderedWaypoints.delete(facility.icao);
        this.props.deregisterWaypoint(waypoint, renderer);
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.canvasLayerRef.instance.setVisible(val);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.facilityRepoSubs.forEach(sub => { sub.destroy(); });
        super.destroy();
    }
}
MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
/**
 * A nearest facility search for MapAbstractNearestWaypointsLayer.
 */
class MapNearestWaypointsLayerSearch {
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session, refreshCallback) {
        this.session = session;
        this.refreshCallback = refreshCallback;
        this._lastCenter = new GeoPoint(0, 0);
        this._lastRadius = 0;
        this.maxItemCount = 0;
        this.refreshDebounceTimer = 0;
        this.isRefreshScheduled = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this search's last refresh.
     */
    get lastCenter() {
        return this._lastCenter.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius() {
        return this._lastRadius;
    }
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param maxItemCount The maximum number of results returned by the refresh.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center, radius, maxItemCount, delay) {
        this._lastCenter.set(center);
        this._lastRadius = radius;
        this.maxItemCount = maxItemCount;
        if (!this.isRefreshScheduled) {
            this.refreshDebounceTimer = delay;
            this.isRefreshScheduled = true;
        }
    }
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed) {
        if (!this.isRefreshScheduled) {
            return;
        }
        this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
        if (this.refreshDebounceTimer === 0) {
            this.refresh();
            this.isRefreshScheduled = false;
        }
    }
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled when the refresh completes.
     */
    async refresh() {
        const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxItemCount);
        this.refreshCallback(results);
    }
}

/**
 * A map controller.
 */
class MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     */
    constructor(context) {
        this._isAlive = true;
        this.context = context;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this controller is alive. */
    get isAlive() {
        return this._isAlive;
    }
    /**
     * This method is called after this controller' map is rendered.
     * @param ref A reference to the rendered map.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterMapRender(ref) {
        // noop
    }
    /**
     * This method is called when the dead zone of this controller's map changes.
     * @param deadZone The map's new dead zone.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDeadZoneChanged(deadZone) {
        // noop
    }
    /**
     * This method is called when the projection of this controller's map changes.
     * @param mapProjection The map projection.
     * @param changeFlags Bit flags describing the type of change.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called immediately before this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onBeforeUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called immediately after this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this controller's map is awakened.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this controller's map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when this controller's map is destroyed.
     */
    onMapDestroyed() {
        // noop
    }
    /**
     * Destroys this controller.
     */
    destroy() {
        this._isAlive = false;
    }
}

/**
 * A controller which maintains an arbitrary number of bindings.
 */
class MapBindingsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param bindings This controller's bindings.
     * @param onDestroy A function to execute when the controller is destroyed.
     */
    constructor(context, bindings, onDestroy) {
        super(context);
        this.bindings = bindings;
        this.onDestroy = onDestroy;
        this.maps = [];
        this.pipes = [];
    }
    /** @inheritdoc */
    onAfterMapRender() {
        for (const binding of this.bindings) {
            if ('map' in binding) {
                if ('sources' in binding) {
                    const map = MappedSubject.create(...binding.sources);
                    this.maps.push(map);
                    this.pipes.push(map.pipe(binding.target, binding.map));
                }
                else {
                    this.pipes.push(binding.source.pipe(binding.target, binding.map));
                }
            }
            else {
                this.pipes.push(binding.source.pipe(binding.target));
            }
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    onWake() {
        this.maps.forEach(map => { map.resume(); });
        this.pipes.forEach(pipe => { pipe.resume(true); });
    }
    /** @inheritdoc */
    onSleep() {
        this.maps.forEach(map => { map.pause(); });
        this.pipes.forEach(pipe => { pipe.pause(); });
    }
    /** @inheritdoc */
    destroy() {
        this.onDestroy && this.onDestroy();
        this.maps.forEach(map => { map.destroy(); });
        this.pipes.forEach(pipe => { pipe.destroy(); });
        super.destroy();
    }
}

/**
 * Updates a map at regular intervals based on event bus clock events.
 */
class MapClockUpdateController extends MapSystemController {
    /** @inheritdoc */
    onAfterMapRender(ref) {
        this.freqSub = this.context.updateFreq.sub(freq => {
            var _a;
            (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.clockSub = this.context.bus.getSubscriber().on('realTime').atFrequency(freq).handle(realTime => {
                ref.update(realTime);
            });
        }, true);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.freqSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/**
 * Controls the map system's flight plan module.
 */
class MapFlightPlanController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
        this.planCopiedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.targetPlanIndex));
            this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).planChanged.notify(this);
        };
        this.planCreatedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.planIndex));
        };
        this.planDeletedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(undefined);
        };
        this.planChangeHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).planChanged.notify(this);
        };
        this.planCalculatedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).planCalculated.notify(this);
        };
        this.activeLegChangedHandler = (evt) => {
            if (evt.type === ActiveLegType.Lateral) {
                this.flightPlanModule.getPlanSubjects(evt.planIndex).activeLeg.set(evt.index);
            }
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.fplCopiedSub = sub.on('fplCopied').handle(this.planCopiedHandler);
        this.fplCreatedSub = sub.on('fplCreated').handle(this.planCreatedHandler);
        this.fplDeletedSub = sub.on('fplDeleted').handle(this.planDeletedHandler);
        this.fplDirectToDataChangedSub = sub.on('fplDirectToDataChanged').handle(this.planChangeHandler);
        this.fplLoadedSub = sub.on('fplLoaded').handle(this.planCreatedHandler);
        this.fplOriginDestChangedSub = sub.on('fplOriginDestChanged').handle(this.planChangeHandler);
        this.fplProcDetailsChangedSub = sub.on('fplProcDetailsChanged').handle(this.planChangeHandler);
        this.fplSegmentChangeSub = sub.on('fplSegmentChange').handle(this.planChangeHandler);
        this.fplUserDataDeleteSub = sub.on('fplUserDataDelete').handle(this.planChangeHandler);
        this.fplUserDataSetSub = sub.on('fplUserDataSet').handle(this.planChangeHandler);
        this.fplActiveLegChangeSub = sub.on('fplActiveLegChange').handle(this.activeLegChangedHandler);
        this.fplCalculatedSub = sub.on('fplCalculated').handle(this.planCalculatedHandler);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super.destroy();
        (_a = this.fplCopiedSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.fplCreatedSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.fplDeletedSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.fplDirectToDataChangedSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.fplLoadedSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.fplOriginDestChangedSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.fplProcDetailsChangedSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.fplSegmentChangeSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.fplUserDataDeleteSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.fplUserDataSetSub) === null || _k === void 0 ? void 0 : _k.destroy();
        (_l = this.fplActiveLegChangeSub) === null || _l === void 0 ? void 0 : _l.destroy();
        (_m = this.fplCalculatedSub) === null || _m === void 0 ? void 0 : _m.destroy();
    }
}

/**
 * Controls the target position of a map to follow the player airplane.
 */
class MapFollowAirplaneController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.isFollowingAirplane = this.context.model.getModule(MapSystemKeys.FollowAirplane).isFollowing;
        this.mapProjectionParams = {
            target: new GeoPoint(0, 0)
        };
        this.targetControl = this.context[MapSystemKeys.TargetControl];
        this.targetControlConsumer = {
            priority: 0,
            onAcquired: () => {
                this.isFollowingAirplane.set(true);
            },
            onCeded: () => {
                this.isFollowingAirplane.set(false);
            }
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.targetControl.claim(this.targetControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.isFollowingAirplane.get()) {
            this.mapProjectionParams.target.set(this.ownAirplanePropsModule.position.get());
            this.context.projection.setQueued(this.mapProjectionParams);
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.targetControl.forfeit(this.targetControlConsumer);
    }
}

/**
 * An enumeration of possible map rotation types.
 */
var MapRotation;
(function (MapRotation) {
    /** Map up position does not follow a defined pattern. */
    MapRotation["Undefined"] = "Undefined";
    /** Map up position points towards true north. */
    MapRotation["NorthUp"] = "NorthUp";
    /** Map up position points towards the current airplane track. */
    MapRotation["TrackUp"] = "TrackUp";
    /** Map up position points towards the current airplane heading. */
    MapRotation["HeadingUp"] = "HeadingUp";
    /** Map up position points towards the current nav desired track. */
    MapRotation["DtkUp"] = "DtkUp";
})(MapRotation || (MapRotation = {}));
/**
 * A module describing the rotation behavior of the map.
 */
class MapRotationModule {
    constructor() {
        /** The type of map rotation to use. */
        this.rotationType = Subject.create(MapRotation.HeadingUp);
    }
}

/**
 * Controls the orientation of the own airplane icon set in {@link MapOwnAirplaneIconModule} based on a desired
 * orientation and the map rotation type. If the desired orientation matches the map rotation (e.g. both Heading Up),
 * the icon orientation is set to Map Up; otherwise the orientation is set to the desired orientation.
 */
class MapOwnAirplaneIconOrientationController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     */
    constructor(context, desiredOrientation) {
        super(context);
        this.ownAirplaneIconModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
        this.needUpdateIconOrientation = false;
        this.desiredIconOrientation = SubscribableUtils.toSubscribable(desiredOrientation, true);
        this.orientationState = MappedSubject.create(this.desiredIconOrientation, this.context.model.getModule(MapSystemKeys.Rotation).rotationType);
    }
    /** @inheritdoc */
    onAfterMapRender() {
        var _a;
        (_a = this.orientationState) === null || _a === void 0 ? void 0 : _a.sub(() => { this.needUpdateIconOrientation = true; }, true);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.needUpdateIconOrientation) {
            const [desiredOrientation, rotation] = this.orientationState.get();
            if ((desiredOrientation === MapOwnAirplaneIconOrientation.HeadingUp && rotation === MapRotation.HeadingUp)
                || (desiredOrientation === MapOwnAirplaneIconOrientation.TrackUp && rotation === MapRotation.TrackUp)) {
                this.ownAirplaneIconModule.orientation.set(MapOwnAirplaneIconOrientation.MapUp);
            }
            else {
                this.ownAirplaneIconModule.orientation.set(desiredOrientation);
            }
            this.needUpdateIconOrientation = false;
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        this.orientationState.destroy();
        super.destroy();
    }
}

/**
 * Updates the properties in a {@link MapOwnAirplanePropsModule}.
 */
class MapOwnAirplanePropsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz.
     */
    constructor(context, properties, updateFreq) {
        super(context);
        this.properties = properties;
        this.updateFreq = updateFreq;
        this.module = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.updateFreqSub = this.updateFreq.sub(freq => {
            var _a;
            for (const property of this.properties) {
                (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
                this.subs[property] = this.bindProperty(sub, property, freq);
            }
        }, true);
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
        switch (property) {
            case 'position':
                return sub.on('gps-position').atFrequency(updateFreq).handle(lla => { this.module.position.set(lla.lat, lla.long); });
            case 'altitude':
                return sub.on('indicated_alt').atFrequency(updateFreq).handle(alt => { this.module.altitude.set(alt, UnitType.FOOT); });
            case 'groundSpeed':
                return sub.on('ground_speed').atFrequency(updateFreq).handle(gs => { this.module.groundSpeed.set(gs, UnitType.KNOT); });
            case 'hdgTrue':
                return sub.on('hdg_deg_true').atFrequency(updateFreq).handle(hdg => { this.module.hdgTrue.set(hdg); });
            case 'trackTrue':
                return sub.on('track_deg_true').atFrequency(updateFreq).handle(track => { this.module.trackTrue.set(track); });
            case 'verticalSpeed':
                return sub.on('vertical_speed').atFrequency(updateFreq).handle(vs => { this.module.verticalSpeed.set(vs, UnitType.FPM); });
            case 'turnRate':
                return sub.on('delta_heading_rate').atFrequency(updateFreq).handle(turnRate => { this.module.turnRate.set(turnRate); });
            case 'isOnGround':
                return sub.on('on_ground').atFrequency(updateFreq).handle(isOnGround => { this.module.isOnGround.set(isOnGround); });
            case 'magVar':
                return sub.on('magvar').atFrequency(updateFreq).handle(magVar => { this.module.magVar.set(magVar); });
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const property of this.properties) {
            (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * Controls the rotation of a map based on the behavior defined in {@link MapRotationModule}.
 */
class MapRotationController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
        this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.rotationParam = {
            rotation: 0
        };
        this.hasRotationControl = false;
        this.rotationControl = this.context[MapSystemKeys.RotationControl];
        this.rotationControlConsumer = {
            priority: 0,
            onAcquired: () => {
                this.hasRotationControl = true;
            },
            onCeded: () => {
                this.hasRotationControl = false;
            }
        };
        this.rotationFuncs = {
            [MapRotation.NorthUp]: () => 0,
            [MapRotation.HeadingUp]: this.ownAirplanePropsModule === undefined
                ? () => 0
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                : () => -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD,
            [MapRotation.TrackUp]: this.ownAirplanePropsModule === undefined
                ? () => 0
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                : () => this.ownAirplanePropsModule.groundSpeed.get().asUnit(UnitType.KNOT) < 5
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    ? -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    : -this.ownAirplanePropsModule.trackTrue.get() * Avionics.Utils.DEG2RAD,
            [MapRotation.DtkUp]: () => 0 // TODO
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.rotationSub = this.rotationModule.rotationType.sub(type => {
            this.rotationFunc = this.rotationFuncs[type];
        }, true);
        this.rotationControl.claim(this.rotationControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.hasRotationControl && this.rotationFunc !== undefined) {
            this.rotationParam.rotation = this.rotationFunc();
            this.context.projection.setQueued(this.rotationParam);
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        super.onMapDestroyed();
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.rotationSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.rotationControl.forfeit(this.rotationControlConsumer);
    }
}

/**
 * Waypoint roles used by the map system waypoint display system.
 */
var MapSystemWaypointRoles;
(function (MapSystemWaypointRoles) {
    /** The normal waypoint display role. */
    MapSystemWaypointRoles["Normal"] = "Normal";
    /** The waypoint role for displaying waypoints along the flight plan. */
    MapSystemWaypointRoles["FlightPlan"] = "FlightPlan";
})(MapSystemWaypointRoles || (MapSystemWaypointRoles = {}));

/**
 * A map system layer that draws the flight plan.
 */
class MapSystemFlightPlanLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.instanceId = MapSystemFlightPlanLayer.instanceId++;
        this.flightPathLayerRef = FSComponent.createRef();
        this.waypointLayerRef = FSComponent.createRef();
        this.defaultRoleId = (_a = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan)) !== null && _a !== void 0 ? _a : 0;
        this.planModule = this.props.model.getModule(MapSystemKeys.FlightPlan);
        this.waypointPrefix = `${MapSystemFlightPlanLayer.WAYPOINT_PREFIX}_${this.instanceId}`;
        this.legWaypoints = new Map();
        this.waypointsUpdating = false;
        this.waypointId = 0;
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
        this.facWaypointCache = DefaultFacilityWaypointCache.getCache(this.props.bus);
        this.clipBounds = VecNSubject.create(new Float64Array(4));
        this.clippedPathStream = new ClippedPathStream(NullPathStream.INSTANCE, this.clipBounds);
        this.pathStreamStack = new GeoProjectionPathStreamStack(NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), Math.PI / 12, 0.25, 8);
        this.updateScheduled = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.flightPathLayerRef.instance.onAttached();
        this.waypointLayerRef.instance.onAttached();
        this.pathStreamStack.pushPostProjected(this.clippedPathStream);
        this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
        this.initWaypointRenderer();
        this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(() => this.updateScheduled = true);
        this.props.waypointRenderer.onRolesAdded.on(() => this.initWaypointRenderer());
        super.onAttached();
    }
    /**
     * Initializes the waypoint renderer for this layer.
     */
    initWaypointRenderer() {
        let hasDefaultRole = false;
        const flightPlanRoles = this.props.waypointRenderer.getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${this.props.planIndex}`);
        for (let i = 0; i < flightPlanRoles.length; i++) {
            const roleId = this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);
            if (roleId !== undefined) {
                this.props.waypointRenderer.setCanvasContext(roleId, this.waypointLayerRef.instance.display.context);
                this.props.waypointRenderer.setIconFactory(roleId, this.props.iconFactory);
                this.props.waypointRenderer.setLabelFactory(roleId, this.props.labelFactory);
                if (!hasDefaultRole) {
                    this.props.flightPathRenderer.defaultRoleId = roleId;
                    hasDefaultRole = true;
                }
            }
        }
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.flightPathLayerRef.instance.onUpdated(time, elapsed);
        this.waypointLayerRef.instance.onUpdated(time, elapsed);
        if (this.isVisible()) {
            const display = this.flightPathLayerRef.instance.display;
            if (display.isInvalid) {
                display.clear();
                display.syncWithMapProjection(this.props.mapProjection);
                this.updateScheduled = true;
            }
            if (this.updateScheduled) {
                if (!this.waypointsUpdating) {
                    this.updateWaypoints();
                }
                const context = display.context;
                display.clear();
                const plan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
                if (plan !== undefined) {
                    this.pathStreamStack.setProjection(display.geoProjection);
                    this.props.flightPathRenderer.render(plan, undefined, undefined, context, this.pathStreamStack);
                }
                this.updateScheduled = false;
            }
        }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        const size = this.flightPathLayerRef.instance.getSize();
        this.clipBounds.set(-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, -MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER);
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.waypointLayerRef.instance.setVisible(val);
        this.flightPathLayerRef.instance.setVisible(val);
    }
    /**
     * Updates waypoints for the flight plan.
     * @throws An error if the waypoints are already updating.
     */
    async updateWaypoints() {
        if (this.waypointsUpdating) {
            throw new Error('A flight plan waypoint update is already in progress.');
        }
        this.waypointsUpdating = true;
        const flightPlan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
        const activeLegIndex = this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();
        if (flightPlan === undefined) {
            for (const legWaypoint of this.legWaypoints.values()) {
                const [waypoint, roleId] = legWaypoint;
                this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            }
            this.legWaypoints.clear();
            this.waypointsUpdating = false;
            return;
        }
        const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
        const legsToDisplay = new Map();
        let legIndex = 0;
        for (const leg of flightPlan.legs()) {
            let roleId = this.defaultRoleId;
            const handler = this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);
            if (handler !== undefined) {
                roleId = handler(flightPlan, leg, activeLeg, legIndex, activeLegIndex);
            }
            if (roleId !== 0) {
                legsToDisplay.set(leg, roleId);
            }
            legIndex++;
        }
        // Remove records of legs that are no longer in the set of legs to display.
        for (const leg of this.legWaypoints) {
            const [legDefinition, legWaypoint] = leg;
            const [waypoint, roleId] = legWaypoint;
            if (!legsToDisplay.has(legDefinition)) {
                this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.delete(legDefinition);
            }
        }
        const waypointRefreshes = [];
        // Create or refresh waypoints to display
        for (const leg of legsToDisplay) {
            waypointRefreshes.push(this.buildPlanWaypoint(leg[0], leg[1]));
        }
        await Promise.all(waypointRefreshes);
        this.waypointsUpdating = false;
    }
    /**
     * Builds or refreshes a flight plan waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildPlanWaypoint(leg, roleId) {
        switch (leg.leg.type) {
            case LegType.CD:
            case LegType.VD:
            case LegType.CR:
            case LegType.VR:
            case LegType.FC:
            case LegType.FD:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.CI:
            case LegType.VI:
                await this.buildTerminatorWaypoint(leg, roleId);
                break;
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                break;
            default:
                await this.buildFixWaypoint(leg, roleId);
                break;
        }
    }
    /**
     * Builds a flight path terminator based waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildTerminatorWaypoint(leg, roleId) {
        var _a, _b, _c, _d, _e, _f;
        const currentLeg = this.legWaypoints.get(leg);
        if (currentLeg !== undefined) {
            const [waypoint, currentRoleId] = currentLeg;
            const lastVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 1];
            if (lastVector !== undefined) {
                if (!waypoint.location.get().equals(lastVector.endLat, lastVector.endLon)) {
                    this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                    const ident = (_c = leg.name) !== null && _c !== void 0 ? _c : '';
                    const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
                    this.legWaypoints.set(leg, [newWaypoint, roleId]);
                    this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                }
                else if (currentRoleId !== roleId) {
                    this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                    this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                    this.legWaypoints.set(leg, [waypoint, roleId]);
                }
            }
            else {
                this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            }
        }
        else {
            const lastVector = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) - 1];
            if (lastVector !== undefined) {
                const ident = (_f = leg.name) !== null && _f !== void 0 ? _f : '';
                const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
                this.legWaypoints.set(leg, [newWaypoint, roleId]);
                this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            }
        }
    }
    /**
     * Builds a standard facility fix waypoint for flight plan waypoint display.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildFixWaypoint(leg, roleId) {
        var _a;
        const legWaypoint = this.legWaypoints.get(leg);
        if (legWaypoint === undefined) {
            const facIcao = leg.leg.fixIcao;
            let facility;
            try {
                facility = await this.facLoader.getFacility(ICAO.getFacilityType(facIcao), facIcao);
            }
            catch (err) {
                /* continue */
            }
            if (facility !== undefined) {
                const waypoint = this.facWaypointCache.get(facility);
                const ident = (_a = leg.name) !== null && _a !== void 0 ? _a : '';
                const newWaypoint = new FlightPathWaypoint(waypoint.location, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
                this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.set(leg, [newWaypoint, roleId]);
            }
        }
        else {
            const [waypoint, currentRoleId] = legWaypoint;
            if (currentRoleId !== roleId) {
                this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.set(leg, [waypoint, roleId]);
            }
        }
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, overdrawFactor: Math.SQRT2, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }),
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_b = this.props.class) !== null && _b !== void 0 ? _b : '' })));
    }
}
MapSystemFlightPlanLayer.WAYPOINT_PREFIX = 'MapSystemFplLayer';
MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER = 10;
MapSystemFlightPlanLayer.instanceId = 0;

/**
 * TCAS operating modes.
 */
var TcasOperatingMode;
(function (TcasOperatingMode) {
    TcasOperatingMode["Off"] = "Off";
    TcasOperatingMode["Standby"] = "Standby";
    TcasOperatingMode["TAOnly"] = "TAOnly";
    TcasOperatingMode["TA_RA"] = "TA/RA";
    TcasOperatingMode["Test"] = "Test";
    TcasOperatingMode["Failed"] = "Failed";
})(TcasOperatingMode || (TcasOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TcasAlertLevel;
(function (TcasAlertLevel) {
    TcasAlertLevel[TcasAlertLevel["None"] = 0] = "None";
    TcasAlertLevel[TcasAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel[TcasAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel[TcasAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TcasAlertLevel || (TcasAlertLevel = {}));
/**
 * Bit flags describing TCAS resolution advisories.
 */
var TcasResolutionAdvisoryFlags;
(function (TcasResolutionAdvisoryFlags) {
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Corrective"] = 1] = "Corrective";
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["UpSense"] = 2] = "UpSense";
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DownSense"] = 4] = "DownSense";
    /** A resolution advisory which crosses an intruder's altitude. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Crossing"] = 8] = "Crossing";
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Climb"] = 16] = "Climb";
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Descend"] = 32] = "Descend";
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Increase"] = 64] = "Increase";
    /** A CLIMB or DESCEND resolution advisory that reverses sense. Commands a vertical speed above 1500 FPM or below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Reversal"] = 128] = "Reversal";
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceClimb"] = 256] = "ReduceClimb";
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceDescent"] = 512] = "ReduceDescent";
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotClimb"] = 1024] = "DoNotClimb";
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotDescend"] = 2048] = "DoNotDescend";
})(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
/**
 * Types of TCAS resolution advisories.
 */
var TcasResolutionAdvisoryType;
(function (TcasResolutionAdvisoryType) {
    /** Upward sense, positive, corrective, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["Climb"] = "Climb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingClimb"] = "CrossingClimb";
    /** Upward sense, positive, corrective, required vertical speed 1500 to 4400 fpm. */
    TcasResolutionAdvisoryType["MaintainClimb"] = "MaintainClimb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    /** Upward sense, positive, corrective, required vertical speed 2500 to 3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseClimb"] = "IncreaseClimb";
    /** Upward sense, positive, corrective, transition from downward sense, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["ReversalClimb"] = "ReversalClimb";
    /** Upward sense, negative, corrective, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceDescent"] = "ReduceDescent";
    /** Upward sense, negative, preventative, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend0"] = "DoNotDescend0";
    /** Upward sense, negative, preventative, required vertical speed >= -500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend500"] = "DoNotDescend500";
    /** Upward sense, negative, preventative, required vertical speed >= -1000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1000"] = "DoNotDescend1000";
    /** Upward sense, negative, preventative, required vertical speed >= -1500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1500"] = "DoNotDescend1500";
    /** Upward sense, negative, preventative, required vertical speed >= -2000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend2000"] = "DoNotDescend2000";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["Descend"] = "Descend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["CrossingDescend"] = "CrossingDescend";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["MaintainDescend"] = "MaintainDescend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    /** Downward sense, positive, corrective, required vertical speed -2500 to -3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseDescend"] = "IncreaseDescend";
    /** Downward sense, positive, corrective, transition from upward sense, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["ReversalDescend"] = "ReversalDescend";
    /** Downward sense, negative, corrective, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceClimb"] = "ReduceClimb";
    /** Downward sense, negative, preventative, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb0"] = "DoNotClimb0";
    /** Downward sense, negative, preventative, required vertical speed <= 500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb500"] = "DoNotClimb500";
    /** Downward sense, negative, preventative, required vertical speed <= 1000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1000"] = "DoNotClimb1000";
    /** Downward sense, negative, preventative, required vertical speed <= 1500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1500"] = "DoNotClimb1500";
    /** Downward sense, negative, preventative, required vertical speed <= 2000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb2000"] = "DoNotClimb2000";
    /** Clear of conflict. */
    TcasResolutionAdvisoryType["Clear"] = "Clear";
})(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
/**
 * A TCAS-II-like system.
 */
class Tcas {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.bus = bus;
        this.tfcInstrument = tfcInstrument;
        this.maxIntruderCount = maxIntruderCount;
        this.realTimeUpdateFreq = realTimeUpdateFreq;
        this.simTimeUpdateFreq = simTimeUpdateFreq;
        this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.intrudersRA = new Set();
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.ownAirplaneSubs = {
            position: GeoPointSubject.create(new GeoPoint(0, 0)),
            altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            groundTrack: ConsumerSubject.create(null, 0),
            groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
            verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
            radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            isOnGround: ConsumerSubject.create(null, false)
        };
        this.simTime = ConsumerSubject.create(null, 0);
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.alertLevelSubs = new Map();
        this.eventPublisher = this.bus.getPublisher();
        this.eventSubscriber = this.bus.getSubscriber();
        this.paSeparationCache = {
            horizontal: UnitType.NMILE.createNumber(0),
            vertical: UnitType.FOOT.createNumber(0)
        };
        this.sensitivity = this.createSensitivity();
        this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
        const fullRAOptions = {
            initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
            initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
            subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
            subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
            allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : (() => true),
            allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : (() => true),
            allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100),
            allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450)
        };
        this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
        return this.intrudersFiltered;
    }
    /**
     * Gets this system's resolution advisory host.
     * @returns This system's resolution advisory host.
     */
    getResolutionAdvisoryHost() {
        return this.resolutionAdvisoryHost;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
        // init contact listeners
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('traffic_contact_added');
        this.contactRemovedConsumer = sub.on('traffic_contact_removed');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        // add all existing contacts
        this.tfcInstrument.forEachContact(contact => { this.onContactAdded(contact.uid); });
        // init own airplane subjects
        sub.on('gps-position').atFrequency(this.realTimeUpdateFreq).handle(lla => {
            this.ownAirplaneSubs.position.set(lla.lat, lla.long);
            this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
        });
        sub.on('ground_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(gs => { this.ownAirplaneSubs.groundSpeed.set(gs); });
        sub.on('vertical_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(vs => { this.ownAirplaneSubs.verticalSpeed.set(vs); });
        sub.on('radio_alt').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(alt => { this.ownAirplaneSubs.radarAltitude.set(alt); });
        this.ownAirplaneSubs.groundTrack.setConsumer(sub.on('track_deg_true'));
        this.ownAirplaneSubs.isOnGround.setConsumer(sub.on('on_ground'));
        // init sim time subject
        this.simTime.setConsumer(sub.on('simTime'));
        // init operating mode notifier
        this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
        // init update loop
        sub.on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    onOperatingModeChanged(mode) {
        this.bus.pub('tcas_operating_mode', mode, false, true);
        if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
            // We are in a mode where TCAS is not operating normally.
            // Cancel any active resolution advisories.
            this.resolutionAdvisoryHost.cancel(this.simTime.get());
            // Clean up all intruders.
            for (let i = 0; i < this.intrudersFiltered.length; i++) {
                this.cleanUpIntruder(this.intrudersFiltered[i]);
            }
            this.intrudersFiltered = [];
        }
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
        // always sort intruders with valid predictions first
        if (a.isPredictionValid && !b.isPredictionValid) {
            return -1;
        }
        else if (!a.isPredictionValid && b.isPredictionValid) {
            return 1;
        }
        else if (a.isPredictionValid) {
            let tcaPredictionA, tcaPredictionB;
            // Always sort intruders predicted to violate RA protected volume first (or for whom an RA has been issued), then
            // TA protected volume (or for whom a TA has been issued)
            const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (a.tcaRA.isValid && a.tcaRA.isThreat);
            const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (b.tcaRA.isValid && b.tcaRA.isThreat);
            if (aRA && !bRA) {
                return -1;
            }
            else if (!aRA && bRA) {
                return 1;
            }
            else if (aRA && bRA) {
                tcaPredictionA = a.tcaRA;
                tcaPredictionB = b.tcaRA;
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (a.tcaTA.isValid && a.tcaTA.isThreat);
                const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (b.tcaTA.isValid && b.tcaTA.isThreat);
                if (aTA && !bTA) {
                    return -1;
                }
                else if (!aTA && bTA) {
                    return 1;
                }
                else if (aTA && bTA) {
                    tcaPredictionA = a.tcaTA;
                    tcaPredictionB = b.tcaTA;
                }
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
                    return -1;
                }
                else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            // If both are predicted to violate the RA or TA protected volume, sort by time to CPA.
            // Otherwise sort by how close they approach the protected volume at CPA.
            const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
            const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
            let firstComparison;
            let secondComparison;
            if (tcaPredictionA.isThreat) {
                firstComparison = tcaComparison;
                secondComparison = normComparison;
            }
            else {
                firstComparison = normComparison;
                secondComparison = tcaComparison;
            }
            if (firstComparison === 0) {
                return secondComparison;
            }
            else {
                return firstComparison;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
        const contact = this.tfcInstrument.getContact(uid);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
        const sortedIndex = this.intrudersSorted.findIndex(intruder => intruder.contact.uid === uid);
        const culledIndex = this.intrudersFiltered.findIndex(intruder => intruder.contact.uid === uid);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
        switch (this.operatingModeSub.get()) {
            case TcasOperatingMode.Off:
            case TcasOperatingMode.Standby:
            case TcasOperatingMode.Failed:
            case TcasOperatingMode.Test: // TODO: support TEST mode
                return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq) {
            return;
        }
        this.doUpdate(simTime);
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    doUpdate(simTime) {
        this.updateSensitivity();
        this.updateIntruderPredictions(simTime);
        this.updateIntruderArrays();
        this.updateFilteredIntruderAlertLevels(simTime);
        this.updateResolutionAdvisory(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateIntruderPredictions(simTime) {
        this.ownAirplane.update(simTime);
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            const sensitivity = this.sensitivity.selectParameters(intruder);
            intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
        }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
            const intruder = this.intrudersSorted[i];
            if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filterIntruder(intruder) {
        return true;
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateFilteredIntruderAlertLevels(simTime) {
        let taCount = 0, raCount = 0;
        const len = this.intrudersFiltered.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersFiltered[i];
            this.updateIntruderAlertLevel(simTime, intruder);
            switch (intruder.alertLevel.get()) {
                case TcasAlertLevel.TrafficAdvisory:
                    taCount++;
                    break;
                case TcasAlertLevel.ResolutionAdvisory:
                    raCount++;
                    break;
            }
        }
        this.eventPublisher.pub('tcas_ta_intruder_count', taCount, false, true);
        this.eventPublisher.pub('tcas_ra_intruder_count', raCount, false, true);
    }
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    updateIntruderAlertLevel(simTime, intruder) {
        const currentAlertLevel = intruder.alertLevel.get();
        if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
            if (this.canIssueResolutionAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory
            && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat)
            && !this.canCancelResolutionAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
            if (this.canIssueTrafficAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory
            && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat)
            && !this.canCancelTrafficAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.isPredictionValid) {
            const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
            const radius = parametersPA.protectedRadius;
            const height = parametersPA.protectedHeight;
            if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
                intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
                if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0
                    && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
                    intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
                    return;
                }
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
            return;
        }
        intruder.alertLevel.set(TcasAlertLevel.None);
    }
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() === TcasOperatingMode.TA_RA
            && intruder.tcaRA.isValid
            && intruder.tcaRA.tcpa.number > 0
            && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA
            || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateResolutionAdvisory(simTime) {
        if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
            this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
        }
        else {
            this.resolutionAdvisoryHost.cancel(simTime);
        }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
        this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
        this.eventPublisher.pub('tcas_intruder_added', intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
        var _a;
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.delete(intruder);
        }
        (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
        this.eventPublisher.pub('tcas_intruder_removed', intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.add(intruder);
        }
        else {
            this.intrudersRA.delete(intruder);
        }
        this.eventPublisher.pub('tcas_intruder_alert_changed', intruder, false, false);
    }
}
Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
};
/**
 * An airplane managed by TCAS.
 */
class TcasAirplane {
    constructor() {
        this._position = new GeoPoint(0, 0);
        /** The position of this airplane at the time of the most recent update. */
        this.position = this._position.readonly;
        /** The altitude of this airplane at the time of the most recent update. */
        this._altitude = UnitType.FOOT.createNumber(0);
        this.altitude = this._altitude.readonly;
        this._groundTrack = 0;
        /** The ground speed of this airplane at the time of the most recent update. */
        this._groundSpeed = UnitType.KNOT.createNumber(0);
        this.groundSpeed = this._groundSpeed.readonly;
        /** The vertical speed of this airplane at the time of the most recent update. */
        this._verticalSpeed = UnitType.FPM.createNumber(0);
        this.verticalSpeed = this._verticalSpeed.readonly;
        /**
         * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
         * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
         * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
         * airplane.
         */
        this.positionVec = new Float64Array(3);
        /**
         * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters per second. The coordinate system is defined the same as for position vectors.
         */
        this.velocityVec = new Float64Array(3);
        this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
        return this._groundTrack;
    }
}
/**
 * The own airplane managed by TCAS.
 */
class OwnAirplane extends TcasAirplane {
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
        super();
        this.subs = subs;
        /** The radar altitude of this airplane at the time of the most recent update. */
        this._radarAltitude = UnitType.FOOT.createNumber(0);
        this.radarAltitude = this._radarAltitude.readonly;
        this._isOnGround = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this airplane is on the ground. */
    get isOnGround() {
        return this._isOnGround;
    }
    /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime, out) {
        const dt = (simTime - this.lastUpdateTime) / 1000;
        return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
        this.updateParameters();
        this.updateVectors();
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    updateParameters() {
        this._position.set(this.subs.position.get());
        this._altitude.set(this.subs.altitude.get());
        this._groundTrack = this.subs.groundTrack.get();
        this._groundSpeed.set(this.subs.groundSpeed.get());
        this._verticalSpeed.set(this.subs.verticalSpeed.get());
        this._radarAltitude.set(this.subs.radarAltitude.get());
        this._isOnGround = this.subs.isOnGround.get();
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
        Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
}
/**
 * An abstract implementation of {@link TcasIntruder}.
 */
class AbstractTcasIntruder extends TcasAirplane {
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
        super();
        this.contact = contact;
        this.alertLevel = Subject.create(TcasAlertLevel.None);
        /** The 3D position vector of this intruder relative to own airplane. */
        this.relativePositionVec = new Float64Array(3);
        /** The 3D velocity vector of this intruder relative to own airplane. */
        this.relativeVelocityVec = new Float64Array(3);
        this._isPredictionValid = false;
        /** @inheritdoc */
        this.tcaTA = new TcasTcaPredictionClass(this);
        /** @inheritdoc */
        this.tcaRA = new TcasTcaPredictionClass(this);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
        return this._isPredictionValid;
    }
    /** @inheritdoc */
    predictDisplacement(simTime, out) {
        if (!this._isPredictionValid) {
            return Vec3Math.set(NaN, NaN, NaN, out);
        }
        const dt = (simTime - this.contact.lastContactTime) / 1000;
        return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    /** @inheritdoc */
    predictSeparation(simTime, horizontalOut, verticalOut) {
        if (!this._isPredictionValid) {
            horizontalOut.set(NaN);
            verticalOut.set(NaN);
            return;
        }
        const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
        AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
        AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime, ownAirplane, sensitivity) {
        this.updateParameters(simTime, ownAirplane);
        if (this.isPredictionValid) {
            const taParams = sensitivity.parametersTA;
            const raParams = sensitivity.parametersRA;
            this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
            this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
        }
        else {
            this.invalidatePredictions();
        }
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
        if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
            this._isPredictionValid = false;
            this._position.set(NaN, NaN);
            this._altitude.set(NaN);
            this._groundTrack = NaN;
            this._groundSpeed.set(NaN);
            this._verticalSpeed.set(NaN);
            Vec3Math.set(NaN, NaN, NaN, this.positionVec);
            Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
        }
        else {
            this.updatePosition(simTime, ownAirplane);
            this.updateVelocity(ownAirplane);
            this._groundSpeed.set(this.contact.groundSpeed);
            this._verticalSpeed.set(this.contact.verticalSpeed);
            this._isPredictionValid = true;
        }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
        this.contact.predict(simTime, this._position, this._altitude);
        this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
        const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
        const bearing = ownAirplane.position.bearingTo(this._position);
        Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
        const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
        this.positionVec[2] = verticalPosition;
        Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    updateVelocity(ownAirplane) {
        Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
        Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePredictions() {
        this.tcaTA.invalidate();
        this.tcaRA.invalidate();
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
        return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
        return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
}
AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
/**
 * An default implementation of {@link TcasIntruder}.
 */
class DefaultTcasIntruder extends AbstractTcasIntruder {
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
class TcasTcaPredictionClass {
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder) {
        this.intruder = intruder;
        this._isValid = false;
        this._time = NaN;
        this._tcpa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcpa = this._tcpa.readonly;
        this._tcoa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcoa = this._tcoa.readonly;
        this._isThreat = false;
        /** @inheritdoc */
        this.cpaDisplacement = new Float64Array(3);
        this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
        /** @inheritdoc */
        this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
        this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
        /** @inheritdoc */
        this.cpaVerticalSep = this._cpaVerticalSep.readonly;
        this._cpaNorm = NaN;
    }
    /** @inheritdoc */
    get isValid() {
        return this._isValid;
    }
    /** @inheritdoc */
    get time() {
        return this._time;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get isThreat() {
        return this._isThreat;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get cpaNorm() {
        return this._cpaNorm;
    }
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tau The maximum lookahead time.
     * @param dmod The radius of the own airplane's protected volume.
     * @param zthr The half-height of the own airplane's protected volume.
     * @param hmd The distance threshold for the horizontal miss distance filter. If not defined, the HMD filter will
     * not be applied.
     */
    update(simTime, tau, dmod, zthr, hmd) {
        var _a;
        this._time = simTime;
        if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
            this.invalidate();
            return;
        }
        // Source: Munoz, CA and Narkawicz, AJ. "A TCAS-II Resolution Advisory Detection Algorithm."
        // https://ntrs.nasa.gov/api/citations/20140002736/downloads/20140002736.pdf
        const tauSeconds = tau.asUnit(UnitType.SECOND);
        const s = this.intruder.relativePositionVec;
        const v = this.intruder.relativeVelocityVec;
        const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
        const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
        const h = zthr.asUnit(UnitType.METER);
        const r = dmod.asUnit(UnitType.METER);
        const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
        const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
        const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
        const rSquared = r * r;
        // Time to closest horizontal approach
        const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
        // Modified tau
        const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
        // Time to co-altitude
        const tcoa = -s[2] / v[2];
        const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
        const isVerticalThreat = Math.abs(s[2]) <= h || (tcoa >= 0 && tcoa <= tauSeconds);
        let passHmdFilter = true;
        if (hmd !== undefined && isHorizontalThreat && isVerticalThreat) {
            const d = hmd.asUnit(UnitType.METER);
            const dSquared = d * d;
            if (vHorizSquared === 0) {
                passHmdFilter = sHorizSquared <= dSquared;
            }
            else {
                const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
                if (delta < 0) {
                    passHmdFilter = false;
                }
                else {
                    const a = vHorizSquared;
                    const b = 2 * dotSHorizVHoriz;
                    const c = sHorizSquared - dSquared;
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant < 0) {
                        passHmdFilter = false;
                    }
                    else {
                        passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
                    }
                }
            }
        }
        this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
        this._tcpa.set(tcpa);
        this._tcoa.set(tcoa);
        TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
        AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
        AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
        this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
        this._isValid = true;
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate() {
        this._isValid = false;
        this._isThreat = false;
        this._tcpa.set(NaN);
        this._tcoa.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
        this._cpaHorizontalSep.set(NaN);
        this._cpaVerticalSep.set(NaN);
        this._cpaNorm = NaN;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
        return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
        const horizLength = Math.hypot(vector[0], vector[1]);
        return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
}
TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
/**
 * An implementation of {@link TcasResolutionAdvisoryHost}.
 */
class TcasResolutionAdvisoryHostClass {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how the host should calculate resolution advisories.
     * @param ownAirplane The own airplane.
     */
    constructor(bus, options, ownAirplane) {
        this.options = options;
        this.ownAirplane = ownAirplane;
        this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
        this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
        this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.intruders = new Set();
        this.intruderArray = [];
        this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
        this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.minVerticalSpeed = this._minVerticalSpeed.readonly;
        this._flags = 0;
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._secondaryType = null;
        this._primaryFlags = 0;
        this._secondaryFlags = 0;
        this.vsConstraints = [];
        this.lastStateChangeTime = 0;
        this.stateChangeDelay = 0;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    get flags() {
        return this._flags;
    }
    /** @inheritdoc */
    get primaryType() {
        return this._primaryType;
    }
    /** @inheritdoc */
    get secondaryType() {
        return this._secondaryType;
    }
    /** @inheritdoc */
    get primaryFlags() {
        return this._primaryFlags;
    }
    /** @inheritdoc */
    get secondaryFlags() {
        return this._secondaryFlags;
    }
    /**
     * Checks whether this host can issue a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder The query intruder.
     * @returns Whether this host can issue a resolution advisory for an intruder.
     */
    canIssueResolutionAdvisory(simTime, intruder) {
        // Inhibit resolution advisories for intruders whose time to closest horizontal approach is less than or equal to
        // zero (indicating the closest point of approach has already been passed) and whose horizontal separation from the
        // own airplane is increasing.
        if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
            return false;
        }
        if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Checks whether this host can cancel a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @returns Whether this host can cancel a resolution advisory for an intruder.
     */
    canCancelResolutionAdvisory(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Updates this host's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    update(simTime, alim, intruders) {
        if (this.intruderArray.length === 0 && intruders.size === 0) {
            return;
        }
        if (simTime < this.lastStateChangeTime) {
            this.lastStateChangeTime = simTime;
        }
        if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
            return;
        }
        if (intruders.size === 0) {
            this.cancel(simTime);
        }
        else {
            const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
            const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
            const alimMeters = alim.asUnit(UnitType.METER);
            const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
            const responseTimeSecondsRemaining = isInitial
                ? responseTimeSeconds
                : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1000, 0, responseTimeSeconds);
            const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
            this.updateIntruders(intruders);
            this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
            if (isInitial) {
                this.selectInitialState(simTime, ownAirplaneVsMps);
            }
            else {
                if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
                    this.updatePositive(simTime);
                }
                else if (this._secondaryType === null) {
                    this.updateNegative(simTime, ownAirplaneVsMps);
                }
                else {
                    this.updateComposite(simTime, ownAirplaneVsMps);
                }
            }
        }
    }
    /**
     * Updates this host's resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    updateIntruders(intruders) {
        // Remove one sense reversal used for every intruder that was removed from the RA.
        for (let i = 0; i < this.intruderArray.length; i++) {
            if (!intruders.has(this.intruderArray[i])) {
                this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
            }
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        for (const intruder of intruders) {
            this.intruders.add(intruder);
            this.intruderArray.push(intruder);
        }
        this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    /**
     * Updates the vertical speed constraints associated with the intruders participating in this host's current
     * resolution advisory.
     * @param alimMeters The value of ALIM (the minimum desired vertical separation between the own airplane and an
     * intruder at time of closest approach), in meters.
     * @param responseTimeSeconds The predicted amount of time, in seconds, for the own airplane to respond to the most
     * recently issued resolution advisory, relative to the present.
     * @param accelMps The predicted vertical acceleration, in meters per second squared, of the own airplane when
     * responding to the most recently issued resolution advisory.
     */
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
        var _a;
        var _b;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        for (let i = 0; i < this.intruderArray.length; i++) {
            const intruder = this.intruderArray[i];
            let above = -Infinity;
            let below = Infinity;
            if (intruder.tcaRA.isValid) {
                const t0 = intruder.tcaRA.time;
                const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
                const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1000;
                const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
                const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                // The altitude own airplane needs to be above in order to pass above the intruder with ALIM vertical separation at CPA.
                const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
                // The altitude own airplane needs to be below in order to pass below the intruder with ALIM vertical separation at CPA.
                const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
                const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
                const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
                if (aboveAlimSense === 1) {
                    // Own airplane needs to adjust vertical speed in the positive direction in order to pass above the intruder with
                    // ALIM vertical separation at CPA.
                    above = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters)
                        : NaN;
                    if (isNaN(above)) {
                        above = Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass above the intruder with ALIM vertical separation at CPA.
                    above = tcpaSeconds > 0
                        ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : -Infinity;
                }
                if (belowAlimSense === -1) {
                    // Own airplane needs to adjust vertical speed in the negative direction in order to pass below the intruder with
                    // ALIM vertical separation at CPA
                    below = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters)
                        : NaN;
                    if (isNaN(below)) {
                        below = -Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass below the intruder with ALIM vertical separation at CPA.
                    below = tcpaSeconds > 0
                        ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : Infinity;
                }
            }
            const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : (_b[i] = { above: 0, below: 0 });
            constraint.above = above;
            constraint.below = below;
        }
        this.vsConstraints.length = this.intruderArray.length;
    }
    /**
     * Selects an initial state for a new resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    selectInitialState(simTime, ownAirplaneVsMps) {
        // We need to first select either upward or downward sense.
        // The minimum vertical speed own airplane can target while still achieving ALIM separation ABOVE all intruders
        let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
        // The maximum vertical speed own airplane can target while still achieving ALIM separation BELOW all intruders
        let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
        // The strongest initial upward and downward sense RAs are CLIMB and DESCEND, respectively (or their crossing/maintain
        // variants, but all have the same vertical speed target).
        let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
        const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
        const canClimb = this.options.allowClimb(simTime);
        const canDescend = this.options.allowDescend(simTime);
        const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
        const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
        minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
        maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
        let sense;
        let senseIsCrossing = false;
        let doesSenseAchieveAlim = false;
        let senseRequiredVs = 0;
        // If one sense RA achieves ALIM separation and the other does not, choose the one that achieves ALIM separation.
        if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
            sense = 1;
        }
        else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
            sense = -1;
        }
        else {
            // If both or neither sense RA achieves ALIM separation, choose the non-crossing sense. Only the closest intruder
            // is evaluated, since in a multi-intruder RA there is the opportunity to reverse sense with each intruder.
            const closestIntruder = this.intruderArray[0];
            const t0 = closestIntruder.tcaRA.time;
            const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
            const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
            const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
            const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
            if (crossingSense === -1 && !isUpSenseInhibited) {
                sense = 1;
            }
            else if (crossingSense === 1 && !isDownSenseInhibited) {
                sense = -1;
            }
            else {
                // If neither sense is crossing or the non-crossing sense is inhibited, choose the one that is not inhibited.
                if (!isUpSenseInhibited && isDownSenseInhibited) {
                    sense = 1;
                }
                else if (isUpSenseInhibited && !isDownSenseInhibited) {
                    sense = -1;
                }
                else {
                    // If neither or both senses are inhibited, choose the one that gives the greatest potential separation at
                    // CPA (i.e. the one that requires the least change in vertical speed). Again, only the closest intruder is evaluated.
                    if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
                        sense = 1;
                    }
                    else {
                        sense = -1;
                    }
                }
                senseIsCrossing = sense === crossingSense;
            }
        }
        doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
        doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
        doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
        senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
        // For multi-intruder RAs, there is the option to choose an initial composite RA which combines two negative RAs of
        // opposite senses.
        if (this.intruderArray.length > 1) {
            // Because the composite RA always includes a vertical speed of 0 within its vertical speed target range, it
            // achieves ALIM separation from all intruders if and only if a vertical speed of 0 does.
            const doesCompositeAchieveAlim = this.vsConstraints.every(constraint => constraint.above <= 0 || constraint.below >= 0);
            // If the composite RA achieves ALIM separation from all intruders and the selected up/down sense RA does not,
            // choose the composite RA.
            if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
                sense = 0;
                doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
            else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
                // If both or neither the composite RA or the selected up/down sense RA achieves ALIM separation from all
                // intruders, choose the composite RA if the up/down sense RA is crossing.
                if (senseIsCrossing) {
                    sense = 0;
                    doesSenseAchieveAlim = doesCompositeAchieveAlim;
                }
                else {
                    // If both or neither the composite RA or the selected up/down sense RA is crossing, choose the one that
                    // provides the greatest potential vertical separation at CPA. Again, only the closest intruder is
                    // evaluated.
                    if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
                        sense = 0;
                        doesSenseAchieveAlim = doesCompositeAchieveAlim;
                    }
                }
            }
        }
        // Now that we have selected the sense, we need to choose the appropriate initial RA type.
        let primaryType;
        let secondaryType = null;
        switch (sense) {
            case 0: // Composite RA
                if (doesSenseAchieveAlim) {
                    // Find the vertical speed limits required to achieve ALIM separation.
                    const maxVsMps = this.getCompositeRequiredMaxVs();
                    const minVsMps = this.getCompositeRequiredMinVs();
                    if (ownAirplaneVsMps > maxVsMps) {
                        // Downward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                    }
                    else if (ownAirplaneVsMps < minVsMps) {
                        // Upward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                    else {
                        // Preventative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                }
                else {
                    primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
                }
                break;
            case 1: // Upward sense single RA
                if (ownAirplaneVsMps < minUpSenseVsMps) {
                    // Corrective
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    }
                }
                else {
                    // Preventative
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
                    }
                }
                break;
            case -1: // Downward sense single RA
                if (ownAirplaneVsMps > maxDownSenseVsMps) {
                    // Corrective
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                    }
                }
                else {
                    // Preventative
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
                    }
                }
                break;
        }
        this.setState(simTime, primaryType, secondaryType, true);
    }
    /**
     * Updates an existing positive resolution advisory. Positive resolution advisories include the CLIMB and DESCEND and
     * related types (CROSSING, MAINTAIN, INCREASE, REVERSAL).
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updatePositive(simTime) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
        // Check if we are inhibited, if so -> convert the current RA to its negative preventative counterpart.
        const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        if (isInhibited) {
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
            return;
        }
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, attempt to
        // weaken the RA. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            // If weakening to a REDUCE CLIMB/DESCENT RA would still provide ALIM separation, do so.
            if (requiredVsMps * sense <= 0) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
            }
        }
        else {
            // Check if strengthening to an INCREASE CLIMB/DESCENT RA would provide ALIM separation
            const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
            let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
            }
        }
    }
    /**
     * Updates an existing negative resolution advisory. Negative resolution advisories include the REDUCE CLIMB/DESCENT
     * and DO NOT CLIMB/DESCEND types.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    updateNegative(simTime, ownAirplaneVsMps) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, we do nothing since
        // negative RAs cannot be weakened. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            return;
        }
        const requirePositive = requiredVsMps * sense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // negative RA we can.
        }
        if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
            // We need to issue a corrective negative RA.
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            this.setState(simTime, sense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
        }
    }
    /**
     * Updates an existing composite resolution advisory. Composite resolution advisories consist of a (corrective or
     * preventative) negative resolution advisory combined with a negative preventative resolution advisory of the
     * opposite sense.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     * @throws Error if a composite resolution advisory is not active.
     */
    updateComposite(simTime, ownAirplaneVsMps) {
        if (this._secondaryType === null) {
            throw new Error('TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active');
        }
        const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
        const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredMinVsMps = this.getCompositeRequiredMinVs();
        const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
        const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
        if (primarySense === 1) {
            primaryCurrentVsMps = currentMinVsMps;
            primaryRequiredVsMps = requiredMinVsMps;
            secondaryCurrentVsMps = currentMaxVsMps;
            secondaryRequiredVsMps = requiredMaxVsMps;
        }
        else {
            primaryCurrentVsMps = currentMaxVsMps;
            primaryRequiredVsMps = requiredMaxVsMps;
            secondaryCurrentVsMps = currentMinVsMps;
            secondaryRequiredVsMps = requiredMinVsMps;
        }
        const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
        const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
        const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0
            || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // pair of negative RAs we can.
        }
        let primaryType;
        if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
            // We need to issue a corrective negative RA.
            primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            primaryType = primarySense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
        }
        const secondaryType = primarySense === 1
            ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps)
            : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
        this.setState(simTime, primaryType, secondaryType);
    }
    /**
     * Sets the state of this host's current resolution advisory. If the specified state is equal to the current state
     * of the resolution advisory, this method does nothing. If the state is successfully set, the `tcas_ra_issued`
     * event will be published if `isInitial` is `true`, or the `tcas_ra_updated` event if `isInitial` is `false`.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param primaryType The primary type of the resolution advisory.
     * @param secondaryType The secondary type of the resolution advisory.
     * @param isInitial Whether the state to set is for an initial resolution advisory.
     */
    setState(simTime, primaryType, secondaryType, isInitial = false) {
        if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
            return;
        }
        let minSpeed, maxSpeed;
        const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
        this._primaryType = primaryType;
        this._primaryFlags = primaryTypeDef.flags;
        this._secondaryType = secondaryType;
        if (secondaryType !== null) {
            const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
            this._secondaryFlags = secondaryTypeDef.flags;
            minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
            maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
        }
        else {
            this._secondaryFlags = 0;
            minSpeed = primaryTypeDef.minVerticalSpeed;
            maxSpeed = primaryTypeDef.maxVerticalSpeed;
        }
        this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
        this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
        this.isInitial = isInitial;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE
            + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1000;
        if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
            this.senseReversalCount++;
        }
        if (isInitial) {
            this.publisher.pub('tcas_ra_issued', this, false, false);
        }
        else {
            this.publisher.pub('tcas_ra_updated', this, false, false);
        }
    }
    /**
     * Cancels this host's current resolution advisory. If there is no currently active resolution advisory, this
     * method does nothing. If the resolution advisory is successfully cancelled, the `tcas_ra_canceled` event will be
     * published.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    cancel(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
            return;
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        this._maxVerticalSpeed.set(NaN);
        this._minVerticalSpeed.set(NaN);
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._primaryFlags = 0;
        this._secondaryType = null;
        this._secondaryFlags = 0;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher.pub('tcas_ra_canceled', undefined, false, false);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * above all current RA intruders.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation above all current RA intruders.
     */
    getUpSenseRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * below all current RA intruders.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation below all current RA intruders.
     */
    getDownSenseRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tcpa The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
        const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
        if (signedAccel === 0) {
            return vs;
        }
        const y0 = currentAlt + vs * responseTime;
        const tc = tcpa - responseTime;
        const a = signedAccel / 2;
        const b = -signedAccel * tc;
        const c = targetAlt - y0 - vs * tc;
        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
            return NaN;
        }
        const sqrtDiscr = Math.sqrt(discriminant);
        const t1 = (-b + sqrtDiscr) / (2 * a);
        const t2 = (-b - sqrtDiscr) / (2 * a);
        if (t1 <= tc && t1 >= 0) {
            return vs + signedAccel * t1;
        }
        if (t2 <= tc && t2 >= 0) {
            return vs + signedAccel * t2;
        }
        return NaN;
    }
    /**
     * Gets the least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for a given minimum
     * vertical speed requirement.
     * @param minVsMps A minimum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for the specified
     * minimum vertical speed requirement.
     */
    static getDoNotDescendType(minVsMps) {
        if (minVsMps > -500) {
            return TcasResolutionAdvisoryType.DoNotDescend0;
        }
        else if (minVsMps > -1000) {
            return TcasResolutionAdvisoryType.DoNotDescend500;
        }
        else if (minVsMps > -1500) {
            return TcasResolutionAdvisoryType.DoNotDescend1000;
        }
        else if (minVsMps > -2000) {
            return TcasResolutionAdvisoryType.DoNotDescend1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotDescend2000;
        }
    }
    /**
     * Gets the least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for a given maximum
     * vertical speed requirement.
     * @param maxVsMps A maximum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for the specified
     * maximum vertical speed requirement.
     */
    static getDoNotClimbType(maxVsMps) {
        if (maxVsMps < 500) {
            return TcasResolutionAdvisoryType.DoNotClimb0;
        }
        else if (maxVsMps < 1000) {
            return TcasResolutionAdvisoryType.DoNotClimb500;
        }
        else if (maxVsMps < 1500) {
            return TcasResolutionAdvisoryType.DoNotClimb1000;
        }
        else if (maxVsMps < 2000) {
            return TcasResolutionAdvisoryType.DoNotClimb1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotClimb2000;
        }
    }
}
/** The base amount of delay between state changes, in milliseconds, before predicted response time is taken into account. */
TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5000;
TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
        return -1;
    }
    else if (tcpaComparison > 0) {
        return 1;
    }
    else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
        return -1;
    }
    else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
        return 1;
    }
    else {
        return 0;
    }
};
TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
        flags: 0,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 2500,
        maxVerticalSpeed: 3000
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -3000,
        maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1000
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 2000
    },
};
TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];

/**
 * Standard TCAS-II sensitivity parameters.
 */
class TcasIISensitivityParameters {
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude, radarAltitude) {
        const altFeet = altitude.asUnit(UnitType.FOOT);
        const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
        let level;
        if (radarAltFeet > 2350) {
            if (altFeet > 42000) {
                level = 6;
            }
            else if (altFeet > 20000) {
                level = 5;
            }
            else if (altFeet > 10000) {
                level = 4;
            }
            else if (altFeet > 5000) {
                level = 3;
            }
            else {
                level = 2;
            }
        }
        else if (radarAltFeet > 1000) {
            level = 1;
        }
        else {
            level = 0;
        }
        return level;
    }
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    altitude, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    radarAltitude) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPA(level) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level) {
        return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
}
TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
};
TcasIISensitivityParameters.TA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.33),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.48),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(40),
        protectedRadius: UnitType.NMILE.createNumber(0.75),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(45),
        protectedRadius: UnitType.NMILE.createNumber(1),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(1200)
    }
];
TcasIISensitivityParameters.RA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.35),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.55),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(350),
        hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.8),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(400),
        hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(700),
        alim: UnitType.FOOT.createNumber(600),
        hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(800),
        alim: UnitType.FOOT.createNumber(700),
        hmd: UnitType.NMILE.createNumber(0.98)
    }
];
/**
 * An implementation of {@link TCASSensitivity} which provides sensitivity parameters as defined in the official
 * TCAS II specification.
 */
class TcasIISensitivity {
    constructor() {
        this.sensitivity = new TcasIISensitivityParameters();
        this.level = 0;
        this.params = {
            parametersPA: this.sensitivity.getPA(0),
            parametersTA: this.sensitivity.getTA(0),
            parametersRA: this.sensitivity.getRA(0)
        };
    }
    /** @inheritdoc */
    selectParameters() {
        return this.params;
    }
    /** @inheritdoc */
    selectRAAlim() {
        return this.sensitivity.getRAAlim(this.level);
    }
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude, radarAltitude) {
        this.level = this.sensitivity.selectLevel(altitude, radarAltitude);
        this.params.parametersPA = this.sensitivity.getPA(this.level);
        this.params.parametersTA = this.sensitivity.getTA(this.level);
        this.params.parametersRA = this.sensitivity.getRA(this.level);
    }
}

/**
 * Traffic alert level modes.
 */
var MapTrafficAlertLevelVisibility;
(function (MapTrafficAlertLevelVisibility) {
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["Other"] = 1] = "Other";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ProximityAdvisory"] = 2] = "ProximityAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["TrafficAdvisory"] = 4] = "TrafficAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ResolutionAdvisory"] = 8] = "ResolutionAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["All"] = 15] = "All";
})(MapTrafficAlertLevelVisibility || (MapTrafficAlertLevelVisibility = {}));
/**
 * A module describing the display of traffic.
 */
class MapTrafficModule {
    /**
     * Creates an instance of a MapTrafficModule.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas) {
        this.tcas = tcas;
        /** Whether to show traffic information. */
        this.show = Subject.create(true);
        /** The TCAS operating mode. */
        this.operatingMode = Subject.create(TcasOperatingMode.Standby);
        /**
         * The distance from the own airplane beyond which intruders are considered off-scale. If the value is `NaN`,
         * intruders are never considered off-scale.
         */
        this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        /** Alert level visibility flags. */
        this.alertLevelVisibility = Subject.create(MapTrafficAlertLevelVisibility.All);
        /** The difference in altitude above the own airplane above which intruders will not be displayed. */
        this.altitudeRestrictionAbove = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
        /** The difference in altitude below the own airplane below which intruders will not be displayed. */
        this.altitudeRestrictionBelow = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
        /** Whether displayed intruder altitude is relative. */
        this.isAltitudeRelative = Subject.create(true);
        this.tcas.getEventSubscriber().on('tcas_operating_mode').whenChanged().handle(mode => {
            this.operatingMode.set(mode);
        });
    }
}

/**
 * A map layer which displays traffic intruders.
 */
class MapSystemTrafficLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.iconLayerRef = FSComponent.createRef();
        this.trafficModule = this.props.model.getModule(MapSystemKeys.Traffic);
        this.intruderIcons = {
            [TcasAlertLevel.None]: new Map(),
            [TcasAlertLevel.ProximityAdvisory]: new Map(),
            [TcasAlertLevel.TrafficAdvisory]: new Map(),
            [TcasAlertLevel.ResolutionAdvisory]: new Map()
        };
        this.needHandleOffscaleOob = this.props.offScaleIntruders !== undefined || this.props.oobIntruders !== undefined;
        this.oobOffset = (_a = this.props.oobOffset) !== null && _a !== void 0 ? _a : Subject.create(VecNMath.create(4));
        this.oobBounds = VecNSubject.createFromVector(VecNMath.create(4));
        this.isInit = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a, _b;
        if (!isVisible) {
            if (this.isInit) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.iconLayerRef.instance.display.clear();
            }
            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.clear();
            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    /** @inheritdoc */
    onAttached() {
        this.iconLayerRef.instance.onAttached();
        this.oobOffset.sub(this.updateOobBounds.bind(this), true);
        this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
        this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
        this.initCanvasStyles();
        this.initIntruders();
        this.initTCASHandlers();
        this.isInit = true;
    }
    /**
     * Initializes canvas styles.
     */
    initCanvasStyles() {
        this.props.initCanvasStyles && this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);
    }
    /**
     * Initializes all currently existing TCAS intruders.
     */
    initIntruders() {
        const intruders = this.trafficModule.tcas.getIntruders();
        const len = intruders.length;
        for (let i = 0; i < len; i++) {
            this.onIntruderAdded(intruders[i]);
        }
    }
    /**
     * Initializes handlers to respond to TCAS events.
     */
    initTCASHandlers() {
        const tcasSub = this.props.context.bus.getSubscriber();
        tcasSub.on('tcas_intruder_added').handle(this.onIntruderAdded.bind(this));
        tcasSub.on('tcas_intruder_removed').handle(this.onIntruderRemoved.bind(this));
        tcasSub.on('tcas_intruder_alert_changed').handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.initCanvasStyles();
            this.updateOobBounds();
        }
    }
    /**
     * Updates the boundaries of the intruder out-of-bounds area.
     */
    updateOobBounds() {
        const projectedSize = this.props.mapProjection.getProjectedSize();
        const oobOffset = this.oobOffset.get();
        this.oobBounds.set(oobOffset[0], oobOffset[1], projectedSize[0] - oobOffset[2], projectedSize[1] - oobOffset[3]);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.redrawIntruders();
    }
    /**
     * Redraws all tracked intruders.
     */
    redrawIntruders() {
        const alertLevelVisFlags = this.trafficModule.alertLevelVisibility.get();
        const offScaleRange = this.trafficModule.offScaleRange.get();
        const oobBounds = this.oobBounds.get();
        const iconDisplay = this.iconLayerRef.instance.display;
        iconDisplay.clear();
        for (let i = 0; i < MapSystemTrafficLayer.DRAW_GROUPS.length; i++) {
            const group = MapSystemTrafficLayer.DRAW_GROUPS[i];
            if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
                this.intruderIcons[group.alertLevel].forEach(icon => {
                    var _a, _b, _c, _d, _e, _f;
                    icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
                    if (this.needHandleOffscaleOob) {
                        if (icon.isOffScale) {
                            (_a = this.props.oobIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                            (_b = this.props.offScaleIntruders) === null || _b === void 0 ? void 0 : _b.add(icon.intruder);
                        }
                        else if (!this.props.mapProjection.isInProjectedBounds(icon.projectedPos, oobBounds)) {
                            (_c = this.props.offScaleIntruders) === null || _c === void 0 ? void 0 : _c.delete(icon.intruder);
                            (_d = this.props.oobIntruders) === null || _d === void 0 ? void 0 : _d.add(icon.intruder);
                        }
                        else {
                            (_e = this.props.offScaleIntruders) === null || _e === void 0 ? void 0 : _e.delete(icon.intruder);
                            (_f = this.props.oobIntruders) === null || _f === void 0 ? void 0 : _f.delete(icon.intruder);
                        }
                    }
                });
            }
            else if (this.needHandleOffscaleOob) {
                this.intruderIcons[group.alertLevel].forEach(icon => {
                    var _a, _b;
                    (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                    (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
                });
            }
        }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        const operatingMode = this.trafficModule.tcas.getOperatingMode();
        this.setVisible(this.trafficModule.show.get()
            && (operatingMode === TcasOperatingMode.TAOnly
                || operatingMode === TcasOperatingMode.TA_RA
                || operatingMode === TcasOperatingMode.Test));
    }
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    onIntruderAdded(intruder) {
        const icon = this.props.iconFactory(intruder, this.props.context);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    onIntruderRemoved(intruder) {
        var _a, _b;
        (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(intruder);
        (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(intruder);
        this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    onIntruderAlertLevelChanged(intruder) {
        let oldAlertLevel;
        let view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.None].get(intruder);
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ProximityAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.TrafficAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ResolutionAdvisory].get(intruder));
        if (view) {
            this.intruderIcons[oldAlertLevel].delete(intruder);
            this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
}
MapSystemTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.Other, alertLevel: TcasAlertLevel.None },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ProximityAdvisory, alertLevel: TcasAlertLevel.ProximityAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.TrafficAdvisory, alertLevel: TcasAlertLevel.TrafficAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ResolutionAdvisory, alertLevel: TcasAlertLevel.ResolutionAdvisory },
];
/**
 * An abstract implementation of {@link MapTrafficIntruderIcon} which handles the projection of the intruder's position
 * and off-scale calculations.
 */
class AbstractMapTrafficIntruderIcon {
    /**
     * Constructor.
     * @param intruder This icon's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The ownship module for this icon's parent map.
     */
    constructor(intruder, trafficModule, ownshipModule) {
        this.intruder = intruder;
        this.trafficModule = trafficModule;
        this.ownshipModule = ownshipModule;
        this.projectedPos = new Float64Array(2);
        this.isOffScale = false;
    }
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this icon.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    draw(projection, context, offScaleRange) {
        this.updatePosition(projection, offScaleRange);
        this.drawIcon(projection, context, this.projectedPos, this.isOffScale);
    }
    /**
     * Updates this icon's intruder's projected position and off-scale status.
     * @param projection The map projection.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    updatePosition(projection, offScaleRange) {
        const ownAirplanePos = this.ownshipModule.position.get();
        if (offScaleRange.isNaN()) {
            projection.project(this.intruder.position, this.projectedPos);
            this.isOffScale = false;
        }
        else {
            this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
        }
    }
    /**
     * Updates this icon's intruder's projected position and off-scale status using a specific range from the own
     * airplane to define off-scale.
     * @param projection The map projection.
     * @param ownAirplanePos The position of the own airplane.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale.
     */
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
        const intruderPos = this.intruder.position;
        const horizontalSeparation = intruderPos.distance(ownAirplanePos);
        const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
        if (horizontalSeparation > offscaleRangeRad) {
            this.isOffScale = true;
            projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, AbstractMapTrafficIntruderIcon.geoPointCache[0]), this.projectedPos);
        }
        else {
            this.isOffScale = false;
            projection.project(intruderPos, this.projectedPos);
        }
    }
}
AbstractMapTrafficIntruderIcon.geoPointCache = [new GeoPoint(0, 0)];

/**
 * A class that renders waypoints into a layer.
 */
class MapSystemWaypointsLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.waypointsLayer = FSComponent.createRef();
        this.displayModule = this.props.model.getModule(MapSystemKeys.NearestWaypoints);
        this.waypointCache = (_a = this.props.waypointCache) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.getCache(this.props.bus);
        this.searchItemLimits = {
            [FacilitySearchType.Airport]: 500,
            [FacilitySearchType.Vor]: 250,
            [FacilitySearchType.Ndb]: 250,
            [FacilitySearchType.Intersection]: 500,
            [FacilitySearchType.User]: 100
        };
        this.searchRadiusLimits = {
            [FacilitySearchType.Airport]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Vor]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Ndb]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Intersection]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.User]: Number.POSITIVE_INFINITY
        };
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.waypointsLayer.instance.onAttached();
        this.initEventHandlers();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointsLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        if (this.isVisible()) {
            this.waypointsLayer.instance.onUpdated(time, elapsed);
        }
    }
    /** @inheritdoc */
    initEventHandlers() {
        this.displayModule.numAirports.sub(num => this.searchItemLimits[FacilitySearchType.Airport] = num, true);
        this.displayModule.numIntersections.sub(num => this.searchItemLimits[FacilitySearchType.Intersection] = num, true);
        this.displayModule.numVors.sub(num => this.searchItemLimits[FacilitySearchType.Vor] = num, true);
        this.displayModule.numNdbs.sub(num => this.searchItemLimits[FacilitySearchType.Ndb] = num, true);
        this.displayModule.airportsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Airport] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.intersectionsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Intersection] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.vorsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Vor] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.ndbsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Ndb] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.refreshWaypoints.on(() => this.waypointsLayer.instance.refreshWaypoints());
    }
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     */
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession) {
        this.displayModule.intersectionsFilter.sub(filters => intSession.setIntersectionFilter(filters.typeMask));
        this.displayModule.vorsFilter.sub(filters => vorSession.setVorFilter(filters.classMask, filters.typeMask));
        this.displayModule.airportsFilter.sub(filters => {
            airportSession.setAirportFilter(filters.showClosed, filters.classMask);
        });
        this.displayModule.extendedAirportsFilter.sub(filters => {
            airportSession.setExtendedAirportFilters(filters.runwaySurfaceTypeMask, filters.approachTypeMask, filters.toweredMask, filters.minimumRunwayLength);
        });
    }
    /**
     * Initializes this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    initWaypointRenderer(renderer, canvasLayer) {
        this.defineRenderRole(renderer, canvasLayer);
        renderer.onRolesAdded.on(this.defineRenderRole.bind(this, renderer, canvasLayer));
    }
    /**
     * Defines the render role for this layer's waypoints.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    defineRenderRole(renderer, canvasLayer) {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach(id => {
            const roleId = renderer.getRoleFromName(id);
            if (roleId !== undefined) {
                renderer.setCanvasContext(roleId, canvasLayer.display.context);
                renderer.setIconFactory(roleId, this.props.iconFactory);
                renderer.setLabelFactory(roleId, this.props.labelFactory);
                renderer.setVisibilityHandler(roleId, this.isWaypointVisible.bind(this));
            }
        });
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.waypointsLayer.instance.setVisible(val);
    }
    /**
     * Checks to see if a waypoint should be visible.
     * @param waypoint The waypoint to check.
     * @returns True if visible, false otherwise.
     */
    isWaypointVisible(waypoint) {
        if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
            switch (waypoint.type) {
                case WaypointTypes.Airport:
                    return this.displayModule.showAirports.get()(waypoint);
                case WaypointTypes.Intersection:
                    return this.displayModule.showIntersections.get()(waypoint);
                case WaypointTypes.VOR:
                    return this.displayModule.showVors.get()(waypoint);
                case WaypointTypes.NDB:
                    return this.displayModule.showNdbs.get()(waypoint);
            }
        }
        return false;
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapNearestWaypointsLayer, { ref: this.waypointsLayer, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: this.registerWaypoint.bind(this), deregisterWaypoint: this.deregisterWaypoint.bind(this), searchItemLimit: (type) => this.searchItemLimits[type], searchRadiusLimit: (type) => this.searchRadiusLimits[type], getSearchCenter: this.props.useMapTargetAsSearchCenter === true ? (mapProjection) => mapProjection.getTarget() : undefined, onSessionsStarted: this.onSessionsStarted.bind(this), class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /**
     * Registers a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to register.
     * @param renderer The renderer to register the waypoint to.
     */
    registerWaypoint(waypoint, renderer) {
        const selector = this.displayModule.waypointRoleSelector.get();
        if (selector) {
            const id = selector(waypoint);
            const roleId = renderer.getRoleFromName(id);
            if (roleId !== undefined) {
                renderer.register(waypoint, roleId, 'waypoints-layer');
            }
        }
        else {
            const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
            groupRoles.forEach(id => {
                const roleId = renderer.getRoleFromName(id);
                if (roleId !== undefined) {
                    renderer.register(waypoint, roleId, 'waypoints-layer');
                }
            });
        }
    }
    /**
     * Deregisters a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to deregister.
     * @param renderer The renderer to deregister the waypoint from.
     */
    deregisterWaypoint(waypoint, renderer) {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach(id => {
            const roleId = renderer.getRoleFromName(id);
            if (roleId !== undefined) {
                renderer.deregister(waypoint, roleId, 'waypoints-layer');
            }
        });
    }
}

/**
 * A map data module that controls the terrain color reference point.
 */
class MapTerrainColorsModule {
    constructor() {
        /** The terrain colors reference point. */
        this.reference = Subject.create(EBingReference.SEA);
        /** Whether or not to show the map terrain isolines. */
        this.showIsoLines = Subject.create(false);
        /** The terrain colors array. */
        this.colors = ArraySubject.create(BingComponent.createEarthColorsArray('#0000FF', [
            {
                elev: 0,
                color: '#000000'
            }
        ], 0, 30000, 1));
        /** The elevation range over which to assign the terrain colors, as `[minimum, maximum]` in feet. */
        this.colorsElevationRange = Vec2Subject.create(Vec2Math.create(0, 30000));
    }
}

/**
 * A map data module that handles the display of flight plan data.
 */
class MapFlightPlanModule {
    constructor() {
        this.plans = [];
    }
    /**
     * Gets the flight plan subjects for a specified flight plan.
     * @param index The index of the flight plan.
     * @returns The subject for the specified plan index.
     */
    getPlanSubjects(index) {
        let planSubject = this.plans[index];
        if (planSubject === undefined) {
            planSubject = new PlanSubjects();
            this.plans[index] = planSubject;
        }
        return planSubject;
    }
}
/**
 * A collection of subjects for consuming flight plan data in the flight plan module.
 */
class PlanSubjects {
    constructor() {
        /** The current flight plan to display, if any. */
        this.flightPlan = Subject.create(undefined);
        /** An event that fires when the plan is changed. */
        this.planChanged = new SubEvent();
        /** An event that fired when the flight path of the plan is recalculated. */
        this.planCalculated = new SubEvent();
        /** The active leg index currently being navigated to. */
        this.activeLeg = Subject.create(0);
    }
}

/**
 * A module which describes whether the map is following the player airplane.
 */
class MapFollowAirplaneModule {
    constructor() {
        /** Whether the map is following the player airplane. */
        this.isFollowing = Subject.create(false);
    }
}

/**
 * A map data module that controls waypoint display options.
 */
class MapWaypointDisplayModule {
    constructor() {
        /** A handler that dictates airport waypoint visibility. */
        this.showAirports = Subject.create(() => true);
        /** A handler that dictates intersection waypoint visibility. */
        this.showIntersections = Subject.create(() => false);
        /** A handler that dictates NDB waypoint visibility. */
        this.showNdbs = Subject.create(() => true);
        /** A handler that dictates VOR waypoint visibility. */
        this.showVors = Subject.create(() => true);
        /** The maximum range at which airport waypoints should be searched for. */
        this.airportsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
        /** The maximum range at which intersection waypoints should be searched for. */
        this.intersectionsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
        /** The maximum range at which NDB waypoints should be searched for. */
        this.ndbsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
        /** The maximum range at which VOR waypoints should be searched for. */
        this.vorsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
        /** The maximum number of airports that should be displayed. */
        this.numAirports = Subject.create(40);
        /** The maximum number of intersections that should be displayed. */
        this.numIntersections = Subject.create(40);
        /** The maximum number of NDBs that should be displayed. */
        this.numNdbs = Subject.create(40);
        /** The maximum number of VORs that should be displayed. */
        this.numVors = Subject.create(40);
        /** The filter to apply to the intersection search. */
        this.intersectionsFilter = Subject.create({
            typeMask: NearestIntersectionSearchSession.Defaults.TypeMask,
            showTerminalWaypoints: true
        });
        /** The filter to apply to the VOR search. */
        this.vorsFilter = Subject.create({
            typeMask: NearestVorSearchSession.Defaults.TypeMask,
            classMask: NearestVorSearchSession.Defaults.ClassMask
        });
        /** The filter to apply to the airport search. */
        this.airportsFilter = Subject.create({
            classMask: NearestAirportSearchSession.Defaults.ClassMask,
            showClosed: NearestAirportSearchSession.Defaults.ShowClosed
        });
        /** The extended airport filter to apply to the airport search. */
        this.extendedAirportsFilter = Subject.create({
            runwaySurfaceTypeMask: NearestAirportSearchSession.Defaults.SurfaceTypeMask,
            approachTypeMask: NearestAirportSearchSession.Defaults.ApproachTypeMask,
            minimumRunwayLength: NearestAirportSearchSession.Defaults.MinimumRunwayLength,
            toweredMask: NearestAirportSearchSession.Defaults.ToweredMask
        });
        /** A function that will be called with a waypoint when it is registered,
         * and should return the role to use for that waypoint. */
        this.waypointRoleSelector = Subject.create(undefined);
        /** Forces a refresh of all the waypoints. Useful if a waypoint needs a different role to be selected. */
        this.refreshWaypoints = new SubEvent();
    }
}

/**
 * A module that describes the display of weather on a Bing Map instance.
 */
class MapWxrModule {
    constructor() {
        /** Whether the weather radar is enabled. */
        this.isEnabled = Subject.create(false);
        /** The current map weather radar arc sweep angle in degrees. */
        this.weatherRadarArc = NumberUnitSubject.create(UnitType.DEGREE.createNumber(90));
        /** The current weather radar mode. */
        this.weatherRadarMode = Subject.create(EWeatherRadar.HORIZONTAL);
        /**
         * The current weather radar colors. Each entry `E_i` of the array is a tuple `[color, rate]` that defines a color
         * stop, where `color` is an RGBA color expressed as `R + G * 256 + B * 256^2 + A * 256^3` and `rate` is a
         * precipitation rate in millimeters per hour.
         *
         * In general, the color defined by `E_i` is applied to precipitation rates ranging from the rate defined by `E_i-1`
         * to the rate defined by `E_i`. There are two special cases. The color defined by `E_0` is applied to the
         * precipitation rates from zero to the rate defined by `E_0`. The color defined by `E_n-1`, where `n` is the length
         * of the array, is applied to the precipitation rates from the rate defined by `E_n-2` to positive infinity.
         */
        this.weatherRadarColors = ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
        this._wxrMode = MappedSubject.create(([isEnabled, arc, mode]) => {
            return {
                mode: isEnabled ? mode : EWeatherRadar.OFF,
                arcRadians: arc.asUnit(UnitType.RADIAN),
            };
        }, this.isEnabled, this.weatherRadarArc, this.weatherRadarMode);
    }
    /**
     * A subscribable containing the combined WxrMode from the mode and arc subjects,
     * suitable for consumption in a MapBingLayer.
     * @returns The WxrMode subscribable.
     */
    get wxrMode() {
        return this._wxrMode;
    }
}

/**
 * A module describing the display of the altitude intercept arc.
 */
class MapAltitudeArcModule {
    /**
     * MapAltitudeArcModule constructor.
     * @param show When passed, the `show` field will be initialized to this value.
     */
    constructor(show) {
        /** Whether to show the altitude intercept arc. */
        this.show = Subject.create(false);
        if (show !== undefined) {
            this.show.set(show);
        }
    }
}

/**
 * A class that builds a configuration for the waypoint display.
 */
class WaypointDisplayBuilder {
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     */
    constructor(iconFactory, labelFactory, waypointRenderer) {
        this.iconFactory = iconFactory;
        this.labelFactory = labelFactory;
        this.waypointRenderer = waypointRenderer;
        this.roleGroup = MapSystemWaypointRoles.Normal;
        this.isCenterTarget = false;
    }
    /**
     * Adds a icon configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an icon for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addIcon(role, type, config) {
        this.iconFactory.addIconFactory(this.determineRoleId(role), type, config);
        return this;
    }
    /**
     * Adds a default icon configuration to the waypoint display system, if no other configuration is found.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultIcon(role, config) {
        this.iconFactory.addDefaultIconFactory(this.determineRoleId(role), config);
        return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an label for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addLabel(role, type, config) {
        this.labelFactory.addLabelFactory(this.determineRoleId(role), type, config);
        return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultLabel(role, config) {
        this.labelFactory.addDefaultLabelFactory(this.determineRoleId(role), config);
        return this;
    }
    /**
     * Determines the role ID given either a numeric or string based role.
     * @param role The role to determine.
     * @returns The numeric role ID.
     */
    determineRoleId(role) {
        let roleId = 0;
        if (typeof role === 'string') {
            const roleIdFromName = this.waypointRenderer.getRoleFromName(role);
            if (roleIdFromName !== undefined) {
                roleId = roleIdFromName;
            }
        }
        else {
            roleId = role;
        }
        return roleId;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
        this.waypointRenderer.addRenderRole(name, undefined, this.roleGroup);
        return this;
    }
    /**
     * Gets the ID of a role in the waypoint display system.
     * @param role The name of the role to get the ID for.
     * @returns The ID of the role.
     * @throws An error if an invalid role name is supplied.
     */
    getRoleId(role) {
        const roleId = this.waypointRenderer.getRoleFromName(role);
        if (roleId === undefined) {
            throw new Error(`The role with name ${role} was not defined and could not be found.`);
        }
        return roleId;
    }
    /**
     * Configures the center for waypoint searches for this display.
     * @param center If center, then waypoint searches will use the map center. If target,
     * waypoint searches will use the map target with offset.
     * @returns The modified builder.
     */
    withSearchCenter(center) {
        if (center === 'center') {
            this.isCenterTarget = false;
        }
        else {
            this.isCenterTarget = true;
        }
        return this;
    }
    /**
     * Gets if the waypoint search is using the map target with offset as the search center.
     * @returns True if the search center is the map target, false if it is the map center.
     */
    getIsCenterTarget() {
        return this.isCenterTarget;
    }
    /**
     * Configures the facility waypoint cache to use with the waypoint display.
     * @param cache The facility waypoint cache to use, or undefined to use the default.
     * @returns The modified builder.
     */
    withWaypointCache(cache) {
        this.facilityWaypointCache = cache;
        return this;
    }
    /**
     * Gets the currently set facility waypoint cache.
     * @returns The currently set facility waypoint cache.
     */
    getWaypointCache() {
        return this.facilityWaypointCache;
    }
}

/**
 * A class that builds the configuration for the flight plan display.
 */
class FlightPlanDisplayBuilder extends WaypointDisplayBuilder {
    /**
     * Creates an instance of the FlightPlanDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     * @param flightPlanRenderer The flight plan renderer to use with this builder.
     * @param planIndex The flight plan index to be displayed by this system.
     */
    constructor(iconFactory, labelFactory, waypointRenderer, flightPlanRenderer, planIndex) {
        super(iconFactory, labelFactory, waypointRenderer);
        this.flightPlanRenderer = flightPlanRenderer;
        this.planIndex = planIndex;
        this.roleGroup = MapSystemWaypointRoles.FlightPlan;
        this.roleGroup = `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`;
        flightPlanRenderer.legStyleHandlers;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
        this.waypointRenderer.insertRenderRole(name, MapSystemWaypointRoles.Normal, undefined, this.roleGroup);
        return this;
    }
    /**
     * Configures the flight path display to use styles returned by the provided function.
     * @param handler The handler to use to return the required path rendering styles.
     * @returns The modified builder.
     */
    withLegPathStyles(handler) {
        this.flightPlanRenderer.legStyleHandlers.set(this.planIndex, handler);
        return this;
    }
    /**
     * Configures the flight plan waypoint display to use the roles returned by the
     * provided function.
     * @param handler The handler to use to return the required waypoint display roles.
     * @returns The modified builder.
     */
    withLegWaypointRoles(handler) {
        this.flightPlanRenderer.legWaypointHandlers.set(this.planIndex, handler);
        return this;
    }
    /**
     * Configures the flight plan flight path display to set visibility of leg-to-leg
     * turn anticipation transitions.
     * @param visible Whether or not the leg-to-leg turn anticipation transitions will be visible.
     * @returns The modified builder.
     */
    withAnticipationTurns(visible) {
        const visibleSub = SubscribableUtils.toSubscribable(visible, true);
        this.flightPlanRenderer.renderEgress = visibleSub;
        this.flightPlanRenderer.renderIngress = visibleSub;
        return this;
    }
}

/**
 * An generic implementation of {@link MapAirspaceRenderManager}.
 */
class GenericAirspaceRenderManager {
    /**
     * Constructor.
     * @param renderOrder A function which determines the order in which this manager renders airspaces. The function
     * should return a negative number when airspace `a` should be rendered before (below) airspace `b`, a positive
     * number when airspace `a` should be rendered after (above) airspace `b`, and `0` when the relative render order
     * of the two airspaces does not matter.
     * @param selectRenderer A function which selects airspace renderers for individual airspaces.
     */
    constructor(renderOrder, selectRenderer) {
        this.renderOrder = renderOrder;
        this.selectRenderer = selectRenderer;
        this.airspaces = new Map();
    }
    /** @inheritdoc */
    getRegisteredAirspaces() {
        return Array.from(this.airspaces.values());
    }
    /** @inheritdoc */
    registerAirspace(airspace) {
        if (this.airspaces.has(airspace.facility.id)) {
            return false;
        }
        this.airspaces.set(airspace.facility.id, airspace);
        return true;
    }
    /** @inheritdoc */
    deregisterAirspace(airspace) {
        return this.airspaces.delete(airspace.facility.id);
    }
    /** @inheritdoc */
    replaceRegisteredAirspaces(airspaces) {
        let changed = false;
        let numMatched = 0;
        for (const airspace of airspaces) {
            changed || (changed = !this.airspaces.has(airspace.facility.id));
            if (changed) {
                break;
            }
            else {
                numMatched++;
            }
        }
        changed || (changed = numMatched !== this.airspaces.size);
        if (!changed) {
            return false;
        }
        this.airspaces.clear();
        for (const airspace of airspaces) {
            this.registerAirspace(airspace);
        }
        return true;
    }
    /** @inheritdoc */
    clearRegisteredAirspaces() {
        if (this.airspaces.size === 0) {
            return false;
        }
        this.airspaces.clear();
        return true;
    }
    /** @inheritdoc */
    prepareRenderProcess(projection, context, taskQueueHandler, lod = 0, stream) {
        const sorted = Array.from(this.airspaces.values()).sort(this.renderOrder);
        const tasks = sorted.map(airspace => {
            const renderer = this.selectRenderer(airspace);
            // The explicit cast is to avoid a bogus typescript error
            return renderer.render.bind(renderer, airspace, projection, context, lod, stream);
        });
        return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
}

/**
 * Updates the properties in a {@link MapAutopilotPropsModule}.
 */
class MapAutopilotPropsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz. If not defined, the properties
     * will be updated every frame.
     */
    constructor(context, properties, updateFreq) {
        super(context);
        this.properties = properties;
        this.updateFreq = updateFreq;
        this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
        this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        if (this.updateFreq) {
            this.updateFreqSub = this.updateFreq.sub(freq => {
                var _a;
                for (const property of this.properties) {
                    (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.subs[property] = this.bindProperty(sub, property, freq);
                }
            }, true);
        }
        else {
            for (const property of this.properties) {
                this.subs[property] = this.bindProperty(sub, property);
            }
        }
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
        switch (property) {
            case 'selectedAltitude':
                return (updateFreq === undefined ? sub.on('ap_altitude_selected') : sub.on('ap_altitude_selected').atFrequency(updateFreq))
                    .handle(alt => { this.module.selectedAltitude.set(alt, UnitType.FOOT); });
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const property of this.properties) {
            (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
}

/**
 * A component that encompasses the compiled map system.
 */
class MapSystemComponent extends MapComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.rootStyles = ObjectSubject.create({
            width: '0px',
            height: '0px'
        });
        this.deadZone = (_a = this.props.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.create(new Float64Array(4));
        this.deadZone.sub(this.onDeadZoneChanged.bind(this));
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        super.onAfterRender(thisNode);
        this.onProjectedSizeChanged();
        this.props.onAfterRender();
    }
    /**
     * This method is called when the size of this map's dead zone changes.
     * @param deadZone The dead zone.
     */
    onDeadZoneChanged(deadZone) {
        this.props.onDeadZoneChanged(deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.props.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
        this.rootStyles.set('width', `${size[0]}px`);
        this.rootStyles.set('height', `${size[1]}px`);
    }
    /** @inheritdoc */
    onProjectedSizeChanged() {
        this.setRootSize(this.mapProjection.getProjectedSize());
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.props.onBeforeUpdated(time, elapsed);
        super.onUpdated(time, elapsed);
        this.props.onAfterUpdated(time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
        super.onWake();
        this.props.onWake();
    }
    /** @inheritdoc */
    onSleep() {
        super.onSleep();
        this.props.onSleep();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { style: this.rootStyles, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.props.children));
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.props.onDestroy();
    }
}

/**
 * An implementation of the base properties in {@link MapSystemContext}.
 */
class DefaultMapSystemContext {
    /**
     * Creates an instance of a MapSystemContext.
     * @param bus This context's event bus.
     * @param projection This context's map projection.
     * @param projectedSize A subscribable which provides the projected size of this context's map.
     * @param deadZone A subscribable which provides the dead zone of this context's map.
     */
    constructor(bus, projection, projectedSize, deadZone) {
        this.bus = bus;
        this.projection = projection;
        this.projectedSize = projectedSize;
        this.deadZone = deadZone;
        /** This context's map model. */
        this.model = new MapModel();
        this.layers = new Map();
        this.controllers = new Map();
    }
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer(key) {
        return this.layers.get(key);
    }
    /**
     * Retrieves a controller from this context.
     * @param key The key fo the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController(key) {
        return this.controllers.get(key);
    }
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer(key, layer) {
        this.layers.set(key, layer);
    }
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController(key, controller) {
        this.controllers.set(key, controller);
    }
}

/**
 * A map controller which delegates its behavior to injected callback functions.
 */
class MapSystemGenericController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param callbacks The callback functions to which this controller delegates its behavior.
     */
    constructor(context, callbacks) {
        super(context);
        this.callbacks = callbacks;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.callbacks.onAfterMapRender && this.callbacks.onAfterMapRender(this.context);
    }
    /** @inheritdoc */
    onDeadZoneChanged(deadZone) {
        this.callbacks.onDeadZoneChanged && this.callbacks.onDeadZoneChanged(this.context, deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.callbacks.onMapProjectionChanged && this.callbacks.onMapProjectionChanged(this.context, mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onBeforeUpdated(time, elapsed) {
        this.callbacks.onBeforeUpdated && this.callbacks.onBeforeUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onAfterUpdated(time, elapsed) {
        this.callbacks.onAfterUpdated && this.callbacks.onAfterUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
        this.callbacks.onWake && this.callbacks.onWake(this.context);
    }
    /** @inheritdoc */
    onSleep() {
        this.callbacks.onSleep && this.callbacks.onSleep(this.context);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.callbacks.onMapDestroyed && this.callbacks.onMapDestroyed(this.context);
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.callbacks.onDestroyed && this.callbacks.onDestroyed(this.context);
    }
}

/**
 * A map flight plan renderer that can be supplied styling from the outside.
 */
class MapSystemPlanRenderer extends AbstractFlightPathPlanRenderer {
    /**
     * Creates an instance of the MapSystemPlanRenderer.
     * @param defaultRoleId The default role ID to render the plan waypoints under.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in a first-to-last
     * fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(defaultRoleId, renderOrder, renderActiveLegLast) {
        super(renderOrder, renderActiveLegLast);
        this.defaultRoleId = defaultRoleId;
        this.legRenderer = new MapSystemLegRenderer();
        /**
         * A handler that returns a leg rendering style for a given set of leg data.
         * @returns A leg rendering style.
         */
        this.legStyleHandlers = new Map();
        /**
         * A handler that returns whether or not a leg waypoint should be displayed.
         * @returns Whether or not the leg should be displayed.
         */
        this.legWaypointHandlers = new Map();
        /** Whether or not to render flight path ingress turns. */
        this.renderIngress = Subject.create(false);
        /** Whether or not to render flight path egress turns. */
        this.renderEgress = Subject.create(false);
    }
    /** @inheritdoc */
    renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
        this.legRenderer.currentRenderStyle = FlightPathRenderStyle.Default;
        const handler = this.legStyleHandlers.get(plan.planIndex);
        if (handler !== undefined) {
            this.legRenderer.currentRenderStyle = handler(plan, leg, activeLeg, legIndex, activeLegIndex);
        }
        let partsToRender = FlightPathLegRenderPart.Base
            | (this.renderIngress.get() ? FlightPathLegRenderPart.Ingress : 0)
            | (this.renderEgress.get() ? FlightPathLegRenderPart.Egress : 0);
        if (this.legRenderer.currentRenderStyle.partsToRender !== undefined) {
            partsToRender = this.legRenderer.currentRenderStyle.partsToRender;
        }
        this.legRenderer.render(leg, context, streamStack, partsToRender);
    }
}
/**
 * A map system flight plan leg renderer that uses a swappable style.
 */
class MapSystemLegRenderer extends AbstractFlightPathLegRenderer {
    constructor() {
        super(...arguments);
        this.vectorRenderer = new FlightPathVectorLineRenderer();
        this.currentRenderStyle = new FlightPathRenderStyle();
    }
    /** @inheritdoc */
    renderVector(vector, isIngress, isEgress, leg, context, streamStack) {
        if ('styleBuilder' in this.currentRenderStyle) {
            const currentRenderStyle = this.currentRenderStyle.styleBuilder(vector, isIngress, isEgress);
            this.vectorRenderer.render(vector, context, streamStack, currentRenderStyle.width, currentRenderStyle.style, currentRenderStyle.dash, currentRenderStyle.outlineWidth, currentRenderStyle.outlineStyle, currentRenderStyle.lineCap);
        }
        else {
            if (this.currentRenderStyle.isDisplayed) {
                this.vectorRenderer.render(vector, context, streamStack, this.currentRenderStyle.width, this.currentRenderStyle.style, this.currentRenderStyle.dash, this.currentRenderStyle.outlineWidth, this.currentRenderStyle.outlineStyle, this.currentRenderStyle.lineCap);
            }
        }
    }
}
/**
 * A vector line rendering style to apply to a flight path display on the map.
 */
class FlightPathRenderStyle {
    /**
     * Creates an instance of a FlightPathRenderStyle.
     * @param isDisplayed Whether or not the path is displayed.
     */
    constructor(isDisplayed = true) {
        this.isDisplayed = isDisplayed;
        /** The pixel width of the path line. */
        this.width = 2;
        /** The style string for the line. */
        this.style = '';
    }
}
/** The default rendering style. */
FlightPathRenderStyle.Default = new FlightPathRenderStyle();
/** A style that does not display the path. */
FlightPathRenderStyle.Hidden = new FlightPathRenderStyle(false);

/**
 * Utility methods related to MapSystem.
 */
class MapSystemUtils {
    /**
     * Converts a nominal relative projected x coordinate to a true relative projected x coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelX A nominal relative projected x coordinate.
     * @param width The width of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected x coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeX(nominalRelX, width, deadZone) {
        return (nominalRelX * (width - deadZone[0] - deadZone[2]) + deadZone[0]) / width;
    }
    /**
     * Converts a nominal relative projected y coordinate to a true relative projected y coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelY A nominal relative projected y coordinate.
     * @param height The height of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected y coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeY(nominalRelY, height, deadZone) {
        return (nominalRelY * (height - deadZone[1] - deadZone[3]) + deadZone[1]) / height;
    }
    /**
     * Converts nominal relative projected coordinates to a true relative projected coordinates. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominal Nominal relative projected coordinates.
     * @param size The size of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @param out The vector to which to write the result.
     * @returns The true relative projected coordinates that are equivalent to the specified nominal coordinates.
     */
    static nominalToTrueRelativeXY(nominal, size, deadZone, out) {
        return Vec2Math.set(MapSystemUtils.nominalToTrueRelativeX(nominal[0], size[0], deadZone), MapSystemUtils.nominalToTrueRelativeY(nominal[1], size[1], deadZone), out);
    }
}

/**
 * A waypoint renderer for the MapSystem API. Supports addition of string-keyed render roles. Each render role is
 * assigned a position in an ordered list that determines the priority of being chosen when roles are selected for
 * rendering waypoints. For each waypoint, the renderer iterates through all render roles in the priority order list
 * and selects the first role under which the waypoint is registered and is visible.
 */
class MapSystemWaypointsRenderer extends MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager) {
        super(textManager, (entry, roleDefinitions) => {
            var _a;
            for (let i = 0; i < this.rolePriorityOrder.length; i++) {
                const role = this.rolePriorityOrder[i];
                if (entry.isAllRoles(role) && ((_a = roleDefinitions.get(role)) === null || _a === void 0 ? void 0 : _a.visibilityHandler(entry.waypoint))) {
                    return role;
                }
            }
            return 0;
        });
        this.rolePriorityOrder = [];
        this.rolesByGroup = new Map();
        this.roleIdMap = new Map();
        this.currentBit = 1;
        /** An event that fires when any roles are added. */
        this.onRolesAdded = new SubEvent();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRenderRole(arg1, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
        if (typeof arg1 === 'number') {
            return false;
        }
        this.roleIdMap.set(arg1, this.currentBit);
        super.addRenderRole(this.currentBit, def);
        this.rolePriorityOrder.push(this.currentBit);
        let roleGroup = this.rolesByGroup.get(group);
        if (roleGroup === undefined) {
            roleGroup = [];
            this.rolesByGroup.set(group, roleGroup);
        }
        roleGroup.push(arg1);
        this.currentBit *= 2;
        this.onRolesAdded.notify(this);
        return true;
    }
    /**
     * Adds a new named render role to this renderer and inserts it before an existing render role in this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param insertBefore The name of the role before which to insert the new role in this renderer's render role
     * selection priority order. If the name does not match any of this renderer's existing render roles, the new role
     * will be placed at the end of the priority order.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully inserted.
     */
    insertRenderRole(name, insertBefore, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
        const role = this.currentBit;
        this.addRenderRole(name, def, group);
        const roleToInsertBefore = this.roleIdMap.get(insertBefore);
        if (roleToInsertBefore !== undefined) {
            const indexToInsertBefore = this.rolePriorityOrder.indexOf(roleToInsertBefore);
            if (indexToInsertBefore >= 0 && indexToInsertBefore < this.rolePriorityOrder.length - 1) {
                this.rolePriorityOrder.pop();
                this.rolePriorityOrder.splice(indexToInsertBefore, 0, role);
            }
        }
        return true;
    }
    /**
     * Gets a render role associated with a name.
     * @param name The name of the role.
     * @returns The render role associated with the specified name, or undefined if there is no such role.
     */
    getRoleFromName(name) {
        return this.roleIdMap.get(name);
    }
    /**
     * Gets the names of roles in a specified group.
     * @param group A render role group.
     * @returns An array of the names of all render roles belonging to the specified group.
     */
    getRoleNamesByGroup(group) {
        const roleNames = this.rolesByGroup.get(group);
        if (roleNames !== undefined) {
            return roleNames;
        }
        return [];
    }
}
/** The default render role group. */
MapSystemWaypointsRenderer.DefaultGroup = 'DEFAULT_GROUP';
/**
 * A class that creates icons for the map system waypoint renderer.
 */
class MapSystemIconFactory {
    constructor() {
        this.cache = new Map();
        this.iconFactories = new Map();
        this.defaultIconFactories = new Map();
    }
    /**
     * Adds an icon factory to the container.
     * @param role The role that this icon factory will be assigned to.
     * @param iconType The unique string type name of the icon.
     * @param factory The factory that will produce the icon.
     */
    addIconFactory(role, iconType, factory) {
        if (!this.iconFactories.has(role)) {
            this.iconFactories.set(role, new Map());
        }
        const roleFactories = this.iconFactories.get(role);
        roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default icon factory for a role.
     * @param role The role to add a default icon factory for.
     * @param factory The factory that will produce the icons.
     */
    addDefaultIconFactory(role, factory) {
        this.defaultIconFactories.set(role, factory);
    }
    /** @inheritdoc */
    getIcon(role, waypoint) {
        if (!this.cache.has(role)) {
            this.cache.set(role, new Map());
        }
        const roleCache = this.cache.get(role);
        let icon = roleCache.get(waypoint.uid);
        if (icon === undefined) {
            icon = this.createIcon(role, waypoint);
            roleCache.set(waypoint.uid, icon);
        }
        return icon;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(role, waypoint) {
        if (!this.iconFactories.has(role)) {
            this.iconFactories.set(role, new Map());
        }
        const roleFactories = this.iconFactories.get(role);
        const factory = roleFactories.get(waypoint.type);
        if (factory !== undefined) {
            return factory(waypoint);
        }
        else {
            const defaultFactory = this.defaultIconFactories.get(role);
            if (defaultFactory !== undefined) {
                return defaultFactory(waypoint);
            }
        }
        const imageEl = document.createElement('img');
        imageEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFjSURBVFhHvZarTsVAEIa3qCMQCAxPgEEikDwGAkGCAIFAIHgQHgGJ4C0Q4AiBN8CQQAIJuOGfs9N0d3p62tlLv+RPd2fFNrNfLy4Lov1lMtiQayqnyJkfzg3RAvlEfpEtqZrJ6cARwhsvkGMuzAvRA0KSZ6nOBNFesHmbA1k1kXoEq8SbScZOPt2BJBlTOtDKx7whT344l4yxfFfIeTCvLGMsH7d8G9lEvqXGMcloPYJQtHvXNB/ID8a3vrSkkox9+Q5lhdf4m9DWs96MwxCdBJu8SrWD6DFYv5BqQbR8mqoyrpJPkyjjVAn78mmqybhOPk0VGcfk0xSXcUw+TVEZp8inMco4JuG4fJpiMlrk0xSR0SqfJltGq3yaLBlT5NNMlHFIQrt8mokyNnLtYPmce0dace6QFz80s4vwLxzzh+zgxr78dIhYvtK5lF3WEMtXOr2nKT4C3/5rP6nGTZJTdXDuH4TJQyPZ/x+gAAAAAElFTkSuQmCC';
        return new MapWaypointImageIcon(waypoint, 0, imageEl, Vec2Math.create(24, 24));
    }
}
/**
 * A class that create labels for the map system waypoint renderer.
 */
class MapSystemLabelFactory {
    constructor() {
        this.cache = new Map();
        this.labelFactories = new Map();
        this.defaultLabelFactories = new Map();
    }
    /**
     * Adds an label factory to the container.
     * @param role The role to add this label factory for.
     * @param iconType The unique string type name of the waypoint.
     * @param factory The factory that will produce the waypoint label.
     */
    addLabelFactory(role, iconType, factory) {
        if (!this.labelFactories.has(role)) {
            this.labelFactories.set(role, new Map());
        }
        const roleFactories = this.labelFactories.get(role);
        roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default label factory for a role.
     * @param role The role to add a default label factory for.
     * @param factory The factory that will produce the labels.
     */
    addDefaultLabelFactory(role, factory) {
        this.defaultLabelFactories.set(role, factory);
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        if (!this.cache.has(role)) {
            this.cache.set(role, new Map());
        }
        const roleCache = this.cache.get(role);
        let label = roleCache.get(waypoint.uid);
        if (label === undefined) {
            label = this.createLabel(role, waypoint);
            roleCache.set(waypoint.uid, label);
        }
        return label;
    }
    /**
     * Creates a new label for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint to create a label for.
     * @returns A new waypoint label.
     */
    createLabel(role, waypoint) {
        if (!this.labelFactories.has(role)) {
            this.labelFactories.set(role, new Map());
        }
        const roleFactories = this.labelFactories.get(role);
        const factory = roleFactories.get(waypoint.type);
        if (factory !== undefined) {
            return factory(waypoint);
        }
        else {
            const defaultFactory = this.defaultLabelFactories.get(role);
            if (defaultFactory !== undefined) {
                return defaultFactory(waypoint);
            }
        }
        let text = '';
        if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
            text = ICAO.getIdent(waypoint.facility.get().icao);
        }
        return new MapCullableLocationTextLabel(text, 0, waypoint.location, false, { fontSize: 22, font: 'monospace', anchor: new Float64Array([-0.25, 0.4]) });
    }
}

/**
 * Builds maps. Each builder is configured with a series of build steps which collectively define how the builder
 * compiles finished maps. In addition to defining basic map properties such as size and range, build steps can also
 * customize map behavior and appearance through adding map model modules, layers, and controllers.
 *
 * Each map compiled by the builder is associated with a {@link MapSystemContext}, which holds references to the map
 * projection, map model, all layers and controllers, and other data associated with the map. Layers and controllers
 * have access to the context when they are created during compilation, and a reference to the context is stored with
 * the compiled map.
 *
 * A single builder can compile multiple maps. Each compiled map is a separate entity, with its own model, layers,
 * controllers, and context.
 */
class MapSystemBuilder {
    /**
     * Creates an instance of a map system builder.
     * @param bus This builder's event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.moduleFactories = new Map();
        this.layerFactories = new Map();
        this.controllerFactories = new Map();
        this.contextFactories = new Map();
        this.initCallbacks = new Map();
        this.projectedSize = Subject.create(Vec2Math.create(100, 100));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map model modules added to this builder. */
    get moduleCount() {
        return this.moduleFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map layers added to this builder. */
    get layerCount() {
        return this.layerFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map controllers added to this builder. */
    get controllerCount() {
        return this.controllerFactories.size;
    }
    /**
     * Creates a new Garmin map builder. The builder is initialized with a default projected size of `[100, 100]` pixels.
     * @param bus The event bus.
     * @returns A new Garmin map builder.
     */
    static create(bus) {
        return new MapSystemBuilder(bus);
    }
    /**
     * Configures this builder to generate a map with a given projected window size.
     * @param size The size of the projected window, as `[width, height]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withProjectedSize(size) {
        this.projectedSize = 'isSubscribable' in size ? size : Subject.create(size);
        return this;
    }
    /**
     * Configures this builder to generate a map with a given dead zone.
     * @param deadZone The dead zone, as `[left, top, right, bottom]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withDeadZone(deadZone) {
        this.deadZone = 'isSubscribable' in deadZone ? deadZone : VecNSubject.createFromVector(new Float64Array(deadZone));
        return this;
    }
    /**
     * Configures this builder to generate a map with an initial projected target offset.
     * @param offset The initial projected target offset, as `[x, y]` in pixels.
     * @returns This builder, after it has been configured.
     */
    withTargetOffset(offset) {
        this.targetOffset = offset;
        return this;
    }
    /**
     * Configures this builder to generate a map with specific initial range endpoints. The endpoints are defined
     * relative to the width and height of the map's projected window, *excluding* the dead zone.
     * @param endpoints The initial range endpoints, as `[x1, y1, x2, y2]`.
     * @returns This builder, after it has been configured.
     */
    withRangeEndpoints(endpoints) {
        this.nominalRangeEndpoints = endpoints;
        return this;
    }
    /**
     * Configures this build to generate a map with a specific initial range.
     * @param range The initial range.
     * @returns This builder, after it has been configured.
     */
    withRange(range) {
        this.range = range.asUnit(UnitType.GA_RADIAN);
        return this;
    }
    /**
     * Adds a map module to this builder. When this builder compiles its map, all added modules will be created and added
     * to the map's model. If an existing module has been added to this builder with the same key, it will be replaced.
     * @param key The key (name) of the module.
     * @param factory A function which creates the module.
     * @returns This builder, after the map module has been added.
     */
    withModule(key, factory) {
        this.moduleFactories.set(key, { key, factory });
        return this;
    }
    /**
     * Adds a map layer to this builder. When this builder compiles its map, all added layers will be created and
     * attached to the map. Layers with a lower assigned order will be attached before and appear below layers with
     * greater assigned order values. If an existing layer has been added to this builder with the same key, it will be
     * replaced.
     * @param key The key of the layer.
     * @param factory A function which renders the layer as a VNode.
     * @param order The order assigned to the layer. Layers with lower assigned order will be attached to the map before
     * and appear below layers with greater assigned order values. Defaults to the number of layers already added to this
     * builder.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the layer.
     */
    withLayer(key, factory, order) {
        // Delete the key to ensure a consistent layer order.
        const wasDeleted = this.layerFactories.delete(key);
        this.layerFactories.set(key, { key, factory, order: order !== null && order !== void 0 ? order : (this.layerFactories.size + (wasDeleted ? 1 : 0)) });
        return this;
    }
    /**
     * Adds a controller to this builder. When this builder compiles its map, all added controllers will be created and
     * hooked up to the map's lifecycle callbacks. If an existing controller has been added to this builder with the same
     * key, it will be replaced.
     * @param key The key of the controller.
     * @param factory A function which creates the controller.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the controller.
     */
    withController(key, factory) {
        this.controllerFactories.set(key, { factory });
        return this;
    }
    /**
     * Adds a context property to this builder. When the builder compiles its map, all added properties will be available
     * on the context. Properties are created on the context in the order they were added to the builder, and property
     * factories have access to previously created properties on the context. If an existing property has been added to
     * this builder with the same key, it will be replaced.
     * @param key The key of the property to add.
     * @param factory A function which creates the value of the property.
     * @returns This builder, after the context property has been added.
     */
    withContext(key, factory) {
        var _a;
        if (!MapSystemBuilder.RESTRICTED_CONTEXT_KEYS.has(key)) {
            const existing = this.contextFactories.get(key);
            const order = (_a = existing === null || existing === void 0 ? void 0 : existing.order) !== null && _a !== void 0 ? _a : this.contextFactories.size;
            this.contextFactories.set(key, { key, factory, order });
        }
        return this;
    }
    /**
     * Configures this builder to execute a callback function immediately after it is finished compiling a map. If an
     * existing callback has been added to this builder with the same key, it will be replaced.
     * @param key The key of the callback.
     * @param callback The callback function to add.
     * @returns This builder, after the callback has been added.
     */
    withInit(key, callback) {
        this.initCallbacks.set(key, callback);
        return this;
    }
    /**
     * Assigns an order value to a layer. Layers with a lower assigned order will be attached before and appear below
     * layers with greater assigned order values.
     * @param key The key of the layer to which to assign the order value.
     * @param order The order value to assign.
     * @returns This builder, after the order value has been assigned.
     */
    withLayerOrder(key, order) {
        const factory = this.layerFactories.get(key);
        if (factory) {
            // Delete the key to ensure a consistent layer order.
            this.layerFactories.delete(key);
            factory.order = order;
            this.layerFactories.set(key, factory);
        }
        return this;
    }
    /**
     * Configures this builder to add a controller which maintains a list of bindings from source to target
     * subscribables.
     * @param key The key of the controller.
     * @param bindings The bindings to maintain.
     * @param onDestroy A function to execute when the controller is destroyed.
     * @returns This builder, after it has been configured.
     */
    withBindings(key, bindings, onDestroy) {
        return this.withController(key, context => new MapBindingsController(context, bindings(context), onDestroy));
    }
    /**
     * Configures this builder to generate a map which is updated at a regular frequency based on event bus clock events.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'updateFreq': Subscribable<number>`
     *
     * Controllers:
     * * `[MapSystemKeys.ClockUpdate]: MapClockUpdateController`.
     * @param updateFreq The map's update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withClockUpdate(updateFreq) {
        return this
            .withContext('updateFreq', () => typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq)
            .withController(MapSystemKeys.ClockUpdate, context => new MapClockUpdateController(context));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's projection target.
     *
     * Adds the context property `[MapSystemKeys.TargetControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withTargetControlModerator() {
        return this.withContext(MapSystemKeys.TargetControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's rotation.
     *
     * Adds the context property `[MapSystemKeys.RotationControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRotationControlModerator() {
        return this.withContext(MapSystemKeys.RotationControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's range.
     *
     * Adds the context property `[MapSystemKeys.RangeControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRangeControlModerator() {
        return this.withContext(MapSystemKeys.RangeControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to generate a map whose projection target follows the player airplane. The follow airplane
     * behavior will be active if and only if the controller owns the projection target control resource. The
     * controller's priority for the resource is `0`.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TargetControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
     *
     * Controllers:
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneController`
     * @returns This builder, after it has been configured.
     */
    withFollowAirplane() {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule)
            .withModule(MapSystemKeys.FollowAirplane, () => new MapFollowAirplaneModule())
            .withTargetControlModerator()
            .withController(MapSystemKeys.FollowAirplane, context => new MapFollowAirplaneController(context));
    }
    /**
     * Configures this builder to generate a map which supports common rotation behavior. The rotation behavior will be
     * active if and only if the controller owns the rotation control resource. The controller's priority for the
     * resource is `0`.
     *
     * Requires the module `'ownAirplaneProps': MapOwnAirplanePropsModule` to support player airplane-derived rotation
     * behavior, such as Heading Up and Track Up.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'[MapSystemKeys.RotationControl]': ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * @returns This builder, after it has been configured.
     */
    withRotation() {
        return this
            .withModule(MapSystemKeys.Rotation, () => new MapRotationModule())
            .withRotationControlModerator()
            .withController(MapSystemKeys.Rotation, context => new MapRotationController(context));
    }
    /**
     * Configures this builder to generate a map which displays an icon depicting the position of the player airplane.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule`
     *
     * Layers:
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneLayer`
     * @param iconSize The size of the icon, in pixels.
     * @param iconFilePath The path to the icon's image asset, or a subscribable which provides it.
     * @param iconAnchor The point on the icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with `[0, 0]` at the
     * top left and `[1, 1]` at the bottom right.
     * @param cssClass The CSS class(es) to apply to the root of the airplane icon layer.
     * @param order The order assigned to the icon layer. Layers with lower assigned order will be attached to the map
     * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
     * to this builder.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIcon(iconSize, iconFilePath, iconAnchor, cssClass, order) {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
            .withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule())
            .withLayer(MapSystemKeys.OwnAirplaneIcon, (context) => {
            return (FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: iconFilePath, iconSize: iconSize, iconAnchor: iconAnchor, class: cssClass }));
        }, order);
    }
    /**
     * Configures this builder to add a controller which controls and optimizes the orientation of the own airplane icon
     * in response to a desired orientation and the map rotation type. If the desired orientation matches the map
     * rotation (e.g. both Heading Up), the icon orientation is set to Map Up; otherwise the orientation is set to the
     * desired orientation.
     *
     * Requires the modules `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule` and
     * `[MapSystemKeys.Rotation]: MapRotationModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneIconOrientation]: MapOwnAirplaneIconOrientationController`.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIconOrientation(desiredOrientation) {
        return this.withController(MapSystemKeys.OwnAirplaneIconOrientation, context => new MapOwnAirplaneIconOrientationController(context, desiredOrientation));
    }
    /**
     * Configures this builder to bind properties in an added {@link MapOwnAirplanePropsModule} to data derived from
     * event bus events.
     *
     * Requires the module `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsController`.
     * @param properties The properties to bind.
     * @param updateFreq The update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplanePropBindings(properties, updateFreq) {
        return this.withController(MapSystemKeys.OwnAirplaneProps, context => new MapOwnAirplanePropsController(context, properties, typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq));
    }
    /**
     * Configures this builder to add a module describing the player airplane's autopilot properties, and optionally
     * binds the module's properties to data received over the event bus.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsController` (optional)
     * @param propertiesToBind Properties on the autopilot module to bind to data received over the event bus.
     * @param updateFreq The update frequency, in hertz, of the data bindings, or a subscribable which provides it. If
     * not defined, the data bindings will update every frame. Ignored if `propertiesToBind` is undefined.
     * @returns This builder, after it has been configured.
     */
    withAutopilotProps(propertiesToBind, updateFreq) {
        this.withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule());
        if (propertiesToBind !== undefined) {
            this.withController(MapSystemKeys.AutopilotProps, context => new MapAutopilotPropsController(context, propertiesToBind, typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq));
        }
        return this;
    }
    /**
     * Configures this builder to generate a map which includes a layer displaying text.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     *
     * Layers:
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param enableCulling Whether to enable text culling. Defaults to `false`.
     * @param order The order value to assign to the text layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to this builder.
     * @param cssClass The CSS class(es) to apply to the text layer.
     * @returns This builder, after it has been configured.
     */
    withTextLayer(enableCulling, order, cssClass) {
        return this.withContext(MapSystemKeys.TextManager, () => new MapCullableTextLabelManager(enableCulling))
            .withLayer(MapSystemKeys.TextLayer, (context) => {
            return (FSComponent.buildComponent(MapCullableTextLayer, { model: context.model, mapProjection: context.projection, manager: context.textManager, class: cssClass }));
        }, order);
    }
    /**
     * Configures this builder to generate a map which displays Bing Map terrain and weather.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsModule`
     * * `[MapSystemKeys.Weather]: MapWxrModule`
     *
     * Layers:
     * * `[MapSystemKeys.Bing]: MapBingLayer`
     * @param bingId The ID to assign to the Bing Map instance bound to the layer.
     * @param delay The delay, in milliseconds, to wait after the Bing layer has been rendered before attempting to bind
     * a Bing Map instance.
     * @param mode The mode of the map, optional. If omitted, will be EBingMode.PLANE.
     * @param order The order value to assign to the Bing layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @param cssClass The CSS class(es) to apply to the root of the map bing layer.
     * @returns This builder, after it has been configured.
     */
    withBing(bingId, delay = 0, mode, order, cssClass) {
        return this
            .withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule())
            .withModule(MapSystemKeys.Weather, () => new MapWxrModule())
            .withLayer(MapSystemKeys.Bing, context => {
            const terrainColors = context.model.getModule('terrainColors');
            const weather = context.model.getModule('weather');
            return (FSComponent.buildComponent(MapBingLayer, { model: context.model, mapProjection: context.projection, bingId: bingId, reference: terrainColors.reference, earthColors: terrainColors.colors, earthColorsElevationRange: terrainColors.colorsElevationRange, isoLines: terrainColors.showIsoLines, wxrMode: weather.wxrMode, wxrColors: weather.weatherRadarColors, mode: mode, delay: delay, class: cssClass }));
        }, order);
    }
    /**
     * Configures this builder to generate a map which uses a {@link MapSystemWaypointsRenderer} to render waypoints.
     *
     * Requires the `[MapSystemKeys.TextManager]: MapCullableTextLabelManager` context property.
     *
     * Adds the `[MapSystemKeys.WaypointRenderer]: MapSystemWaypointsRenderer` context property.
     * @returns This builder, after it has been configured.
     */
    withWaypoints() {
        return this
            .withContext(MapSystemKeys.WaypointRenderer, context => new MapSystemWaypointsRenderer(context[MapSystemKeys.TextManager]))
            .withController('waypointRendererUpdate', context => new MapSystemGenericController(context, {
            onAfterUpdated: (contextArg) => { contextArg[MapSystemKeys.WaypointRenderer].update(context.projection); }
        }));
    }
    /**
     * Configures this builder to generate a map which displays waypoints near the map center or target. Waypoints
     * displayed in this manner are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule`
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapSystemWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param configure A function to configure the waypoint display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the nearest waypoints layer.
     * @returns This builder, after it has been configured.
     */
    withNearestWaypoints(configure, enableTextCulling = false, order, cssClass) {
        this
            .withTextLayer(enableTextCulling)
            .withModule(MapSystemKeys.NearestWaypoints, () => new MapWaypointDisplayModule())
            .withWaypoints()
            .withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory())
            .withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory());
        let facilityWaypointCache = undefined;
        this.withContext('useTargetAsWaypointSearchCenter', context => {
            context[MapSystemKeys.WaypointRenderer].addRenderRole(MapSystemWaypointRoles.Normal, undefined, MapSystemWaypointRoles.Normal);
            const builder = new WaypointDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer]);
            configure(builder);
            facilityWaypointCache = builder.getWaypointCache();
            return builder.getIsCenterTarget();
        });
        const layerCount = this.layerCount;
        return this
            .withLayer(MapSystemKeys.NearestWaypoints, context => {
            return (FSComponent.buildComponent(MapSystemWaypointsLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], useMapTargetAsSearchCenter: context.useTargetAsWaypointSearchCenter, waypointCache: facilityWaypointCache, class: cssClass }));
        }, order)
            .withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays a flight plan. Waypoints displayed as part of the flight
     * plan are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.FlightPlanner]: FlightPlanner`
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     * * `[MapSystemKeys.FlightPathRenderer]: MapSystemPlanRenderer`
     *
     * Modules:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanModule`
     *
     * Layers:
     * * `` `${[MapSystemKeys.FlightPlan]}${planIndex}`: MapSystemFlightPlanLayer ``
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanController`
     * @param configure A function to configure the waypoint display.
     * @param flightPlanner The flight planner.
     * @param planIndex The index of the flight plan to display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the plan layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the flight plan canvas elements.
     * @returns This builder, after it has been configured.
     */
    withFlightPlan(configure, flightPlanner, planIndex, enableTextCulling = false, order, cssClass) {
        this
            .withTextLayer(enableTextCulling, undefined, 'flight-plan-text-layer')
            .withModule(MapSystemKeys.FlightPlan, () => new MapFlightPlanModule())
            .withWaypoints()
            .withContext(MapSystemKeys.FlightPlanner, () => flightPlanner)
            .withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory())
            .withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory())
            .withContext(MapSystemKeys.FlightPathRenderer, () => new MapSystemPlanRenderer(1))
            .withController(MapSystemKeys.FlightPlan, context => new MapFlightPlanController(context))
            .withInit(`${MapSystemKeys.FlightPlan}${planIndex}`, context => {
            const builder = new FlightPlanDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer], context[MapSystemKeys.FlightPathRenderer], planIndex);
            context[MapSystemKeys.WaypointRenderer].insertRenderRole(MapSystemWaypointRoles.FlightPlan, MapSystemWaypointRoles.Normal, undefined, `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
            configure(builder, context);
        });
        const layerCount = this.layerCount;
        return this
            .withLayer(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
            return (FSComponent.buildComponent(MapSystemFlightPlanLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], flightPathRenderer: context[MapSystemKeys.FlightPathRenderer], planIndex: planIndex, class: cssClass }));
        }, order)
            .withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays airspaces.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
     *
     * Modules:
     * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
     *
     * Layers:
     * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
     * @param cache The airspace cache to use to store airspaces retrieved for rendering.
     * @param showTypes The airspace show types to define in the airspace module. Each show type will be assigned a
     * {@link Subject} in the `show` property of the module. The Subject controls the visibility of airspace types
     * included in its show type. Airspace types that are not included in any defined show type will never be displayed.
     * @param selectRenderer A function which selects a {@link MapAirspaceRenderer}
     * @param renderOrder A function which determines the rendering order of airspaces. The function should return a
     * negative number when airspace `a` should be rendered before (below) airspace `b`, a positive number when airspace
     * `a` should be rendered after (above) airspace `b`, and `0` when the relative render order of the two airspaces
     * does not matter. If not defined, there will be no guarantee on the order in which airspaces are rendered.
     * @param options Options for the airspace layer. Option defaults are as follows:
     * * `maxSearchRadius`: 10 nautical miles
     * * `maxSearchItemCount`: 100
     * * `searchDebounceDelay`: 500 (milliseconds)
     * * `renderTimeBudget`: 0.2 (milliseconds)
     * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withAirspaces(cache, showTypes, selectRenderer, renderOrder = () => 0, options, order) {
        return this
            .withModule(MapSystemKeys.Airspace, () => new MapAirspaceModule(showTypes))
            .withContext(MapSystemKeys.AirspaceManager, () => new GenericAirspaceRenderManager(renderOrder, selectRenderer))
            .withLayer(MapSystemKeys.Airspace, context => {
            var _a, _b;
            const optionsToUse = Object.assign({}, options);
            (_a = optionsToUse.maxSearchRadius) !== null && _a !== void 0 ? _a : (optionsToUse.maxSearchRadius = Subject.create(UnitType.NMILE.createNumber(10)));
            (_b = optionsToUse.maxSearchItemCount) !== null && _b !== void 0 ? _b : (optionsToUse.maxSearchItemCount = Subject.create(100));
            return (FSComponent.buildComponent(MapAirspaceLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus, lodBoundaryCache: cache, airspaceRenderManager: context[MapSystemKeys.AirspaceManager] }, optionsToUse)));
        }, order);
    }
    /**
     * Configures this builder to generate a map which displays TCAS intruders.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.Traffic]: MapTrafficModule`
     *
     * Layers:
     * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
     * @param tcas The TCAS used by the traffic display.
     * @param iconFactory A function which creates intruder icons for the traffic display.
     * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
     * @param offScaleOobOptions A function which generates options for handling off-scale and out-of-bounds intruders.
     * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the traffic component.
     * @returns This builder, after it has been configured.
     */
    withTraffic(tcas, iconFactory, initCanvasStyles, offScaleOobOptions, order, cssClass) {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
            .withModule(MapSystemKeys.Traffic, () => new MapTrafficModule(tcas))
            .withLayer(MapSystemKeys.Traffic, context => {
            const options = offScaleOobOptions !== undefined ? Object.assign({}, offScaleOobOptions(context)) : {};
            if (options.oobOffset !== undefined && !('isSubscribable' in options.oobOffset)) {
                options.oobOffset = Subject.create(options.oobOffset);
            }
            return (FSComponent.buildComponent(MapSystemTrafficLayer, Object.assign({ context: context, model: context.model, mapProjection: context.projection, iconFactory: iconFactory, initCanvasStyles: initCanvasStyles, class: cssClass }, options)));
        }, order);
    }
    /**
     * Configures this builder using a custom build step.
     * @param builder A function which defines a custom build step.
     * @param args Arguments to pass to the custom build function.
     * @returns This builder, after it has been configured.
     */
    with(builder, ...args) {
        return builder(this, ...args);
    }
    /**
     * Compiles a map. The compiled map consists of a map context, a rendered map (as a VNode), and a node reference to
     * the rendered map component.
     *
     * The compiled map will be bound to a model (accessible through the map context) which contains all the modules
     * added to this builder.
     *
     * The map will also contain all layers added to this builder, with layers assigned lower order values appearing
     * below layers assigned greater order values. The layers can be retrieved by their keys from the map context.
     *
     * All controllers added to this builder will be created with the map and hooked up to the map's lifecycle callbacks.
     * The controllers can be retrieved by their keys from the map context.
     * @param cssClass The CSS class(es) to apply to the root of the rendered map component.
     * @returns A compiled map.
     */
    build(cssClass) {
        const context = this.buildContext();
        const controllers = [];
        const ref = FSComponent.createRef();
        const onAfterRender = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onAfterMapRender(ref.instance);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onAfterMapRender() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onDeadZoneChanged = (deadZone) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onDeadZoneChanged(deadZone);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onDeadZoneChanged() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onMapProjectionChanged = (mapProjection, changeFlags) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onMapProjectionChanged(mapProjection, changeFlags);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onMapProjectionChanged() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onBeforeUpdated = (time, elapsed) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onBeforeUpdated(time, elapsed);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onBeforeUpdated() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
            context.projection.applyQueued();
        };
        const onAfterUpdated = (time, elapsed) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onAfterUpdated(time, elapsed);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onAfterUpdated() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onWake = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onWake();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onWake() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onSleep = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onSleep();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onSleep() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onDestroy = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onMapDestroyed();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onMapDestroyed() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const map = (FSComponent.buildComponent(MapSystemComponent, { ref: ref, model: context.model, projection: context.projection, bus: context.bus, projectedSize: this.projectedSize, onAfterRender: onAfterRender, onDeadZoneChanged: onDeadZoneChanged, onMapProjectionChanged: onMapProjectionChanged, onBeforeUpdated: onBeforeUpdated, onAfterUpdated: onAfterUpdated, onWake: onWake, onSleep: onSleep, onDestroy: onDestroy, class: cssClass }, Array.from(this.layerFactories.values()).sort((a, b) => a.order - b.order).map(factory => {
            const node = factory.factory(context);
            context.setLayer(factory.key, node.instance);
            return node;
        })));
        const controllerEntries = Array.from(this.controllerFactories)
            .map(([key, factory]) => [key, factory.factory(context)]);
        for (const [key, controller] of controllerEntries) {
            context.setController(key, controller);
        }
        controllers.push(...controllerEntries.map(([, controller]) => controller));
        for (const callback of this.initCallbacks.values()) {
            callback(context);
        }
        return { context, map, ref };
    }
    /**
     * Builds a new map context. The map context will be initialized with all context properties and modules added to
     * this builder.
     * @returns The new map context.
     */
    buildContext() {
        var _a;
        const context = new DefaultMapSystemContext(this.bus, new MapProjection(this.projectedSize.get()[0], this.projectedSize.get()[1]), this.projectedSize, (_a = this.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.createFromVector(new Float64Array(4)));
        context.projection.set({
            targetProjectedOffset: this.targetOffset,
            rangeEndpoints: this.nominalRangeEndpoints !== undefined
                ? MapSystemUtils.nominalToTrueRelativeXY(this.nominalRangeEndpoints, context.projectedSize.get(), context.deadZone.get(), Vec2Math.create())
                : undefined,
            range: this.range
        });
        for (const factory of Array.from(this.contextFactories.values()).sort((a, b) => a.order - b.order)) {
            context[factory.key] = factory.factory(context);
        }
        for (const factory of this.moduleFactories.values()) {
            context.model.addModule(factory.key, factory.factory());
        }
        return context;
    }
}
MapSystemBuilder.RESTRICTED_CONTEXT_KEYS = new Set([
    'bus',
    'model',
    'projection',
    'projectedSize',
    'deadZone',
    'getLayer',
    'setLayer',
    'getController',
    'setController'
]);

var APVerticalModes;
(function (APVerticalModes) {
    APVerticalModes[APVerticalModes["NONE"] = 0] = "NONE";
    APVerticalModes[APVerticalModes["PITCH"] = 1] = "PITCH";
    APVerticalModes[APVerticalModes["VS"] = 2] = "VS";
    APVerticalModes[APVerticalModes["FLC"] = 3] = "FLC";
    APVerticalModes[APVerticalModes["ALT"] = 4] = "ALT";
    APVerticalModes[APVerticalModes["PATH"] = 5] = "PATH";
    APVerticalModes[APVerticalModes["GP"] = 6] = "GP";
    APVerticalModes[APVerticalModes["GS"] = 7] = "GS";
    APVerticalModes[APVerticalModes["CAP"] = 8] = "CAP";
    APVerticalModes[APVerticalModes["TO"] = 9] = "TO";
    APVerticalModes[APVerticalModes["GA"] = 10] = "GA";
    APVerticalModes[APVerticalModes["FPA"] = 11] = "FPA";
    APVerticalModes[APVerticalModes["FLARE"] = 12] = "FLARE";
})(APVerticalModes || (APVerticalModes = {}));
var APLateralModes;
(function (APLateralModes) {
    APLateralModes[APLateralModes["NONE"] = 0] = "NONE";
    APLateralModes[APLateralModes["ROLL"] = 1] = "ROLL";
    APLateralModes[APLateralModes["LEVEL"] = 2] = "LEVEL";
    APLateralModes[APLateralModes["GPSS"] = 3] = "GPSS";
    APLateralModes[APLateralModes["HEADING"] = 4] = "HEADING";
    APLateralModes[APLateralModes["VOR"] = 5] = "VOR";
    APLateralModes[APLateralModes["LOC"] = 6] = "LOC";
    APLateralModes[APLateralModes["BC"] = 7] = "BC";
    APLateralModes[APLateralModes["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes[APLateralModes["NAV"] = 9] = "NAV";
    APLateralModes[APLateralModes["TO"] = 10] = "TO";
    APLateralModes[APLateralModes["GA"] = 11] = "GA";
    APLateralModes[APLateralModes["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes[APLateralModes["TRACK"] = 13] = "TRACK";
    APLateralModes[APLateralModes["TRACK_HOLD"] = 14] = "TRACK_HOLD";
    APLateralModes[APLateralModes["FMS_LOC"] = 15] = "FMS_LOC";
})(APLateralModes || (APLateralModes = {}));
var APAltitudeModes;
(function (APAltitudeModes) {
    APAltitudeModes[APAltitudeModes["NONE"] = 0] = "NONE";
    APAltitudeModes[APAltitudeModes["ALTS"] = 1] = "ALTS";
    APAltitudeModes[APAltitudeModes["ALTV"] = 2] = "ALTV";
})(APAltitudeModes || (APAltitudeModes = {}));

/**
 * A Utility Class for VNAV
 */
class VNavUtils {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg) {
        if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc
            || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1
            || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
            return true;
        }
        return false;
    }
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
        const delta = targetAltitude - currentAltitude;
        const minutesToConstraint = distance / groundSpeed * 60;
        return delta / minutesToConstraint;
    }
    /**
     * Gets the vertical speed required to maintain a given flight path angle and groundspeed.
     * @param fpa The flight path angle, in degrees. Positive angles represent an ascending flight path.
     * @param groundspeed The groundspeed, in knots.
     * @returns The vertical speed required to maintain the specified flight path angle and groundspeed.
     */
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
        return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    /**
     * Gets the equivalent flight path angle for a given vertical speed and groundspeed. For this calculation, positive
     * flight path angles represent an ascending flight path.
     * @param vs The vertical speed, in feet per minute.
     * @param groundspeed The groundspeed, in knots.
     * @returns The flight path angle equivalent to the specified vertical speed and ground speed.
     */
    static getFpaFromVerticalSpeed(vs, groundspeed) {
        return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    /**
     * Gets the flight path angle for a given distance and altitude. Positive flight path angles represent an ascending
     * flight path.
     * @param distance The distance to get the angle for, in the same unit as `altitude`.
     * @param altitude The altitude to get the angle for, in the same unit as `distance`.
     * @returns The required flight path angle, in degrees.
     */
    static getFpa(distance, altitude) {
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Gets the change in altitude along a flight path angle for a given lateral distance covered.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param distance The lateral distance covered.
     * @returns The change in altitude along the specified flight path angle for the specified lateral distance covered,
     * expressed in the same units as `distance`.
     */
    static altitudeForDistance(fpa, distance) {
        return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    /**
     * Gets the lateral distance covered along a flight path angle for a given change in altitude.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param altitude The change in the altitude.
     * @returns The lateral distance covered along the specified flight path angle for the specified change in altitude,
     * expressed in the same units as `altitude`.
     */
    static distanceForAltitude(fpa, altitude) {
        return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    return l;
                }
            }
        }
        return Math.max(0, plan.length - 1);
    }
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan, iterator) {
        let fafIndex = -1;
        iterator.iterateReverse(lateralPlan, cursor => {
            if (fafIndex === -1 && cursor.legDefinition && (cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF)) {
                fafIndex = cursor.legIndex + cursor.segment.offset;
            }
        });
        fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
        return fafIndex;
    }
    /**
     * Gets the index of the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint that contains the specified flight plan leg, or `-1` if one could not
     * be found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
            if (verticalPlan.constraints[c].index >= globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint that contains the specified flight plan leg, or `undefined` if one could not be
     * found.
     */
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets the index of the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint immediately prior to the constraint that contains the specified flight
     * plan leg, or `-1` if one could nto be found.
     */
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            if (verticalPlan.constraints[c].index < globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint immediately prior to the constraint that contains the specified flight plan leg, or
     * `undefined` if one could nto be found.
     */
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan, globalLegIndex) {
        const constraintIndex = verticalPlan.constraints.findIndex(c => c.index === globalLegIndex);
        if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
            return true;
        }
        return false;
    }
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromConstraint(constraint) {
        let distance = 0;
        for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
            distance += constraint.legs[legIndex].distance;
        }
        return distance;
    }
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
        let distance = 0;
        const startGlobalIndex = previousConstraint !== undefined ? previousConstraint.index + 1 : 0;
        for (let i = startGlobalIndex; i <= constraint.index; i++) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
            distance += verticalLeg.distance;
        }
        return distance;
    }
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
        if (activeLegIndex > constraint.index) {
            return 0;
        }
        let distance = 0;
        let index = activeLegIndex;
        for (const leg of lateralPlan.legs(false, activeLegIndex)) {
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
                return Number.POSITIVE_INFINITY;
            }
            else if (leg.calculated !== undefined) {
                distance += leg.calculated.distanceWithTransitions;
            }
            if (++index > constraint.index) {
                break;
            }
        }
        distance -= distanceAlongLeg;
        return distance;
    }
    /**
     * Gets VNAV Constraint Details from a constraint.
     * @param constraint The constraint to get details from.
     * @param out The object to which write the results.
     * @returns The VNav Constraint Details.
     */
    static getConstraintDetails(constraint, out) {
        if (constraint.maxAltitude === constraint.minAltitude) {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
            switch (constraint.type) {
                case 'climb':
                case 'missed':
                    if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    break;
                default:
                    if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
            }
        }
        else {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        return out;
    }
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
        if (verticalPlan.constraints.length > 0) {
            if (selectedGlobalLegIndex < activeLegIndex) {
                return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
            }
            for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
                const constraint = verticalPlan.constraints[c];
                if (constraint.index === selectedGlobalLegIndex || (c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index)) {
                    return constraint;
                }
                else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
                    return verticalPlan.constraints[c + 1];
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the next descent constraint with a defined minimum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint with a defined minimum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if ((constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next descent constraint minimum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint defined minimum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.minAltitude : undefined;
    }
    /**
     * Gets the next climb constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint with a defined maximum altitude at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint) {
            if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return currentConstraint;
            }
            else if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
                const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== undefined ?
                    VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
                for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
                    const constraint = verticalPlan.constraints[c];
                    if (constraint.type === 'climb' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        return constraint;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the current climb constraint, if one exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The current climb constraint, or `undefined` if no such constraint exists.
     */
    static getCurrentClimbConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.type === 'climb') {
            return currentConstraint;
        }
        return undefined;
    }
    /**
     * Gets the next climb constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the next missed approach constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint with a defined maximum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next missed approach constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.targetAltitude;
        }
        const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan) {
        if (verticalPlan.fafLegIndex !== undefined) {
            return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
        }
        return undefined;
    }
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
        var _a;
        out.todLegIndex = -1;
        out.bodLegIndex = -1;
        out.todLegDistance = 0;
        out.distanceFromTod = 0;
        out.distanceFromBod = 0;
        out.currentConstraintLegIndex = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no TOD/BOD if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active constraint contains a VNAV-ineligible leg after the active leg.
            || ((activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== undefined && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex)) {
            return out;
        }
        out.currentConstraintLegIndex = activeConstraint.index;
        // Find the next BOD, which will be at the end of the earliest non-flat descent constraint subsequent to and
        // including the active constraint that ends in a level-off at a lower altitude than the aircraft's current
        // altitude. Note that we are guaranteed to not go through a VNAV discontinuity, since all constraints that end in
        // a discontinuity also end in a level-off.
        // lag altitude by ~3 seconds so that we aren't continuously pushing TOD in front of the plane while descending.
        const altitude = currentAltitude - currentVS / 20;
        let bodConstraintIndex, bodConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a climb constraint, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
                bodConstraintIndex = i;
                bodConstraint = constraint;
                break;
            }
        }
        if (!bodConstraint) {
            return out;
        }
        out.bodLegIndex = bodConstraint.index;
        // Find the TOD associated with the BOD. To do this, we need to first find the earliest non-flat descent constraint
        // between the active constraint and the BOD constraint (inclusive) that is connected to the BOD constraint with no
        // intervening flat constraints or VNAV path discontinuities and whose target altitude less than the aircraft's
        // current altitude.
        let todConstraintIndex = bodConstraintIndex;
        for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const prevConstraint = verticalPlan.constraints[i + 1];
            if (!prevConstraint
                || prevConstraint.index < activeLegIndex
                || prevConstraint.type === 'climb'
                || prevConstraint.type === 'missed'
                || prevConstraint.targetAltitude > altitude
                || prevConstraint.fpa <= 0
                || prevConstraint.isPathEnd) {
                todConstraintIndex = i;
                break;
            }
        }
        const todConstraint = verticalPlan.constraints[todConstraintIndex];
        // Now that we have found the TOD constraint, we need to find the TOD leg: the leg on which the TOD actually lies.
        // To do this, we calculate the along-track distance from the end of the TOD constraint to the TOD, then iterate
        // through the legs in the constraint backwards while keeping track of the total along-track distance covered by
        // each leg.
        let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
        let constraintIndex = todConstraintIndex;
        let todLegIndex = todConstraint.index;
        let todLegDistance = 0;
        let todLeg = todConstraint.legs[0];
        while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
            const constraint = verticalPlan.constraints[constraintIndex];
            // Remember that flight plan legs in a VNAV constraint appear in reverse order relative to how they are ordered
            // in the flight plan.
            for (let i = 0; i < constraint.legs.length; i++) {
                if (!constraint.legs[i].isEligible) {
                    // We've encounted a VNAV-ineligible leg. Since we cannot calculate a vertical path through this leg, we have
                    // to stop iterating now so that the TOD gets set to the most recent VNAV-eligible leg.
                    constraintIndex = verticalPlan.constraints.length;
                    break;
                }
                todLeg = constraint.legs[i];
                distance -= todLeg.distance;
                if (distance <= 0) {
                    todLegIndex = constraint.index - i;
                    todLegDistance = todLeg.distance + distance;
                    break;
                }
            }
            constraintIndex++;
        }
        if (distance > 0) {
            // If we still haven't found the TOD yet, set it to the beginning of the earliest VNAV leg that was iterated.
            todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
            todLegDistance = todLeg.distance;
        }
        out.todLegIndex = todLegIndex;
        out.todLegDistance = todLegDistance;
        // calculate distance to TOD/BOD
        let globalLegIndex = bodConstraint.index;
        let distanceToBOD = 0, distanceToTOD = 0;
        let hasReachedTOD = false;
        let isDone = false;
        for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const constraint = verticalPlan.constraints[i];
            for (let j = 0; j < constraint.legs.length; j++) {
                const leg = constraint.legs[j];
                if (globalLegIndex === todLegIndex) {
                    distanceToTOD -= todLegDistance;
                    hasReachedTOD = true;
                }
                if (globalLegIndex > activeLegIndex) {
                    distanceToBOD += leg.distance;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance;
                    }
                }
                else if (globalLegIndex === activeLegIndex) {
                    distanceToBOD += leg.distance - distanceAlongLeg;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance - distanceAlongLeg;
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= distanceAlongLeg;
                    }
                }
                else {
                    if (hasReachedTOD) {
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= leg.distance;
                    }
                }
                if (isDone) {
                    break;
                }
                else {
                    globalLegIndex--;
                }
            }
            if (isDone) {
                break;
            }
        }
        out.distanceFromBod = distanceToBOD;
        out.distanceFromTod = distanceToTOD;
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
        var _a, _b;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no BOC/TOC if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active VNAV constraint is not a climb-type constraint.
            || (activeConstraint.type !== 'climb' && activeConstraint.type !== 'missed')) {
            return out;
        }
        // Find the TOC. To do this, we need to first find the earliest climb constraint subsequent to and including the
        // active constraint that has a maximum altitude (i.e. is an AT, AT OR BELOW, or BETWEEN constraint). Additionally,
        // the TOC must not be separated from the active constraint by a descent-type constraint.
        let tocConstraintIndex, tocConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (isFinite(constraint.maxAltitude)) {
                tocConstraintIndex = i;
                tocConstraint = constraint;
                break;
            }
        }
        // If there is no next TOC, there also can be no next BOC since the next BOC must follow the next TOC.
        if (!tocConstraint) {
            return out;
        }
        out.tocConstraintIndex = tocConstraintIndex;
        out.tocAltitude = tocConstraint.maxAltitude;
        // Calculate distance to TOC.
        const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies.
        const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
        let tocLegIndex;
        let currentConstraintIndex = activeConstraintIndex;
        let currentConstraint;
        let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
        let currentLeg = activeLeg;
        const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
        if (distanceRemaining > activeLegDistanceRemaining) {
            distanceRemaining -= activeLegDistanceRemaining;
            if (currentConstraintLegIndex <= 0) {
                --currentConstraintIndex;
            }
            else {
                currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
            }
            while (currentConstraintIndex >= tocConstraintIndex) {
                currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                currentLeg = currentConstraint.legs[currentConstraintLegIndex];
                if (currentLeg !== undefined) {
                    if (distanceRemaining > currentLeg.distance) {
                        out.distanceFromToc += currentLeg.distance;
                        distanceRemaining -= currentLeg.distance;
                    }
                    else {
                        out.distanceFromToc += distanceRemaining;
                        tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
                        distanceRemaining -= currentLeg.distance;
                        break;
                    }
                }
                if (currentConstraintLegIndex <= 0) {
                    --currentConstraintIndex;
                }
                else {
                    currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
                }
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last leg of the TOC constraint.
            out.tocLegIndex = tocConstraint.index;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        // Find the next BOC, which is located at the beginning of the earliest climb constraint subsequent to (and not
        // including) the TOC constraint with a maximum altitude greater than the TOC constraint. Additionally, the BOC
        // must not be separated from the TOC constraint by a descent-type constraint.
        let lastClimbConstraintIndex = tocConstraintIndex;
        let bocConstraintIndex, bocConstraint;
        for (let i = tocConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (constraint.maxAltitude > tocConstraint.maxAltitude) {
                bocConstraintIndex = i;
                bocConstraint = constraint;
                break;
            }
            lastClimbConstraintIndex = i;
        }
        let bocDistanceStopConstraintIndex = undefined;
        if (bocConstraint) {
            out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
            bocDistanceStopConstraintIndex = bocConstraintIndex;
        }
        else {
            // If we did not find a climb constraint subsequent to the TOC constraint with a maximum altitude greater than the
            // the TOC constraint, then the BOC will be located at the last climb constraint.
            const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
            if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
                out.bocLegIndex = lastClimbConstraint.index + 1;
                bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
            }
        }
        // Calculate distance to BOC
        if (bocDistanceStopConstraintIndex !== undefined) {
            let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
            for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
                distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
            }
            out.distanceFromBoc = distanceToEndOfActiveConstraint;
            for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
                out.distanceFromBoc += verticalPlan.constraints[i].distance;
            }
        }
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC to cruise altitude details for a vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param cruiseAltitude The cruise altitude, in meters.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC to cruise altitude details.
     */
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        // Find the last climb constraint
        const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        // If the active leg is past the first descent constraint, both cruise BOC and cruise TOC are undefined.
        if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
            return out;
        }
        const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
        const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        // Cruise BOC will always be located at the beginning of the first leg after the last climb constraint. If there
        // are no climb constraints in the plan, then cruise BOC is undefined.
        if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
            const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
            out.bocLegIndex = lastClimbConstraint.index + 1;
            out.distanceFromBoc = activeLegDistanceRemaining
                + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
        // Calculate distance to TOC.
        const deltaAltitude = cruiseAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies. The TOC is restricted to legs prior to the first descent constraint.
        let tocLegIndex;
        const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
        if (distanceRemaining > activeLegDistanceRemaining) {
            let legIndex = activeLegIndex + 1;
            for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
                const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                if (distanceRemaining > legDistance) {
                    out.distanceFromToc += legDistance;
                    distanceRemaining -= legDistance;
                }
                else {
                    out.distanceFromToc += distanceRemaining;
                    tocLegIndex = legIndex;
                    distanceRemaining -= legDistance;
                    break;
                }
                legIndex++;
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last viable leg.
            out.tocLegIndex = lastLegIndex;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        out.tocAltitude = cruiseAltitude;
        return out;
    }
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset] !== undefined;
            }
        }
        return false;
    }
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset];
            }
        }
        throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
        const segment = verticalPlan.segments[segmentIndex];
        const leg = segment.legs[legIndex];
        if (segment && leg) {
            return leg;
        }
        else {
            throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
        }
    }
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
        return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan) {
        return verticalPlan.segments;
    }
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
        if (lateralLeg.leg !== undefined) {
            switch (lateralLeg.leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    return true;
            }
        }
        return false;
    }
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index, minAltitude, maxAltitude, name, type = 'descent') {
        return {
            index,
            minAltitude,
            maxAltitude,
            targetAltitude: 0,
            name,
            isTarget: false,
            isPathEnd: false,
            distance: 0,
            fpa: 0,
            legs: [],
            type,
            isBeyondFaf: false
        };
    }
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
        return {
            segmentIndex,
            legIndex,
            fpa: 0,
            altitude: 0,
            isUserDefined: false,
            isDirectToTarget: false,
            distance: distance,
            isEligible: true,
            isBod: false,
            isAdvisory: true,
            name
        };
    }
    /**
     * Finds the index of the first climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getFirstClimbConstraintIndex(verticalPlan) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the last climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getLastClimbConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the first descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getFirstDescentConstraintIndex(verticalPlan) {
        let index = -1;
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            const type = verticalPlan.constraints[c].type;
            if (type === 'descent' || type === 'manual') {
                index = c;
            }
            if (type === 'direct') {
                return c;
            }
        }
        return index;
    }
    /**
     * Finds the index of the last descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getLastDescentConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            const type = verticalPlan.constraints[i].type;
            if (type === 'descent' || type === 'direct' || type === 'manual') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Checks whether two speed constraints are equal.
     * @param a The first speed constraint.
     * @param b The second speed constraint.
     * @returns Whether the two speed constraints are equal.
     */
    static speedConstraintEquals(a, b) {
        return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    /**
     * Checks whether two altitude constraint details are equal.
     * @param a The first altitude constraint details.
     * @param b The second altitude constraint details.
     * @returns Whether the two altitude constraint details are equal.
     */
    static altitudeConstraintDetailsEquals(a, b) {
        return a.type === b.type && a.altitude === b.altitude;
    }
    /**
     * Checks whether two speed constraint details are equal.
     * @param a The first speed constraint details.
     * @param b The second speed constraint details.
     * @returns Whether the two speed constraint details are equal.
     */
    static speedConstraintDetailsEquals(a, b) {
        return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint
            && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint)
            && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    /**
     * Computes the path error distance that should be used given the groundspeed.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The path error distance to use.
     */
    static getPathErrorDistance(groundSpeed) {
        if (groundSpeed <= 190) {
            return 100;
        }
        else if (groundSpeed >= 210) {
            return 250;
        }
        else {
            return 100 + (((groundSpeed - 190) / 20) * 150);
        }
    }
}

/**
 * The current vertical navigation state.
 */
var VNavState;
(function (VNavState) {
    /** VNAV Disabled. */
    VNavState[VNavState["Disabled"] = 0] = "Disabled";
    /** VNAV Enabled and Inactive. */
    VNavState[VNavState["Enabled_Inactive"] = 1] = "Enabled_Inactive";
    /** VNAV Enabled and Active. */
    VNavState[VNavState["Enabled_Active"] = 2] = "Enabled_Active";
})(VNavState || (VNavState = {}));
/**
 * The current VNAV path mode.
 */
var VNavPathMode;
(function (VNavPathMode) {
    /** VNAV path is not active. */
    VNavPathMode[VNavPathMode["None"] = 0] = "None";
    /** VNAV path is armed for capture. */
    VNavPathMode[VNavPathMode["PathArmed"] = 1] = "PathArmed";
    /** VNAV path is actively navigating. */
    VNavPathMode[VNavPathMode["PathActive"] = 2] = "PathActive";
    /** The current VNAV path is not valid. */
    VNavPathMode[VNavPathMode["PathInvalid"] = 3] = "PathInvalid";
})(VNavPathMode || (VNavPathMode = {}));
/**
 * The current Approach Guidance Mode.
 */
var ApproachGuidanceMode;
(function (ApproachGuidanceMode) {
    /** VNAV is not currently following approach guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["None"] = 0] = "None";
    /** VNAV has armed ILS glideslope guidance for capture. */
    ApproachGuidanceMode[ApproachGuidanceMode["GSArmed"] = 1] = "GSArmed";
    /** VNAV is actively following ILS glideslope guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["GSActive"] = 2] = "GSActive";
    /** VNAV RNAV glidepath guidance is armed for capture. */
    ApproachGuidanceMode[ApproachGuidanceMode["GPArmed"] = 3] = "GPArmed";
    /** VNAV is actively follow RNAV glidepath guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["GPActive"] = 4] = "GPActive";
})(ApproachGuidanceMode || (ApproachGuidanceMode = {}));
/**
 * The current VNAV altitude capture type.
 */
var VNavAltCaptureType;
(function (VNavAltCaptureType) {
    /** Altitude capture is not armed. */
    VNavAltCaptureType[VNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    VNavAltCaptureType[VNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    VNavAltCaptureType[VNavAltCaptureType["VNAV"] = 2] = "VNAV";
})(VNavAltCaptureType || (VNavAltCaptureType = {}));
/**
 * The current state of VNAV availability from the director.
 */
var VNavAvailability;
(function (VNavAvailability) {
    VNavAvailability["Available"] = "Available";
    VNavAvailability["InvalidLegs"] = "InvalidLegs";
})(VNavAvailability || (VNavAvailability = {}));

/**
 * LNAV transition modes.
 */
var LNavTransitionMode;
(function (LNavTransitionMode) {
    /** LNAV is attempting to track a non-transition vector. */
    LNavTransitionMode[LNavTransitionMode["None"] = 0] = "None";
    /** LNAV is attempting to track an ingress vector. */
    LNavTransitionMode[LNavTransitionMode["Ingress"] = 1] = "Ingress";
    /** LNAV is attempting to track an egress vector. */
    LNavTransitionMode[LNavTransitionMode["Egress"] = 2] = "Egress";
    /**
     * LNAV is attempting to track a non-transition vector prior to where the ingress transition joins the base flight
     * path after deactivating suspend mode.
     */
    LNavTransitionMode[LNavTransitionMode["Unsuspend"] = 3] = "Unsuspend";
})(LNavTransitionMode || (LNavTransitionMode = {}));
/**
 * Sim var names for LNAV data.
 */
var LNavVars;
(function (LNavVars) {
    /** The current desired track, in degrees true. */
    LNavVars["DTK"] = "L:WTAP_LNav_DTK";
    /**
     * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavVars["XTK"] = "L:WTAP_LNav_XTK";
    /** Whether LNAV is tracking a path. */
    LNavVars["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    LNavVars["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    /** The currently active LNAV transition mode. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    LNavVars["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    /** The index of the vector LNAV is currently tracking. */
    LNavVars["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    /** The current course LNAV is attempting to steer, in degrees true. */
    LNavVars["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    /** Whether LNAV sequencing is suspended. */
    LNavVars["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
     * distance indicates the plane is before the start of the leg.
     */
    LNavVars["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
     * the end of the leg.
     */
    LNavVars["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position. A
     * negative distance indicates the plane is before the start of the vector.
     */
    LNavVars["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
     * past the end of the vector.
     */
    LNavVars["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    LNavVars["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    /** The current along-track ground speed of the airplane. */
    LNavVars["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
})(LNavVars || (LNavVars = {}));
/**
 * A publisher for LNAV sim var events.
 */
class LNavSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavSimVarPublisher.simvars, bus);
    }
}
LNavSimVarPublisher.simvars = new Map([
    ['lnav_dtk', { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ['lnav_xtk', { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ['lnav_is_tracking', { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ['lnav_tracked_leg_index', { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ['lnav_transition_mode', { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ['lnav_tracked_vector_index', { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ['lnav_course_to_steer', { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ['lnav_is_suspended', { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ['lnav_leg_distance_along', { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_leg_distance_remaining', { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_distance_along', { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_vector_distance_remaining', { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_anticipation_distance', { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ['lnav_along_track_speed', { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
]);

/**
 * Sim var names for VNAV data.
 */
var VNavVars;
(function (VNavVars) {
    /** The vertical deviation in feet. */
    VNavVars["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    /** The VNAV target altitude in feet. */
    VNavVars["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    /** The VNAV path mode. */
    VNavVars["PathMode"] = "L:WTAP_VNav_Path_Mode";
    /** The VNAV State. */
    VNavVars["VNAVState"] = "L:WTAP_VNav_State";
    /** Whether a VNAV Path Exists for the current leg. */
    VNavVars["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    /** The VNAV current altitude capture type. */
    VNavVars["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    /** The distance to the next TOD in meters, or -1 if one does not exist. */
    VNavVars["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    /** The distance to the next BOD in meters, or -1 if one does not exist. */
    VNavVars["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    /** The index of the leg for the next TOD. */
    VNavVars["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    /** The distance from the end of the TOD leg that the TOD is, in meters. */
    VNavVars["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    /** The index of the leg for the next BOD. */
    VNavVars["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    /** The distance to the next TOC in meters, or -1 if one does not exist. */
    VNavVars["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    /** The distance to the next BOC in meters, or -1 if one does not exist. */
    VNavVars["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    /** The index of the leg for the next TOC. */
    VNavVars["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    /** The distance from the end of the TOC leg that the TOC is, in meters. */
    VNavVars["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    /** The index of the leg for the next BOC. */
    VNavVars["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    /** The index of the leg for the next constraint. */
    VNavVars["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    /** The current constraint altitude, in feet. */
    VNavVars["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    /** The next constraint altitude, in feet. */
    VNavVars["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    /** The current required flight path angle, in degrees. */
    VNavVars["FPA"] = "L:WTAP_VNav_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    /** The VNAV approach guidance mode. */
    VNavVars["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    /** The current LPV vertical deviation in feet. */
    VNavVars["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    /** The current remaining LPV distance in meters. */
    VNavVars["GPDistance"] = "L:WTAP_GP_Distance";
    /** The current LPV FPA, in degrees. */
    VNavVars["GPFpa"] = "L:WTAP_GP_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    /** The approach glidepath service level. */
    VNavVars["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
})(VNavVars || (VNavVars = {}));
/** A publisher for VNAV sim var events. */
class VNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(VNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
VNavSimVarPublisher.simvars = new Map([
    ['vnav_vertical_deviation', { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ['vnav_target_altitude', { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ['vnav_path_mode', { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ['vnav_path_available', { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ['vnav_state', { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ['vnav_altitude_capture_type', { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ['vnav_tod_distance', { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_leg_distance', { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_bod_distance', { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_global_leg_index', { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ['vnav_bod_global_leg_index', { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ['vnav_toc_distance', { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_leg_distance', { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_boc_distance', { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_global_leg_index', { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_boc_global_leg_index', { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_global_leg_index', { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_altitude', { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_next_constraint_altitude', { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_fpa', { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ['vnav_required_vs', { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ['gp_approach_mode', { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ['gp_vertical_deviation', { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ['gp_distance', { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ['gp_fpa', { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ['gp_required_vs', { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ['gp_service_level', { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
]);

/**
 * Handles the calculation of the VNAV flight path for Path Smoothing VNAV Implementations.
 */
class SmoothingPathCalculator {
    /**
     * Creates an instance of SmoothingPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param options Options for the calculator. Options that are not explicitly provided default to the following:
     * * `defaultFpa`: 3 degrees.
     * * `minFpa`: 1.5 degrees.
     * * `maxFpa`: 6 degrees.
     * * `excludeFirstLegConstraint`: `false`.
     * * `forceFirstApproachAtConstraint`: `false`.
     * * `directToLegOffset`: `3`.
     * * `isLegEligible`: a function which designates a leg as eligible if and only if it is not a discontinuity leg or
     * a manual termination leg that ends in a discontinuity.
     * * `shouldUseConstraint`: a function which always returns `true`.
     * * `invalidateClimbConstraint`: a function which does not invalidate any climb constraint.
     * * `invalidateDescentConstraint`: a function which invalidates a descent constraint if and only if it requires an
     * ascending path or a flight path angle greater than the maximum in order to meet it from the preceding constraint.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.primaryPlanIndex = primaryPlanIndex;
        /** The Vertical Flight Plans managed by this Path Calculator */
        this.verticalFlightPlans = [];
        /** @inheritdoc */
        this.planBuilt = new SubEvent();
        /** @inheritdoc */
        this.vnavCalculated = new SubEvent();
        this.legAltitudes = [0, 0];
        this.applyPathValuesResult = [undefined, 0];
        this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
        this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
        this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
        this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
        this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
        this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
        this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : (() => true);
        this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
        this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
        const fpl = this.bus.getSubscriber();
        fpl.on('fplCreated').handle(e => this.createVerticalPlan(e.planIndex));
        fpl.on('fplCopied').handle(e => this.onPlanChanged(e.targetPlanIndex));
        fpl.on('fplLoaded').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplLegChange').handle(e => this.onPlanChanged(e.planIndex, e));
        fpl.on('fplSegmentChange').handle(e => this.onPlanChanged(e.planIndex, undefined, e));
        fpl.on('fplIndexChanged').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplCalculated').handle(e => this.onPlanCalculated(e));
        bus.getSubscriber().on('vnav_set_default_fpa').handle(this.setDefaultFpa.bind(this));
        bus.getSubscriber().on('vnav_set_vnav_direct_to').handle(data => {
            if (data.globalLegIndex < 0) {
                this.cancelVerticalDirect(data.planIndex);
            }
            else {
                this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
            }
        });
    }
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex) {
        var _a;
        var _b;
        return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : (_b[planIndex] = this.createVerticalPlan(planIndex));
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /** @inheritdoc */
    requestPathCompute(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== undefined) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            this.computePathAndNotify(lateralPlan, verticalPlan);
            return true;
        }
        return false;
    }
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for a flight plan leg, or `-1` if one
     * could not be found.
     */
    getTargetConstraintIndex(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== undefined && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
                const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
                if (priorConstraint && priorConstraint.type !== 'climb' && priorConstraint.type !== 'missed') {
                    return priorConstraintIndex;
                }
                else {
                    return -1;
                }
            }
            let i = verticalPlan.constraints.length - 1;
            while (i >= 0) {
                const constraint = verticalPlan.constraints[i];
                if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== 'climb' && constraint.type !== 'missed') {
                    return i;
                }
                i--;
            }
        }
        else {
            const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraintIndex >= 0) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isMissed = currentConstraint.type === 'missed';
                for (let i = currentConstraintIndex; i >= 0; i--) {
                    const constraint = verticalPlan.constraints[i];
                    if (constraint.type === 'climb' || (isMissed && constraint.type === 'missed')) {
                        if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                            return i;
                        }
                    }
                    else {
                        return -1;
                    }
                }
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for a flight plan leg, or `undefined` if one could
     * not be found.
     */
    getTargetConstraint(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    /** @inheritdoc */
    getTargetAltitude(planIndex, globalLegIndex) {
        var _a, _b;
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
        }
        else {
            return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
        }
    }
    /** @inheritdoc */
    getFlightPhase(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex)) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
            if (globalLegIndex > -1) {
                const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
                switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
                    case 'climb':
                    case 'missed':
                        return VerticalFlightPhase.Climb;
                }
            }
        }
        return VerticalFlightPhase.Descent;
    }
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return undefined;
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
        }
        else {
            return currentConstraint.targetAltitude;
        }
    }
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            if (priorConstraint) {
                return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
            }
            else {
                return { type: AltitudeRestrictionType.Unused, altitude: 0 };
            }
        }
        else {
            return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        }
    }
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        // added check for climb or descent for smoothing path calc
        if (currentConstraint !== undefined) {
            if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    return currentConstraint.maxAltitude;
                }
                else {
                    return currentConstraint.minAltitude;
                }
            }
            else {
                if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
                    return currentConstraint.minAltitude;
                }
                else {
                    return currentConstraint.maxAltitude;
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
        if (currentConstraint) {
            const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
            if (currentConstraintIndex > -1) {
                if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'climb' || constraint.type === 'missed') {
                            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
                else {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
        if (constraintGlobalLegIndex < 0) {
            return;
        }
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
        verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        if (verticalPlan.constraints.length > 0) {
            if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
                verticalPlan.planChanged = true;
            }
        }
    }
    /**
     * Cancels the existing VNAV direct-to for a vertical flight plan.
     * @param planIndex The index of the vertical flight plan for which to cancel the VNAV direct-to.
     */
    cancelVerticalDirect(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex === undefined) {
            return;
        }
        verticalPlan.verticalDirectIndex = undefined;
        verticalPlan.verticalDirectFpa = undefined;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        if (verticalPlan.constraints.length > 0) {
            if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
                verticalPlan.planChanged = true;
            }
        }
    }
    /**
     * Sets this calculator's default flight path angle.
     * @param fpa The new default flight path angle, in degrees. Increasingly positive values indicate steeper descents.
     */
    setDefaultFpa(fpa) {
        const newFpa = Math.max(0, fpa);
        if (newFpa !== this.flightPathAngle) {
            this.flightPathAngle = newFpa;
            for (let i = 0; i < this.verticalFlightPlans.length; i++) {
                const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : undefined;
                const verticalPlan = this.verticalFlightPlans[i];
                if (lateralPlan && verticalPlan) {
                    if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
                        verticalPlan.planChanged = true;
                        this.notifyCalculated(i);
                    }
                }
            }
        }
    }
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex !== undefined) {
            if (legChangeEvent !== undefined) {
                const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
                if (globalIndex <= verticalPlan.verticalDirectIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
            else if (segmentChangeEvent !== undefined) {
                const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
                if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
        }
        verticalPlan.planChanged = true;
        verticalPlan.currentAlongLegDistance = undefined;
    }
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    onPlanCalculated(event) {
        const lateralPlan = this.flightPlanner.getFlightPlan(event.planIndex);
        const verticalPlan = this.getVerticalFlightPlan(event.planIndex);
        if (verticalPlan.planChanged) {
            this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
            if (verticalPlan.constraints.length > 0) {
                if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
                    verticalPlan.planChanged = true;
                }
            }
            else {
                this.notifyCalculated(event.planIndex);
            }
        }
        else {
            if (verticalPlan.constraints.length > 0) {
                if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
                    verticalPlan.planChanged = true;
                }
            }
            else {
                this.notifyCalculated(event.planIndex);
            }
        }
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    notifyBuilt(planIndex) {
        this.planBuilt.notify(this, planIndex);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    notifyCalculated(planIndex) {
        this.vnavCalculated.notify(this, planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan and sends an event notifying subscribers that the plan
     * was built.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
        this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.notifyBuilt(verticalPlan.planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
        SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
        verticalPlan.planChanged = false;
    }
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
        var _a, _b, _c, _d, _e, _f, _g;
        // Reset the constraints array.
        verticalPlan.constraints.length = 0;
        // Reset the segments array.
        verticalPlan.segments.length = 0;
        verticalPlan.destLegIndex = undefined;
        verticalPlan.firstDescentConstraintLegIndex = undefined;
        verticalPlan.lastDescentConstraintLegIndex = undefined;
        verticalPlan.missedApproachStartIndex = undefined;
        // Find the FAF in the lateral plan, if any.
        verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
        const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
        let firstApproachGlobalLegIndex;
        // Iterate forward through the lateral plan to build the constraints
        for (const segment of lateralPlan.segments()) {
            // Add the plan segments to the VNav Path Calculator Segments
            verticalPlan.segments[segment.segmentIndex] = {
                offset: segment.offset,
                legs: []
            };
            if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === undefined) {
                firstApproachGlobalLegIndex = segment.offset;
            }
            for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                const globalLegIndex = segment.offset + segmentLegIndex;
                const lateralLeg = segment.legs[segmentLegIndex];
                const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '', (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : undefined);
                // Check if the leg is part of the missed approach, and set the missed approach start index.
                if (verticalPlan.missedApproachStartIndex === undefined
                    && segment.segmentType === FlightPlanSegmentType.Approach
                    && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
                    verticalPlan.missedApproachStartIndex = globalLegIndex;
                }
                // Check if the leg contains a constraint
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
                verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                // Check if the leg precedes a defined vertical direct for this vertical flight plan.
                const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== undefined && globalLegIndex < verticalPlan.verticalDirectIndex;
                const legPrecedesDirectTo = directToTargetLegIndex !== undefined && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
                if (constraintAltitudes !== undefined
                    && !legPrecedesVerticalDirectIndex
                    && !legPrecedesDirectTo
                    && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
                    verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
                    const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    // Add the new vertical constraint to the array of constraints in reverse order.
                    verticalPlan.constraints.unshift(verticalConstraint);
                }
                // Add the new vertical leg to the vertical flight plan
                verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
            }
        }
        verticalPlan.length = lateralPlan.length;
        if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== undefined) {
            const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
            if (firstApproachConstraint && firstApproachConstraint.type !== 'climb' && firstApproachConstraint.type !== 'missed') {
                SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
            }
        }
        verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
        verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    /**
     * Builds a VNAV constraint for a lateral flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the lateral flight plan leg for which to build the constraint.
     * @param lateralLeg The lateral flight plan leg for which to build the constraint.
     * @param constraintAltitudes The constraint altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @param name The name of the new constraint.
     * @returns A new VNAV constraint for the specified lateral flight plan leg.
     */
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
        var _a;
        const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? 'missed' : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? 'descent' : 'climb');
        constraint.isBeyondFaf = verticalPlan.fafLegIndex === undefined ? false : globalLegIndex > verticalPlan.fafLegIndex;
        // Check if this constraint is a vertical direct.
        if (verticalPlan.verticalDirectIndex === globalLegIndex) {
            constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
            constraint.type = 'direct';
        }
        const userFpa = lateralLeg.verticalData.fpa;
        if (userFpa !== undefined && constraint.type !== 'climb' && constraint.type !== 'missed') {
            constraint.fpa = userFpa;
            constraint.type = 'manual';
        }
        return constraint;
    }
    /**
     * Computes the vertical path for a flight plan and if successful, sends an event notifying subscribers that the plan
     * was calculated.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     * @returns Whether a path was successfully computed.
     */
    computePathAndNotify(lateralPlan, verticalPlan) {
        if (this.computePath(lateralPlan, verticalPlan)) {
            this.notifyCalculated(lateralPlan.planIndex);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Computes the vertical path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     * @returns Whether a path was successfully computed.
     */
    computePath(lateralPlan, verticalPlan) {
        if (verticalPlan.constraints.length < 1) {
            return false;
        }
        this.computeDescentPath(lateralPlan, verticalPlan);
        return true;
    }
    /**
     * Computes the descent path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computeDescentPath(lateralPlan, verticalPlan) {
        if (verticalPlan.constraints.length < 1) {
            return;
        }
        this.fillLegDistances(lateralPlan, verticalPlan);
        // Updated leg distances could cause some invalidated constraints to become valid, so we will re-insert all
        // invalidated constraints and filter them again.
        this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
        this.findAndRemoveInvalidConstraints(verticalPlan);
        this.populateConstraints(verticalPlan);
        if (this.computeFlightPathAngles(verticalPlan)) {
            for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
                const constraint = verticalPlan.constraints[constraintIndex];
                if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                    let altitude = constraint.targetAltitude;
                    let constraintIsBod = true;
                    if (constraintIndex > 0) {
                        const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
                        if (nextConstraint !== undefined && nextConstraint.type !== 'climb') {
                            const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                            if ((nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25) || constraint.fpa === 0) {
                                constraintIsBod = false;
                            }
                        }
                    }
                    if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
                        constraint.isPathEnd = true;
                        constraint.isTarget = true;
                        constraintIsBod = true;
                    }
                    for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
                        const leg = constraint.legs[legIndex];
                        leg.fpa = constraint.fpa;
                        leg.altitude = altitude;
                        altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
                        if (legIndex === 0) {
                            leg.isAdvisory = false;
                        }
                        else {
                            leg.isAdvisory = true;
                        }
                        if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                            leg.isBod = true;
                        }
                        else {
                            leg.isBod = false;
                        }
                    }
                }
            }
        }
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    fillLegDistances(lateralPlan, verticalPlan) {
        var _a, _b, _c;
        if (lateralPlan.length > 0) {
            for (const segment of lateralPlan.segments()) {
                if (segment) {
                    const vnavSegment = verticalPlan.segments[segment.segmentIndex];
                    for (let l = 0; l < segment.legs.length; l++) {
                        const leg = segment.legs[l];
                        if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                            vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
                        }
                        else if (leg && leg.calculated && leg.calculated.endLat !== undefined && leg.calculated.endLon !== undefined) {
                            let prevLeg;
                            for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                                if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== undefined && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== undefined) {
                                    prevLeg = checkLeg;
                                    break;
                                }
                            }
                            if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                                vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                            }
                        }
                        else {
                            vnavSegment.legs[l].distance = 0;
                        }
                    }
                }
            }
        }
    }
    /**
     * Finds and removes invalid constraints from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    findAndRemoveInvalidConstraints(verticalPlan) {
        var _a, _b, _c;
        let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all constraints prior to the
        // direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? firstDescentConstraintIndex
            : verticalPlan.constraints.length - 1;
        let phase = 'climb';
        let priorMinAltitude = -Infinity;
        let priorMaxAltitude = Infinity;
        let distanceFromPriorMinAltitude = 0;
        let requiredFpa = 0;
        for (let i = startIndex; i >= 0; i--) {
            const currentConstraint = verticalPlan.constraints[i];
            const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
            let currentPhase;
            switch (currentConstraint.type) {
                case 'climb':
                case 'missed':
                    currentPhase = currentConstraint.type;
                    break;
                default:
                    currentPhase = 'descent';
            }
            if (currentPhase !== phase) {
                // Reset prior altitudes when switching phases.
                phase = currentPhase;
                priorMinAltitude = -Infinity;
                priorMaxAltitude = Infinity;
                distanceFromPriorMinAltitude = currentConstraintDistance;
            }
            else {
                distanceFromPriorMinAltitude += currentConstraintDistance;
            }
            let isDescentConstraint;
            let shouldInvalidate;
            switch (phase) {
                case 'climb':
                case 'missed':
                    isDescentConstraint = false;
                    shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
                    break;
                default:
                    isDescentConstraint = true;
                    if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
                        requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
                    }
                    else {
                        requiredFpa = 0;
                    }
                    shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
            }
            const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
            if (shouldInvalidate) {
                constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
                verticalPlan.constraints.splice(i, 1);
                // Need to subtract current constraint distance because it will get added again at the beginning of the next iteration.
                // (The next constraint inherits the legs that belonged to the current constraint after it is removed.)
                distanceFromPriorMinAltitude -= currentConstraintDistance;
                // If we invalidated the first descent constraint, we need to find the new one.
                if (isDescentConstraint && i === firstDescentConstraintIndex) {
                    firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
                    verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
                }
            }
            else {
                constraintLeg.invalidConstraintAltitude = undefined;
                if (isFinite(currentConstraint.minAltitude)) {
                    priorMinAltitude = currentConstraint.minAltitude;
                    distanceFromPriorMinAltitude = 0;
                }
                if (isFinite(currentConstraint.maxAltitude)) {
                    priorMaxAltitude = currentConstraint.maxAltitude;
                }
            }
        }
        // Update last descent leg in case we invalidated some descent constraints
        verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    /**
     * Finds previously invalidated constraints and re-inserts them into the vertical flight plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
        var _a;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all legs prior to and including
        // the direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? (verticalPlan.firstDescentConstraintLegIndex + 1)
            : 0;
        let globalLegIndex = startIndex;
        for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
            if (verticalLeg.invalidConstraintAltitude !== undefined) {
                const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                if (constraintAltitudes !== undefined) {
                    const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
                    // If we re-validated a descent constraint, we need to update the first/last descent constraint when appropriate.
                    if (proposedConstraint.type === 'descent'
                        || proposedConstraint.type === 'manual'
                        || proposedConstraint.type === 'direct'
                        || proposedConstraint.type === 'dest') {
                        if (verticalPlan.firstDescentConstraintLegIndex === undefined || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
                        }
                        if (verticalPlan.lastDescentConstraintLegIndex === undefined || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                            verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
                        }
                    }
                }
            }
            globalLegIndex++;
        }
    }
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    populateConstraints(verticalPlan) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
            const constraint = verticalPlan.constraints[constraintIndex];
            const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
            constraint.legs.length = 0;
            constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
            let eligibleLegIndex;
            let ineligibleLegIndex;
            for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== undefined ? previousConstraint.index : -1); globalLegIndex--) {
                const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
                constraint.legs.push(verticalLeg);
                if (ineligibleLegIndex === undefined && verticalLeg.isEligible) {
                    eligibleLegIndex = globalLegIndex;
                }
                if (ineligibleLegIndex === undefined && !verticalLeg.isEligible) {
                    ineligibleLegIndex = globalLegIndex;
                }
            }
            if (ineligibleLegIndex !== undefined && eligibleLegIndex !== undefined) {
                constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
            }
        }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    computeFlightPathAngles(verticalPlan) {
        // Iterate through all descent constraints in reverse flight plan order and attempt to assign one as a "target"
        // constraint, which is a constraint that anchors a constant FPA path connecting it to one or more prior
        // constraints.
        // Once a target constraint is found, the iteration continues as we attempt to build a constant FPA path backwards
        // from the target constraint that meets all the iterated constraints. Once we reach a constraint that cannot be
        // met with a constant FPA path from the target constraint that also meets all intermediate constraints, we assign
        // a new target constraint at the point where the FPA must change. Certain constraints must also be designated as
        // target constraints regardless of whether a constant FPA path through them is possible. In any case, once we
        // designate a new target constraint, the process is repeated until we run out of descent constraints.
        let currentTargetConstraint;
        let currentPathSegmentDistance = 0;
        let currentPathSegmentMinFpa = this.minFlightPathAngle;
        let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        let currentTargetConstraintHasFixedFpa = false;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
            // There are no descent constraints, so no FPAs to be calculated
            return false;
        }
        for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
            const constraint = verticalPlan.constraints[targetConstraintIndex];
            // If the current constraint is climb or missed, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            // If we haven't found a target constraint yet, attempt to make the current constraint the target constraint,
            // if it defines either a minimum or maximum altitude. The target altitude is preferentially set to the minimum
            // altitude, if it exists. If the current constraint has neither a minimum nor maximum altitude (which should
            // technically never happen), skip it.
            if (!currentTargetConstraint) {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    currentTargetConstraint = constraint;
                    currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
                    currentTargetConstraint.isTarget = true;
                }
                else {
                    continue;
                }
            }
            // Reset the method variables
            currentPathSegmentMinFpa = this.minFlightPathAngle;
            currentPathSegmentMaxFpa = this.maxFlightPathAngle;
            currentPathSegmentDistance = currentTargetConstraint.distance;
            const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
            if (currentTargetConstraintIsFirstDescentConstraint) {
                if (currentTargetConstraint.type === 'descent') {
                    // If this is the first descent constraint and it is not a direct or manual, set the FPA to the default value.
                    currentTargetConstraint.fpa = this.flightPathAngle;
                }
                // If currentTargetConstraintIsFirstDescentConstraint is true, then after this logic, we're done with this method.
                return true;
            }
            // If the current target constraint is a manual or direct type, then honor the FPA by not allowing any other FPAs.
            if (currentTargetConstraint.type === 'manual') {
                currentPathSegmentMinFpa = currentTargetConstraint.fpa;
                currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
                currentTargetConstraintHasFixedFpa = true;
            }
            else {
                currentTargetConstraintHasFixedFpa = false;
            }
            let pathSegmentIsFlat = false;
            for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
                const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
                const isCurrentConstraintClimb = currentConstraint.type === 'climb' || currentConstraint.type === 'missed';
                const isCurrentConstraintManual = currentConstraint.type === 'manual';
                const isCurrentConstraintDirect = currentConstraint.type === 'direct';
                if (isCurrentConstraintClimb) {
                    // We have reached a climb constraint.
                    if (currentConstraintIndex - 1 > targetConstraintIndex) {
                        // There is at least one constraint between the existing target constraint and the current climb
                        // constraint. Attempt to extend the constant-FPA path through the constraint immediately following the
                        // current climb constraint (which is guaranteed to be a descent constraint).
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                        const maxAltitude = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
                        const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude, false);
                        if (terminatedIndex < currentConstraintIndex) {
                            // The path was terminated early, which means there is a new target constraint.
                            targetConstraintIndex = terminatedIndex - 1; // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                            break;
                        }
                    }
                    else {
                        // The existing target constraint immediately follows the current climb constraint. Treat the target
                        // constraint as if it were the first descent constraint and apply the default FPA. Note that we are
                        // guaranteed the target constraint is not a direct constraint.
                        currentTargetConstraint.fpa = this.flightPathAngle;
                    }
                    // Do not designate a new target constraint in order to allow the outer loop to find the new one.
                    targetConstraintIndex = currentConstraintIndex;
                    currentTargetConstraint = undefined;
                    break;
                }
                const minAltitude = currentConstraint.minAltitude;
                const maxAltitude = currentConstraint.maxAltitude;
                if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
                    // We are in a flat segment (all constraints with FPA = 0) and the current constraint would allow a
                    // non-zero FPA to the constraint immediately following it. Therefore, we set the new target constraint
                    // to the constraint immediately following the current one (because it is at the end of that constraint
                    // where the FPA can potentially change from non-zero to zero). Note that we are guaranteed that the
                    // new target constraint lies prior to the existing target constraint.
                    const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                    const newTargetConstraintIndex = currentConstraintIndex - 1;
                    SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, 
                    // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                    // constraints are equal to the flat segment altitude.
                    Infinity, this.applyPathValuesResult);
                    // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                    targetConstraintIndex = newTargetConstraintIndex - 1;
                    currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
                    currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                    currentTargetConstraint.isTarget = true;
                    break;
                }
                else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
                    // The current constraint does not allow a non-zero FPA to the target constraint, and the target constraint
                    // does not have a fixed FPA. We will mark the current segment as flat and set the target constraint FPA to 0.
                    pathSegmentIsFlat = true;
                    currentTargetConstraint.fpa = 0;
                    if (isCurrentConstraintFirstDescent) {
                        // If the current constraint is the first descent constraint, then we need to make it the new target
                        // constraint because the first descent constraint is never flat.
                        const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                        SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, 
                        // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                        // constraints are equal to the flat segment altitude.
                        Infinity, this.applyPathValuesResult);
                        // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                        targetConstraintIndex = currentConstraintIndex - 1;
                        currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
                        currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                        currentTargetConstraint.isTarget = true;
                        break;
                    }
                    continue;
                }
                // Get the min and max FPA from the current target constraint to the current constraint.
                const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
                const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
                const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
                // A new target constraint needs to be created under the following conditions:
                // - The current constraint cannot be met with a constant FPA path from the current target constraint within
                //   this calculator's FPA limits.
                // - The current constraint is the final approach fix.
                // - The current constraint is a vertical direct constraint.
                // - The current constraint is a manual constraint.
                if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
                    // We need to choose a FPA for the constant-FPA smoothed path.
                    if (isFpaOutOfBounds) {
                        // If we are creating a new target constraint because the current constraint can't be met with a
                        // constant-FPA path, then we set the FPA of the smoothed path to the value that brings the new
                        // target constraint's target altitude as close to meeting the current constraint as possible.
                        if (minFpa > currentPathSegmentMaxFpa) {
                            currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
                        }
                        else {
                            currentTargetConstraint.fpa = currentPathSegmentMinFpa;
                        }
                    }
                    else {
                        // If the new target constraint can be met with a constant-FPA path, then we choose a valid FPA that is
                        // as close to the calculator's default FPA as possible.
                        currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                        currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    }
                    // Find the next constraint with a max altitude
                    const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
                    // Attempt to extend a constant-FPA path from the existing target constraint to the current constraint and
                    // make the current constraint the new target constraint.
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
                    targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                    currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                    break;
                }
                else if (isCurrentConstraintFirstDescent) {
                    // We have reached the first descent constraint without needing to create a new target constraint, so
                    // attempt to extend the constant-FPA path from the existing target constraint through the first descent
                    // constraint.
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
                    if (terminatedIndex < currentConstraintIndex + 1) {
                        // The path was terminated early, which means there is a new target constraint.
                        targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                        currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                        break;
                    }
                    else {
                        // The path was not terminated early, so we are done.
                        return true;
                    }
                }
                else {
                    // Extend the current constant-FPA path and update the FPA limits
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentPathSegmentDistance += currentConstraint.distance;
                }
            }
        }
        return true;
    }
    /**
     * Attempts to extend and terminate a constant-FPA path from an existing target constraint at another constraint,
     * applying flight path angles and target altitudes to each constraint along the path. The target constraint defines
     * the FPA of the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param terminatingConstraintIndex The index of the constraint at which to terminate the path.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param terminatingConstraintIsTarget Whether to designate the terminating constraint as a target constraint if the
     * path is not terminated early. If the path is terminated early, this argument is ignored and the constraint at
     * which the path was terminated early is always designated as a target constraint.
     * @returns The index of the constraint at which the constant-FPA path was actually terminated.
     */
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
        const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
        if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== undefined) {
            // A constant-FPA path was not able to be extended from the existing target constraint to the first descent
            // constraint, so we need to designate a new target constraint where the path terminated.
            const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
            // Establish the proposed next target constraint target altitude
            const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
            const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
            // Set the new target constraint values
            const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            newTargetConstraint.isTarget = true;
            newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
        }
        return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.constraints.length > 0) {
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                const constraint = verticalPlan.constraints[i];
                if (constraint.type !== 'climb') {
                    return constraint.targetAltitude;
                }
            }
        }
        return undefined;
    }
    // Start of buildVerticalFlightPlan helper methods
    /**
     * Gets the constraint altitudes for a lateral flight plan leg.
     * @param leg A lateral flight plan leg.
     * @param out The tuple to which to write the altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @returns The constraint altitudes, in meters, for the specified flight plan leg, as
     * `[minimum_altitude, maximum_altitude]`, or `undefined` if the leg does not define any altitude constraints.
     */
    static getConstraintAltitudes(leg, out) {
        if (leg.verticalData !== undefined) {
            switch (leg.verticalData.altDesc) {
                case AltitudeRestrictionType.At:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.AtOrAbove:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = Number.POSITIVE_INFINITY;
                    return out;
                case AltitudeRestrictionType.AtOrBelow:
                    out[0] = Number.NEGATIVE_INFINITY;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.Between:
                    out[0] = leg.verticalData.altitude2;
                    out[1] = leg.verticalData.altitude1;
                    return out;
            }
        }
        return undefined;
    }
    /**
     * Forces a constraint to an AT constraint.
     * @param constraint The constraint to force to an AT constraint.
     */
    static forceAtConstraint(constraint) {
        if (constraint.minAltitude !== constraint.maxAltitude) {
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                constraint.maxAltitude = constraint.minAltitude;
            }
            else {
                constraint.minAltitude = constraint.maxAltitude;
            }
        }
    }
    /**
     * Gets the global index of a flight plan's lateral direct-to target leg.
     * @param lateralPlan A flight plan.
     * @returns The global index of the flight plan's lateral direct-to target leg, or `undefined` if the plan does not
     * have an existing lateral direct-to.
     */
    static getDirectToTargetLegIndex(lateralPlan) {
        const directToData = lateralPlan.directToData;
        if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
            const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
            if (segment !== null) {
                return segment.offset + directToData.segmentLegIndex;
            }
        }
        return undefined;
    }
    /**
     * Checks if there is a lateral direct-to leg in the flight plan and if so, flags the corresponding vertical flight
     * plan leg as such and marks the first descent constraint
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param directToLegOffset The offset of the lateral direct-to leg from the direct-to target leg.
     */
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
        // Check for a direct to in the lateral plan
        if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
            const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
            if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
                const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
                directVerticalLeg.isDirectToTarget = true;
                const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
                if (segment !== undefined) {
                    const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
                    for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type !== 'climb' && constraint.type !== 'missed' && constraint.index >= globalLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                            return;
                        }
                    }
                    verticalPlan.firstDescentConstraintLegIndex = undefined;
                }
            }
        }
    }
    /**
     * Checks whether a leg constraint is part of the missed approach.
     * @param lateralSegment The lateral flight plan segment to which the constraint's leg belongs.
     * @param lateralLeg The lateral flight plan leg to which the constraint belongs.
     * @returns Whether the leg constraint is part of the missed approach.
     */
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
        if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
        const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
        const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
        if (currentMinWithPrecision > priorMaxWithPrecision) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
        if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
            const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
            const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
            if (minFpaTempValue > maxFpa) {
                return true;
            }
        }
        return false;
    }
    /**
     * The default function which checks whether a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVnavEligible(lateralLeg) {
        switch (lateralLeg.leg.type) {
            case LegType.VM:
            case LegType.FM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * The default function which checks whether a climb constraint should be invalidated. This function always returns
     * `false`.
     * @returns Whether the specified climb constraint should be invalidated (always `false`).
     */
    static invalidateClimbConstraint() {
        return false;
    }
    /**
     * The default function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
        return (isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10)) || requiredFpa > maxFpa;
    }
    // Start of computeFlightPathAngles helper methods
    /**
     * Finds the maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to a
     * given constraint, among all constraints prior to and including (in flight plan order) the given constraint. If a
     * vertical direct constraint is among the candidates, its minimum altitude is used if it does not define a maximum
     * altitude.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the constraint for which to find the closest prior maximum altitude.
     * @param firstDescentConstraintIndex The index of the first descent constraint.
     * @returns The maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to the
     * specified constraint, among all constraints prior to and including (in flight plan order) the specified
     * constraint, or `Infinity` if there is no such altitude.
     */
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
        for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.maxAltitude < Infinity) {
                return constraint.maxAltitude;
            }
            if (i === firstDescentConstraintIndex && constraint.type === 'direct') {
                if (constraint.minAltitude > -Infinity) {
                    return constraint.minAltitude;
                }
            }
        }
        return Infinity;
    }
    /**
     * Applies flight path angle and target altitude values to a sequence of constraints connected to a target constraint
     * by a constant-FPA path extending backwards from the target constraint. The target constraint defines the FPA of
     * the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param endConstraintIndex The index of the constraint at which the constant-FPA path ends, exclusive.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param out The tuple to which to write the result of the operation.
     * @returns `[index, distance]`, where `index` is the index of the constraint at which the path was terminated due to
     * violation of the maximum target altitude, or `undefined` if no constraint violated the maximum altitude, and
     * `distance` is the total distance of the path, in meters.
     */
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        let distance = currentTargetConstraint.distance;
        for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
            const smoothedConstraint = verticalPlan.constraints[i];
            const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
            // The path can continue past the current constraint if the target altitude at the current constraint is less
            // than the maximum altitude.
            if (targetAltitude < maxAltitude) {
                smoothedConstraint.fpa = currentTargetConstraint.fpa;
                smoothedConstraint.targetAltitude = targetAltitude;
                distance += smoothedConstraint.distance;
            }
            else {
                out[0] = i;
                out[1] = distance;
                return out;
            }
        }
        out[0] = undefined;
        out[1] = distance;
        return out;
    }
}
SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;

/**
 * Sim var names for LNAV-related data.
 */
var LNavDataVars;
(function (LNavDataVars) {
    /** The current nominal desired track, in degrees true. */
    LNavDataVars["DTKTrue"] = "L:WT_LNavData_DTK_True";
    /** The current nominal desired track, in degrees magnetic. */
    LNavDataVars["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    /**
     * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavDataVars["XTK"] = "L:WT_LNavData_XTK";
    /** The current CDI scale. */
    LNavDataVars["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    LNavDataVars["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */
    LNavDataVars["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV. */
    LNavDataVars["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    /** The nominal distance remaining to the destination. */
    LNavDataVars["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
})(LNavDataVars || (LNavDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class LNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavDataSimVarPublisher.simvars, bus);
    }
}
LNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
]);

/**
 * Transports an alert state to the CAS via the event bus.
 */
class CasAlertTransporter {
    /**
     * Creates an instance of a CasAlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     */
    constructor(bus, uuid, priority, suffix) {
        this.bus = bus;
        this.uuid = uuid;
        this.priority = priority;
        this.suffix = suffix;
        this.currentValue = false;
        this.subs = [];
        this.updateEntries = [];
        this.isAlive = true;
        this.isPaused = false;
    }
    /**
     * Sets whether or not the alert is active.
     * @param active Whether or not the alert is active.
     * @throws Error if this transporter has been destroyed.
     */
    set(active) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot change an alert with a dead transporter');
        }
        if (this.currentValue !== active) {
            if (active) {
                this.bus.getPublisher().pub('cas_activate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            else {
                this.bus.getPublisher().pub('cas_deactivate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            this.currentValue = active;
        }
    }
    /**
     * Binds an alert state to a subscribable value.
     * @param toWatch The subscribable value to watch.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bind(toWatch, predicate) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        this.subs.push(toWatch.sub(v => this.set(predicate(v)), true, this.isPaused));
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindUpdate(predicate) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: false,
            func: (deltaTime) => this.set(predicate(deltaTime))
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @param state The optional state to pass into the predicate.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindStateUpdate(predicate, state) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: true,
            func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
            state
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Resumes this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also resumed. On resumption, the values of bound subscribables are evaluated
     * immediately, while the values of bound update loops will be evaluated during the next update cycle.
     * @returns This transporter, after it has been resumed.
     * @throws Error if this transporter has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot resume a dead transporter');
        }
        if (!this.isPaused) {
            return this;
        }
        this.isPaused = false;
        this.subs.forEach(sub => { sub.resume(true); });
        this.updateEntries.forEach(entry => { entry.isPaused = false; });
        return this;
    }
    /**
     * Pauses this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also paused.
     * @returns This transporter, after it has been paused.
     * @throws Error if this transporter has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot pause a dead transporter');
        }
        if (this.isPaused) {
            return this;
        }
        this.isPaused = true;
        this.subs.forEach(sub => { sub.pause(); });
        if (CasAlertTransporter.updateEntries) {
            this.updateEntries.forEach(entry => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const index = CasAlertTransporter.updateEntries.indexOf(entry);
                if (index >= 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    CasAlertTransporter.updateEntries.splice(index, 1);
                }
            });
        }
        return this;
    }
    /**
     * Destroys this transporter. This will destroy any subscribables or update loops used to bind the state of this
     * transporter's alert. Once this transporter has been destroyed, it cannot be used to change the state of its alert,
     * bind the state of its alert, or be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        this.subs.forEach(sub => { sub.destroy(); });
        this.updateEntries.forEach(entry => { entry.isPaused = true; });
    }
    /**
     * Creates an instance of an AlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     * @returns The created AlertTransporter.
     */
    static create(bus, uuid, priority, suffix) {
        return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    /**
     * Initializes the update functions.
     */
    initUpdateFuncs() {
        if (CasAlertTransporter.updateEntries === undefined) {
            CasAlertTransporter.updateEntries = [];
            this.bus.getSubscriber().on('simTime').handle((timestamp) => {
                if (CasAlertTransporter.previousTimestamp === -1) {
                    CasAlertTransporter.previousTimestamp = timestamp;
                }
                const deltaTime = MathUtils.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 10000);
                if (CasAlertTransporter.updateEntries !== undefined) {
                    for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
                        const entry = CasAlertTransporter.updateEntries[i];
                        if (entry.isPaused) {
                            continue;
                        }
                        if (entry.hasState) {
                            entry.func(deltaTime, entry.state);
                        }
                        else {
                            entry.func(deltaTime);
                        }
                    }
                }
                CasAlertTransporter.previousTimestamp = timestamp;
            });
        }
    }
}
CasAlertTransporter.previousTimestamp = -1;

/**
 * A bus-based system for publishing and managing CAS notifications.
 */
/**
 * A system for CAS management.
 *
 * Every avionics system must have exactly one instance of CasSystem configured as the primary system. This is the one
 * that is responsible for triggering sim-level master caution/warning alerts and intercepting and handling master
 * acknowledge events.
 *
 * Each JS instrument should have at most one instance of CasSystem. Multiple instances of CasSystem on a single
 * instrument will cause duplicated events to be published to the topics defined by {@link CasStateEvents}.
 */
class CasSystem {
    /**
     * Create a CasSystem.
     * @param bus The event bus.
     * @param primary Whether or not this is the system responsible for managing alerts at the sim level.
     */
    constructor(bus, primary = false) {
        this.registeredAlerts = new Map();
        this.activeInhibitStates = new Set();
        this.scheduledSuffixedAlerts = new Map();
        this.scheduledUnsuffixedAlerts = new Map();
        this.previousScheduleCheckTime = -1;
        this.initialAcknowledge = true;
        this.masterWarningActive = undefined;
        this.masterCautionActive = undefined;
        /** A compound map containing every active CAS message at every message priority. */
        this.allMessages = new Map([
            [AnnunciationType.Warning, new Map()],
            [AnnunciationType.Caution, new Map()],
            [AnnunciationType.Advisory, new Map()],
            [AnnunciationType.SafeOp, new Map()],
        ]);
        /** An array of CAS messages filtered to only show the highest priority for any given UUID and suffix. */
        this.displayedCasMessages = ArraySubject.create();
        this.prevDisplayedCasMessages = [];
        /** The displayable CAS messages sorted by the standard sort order of priority, state, and age. */
        // TODO Add the ability to specify alternate sorting logic.
        this._casActiveMessageSubject = SortedMappedSubscribableArray.create(this.displayedCasMessages, (a, b) => {
            if (a.uuid && b.uuid && a.lastActive !== undefined && b.lastActive !== undefined) {
                if (a.priority === b.priority) {
                    return b.lastActive - a.lastActive;
                }
                return a.priority - b.priority;
            }
            else {
                return 0;
            }
        }, (a, b) => a.uuid === b.uuid);
        this.casActiveMessageSubject = this._casActiveMessageSubject;
        this.bus = bus;
        this.casSubscriber = this.bus.getSubscriber();
        this.casPublisher = this.bus.getPublisher();
        this.casStatePublisher = this.bus.getPublisher();
        this.isPrimary = primary;
        this.setMasterStatus(AnnunciationType.Caution, false);
        this.setMasterStatus(AnnunciationType.Warning, false);
        this.bus.getSubscriber().on('simTime').handle(t => this.checkScheduledAlerts(t));
        // If this is the primary CAS system, set up handlers for the master caution and warning
        // acknowledgement events and reset the initial alert state.
        if (this.isPrimary) {
            KeyEventManager.getManager(this.bus).then(manager => {
                manager.interceptKey('MASTER_CAUTION_ACKNOWLEDGE', true);
                manager.interceptKey('MASTER_WARNING_ACKNOWLEDGE', true);
            });
            this.bus.getSubscriber().on('key_intercept').handle((keyData) => {
                switch (keyData.key) {
                    case 'MASTER_CAUTION_ACKNOWLEDGE':
                        this.handleAcknowledgement(AnnunciationType.Caution);
                        break;
                    case 'MASTER_WARNING_ACKNOWLEDGE':
                        this.handleAcknowledgement(AnnunciationType.Warning);
                        break;
                }
            });
        }
        // Set up subs to the events we react to.
        this.casSubscriber.on('cas_register_alert').handle(alertConfig => {
            if (!this.registeredAlerts.has(alertConfig.uuid)) {
                this.registeredAlerts.set(alertConfig.uuid, alertConfig);
            }
        });
        this.casSubscriber.on('cas_activate_alert').handle(eventData => {
            this.scheduleAlert(eventData.key, eventData.priority);
        });
        this.casSubscriber.on('cas_deactivate_alert').handle(eventData => {
            this.deactivateAlert(eventData.key, eventData.priority);
        });
        this.casSubscriber.on('cas_activate_inhibit_state').handle(state => {
            this.handleInhibitState(state, true);
        });
        this.casSubscriber.on('cas_deactivate_inhibit_state').handle(state => {
            this.handleInhibitState(state, false);
        });
        this.casSubscriber.on('cas_set_initial_acknowledge').handle(v => {
            this.initialAcknowledge = v;
        });
        // If we're not primary we need to handle master ack events published by the primary.
        if (!this.isPrimary) {
            this.casSubscriber.on('cas_master_acknowledge').handle(ackType => {
                this.handleAcknowledgement(ackType);
            });
        }
        // Requests the CAS system to suppress all annunciations with the provided priority.
        this.casSubscriber.on('cas_suppress_priority').handle(priority => {
            this.suppressType(priority);
        });
        // Requests the CAS system to unsuppress all annunciations with the provided priority.
        this.casSubscriber.on('cas_unsuppress_priority').handle(priority => {
            this.unsuppressAllSuppressed(priority);
        });
        this.casPublisher.pub('cas_publish_all_registrations', true, true);
    }
    /**
     * Suppress all messages of a given type.
     * @param priority The type of messages which shall be suppressed.
     */
    suppressType(priority) {
        for (const [, message] of this.allMessages.get(priority) || []) {
            message.suppressed = true;
        }
        this.refreshDisplayedAlerts();
    }
    /**
     * Unsuppress all messages of a given type.
     * @param priority The type of messages which shall be suppressed.
     */
    unsuppressAllSuppressed(priority) {
        for (const [, message] of this.allMessages.get(priority) || []) {
            message.suppressed = false;
        }
        this.refreshDisplayedAlerts();
    }
    /**
     * Create a new message from an alert key at a given priority.
     * @param alertKey The alert key.
     * @param priority The priority.
     * @returns A new CasActiveMessage or undefined if the key was invalid.
     */
    createNewMessage(alertKey, priority) {
        var _a;
        const def = this.registeredAlerts.get(alertKey.uuid);
        if (def === undefined) {
            return undefined;
        }
        let inhibited = false;
        for (const state of def.inhibitedBy || []) {
            if (this.activeInhibitStates.has(state)) {
                inhibited = true;
                break;
            }
        }
        return {
            uuid: alertKey.uuid,
            message: (_a = def.message) !== null && _a !== void 0 ? _a : 'MISSING MESSAGE',
            priority: priority,
            acknowledged: this.initialAcknowledge,
            inhibited: inhibited,
            suppressed: false,
            lastActive: Date.now(),
            suffixes: alertKey.suffix !== undefined ? [alertKey.suffix] : undefined,
            acknowledgedSuffixes: alertKey.suffix !== undefined ? this.initialAcknowledge ? [alertKey.suffix] : [] : undefined
        };
    }
    /**
     * Schedule an alert to go active at the end of its debounce time.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to fire.
     */
    scheduleAlert(alertKey, priority) {
        var _a;
        if (!this.checkValidAlertKey(alertKey)) {
            return;
        }
        const debounceTime = (_a = this.registeredAlerts.get(alertKey.uuid)) === null || _a === void 0 ? void 0 : _a.debounceTime;
        if (debounceTime === undefined) {
            this.activateAlert(alertKey, priority);
            return;
        }
        // Traverse the nested maps of scheduled alerts and create a schedule item if needed.
        if (alertKey.suffix !== undefined) {
            let uuidMap = this.scheduledSuffixedAlerts.get(alertKey.uuid);
            if (uuidMap === undefined) {
                uuidMap = new Map();
                this.scheduledSuffixedAlerts.set(alertKey.uuid, uuidMap);
            }
            let suffixMap = uuidMap.get(alertKey.suffix);
            if (suffixMap === undefined) {
                suffixMap = new Map();
                uuidMap.set(alertKey.suffix, suffixMap);
            }
            const time = suffixMap.get(priority);
            if (time !== undefined) {
                return;
            }
            suffixMap.set(priority, debounceTime);
        }
        else {
            let uuidMap = this.scheduledUnsuffixedAlerts.get(alertKey.uuid);
            if (uuidMap === undefined) {
                uuidMap = new Map();
                this.scheduledUnsuffixedAlerts.set(alertKey.uuid, uuidMap);
            }
            const time = uuidMap.get(priority);
            if (time !== undefined) {
                return;
            }
            uuidMap.set(priority, debounceTime);
        }
    }
    /**
     * Check the scheduled alerts to see if there's anything that needs to fire.
     * @param timestamp The current sim time.
     */
    checkScheduledAlerts(timestamp) {
        if (this.previousScheduleCheckTime !== -1) {
            const deltaTime = NavMath.clamp(timestamp - this.previousScheduleCheckTime, 0, 10000);
            if (deltaTime > 0) {
                // Handle unsuffixed alerts.
                for (const [uuid, uuidMap] of this.scheduledUnsuffixedAlerts) {
                    for (const [priority, delay] of uuidMap) {
                        const newDelay = delay - deltaTime;
                        if (newDelay <= 0) {
                            uuidMap.delete(priority);
                            this.activateAlert({ uuid: uuid }, priority);
                        }
                        else {
                            uuidMap.set(priority, newDelay);
                        }
                    }
                }
                // And then suffixed ones.
                for (const [uuid, uuidMap] of this.scheduledSuffixedAlerts) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    for (const [suffix, suffixMap] of uuidMap) {
                        for (const [priority, delay] of suffixMap) {
                            const newDelay = delay - deltaTime;
                            if (newDelay <= 0) {
                                suffixMap.delete(priority);
                                this.activateAlert({ uuid: uuid, suffix: suffix }, priority);
                            }
                            else {
                                suffixMap.set(priority, newDelay);
                            }
                        }
                    }
                }
            }
        }
        this.previousScheduleCheckTime = timestamp;
    }
    /**
     * Handle an alert going active.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to fire.
     */
    activateAlert(alertKey, priority) {
        var _a;
        if (!this.checkValidAlertKey(alertKey)) {
            return;
        }
        // Check to see if there's an existing alert for this message at this priority level.
        const messagesAtPriority = this.allMessages.get(priority);
        const uuidMessageAtPriority = messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.get(alertKey.uuid);
        if (uuidMessageAtPriority === undefined) {
            // There's not already an existing message, so we make one.
            const newMessage = this.createNewMessage(alertKey, priority);
            if (newMessage !== undefined) {
                messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.set(alertKey.uuid, newMessage);
            }
        }
        else {
            // There is an existing message at this priority level so we need to update it instead.
            uuidMessageAtPriority.acknowledged && (uuidMessageAtPriority.acknowledged = this.initialAcknowledge);
            uuidMessageAtPriority.lastActive = Date.now();
            // Suffix handling.  If one is in the alert key, make sure it's added to the active
            // message if it's not already present.
            if (alertKey.suffix !== undefined) {
                // These arrays must be defined or else checkValidAlertKey() would have returned false.
                const suffixes = uuidMessageAtPriority.suffixes;
                const acknowledgedSuffixes = uuidMessageAtPriority.acknowledgedSuffixes;
                if (!suffixes.includes(alertKey.suffix)) {
                    suffixes.push(alertKey.suffix);
                    if (this.initialAcknowledge) {
                        acknowledgedSuffixes.push(alertKey.suffix);
                    }
                    const suffixOrder = (_a = this.registeredAlerts.get(alertKey.uuid)) === null || _a === void 0 ? void 0 : _a.suffixes;
                    if (suffixOrder !== undefined) {
                        const comparator = (a, b) => suffixOrder.indexOf(a) - suffixOrder.indexOf(b);
                        suffixes.sort(comparator);
                        if (this.initialAcknowledge) {
                            acknowledgedSuffixes.sort(comparator);
                        }
                    }
                }
            }
        }
        this.refreshDisplayedAlerts();
    }
    /**
     * Handle an alert going inactive.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to clear.
     */
    deactivateAlert(alertKey, priority) {
        var _a, _b, _c, _d;
        if (!this.checkValidAlertKey(alertKey)) {
            return;
        }
        // We are deactivating an alert.  If there is no suffix provided this is easy.
        if (alertKey.suffix === undefined) {
            (_a = this.allMessages.get(priority)) === null || _a === void 0 ? void 0 : _a.delete(alertKey.uuid);
            (_b = this.scheduledUnsuffixedAlerts.get(alertKey.uuid)) === null || _b === void 0 ? void 0 : _b.delete(priority);
        }
        else {
            (_d = (_c = this.scheduledSuffixedAlerts.get(alertKey.uuid)) === null || _c === void 0 ? void 0 : _c.get(alertKey.suffix)) === null || _d === void 0 ? void 0 : _d.delete(priority);
            // With suffixes in the mix we need a little more intelligence.  First, find the relevant message.
            const messagesAtPriority = this.allMessages.get(priority);
            const uuidMessageAtPriority = messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.get(alertKey.uuid);
            if (uuidMessageAtPriority !== undefined) {
                // These arrays must be defined or else checkValidAlertKey() would have returned false.
                const suffixes = uuidMessageAtPriority.suffixes;
                const acknowledgedSuffixes = uuidMessageAtPriority.acknowledgedSuffixes;
                // Remove the suffix from the message's suffix array.
                const index = suffixes.indexOf(alertKey.suffix);
                if (index >= 0) {
                    suffixes.splice(index, 1);
                }
                if (suffixes.length == 0) {
                    // We've just removed the last suffix, we can fully disable this alert.
                    messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.delete(alertKey.uuid);
                }
                else {
                    // Remove the suffix from the message's acknowledged suffix array.
                    const acknowledgedIndex = acknowledgedSuffixes.indexOf(alertKey.suffix);
                    if (acknowledgedIndex >= 0) {
                        acknowledgedSuffixes.splice(acknowledgedIndex, 1);
                    }
                }
            }
        }
        this.refreshDisplayedAlerts();
    }
    /**
     * Handle a master warning or caution acknowledgement.
     * @param type The type of alert to acknowledge.
     */
    handleAcknowledgement(type) {
        if (this.isPrimary && [AnnunciationType.Caution, AnnunciationType.Warning].includes(type)) {
            this.casPublisher.pub('cas_master_acknowledge', type, true);
        }
        this.setMasterStatus(type, false);
        const messagesAtPriority = this.allMessages.get(type);
        if (messagesAtPriority !== undefined) {
            for (const uuid of messagesAtPriority.keys()) {
                const message = messagesAtPriority.get(uuid);
                if (message !== undefined && !message.inhibited) {
                    message.acknowledged = true;
                    if (message.suffixes && message.acknowledgedSuffixes) {
                        // Copy the suffixes array into the acknowledged suffixes array since every suffix is now acknowledged
                        message.acknowledgedSuffixes.length = message.suffixes.length;
                        for (let i = 0; i < message.suffixes.length; i++) {
                            const suffix = message.suffixes[i];
                            if (message.acknowledgedSuffixes[i] !== suffix) {
                                message.acknowledgedSuffixes.splice(i, 0, suffix);
                                this.casStatePublisher.pub('cas_alert_acknowledged', {
                                    uuid: message.uuid,
                                    suffix: message.suffixes[i],
                                    priority: message.priority,
                                    acknowledged: true
                                }, false, false);
                            }
                        }
                    }
                    else {
                        this.casStatePublisher.pub('cas_alert_acknowledged', {
                            uuid: message.uuid,
                            priority: message.priority,
                            acknowledged: true
                        }, false, false);
                    }
                }
            }
        }
        this.refreshDisplayedAlerts();
    }
    /**
     * Handle the setting of a new inhibit state.
     * @param state The name of the inhibited state to set.
     * @param active Whether the state is active or not.
     */
    handleInhibitState(state, active) {
        var _a, _b, _c, _d;
        if ((active && !this.activeInhibitStates.has(state)) || (!active && this.activeInhibitStates.has(state))) {
            if (active) {
                this.activeInhibitStates.add(state);
            }
            else {
                this.activeInhibitStates.delete(state);
            }
            for (const priority of this.allMessages.keys()) {
                for (const message of (_b = (_a = this.allMessages.get(priority)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : []) {
                    if (message !== undefined) {
                        let isInhibited = false;
                        for (const candidateState of (_d = (_c = this.registeredAlerts.get(message.uuid)) === null || _c === void 0 ? void 0 : _c.inhibitedBy) !== null && _d !== void 0 ? _d : []) {
                            if (this.activeInhibitStates.has(candidateState)) {
                                isInhibited = true;
                                break;
                            }
                        }
                        message.inhibited = isInhibited;
                    }
                }
            }
        }
        this.refreshDisplayedAlerts();
    }
    /**
     * Set both sets of simvars relevant to a master caution or warning status.
     * @param type The type of the status to set
     * @param active Whether or not the status is active
     */
    setMasterStatus(type, active) {
        switch (type) {
            case AnnunciationType.Caution:
                if (this.masterCautionActive !== active) {
                    if (this.isPrimary) {
                        SimVar.SetSimVarValue('K:MASTER_CAUTION_SET', SimVarValueType.Number, active ? 1 : 0);
                        SimVar.SetSimVarValue('L:Generic_Master_Caution_Active', SimVarValueType.Bool, active);
                    }
                    this.masterCautionActive = active;
                    this.casStatePublisher.pub('cas_master_caution_active', active, false, true);
                }
                break;
            case AnnunciationType.Warning:
                if (this.masterWarningActive !== active) {
                    if (this.isPrimary) {
                        SimVar.SetSimVarValue('K:MASTER_WARNING_SET', SimVarValueType.Number, active ? 1 : 0);
                        SimVar.SetSimVarValue('L:Generic_Master_Warning_Active', SimVarValueType.Bool, active);
                    }
                    this.masterWarningActive = active;
                    this.casStatePublisher.pub('cas_master_warning_active', active, false, true);
                }
                break;
        }
    }
    /**
     * Get the full registered definition of an alert based on its key.
     * @param alertKey The key of the alert definition to retrieve.
     * @returns The full alert definition, or undefined if not found.
     */
    getAlertDefinition(alertKey) {
        const alertDefinition = this.registeredAlerts.get(alertKey.uuid);
        if (alertDefinition === undefined) {
            console.warn(`Trying to access an unregistered alert UUID: ${alertKey.uuid}`);
            return undefined;
        }
        else {
            return alertDefinition;
        }
    }
    /**
     * Check whether a provided alert key is valid according to the alert's suffix definition.
     * @param alertKey The key of the alert to check.
     * @returns A boolean indicating whether the key is valid.
     */
    checkValidAlertKey(alertKey) {
        const alertDefinition = this.getAlertDefinition(alertKey);
        if (alertDefinition === undefined) {
            return false;
        }
        const suffixes = alertDefinition.suffixes;
        if (alertKey.suffix === undefined && suffixes !== undefined) {
            console.warn(`Trying to access a suffixed alert without a suffix: '${alertDefinition.message}'`);
            return false;
        }
        else if (alertKey.suffix !== undefined && suffixes === undefined) {
            console.warn(`Trying to access a non-suffixed alert with a suffix: '${alertDefinition.message}:${alertKey.suffix}'`);
            return false;
        }
        else if (alertKey.suffix !== undefined && !(suffixes === null || suffixes === void 0 ? void 0 : suffixes.includes(alertKey.suffix))) {
            console.warn(`Trying to access a suffixed alert with an invalid suffix: '${alertDefinition.message}:${alertKey.suffix}'`);
            return false;
        }
        return true;
    }
    /**
     * See if there is still an active, unacked annunciation of the given type.
     * @param type The annunciation type to check for.
     * @returns True if there is an active, unacked annunciation of the given type, false otherwise.
     */
    checkForActiveType(type) {
        const messagesAtPriority = this.allMessages.get(type);
        if (messagesAtPriority !== undefined) {
            for (const message of messagesAtPriority.values()) {
                if (!message.acknowledged) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Reprocess all active alerts to generate a list consisting only of those which are displayable.
     * At the same time, keep track of whether or not the master warning or caution lights should be
     * active and, if the primary CasSystem, set them appropriately when done.
     */
    refreshDisplayedAlerts() {
        this.displayedCasMessages.clear();
        const unsuffixedDisplayedKeys = new Set();
        const suffixedDisplayedKeys = new Map();
        let unackedWarnings = false;
        let unackedCautions = false;
        for (const priority of [
            AnnunciationType.Warning,
            AnnunciationType.Caution,
            AnnunciationType.Advisory,
            AnnunciationType.SafeOp
        ]) {
            // Go through the UUIDs of all active messages at this priority.
            for (const [uuid, message] of this.allMessages.get(priority) || []) {
                // If the message is currently inhibited or suppressed, skip over it.
                if (message.inhibited || message.suppressed) {
                    continue;
                }
                // In the simple case we have no suffixes.   In which case we either add
                // the message to the displayed array or continue.
                if (message.suffixes === undefined) {
                    if (!unsuffixedDisplayedKeys.has(uuid)) {
                        unsuffixedDisplayedKeys.add(uuid);
                        this.displayedCasMessages.insert(message);
                        if (!message.acknowledged) {
                            switch (priority) {
                                case AnnunciationType.Warning:
                                    unackedWarnings = true;
                                    break;
                                case AnnunciationType.Caution:
                                    unackedCautions = true;
                                    break;
                            }
                        }
                    }
                }
                else {
                    // We do have suffixes to worry about.  Yay.  Let's store all the ones
                    // that are supposed to be displayed at this level and reset the list
                    // in our message.
                    const origSuffixes = message.suffixes;
                    message.suffixes = [];
                    // Now we go through the active suffixes and see if they've already been
                    // displayed at a higher priority.
                    for (const suffix of origSuffixes) {
                        const suffixesDisplayed = suffixedDisplayedKeys.get(uuid);
                        if (suffixesDisplayed === undefined) {
                            // First time we've seen any suffix for this UUID
                            suffixedDisplayedKeys.set(uuid, new Set([suffix]));
                            message.suffixes.push(suffix);
                        }
                        else {
                            // We've already displayed some suffix for this UID.  But is is the one
                            // we're working with now?
                            if (!suffixesDisplayed.has(suffix)) {
                                suffixesDisplayed.add(suffix);
                                message.suffixes.push(suffix);
                            }
                        }
                    }
                    // Now, assuming we added back at least one suffix we want to display this
                    // message, so add it to the array.
                    if (message.suffixes.length > 0) {
                        this.displayedCasMessages.insert(message);
                        if (!message.acknowledged) {
                            switch (priority) {
                                case AnnunciationType.Warning:
                                    unackedWarnings = true;
                                    break;
                                case AnnunciationType.Caution:
                                    unackedCautions = true;
                                    break;
                            }
                        }
                    }
                }
            }
        }
        this.setMasterStatus(AnnunciationType.Caution, unackedCautions);
        this.setMasterStatus(AnnunciationType.Warning, unackedWarnings);
        // Diff the old and new messages and publish state change events.
        const oldMessages = this.prevDisplayedCasMessages;
        const newMessages = this.displayedCasMessages.getArray();
        this.diffAlerts(newMessages, oldMessages, 'cas_alert_hidden');
        this.diffAlerts(oldMessages, newMessages, 'cas_alert_displayed');
        // We need to deep copy the new displayed messages array because messages in the displayed array can be mutated.
        CasSystem.copyMessageArray(newMessages, this.prevDisplayedCasMessages);
    }
    /**
     * Finds alerts displayed in a query message array that are not displayed in a reference message array and publishes
     * them.
     * @param referenceMessages The reference message array.
     * @param queryMessages The query message array.
     * @param topic The event bus topic to publish to.
     */
    diffAlerts(referenceMessages, queryMessages, topic) {
        // Using old-fashioned for loops here to avoid object/function creation
        for (let i = 0; i < queryMessages.length; i++) {
            const queryMessage = queryMessages[i];
            let matchedReferenceMessage = undefined;
            for (let j = 0; j < referenceMessages.length; j++) {
                const referenceMessage = referenceMessages[j];
                if (referenceMessage.priority === queryMessage.priority && referenceMessage.uuid === queryMessage.uuid) {
                    matchedReferenceMessage = referenceMessage;
                    break;
                }
            }
            // If the new message has suffixes, then we need to check each suffix to see if a matched message contained the
            // same suffix. Otherwise, we need to check if a matched message exists and had no suffix.
            if (queryMessage.suffixes && queryMessage.suffixes.length > 0) {
                for (let k = 0; k < queryMessage.suffixes.length; k++) {
                    const suffix = queryMessage.suffixes[k];
                    if (!matchedReferenceMessage || !matchedReferenceMessage.suffixes || !matchedReferenceMessage.suffixes.includes(suffix)) {
                        this.casStatePublisher.pub(topic, {
                            uuid: queryMessage.uuid,
                            suffix,
                            priority: queryMessage.priority,
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            acknowledged: queryMessage.acknowledgedSuffixes.includes(suffix)
                        }, false, false);
                    }
                }
            }
            else if (!matchedReferenceMessage || (matchedReferenceMessage.suffixes && matchedReferenceMessage.suffixes.length > 0)) {
                this.casStatePublisher.pub(topic, {
                    uuid: queryMessage.uuid,
                    priority: queryMessage.priority,
                    acknowledged: queryMessage.acknowledged
                }, false, false);
            }
        }
    }
    /**
     * Copies a CAS message.
     * @param source The source message to copy from.
     * @param target The target message to copy to. If not defined, a new message object will be created.
     * @returns The message copy.
     */
    static copyMessage(source, target) {
        target !== null && target !== void 0 ? target : (target = {});
        target.uuid = source.uuid;
        target.message = source.message;
        target.priority = source.priority;
        target.acknowledged = source.acknowledged;
        target.inhibited = source.inhibited;
        target.suppressed = source.suppressed;
        target.lastActive = source.lastActive;
        if (source.suffixes) {
            target.suffixes = ArrayUtils.shallowCopy(source.suffixes, target.suffixes);
        }
        else {
            target.suffixes = undefined;
        }
        if (source.acknowledgedSuffixes) {
            target.acknowledgedSuffixes = ArrayUtils.shallowCopy(source.acknowledgedSuffixes, target.acknowledgedSuffixes);
        }
        else {
            target.acknowledgedSuffixes = undefined;
        }
        return target;
    }
    /**
     * Performs a deep copy of a CAS message array.
     * @param source The source array to copy from.
     * @param target The target array to copy to. If not defined, a new array will be created.
     * @returns The array copy.
     */
    static copyMessageArray(source, target) {
        target !== null && target !== void 0 ? target : (target = []);
        target.length = source.length;
        for (let i = 0; i < source.length; i++) {
            target[i] = CasSystem.copyMessage(source[i], target[i]);
        }
        return target;
    }
}

/**
 * A class for caching images.
 * Do your own instrument specific implementation with an init() method
 * that will add images to cache on instrument load to prefill the cache.
 * @class ImageCache
 */
class ImageCache {
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key, url) {
        if (this.cache[key] === undefined) {
            const img = new Image();
            img.src = url;
            this.cache[key] = img;
        }
    }
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key) {
        return this.cache[key];
    }
}
ImageCache.cache = {};

/** A collection of handy SVG functions. */
class SVGUtils {
    /**
     * Creates an arc using an SVG path.
     * From https://stackoverflow.com/questions/5736398/how-to-calculate-the-svg-path-for-an-arc-of-a-circle
     * @param x Arc center x position.
     * @param y Arc center y position.
     * @param radius Arc radius.
     * @param startAngle Arc start angle.
     * @param endAngle Arc end angle.
     * @returns The d value for and SVG path element.
     */
    static describeArc(x, y, radius, startAngle, endAngle) {
        const start = polarToCartesian(x, y, radius, endAngle);
        const end = polarToCartesian(x, y, radius, startAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
        const d = [
            'M', start[0], start[1],
            'A', radius, radius, 0, largeArcFlag, 0, end[0], end[1]
        ].join(' ');
        return d;
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
    const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
    return new Float64Array([
        centerX + (radius * Math.cos(angleInRadians)),
        centerY + (radius * Math.sin(angleInRadians))
    ]);
}

/* eslint-disable jsdoc/check-indentation */
/**
 * A utility class for creating duration formatters.
 *
 * Each duration formatter is a function which generates output strings from input duration values. The formatting
 * behavior of a formatter is defined by its format template.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Sign fragment. In EBNF notation, these take the form `['+', ['[', x, ']']], ('-' , ['[', y, ']'])`, where
 * `x` and `y` are arbitrary strings. Each sign fragment is replaced with a string representing the sign of the input.
 * The negative sign string is defined by `y`. If `y` is not defined, the negative sign string defaults to `'-'`
 * (dash). The positive sign string is defined by `x`. If the positive sign token does not appear in the fragment
 * definition, the positive sign string defaults to `''` (the empty string), otherwise it defaults to `'+'`.
 * * Numeric fragment. In EBNF notation, these take the form
 * `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]`, where `x = 'H' | 'M' | 'S' | 'h' | 'm' | 's'`. Each numeric fragment is
 * replaced with the numeric value of the duration in hours, minutes, or seconds, depending on which character is used
 * for `x`. With uppercase letters, the entire portion of the input value is used. With lowercase letters, only the
 * portion of the input value that does not divide evenly into the next smallest unit is used (for hours, which is the
 * largest unit, there is no difference between using `'H'` and `'h'`).
 *   * The number of `x` characters to the left of the decimal point (including all characters if no decimal point is
 * present) in the definition controls the number of leading zeroes with which the output will be padded.
 *   * If the optional `'?'` character is present, the output will drop all digits to the left of the decimal point if
 * all such digits are equal to 0.
 *   * The total number of `x` characters to the right of the decimal point in the definition controls the decimal
 * precision of the output. Trailing zeroes to the right of the decimal point will be added to the output to a number
 * of decimal places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the
 * definition. If there are no `x` characters to the right of the decimal point in the definition, then the output will
 * have infinite decimal precision with no extraneous trailing zeroes.
 *   * Rounding behavior is always round down.
 *
 * @example <caption>Formatting to hours-minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss}', UnitType.SECOND);
 * formatter(3616);       // 1:00:16
 * formatter(36016.9);    // 10:00:16
 *
 * @example <caption>Formatting to hours-minutes-seconds with decimal precision</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss.s(s)}', UnitType.SECOND);
 * formatter(3600);       // 1:00:00.0
 * formatter(3600.55);    // 1:00:00.55
 *
 * @example <caption>Formatting to minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{MM}:{ss}', UnitType.SECOND);
 * formatter(600);        // 10:00
 * formatter(4200);       // 70:00
 *
 * @example <caption>Formatting with signs</caption>
 * const formatter = DurationFormatter.create('{-}{h}:{mm}', UnitType.SECOND);
 * formatter(3600);                   // 1:00
 * formatter(-3600);                  // -1:00
 *
 * const formatterWithPositiveSign = DurationFormatter.create('{+-}{h}:{mm}', UnitType.SECOND);
 * formatterWithPositiveSign(3600);   // +1:00
 *
 * const formatterWithRealMinusSign = DurationFormatter.create('{-[–]}{h}:{mm}', UnitType.SECOND);
 * formatterWithRealMinusSign(3600);  // –1:00
 */
class DurationFormatter {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(format, unit, precision, arg4) {
        const builder = DurationFormatter.createBuilder(format, precision, unit);
        const options = DurationFormatter.resolveOptions(typeof arg4 === 'string' ? { nanString: arg4 } : arg4);
        const built = Array.from(builder, () => '');
        if (options.cache) {
            let cachedInput = undefined;
            let cachedOutput = undefined;
            return (duration) => {
                if (isNaN(duration)) {
                    return options.nanString;
                }
                const roundedInput = MathUtils.round(duration, precision);
                if (cachedInput !== undefined && cachedOutput !== undefined && roundedInput === cachedInput) {
                    return cachedOutput;
                }
                cachedInput = roundedInput;
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration, unit);
                }
                return cachedOutput = built.join('');
            };
        }
        else {
            return (duration) => {
                if (isNaN(duration)) {
                    return options.nanString;
                }
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration, unit);
                }
                return built.join('');
            };
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createForNumberUnit(format, precision, arg3) {
        const builder = DurationFormatter.createBuilder(format, precision.number, precision.unit);
        const options = DurationFormatter.resolveOptions(typeof arg3 === 'string' ? { nanString: arg3 } : arg3);
        const built = Array.from(builder, () => '');
        if (options.cache) {
            let cachedInput = undefined;
            let cachedOutput = undefined;
            return (duration) => {
                if (duration.isNaN()) {
                    return options.nanString;
                }
                const roundedInput = MathUtils.round(duration.asUnit(precision.unit), precision.number);
                if (cachedInput !== undefined && cachedOutput !== undefined && roundedInput === cachedInput) {
                    return cachedOutput;
                }
                cachedInput = roundedInput;
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration.number, duration.unit);
                }
                return cachedOutput = built.join('');
            };
        }
        else {
            return (duration) => {
                if (duration.isNaN()) {
                    return options.nanString;
                }
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration.number, duration.unit);
                }
                return built.join('');
            };
        }
    }
    /**
     * Resolves a full set of options from a partial options object. Any option not explicitly defined by the partial
     * options object will revert to its default value.
     * @param options A partial options object.
     * @returns A new options object containing the full set of options resolved from the specified partial options
     * object.
     */
    static resolveOptions(options) {
        var _a;
        const resolved = Object.assign({}, options);
        for (const key in DurationFormatter.DEFAULT_OPTIONS) {
            (_a = resolved[key]) !== null && _a !== void 0 ? _a : (resolved[key] = DurationFormatter.DEFAULT_OPTIONS[key]);
        }
        return resolved;
    }
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns An output string builder which conforms to the specified format template.
     */
    static createBuilder(format, precision, precisionUnit) {
        const split = format.split(DurationFormatter.FORMAT_REGEXP);
        return split.map((string) => {
            if (string.match(DurationFormatter.FORMAT_REGEXP)) {
                return DurationFormatter.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
            }
            else {
                return () => string;
            }
        });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input duration according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns A function which generates a string from an input duration in milliseconds according to the rules defined
     * by the template fragment.
     */
    static parseFragment(fragment, precision, precisionUnit) {
        var _a, _b;
        const signMatch = fragment.match(DurationFormatter.SIGN_FRAGMENT_REGEX);
        if (signMatch) {
            const [, posCharMatch, // Matches the positive sign char ('+')
            posStringMatch, // Matches the string assigned to represent the positive sign
            negStringMatch // Matches the string assigned to represent the negative sign
            ] = signMatch;
            const posSign = posCharMatch === '+' ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : '+' : '';
            const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : '-';
            return (angle) => {
                return angle < 0 ? negSign : posSign;
            };
        }
        const numericMatch = fragment.match(DurationFormatter.NUM_FRAGMENT_REGEXP);
        if (!numericMatch) {
            console.warn(`DurationFormatter: discarding fragment due to invalid syntax: {${fragment}}`);
            return () => '';
        }
        const [, leftMatch, // Matches unit chars to the left of the decimal point
        unitMatch, // Matches the unit char ('H', 'M', 'S', etc)
        leftOptionalMatch, // Matches the question mark just to the left of the decimal point
        rightMatch, // Matches the decimal point and all chars to the right
        rightForcedMatch, // Matches unit chars to the right of the decimal point not surrounded by parens
        rightOptionalMatch // Matches unit chars to the right of the decimal point surrounded by parens
        ] = numericMatch;
        const unitInfo = DurationFormatter.NUM_FRAGMENT_UNIT_INFO[unitMatch];
        const pad = leftMatch.length;
        const dropZero = !!leftOptionalMatch;
        const step = precisionUnit.convertTo(precision, unitInfo.unit);
        const convertFunc = step <= 0
            ? ((duration, unit) => {
                return unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
            }) : ((duration, unit, epsilon) => {
            return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(duration), unit), step) + epsilon) % unitInfo.mod;
        });
        const formatLeftFunc = dropZero
            ? ((input) => {
                const rounded = Math.floor(input);
                return rounded === 0 ? '' : rounded.toString().padStart(pad, '0');
            })
            : ((input) => Math.floor(input).toString().padStart(pad, '0'));
        if (rightMatch) {
            if (rightMatch.length === 1) {
                // Unlimited decimal precision
                return (duration, unit) => {
                    const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
                    const decimal = converted % 1;
                    return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
                };
            }
            const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
            const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
            const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
            const factor = Math.pow(10, totalDecimalPlaces);
            const epsilon = Math.min(step / 2, 1 / (2 * factor));
            return (duration, unit) => {
                const converted = convertFunc(duration, unit, epsilon);
                const decimal = converted % 1;
                const decimalRounded = Math.floor(decimal * factor) / factor;
                return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, '0')}`;
            };
        }
        else {
            const epsilon = Math.min(step / 2, 0.5);
            return (duration, unit) => {
                return formatLeftFunc(convertFunc(duration, unit, epsilon));
            };
        }
    }
}
DurationFormatter.FORMAT_REGEXP = /({[^{}]*})/;
DurationFormatter.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
DurationFormatter.NUM_FRAGMENT_REGEXP = /^(([HMShms])\2*)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
DurationFormatter.NUM_FRAGMENT_UNIT_INFO = {
    ['h']: { unit: UnitType.HOUR, mod: Infinity },
    ['m']: { unit: UnitType.MINUTE, mod: 60 },
    ['s']: { unit: UnitType.SECOND, mod: 60 },
    ['H']: { unit: UnitType.HOUR, mod: Infinity },
    ['M']: { unit: UnitType.MINUTE, mod: Infinity },
    ['S']: { unit: UnitType.SECOND, mod: Infinity }
};
/** The default options for duration formatters. */
DurationFormatter.DEFAULT_OPTIONS = {
    nanString: 'NaN',
    cache: false
};

/* eslint-disable max-len */
/**
 * A utility class for creating time formatters.
 *
 * Each time formatter is a function which generates output strings from input time values, expressed as UNIX
 * timestamps in milliseconds. The formatting behavior of a formatter is defined by its format template and options.
 *
 * Please refer to the {@link DateTimeFormatterOptions} type documentation for more information on individual
 * formatting options.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Integer fragment. In EBNF notation, these take the form `{x}` where `x = 'M' | 'd' | 'w'`. Each numeric fragment
 * is replaced with an integer representation of the month (`M`), day of month (`d`), or day of week (`w`) part of the
 * input time. The number of `x` characters in the definition controls the number of leading zeroes with which the
 * output will be padded.
 * * Numeric fragment. In EBNF notation, these take the form `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]` where
 * `x = 'H' | 'h' | 'm' | 's'`. Each numeric fragment is replaced with a numeric representation of the hour-24 (`H`),
 * hour-12 (`h`), minute (`m`), or second (`s`) part of the input time. The number of `x` characters in the definition
 * controls the number of leading zeroes with which the output will be padded. If the optional `'?'` character is
 * present, the output will drop all digits to the left of the decimal point if all such digits are equal to 0. The
 * total number of `x` characters to the right of the decimal point in the definition controls the decimal precision of
 * the output. Trailing zeroes to the right of the decimal point will be added to the output to a number of decimal
 * places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the definition.
 * If there are no `x` characters to the right of the decimal point in the definition, then the output will have
 * infinite decimal precision with no extraneous trailing zeroes. Rounding behavior is always round down.
 * * Year fragment. In EBNF notation, these take the form `'YY' | 'YYYY'`. Each year fragment is replaced with either
 * the two-digit (`YY`) or unlimited-digit (`YYYY`) year of the input time.
 * * Month fragment. In EBNF notation, these take the form `('mon', ['.']) | ('MON', ['.']) | 'month' | 'MONTH'`. Each
 * month fragment is replaced with the name of the month of the input time. The case of the definition determines the
 * case of the output. `mon` will use abbreviated names. The presence of the optional `'.'` character will add a period
 * to the end of the abbreviated names.
 * * Day-of-week fragment. In EBNF notation, these take the form `('dy', ['.']) | ('DY', ['.']) | 'day' | 'DAY'`. Each
 * day-of-week fragment is replaced with the name of the day-of-week of the input time. The case of the definition
 * determines the case of the output. `dy` will use abbreviated names. The presence of the optional `'.'` character
 * will add a period to the end of the abbreviated names.
 * * AM/PM fragment. In EBNF notation, these take the form `'am' | 'a.m.' | 'AM' | 'A.M.'`. Each AM/PM fragment is
 * replaced with an AM/PM string depending on the time of day of the input. The case of the definition determines the
 * case of the output. Use of periods in the definition will add periods to the output.
 *
 * @example <caption>Formatting to a date</caption>
 * const formatter = DateTimeFormatter.create('{dd}-{MM}-{YY}');
 * formatter(0);              // 01-01-70
 * formatter(1597723200000);  // 18-08-20
 *
 * @example <caption>Formatting to a time (24-hr)</caption>
 * const formatter = DateTimeFormatter.create('{HH}:{mm}:{ss}');
 * formatter(0);              // 00:00:00
 * formatter(5145000);        // 01:25:45
 * formatter(57600000);       // 16:00:00
 *
 * @example <caption>Formatting to a time (12-hr)</caption>
 * const formatter = DateTimeFormatter.create('{hh}:{mm}:{ss} {am}');
 * formatter(0);              // 12:00:00 am
 * formatter(5145000);        // 01:25:45 am
 * formatter(57600000);       // 04:00:00 pm
 *
 * @example <caption>Formatting to a time with decimals</caption>
 * const formatter = DateTimeFormatter.create('{H}:{mm.m(m)}');
 * formatter(0);              // 0:00.0
 * formatter(5145000);        // 1:25.75
 *
 * @example <caption>Formatting to ISO 8601</caption>
 * const formatter = DateTimeFormatter.create('{YYYY}-{MM}-{dd}T{HH}:{mm}:{ss}');
 * formatter(0);              // 1970-01-01T00:00:00
 * formatter(1597723200000);  // 2020-08-18T04:00:00
 */
class DateTimeFormatter {
    /**
     * Creates a function which formats times, expressed as UNIX timestamps in milliseconds, to strings. The formatting
     * behavior of the function is defined by a specified format template and options. For more information on format
     * templates and their syntax, please refer to the {@link DateTimeFormatter} class documentation. For more
     * information on individual formatting options, please refer to the {@link DateTimeFormatterOptions} type
     * documentation.
     * @param format A template defining how the function formats durations.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']`
     * * `monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']`
     * * `dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`
     * * `dayNamesShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']`
     * * `nanString = 'NaN'`
     * @returns A function which formats times, expressed as UNIX timestamps in milliseconds, to strings.
     */
    static create(format, options) {
        const optsToUse = this.resolveOptions(options);
        const builder = DateTimeFormatter.createBuilder(format, optsToUse);
        const date = new Date();
        const built = Array.from(builder, () => '');
        if (optsToUse.cache) {
            let cachedInput = undefined;
            let cachedOutput = undefined;
            return (time) => {
                if (isNaN(time)) {
                    return optsToUse.nanString;
                }
                const roundedInput = Math.floor(time);
                if (cachedInput !== undefined && cachedOutput !== undefined && roundedInput === cachedInput) {
                    return cachedOutput;
                }
                cachedInput = roundedInput;
                date.setTime(roundedInput);
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](date);
                }
                return cachedOutput = built.join('');
            };
        }
        else {
            return (time) => {
                if (isNaN(time)) {
                    return optsToUse.nanString;
                }
                date.setTime(Math.floor(time));
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](date);
                }
                return built.join('');
            };
        }
    }
    /**
     * Resolves a full set of options from a partial options object. Any option not explicitly defined by the partial
     * options object will revert to its default value.
     * @param options A partial options object.
     * @returns A new options object containing the full set of options resolved from the specified partial options
     * object.
     */
    static resolveOptions(options) {
        var _a;
        const resolved = Object.assign({}, options);
        for (const key in DateTimeFormatter.DEFAULT_OPTIONS) {
            (_a = resolved[key]) !== null && _a !== void 0 ? _a : (resolved[key] = DateTimeFormatter.DEFAULT_OPTIONS[key]);
        }
        return resolved;
    }
    /**
     * Creates an output string builder from a format template and options.
     * @param format A format template.
     * @param options Formatting options.
     * @returns An output string builder which conforms to the specified format template and options.
     */
    static createBuilder(format, options) {
        const split = format.split(DateTimeFormatter.FORMAT_REGEXP);
        return split.map((string) => {
            if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
                return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
            }
            else {
                return () => string;
            }
        });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the template fragment.
     */
    static parseFragment(fragment, options) {
        const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
        if (match) {
            if (match[1]) {
                return DateTimeFormatter.parseIntFragment(match);
            }
            else if (match[3]) {
                return DateTimeFormatter.parseNumFragment(match);
            }
            else if (match[10]) {
                return DateTimeFormatter.parseYearFragment(match);
            }
            else if (match[11]) {
                return DateTimeFormatter.parseMonthFragment(match, options);
            }
            else if (match[12]) {
                return DateTimeFormatter.parseDayFragment(match, options);
            }
            else if (match[13]) {
                return DateTimeFormatter.parseAMPMFragment(match);
            }
        }
        console.warn(`DateTimeFormatter: discarding fragment due to invalid syntax: {${fragment}}`);
        return () => '';
    }
    /**
     * Parses an integer template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An integer template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the integer template fragment.
     */
    static parseIntFragment(match) {
        const [
        /* 0 */ , fragmentMatch, // Matches the full fragment
        unitMatch // Matches the unit char ('M', 'd', 'w')
        ] = match;
        const intGetter = DateTimeFormatter.INT_GETTERS[unitMatch];
        const pad = fragmentMatch.length;
        return (date) => {
            return intGetter(date).toString().padStart(pad, '0');
        };
    }
    /**
     * Parses a numeric template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A numeric template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the numeric template fragment.
     */
    static parseNumFragment(match) {
        var _a, _b;
        const [
        /* 0 */ , /* 1 */ , /* 2 */ , /* 3 */ , leftMatch, // Matches unit chars to the left of the decimal point
        unitMatch, // Matches the unit char ('h', 'm', 's', etc)
        leftOptionalMatch, // Matches the question mark just to the left of the decimal point
        rightMatch, // Matches the decimal point and all chars to the right
        rightForcedMatch, // Matches unit chars to the right of the decimal point not surrounded by parens
        rightOptionalMatch // Matches unit chars to the right of the decimal point surrounded by parens
        ] = match;
        const numGetter = DateTimeFormatter.NUM_GETTERS[unitMatch];
        const numFractionGetter = DateTimeFormatter.NUM_FRACTION_GETTERS[unitMatch];
        const pad = leftMatch.length;
        const dropZero = !!leftOptionalMatch;
        const formatLeftFunc = dropZero
            ? ((date) => {
                const num = numGetter(date);
                return num === 0 ? '' : num.toString().padStart(pad, '0');
            }) : ((date) => numGetter(date).toString().padStart(pad, '0'));
        if (rightMatch) {
            if (rightMatch.length === 1) {
                // Unlimited decimal precision
                return (date) => {
                    return `${formatLeftFunc(date)}${numFractionGetter(date).toString().substring(1)}`;
                };
            }
            const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
            const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
            const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
            const factor = Math.pow(10, totalDecimalPlaces);
            return (date) => {
                const decimal = numFractionGetter(date);
                const decimalRounded = Math.floor(decimal * factor) / factor;
                return `${formatLeftFunc(date)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, '0')}`;
            };
        }
        else {
            return formatLeftFunc;
        }
    }
    /**
     * Parses a year template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A year template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the year template fragment.
     */
    static parseYearFragment(match) {
        if (match[10].length === 2) {
            // YY
            return (date) => (date.getUTCFullYear() % 100).toString();
        }
        else {
            // YYYY
            return (date) => date.getUTCFullYear().toString();
        }
    }
    /**
     * Parses a month template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A month template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the month template fragment.
     */
    static parseMonthFragment(match, options) {
        const fragmentMatch = match[11];
        const isUpperCase = fragmentMatch[0] === 'M';
        if (fragmentMatch.length === 3) {
            // mon
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => text[date.getUTCMonth()];
        }
        else if (fragmentMatch.length === 4) {
            // mon.
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => {
                const month = date.getUTCMonth();
                return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? '' : '.'}`;
            };
        }
        else {
            // month
            const text = isUpperCase ? options.monthNames.map(str => str.toUpperCase()) : options.monthNames;
            return (date) => text[date.getUTCMonth()];
        }
    }
    /**
     * Parses a day-of-week template fragment and returns a function which generates a string from an input time
     * according to the rules defined by the fragment.
     * @param match A day-of-week template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the day-of-week template fragment.
     */
    static parseDayFragment(match, options) {
        const fragmentMatch = match[12];
        const isUpperCase = fragmentMatch[0] === 'D';
        if (fragmentMatch === 'dy') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => text[date.getUTCDay()];
        }
        else if (fragmentMatch === 'dy.') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => {
                const day = date.getUTCDay();
                return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? '' : '.'}`;
            };
        }
        else {
            // day
            const text = isUpperCase ? options.dayNames.map(str => str.toUpperCase()) : options.dayNames;
            return (date) => text[date.getUTCDay()];
        }
    }
    /**
     * Parses an am/pm template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An am/pm template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the am/pm template fragment.
     */
    static parseAMPMFragment(match) {
        const fragmentMatch = match[13];
        const isUpperCase = fragmentMatch[0] === 'A';
        const usePeriod = fragmentMatch.length > 2;
        let text = usePeriod ? ['a.m.', 'p.m.'] : ['am', 'pm'];
        if (isUpperCase) {
            text = text.map(str => str.toUpperCase());
        }
        return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
}
DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
DateTimeFormatter.FRAGMENT_REGEXP = /^(?:(([Mdw])\2*)|((([Hhms])\5*)(\?)?(?:(\.(\5*)(?:\((\5+)\))?)?))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
DateTimeFormatter.INT_GETTERS = {
    ['w']: (date) => date.getUTCDay() + 1,
    ['d']: (date) => date.getUTCDate(),
    ['M']: (date) => date.getUTCMonth() + 1
};
DateTimeFormatter.NUM_GETTERS = {
    ['s']: (date) => date.getUTCSeconds(),
    ['m']: (date) => date.getUTCMinutes(),
    ['h']: (date) => 12 - (24 - date.getUTCHours()) % 12,
    ['H']: (date) => date.getUTCHours()
};
DateTimeFormatter.NUM_FRACTION_GETTERS = {
    ['s']: (date) => (date.getTime() % 1000) / 1000,
    ['m']: (date) => (date.getTime() % 60000) / 60000,
    ['h']: (date) => (date.getTime() % 3600000) / 3600000,
    ['H']: (date) => (date.getTime() % 3600000) / 3600000
};
DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    nanString: 'NaN',
    cache: false
};

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     * @param keepLocal If present and true, values will be kept local to the instrument on which they're set.
     */
    constructor(bus, settingDefs, keepLocal = false) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.subscriber = this.bus.getSubscriber();
        this.syncPublisher = this.bus.getPublisher();
        this.syncSubscriber = this.bus.getSubscriber();
        this.keepLocal = keepLocal;
        this.settings = new Map(settingDefs.map(def => {
            const initTopic = `usersetting_init_${def.name}`;
            const syncTopic = `usersetting_sync_${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0,
                initUid: Math.round(Math.random() * Number.MAX_SAFE_INTEGER)
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            entry.initSub = this.syncSubscriber.on(initTopic).handle(data => {
                // Do not respond to our own initialization sync.
                if (data.uid === entry.initUid) {
                    return;
                }
                // If we receive an initialization sync event for a setting, that means a manager on another instrument tried
                // to initialize the same setting to its default value. However, since the setting already exists here, we will
                // send a response to override the initialized value with the existing value.
                this.syncPublisher.pub(entry.syncTopic, { value: entry.setting.value, syncTime: entry.syncTime, initUid: data.uid }, !this.keepLocal, true);
            }, true);
            // Because sync events are cached, the initial subscriptions to the sync topic below will grab the synced value
            // of the new setting if it exists on the local instrument (e.g. if the value was synced from another instrument
            // after the local instrument was created but before this manager and local setting were created).
            this.syncSubscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            if (entry.syncTime === 0) {
                // If the new setting has no synced value on the local instrument, we will try to grab an initialization value
                // instead. If one exists, we will use it, but keep the local sync time at 0. If there is a pending response
                // to this initialization value, we want to be ready to accept the response when it arrives, which we can't do
                // if the local sync time is non-zero).
                const sub = this.syncSubscriber.on(initTopic).handle(data => {
                    this.onSettingValueSynced(entry, { value: data.value, syncTime: 0 });
                });
                sub.destroy();
            }
            if (entry.syncTime === 0) {
                // An existing synced value does not exist for the new setting on the local instrument, so we will go ahead
                // and initialize the new setting value to its default and send an initialization sync event. If the setting
                // exists on other instruments, their managers will send an initialization response to override our initialized
                // value.
                this.syncPublisher.pub(initTopic, { value: entry.setting.value, syncTime: Date.now(), uid: entry.initUid }, !this.keepLocal, true);
                this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
            }
            entry.initSub.resume();
            return [def.name, entry];
        }));
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        return (_a = this.settings.get(name)) === null || _a === void 0 ? void 0 : _a.setting;
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.syncPublisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, !this.keepLocal, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // If the sync event is an initialization response, ignore it if the local setting value has already been synced.
        // Otherwise, protect against race conditions by not responding to sync events older than the last time this
        // manager synced the setting.
        if ((data.initUid !== undefined && entry.syncTime !== 0)
            || (data.initUid === undefined && data.syncTime < entry.syncTime)) {
            return;
        }
        this.syncSettingFromEvent(entry, data);
    }
    /**
     * Syncs a setting using data received from a sync event.
     * @param entry The entry for the setting to sync.
     * @param data The sync event data.
     */
    syncSettingFromEvent(entry, data) {
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // Publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
    }
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.tryGetSetting(mappedName);
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
    /** @inheritdoc */
    getAllSettings() {
        return this.parent.getAllSettings();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        super();
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isMutableSubscribable = true;
        this._value = definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this._value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.valueChangedCallback(v);
        this.notify();
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        if (this._value === value) {
            return;
        }
        this._value = value;
        this.notify();
    }
    /** @inheritdoc */
    get() {
        return this._value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * An aliased user setting manager which can dynamically (re)define the settings from which its aliased settings are
 * sourced.
 */
class AliasedUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings. The definitions should
     * define the settings' aliased names.
     */
    constructor(bus, settingDefs) {
        this.bus = bus;
        this.aliasedSettings = new Map(settingDefs.map(def => [def.name, new AliasedUserSetting(def)]));
    }
    /**
     * Defines the mappings from this manager's aliased settings to their source settings. Once the mappings are defined,
     * each aliased setting will take the value of its source setting, and setting the value of the aliased setting will
     * also set the value of the source setting. If a source setting cannot be defined for an aliased setting, the
     * aliased setting's value will be fixed to its default value and cannot be changed.
     * @param masterManager The manager hosting the settings from which this manager's aliased settings will be sourced.
     * @param map The mappings for this manager's aliased settings, as a set of key-value pairs where the keys are the
     * aliased setting names and the values are the source setting names. For any aliased setting whose name does not
     * appear as a key in the mapping, its source setting is assumed to have the same name.
     */
    useAliases(masterManager, map) {
        this.manager = masterManager.mapTo(map);
        for (const aliasedSetting of this.aliasedSettings.values()) {
            aliasedSetting.useSource(this.manager.tryGetSetting(aliasedSetting.definition.name));
        }
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        return this.aliasedSettings.get(name);
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.aliasedSettings.get(name);
        if (!setting) {
            throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
        }
        return new BasicConsumer((handler, paused) => {
            return setting.sub(handler, true, paused);
        }).whenChanged();
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.aliasedSettings.values());
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * A user setting with a value which is sourced from another setting. While the setting has no source, its value is
 * fixed to its default value and cannot be changed.
 */
class AliasedUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     */
    constructor(definition) {
        super();
        this.definition = definition;
        this.isMutableSubscribable = true;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        var _a, _b;
        return (_b = (_a = this.setting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        this.setting && (this.setting.value = v);
    }
    /**
     * Sets this setting's source.
     * @param setting The user setting to use as the new source, or `undefined` to leave this setting without a source.
     */
    useSource(setting) {
        var _a;
        const oldValue = this.value;
        (_a = this.settingSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.setting = setting;
        if (setting !== undefined) {
            this.settingSub = setting.sub(() => { this.notify(); });
        }
        else {
            this.settingSub = undefined;
        }
        if (oldValue !== this.value) {
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * The state of an avionics system.
 */
var AvionicsSystemState;
(function (AvionicsSystemState) {
    AvionicsSystemState["Off"] = "Off";
    AvionicsSystemState["Initializing"] = "Initializing";
    AvionicsSystemState["On"] = "On";
    AvionicsSystemState["Failed"] = "Failed";
})(AvionicsSystemState || (AvionicsSystemState = {}));

/**
 * A basic avionics system with a fixed initialization time and logic.
 */
class BasicAvionicsSystem {
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index, bus, stateEvent) {
        this.index = index;
        this.bus = bus;
        this.stateEvent = stateEvent;
        /** The time it takes in milliseconds for the system to initialize. */
        this.initializationTime = 0;
        /** A timeout after which initialization will be complete. */
        this.initializationTimer = new DebounceTimer();
        this.publisher = this.bus.getPublisher();
        /** Whether power data consumed by this system is valid. */
        this.isPowerValid = false;
        this.bus.pub(this.stateEvent, { previous: undefined, current: undefined });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            var _a;
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.isPowerValid = true;
                (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    get state() {
        return this._state;
    }
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic, electricity logic element, or
     * {@link Subscribable}.
     * @param source The source to which to connect this system's power state.
     */
    connectToPower(source) {
        var _a;
        (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.electricalPowerSub = undefined;
        this.electricalPowerLogic = undefined;
        if (typeof source === 'string') {
            this.electricalPowerSub = this.bus.getSubscriber()
                .on(source)
                .whenChanged()
                .handle(this.onPowerChanged.bind(this), !this.isPowerValid);
        }
        else if (SubscribableUtils.isSubscribable(source)) {
            this.electricalPowerSub = source.sub(this.onPowerChanged.bind(this), true, !this.isPowerValid);
        }
        else {
            this.electricalPowerLogic = source;
            this.updatePowerFromLogic();
        }
    }
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    setState(state) {
        if (this._state !== state) {
            const previous = this._state;
            this._state = state;
            this.onStateChanged(previous, state);
            this.bus.pub(this.stateEvent, { previous, current: state });
        }
    }
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        // noop
    }
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Off);
            }
        }
        else {
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(() => this.setState(AvionicsSystemState.On), this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        this.updatePowerFromLogic();
    }
    /**
     * Updates this system's power state from an electricity logic element.
     */
    updatePowerFromLogic() {
        if (!this.isPowerValid || this.electricalPowerLogic === undefined) {
            return;
        }
        const isPowered = this.electricalPowerLogic.getValue() !== 0;
        if (isPowered !== this.isPowered) {
            this.onPowerChanged(isPowered);
        }
    }
}

/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
class FsBaseInstrument extends BaseInstrument {
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.fsInstrument = this.constructInstrument();
    }
    /**
     * Update method called by BaseInstrument
     */
    Update() {
        super.Update();
        if (this.fsInstrument) {
            this.fsInstrument.Update();
        }
    }
    /** @inheritdoc */
    onInteractionEvent(_args) {
        if (this.fsInstrument) {
            this.fsInstrument.onInteractionEvent(_args);
        }
    }
    /** @inheritdoc */
    onGameStateChanged(oldState, newState) {
        super.onGameStateChanged(oldState, newState);
        if (this.fsInstrument) {
            this.fsInstrument.onGameStateChanged(oldState, newState);
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
        if (this.fsInstrument) {
            this.fsInstrument.onFlightStart();
        }
    }
    /** @inheritdoc */
    onSoundEnd(soundEventId) {
        super.onSoundEnd(soundEventId);
        if (this.fsInstrument) {
            this.fsInstrument.onSoundEnd(soundEventId);
        }
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return false;
    }
}

/**
 * A configuration object which defines options related to various aircraft sensors.
 */
class SensorsConfig {
    /**
     * Creates a new SensorsConfig from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     */
    constructor(baseInstrument, element) {
        if (element === undefined) {
            this.adcCount = 1;
            this.ahrsCount = 1;
            this.radarAltimeterCount = 1;
            this.gpsCount = 1;
            this.adcDefinitions = [undefined, { altimeterIndex: 1, airspeedIndicatorIndex: 1 }];
            this.ahrsDefinitions = [undefined, { attitudeIndicatorIndex: 1, directionIndicatorIndex: 1 }];
            this.radarAltimeterDefinitions = [undefined, {}];
            this.gpsDefinitions = [undefined, {}];
        }
        else {
            if (element.tagName !== 'Sensors') {
                throw new Error(`Invalid SensorsConfig definition: expected tag name 'Sensors' but was '${element.tagName}'`);
            }
            const adcCount = Number(element.getAttribute('adc-count'));
            if (!Number.isInteger(adcCount) || adcCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC count (must be a positive integer)');
                this.adcCount = 1;
            }
            else {
                this.adcCount = adcCount;
            }
            const ahrsCount = Number(element.getAttribute('ahrs-count'));
            if (!Number.isInteger(ahrsCount) || ahrsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS count (must be a positive integer)');
                this.ahrsCount = 1;
            }
            else {
                this.ahrsCount = ahrsCount;
            }
            const radarAltimeterCount = Number(element.getAttribute('radar-altimeter-count'));
            if (!Number.isInteger(radarAltimeterCount) || radarAltimeterCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized RA count (must be a positive integer)');
                this.radarAltimeterCount = 1;
            }
            else {
                this.radarAltimeterCount = radarAltimeterCount;
            }
            const gpsCount = Number(element.getAttribute('gps-count'));
            if (!Number.isInteger(gpsCount) || gpsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS count (must be a positive integer)');
                this.gpsCount = 1;
            }
            else {
                this.gpsCount = gpsCount;
            }
            this.adcDefinitions = this.parseAdcDefinitions(baseInstrument, element);
            this.ahrsDefinitions = this.parseAhrsDefinitions(baseInstrument, element);
            this.radarAltimeterDefinitions = this.parseRadarAltimeterDefinitions(baseInstrument, element);
            this.gpsDefinitions = this.parseGpsDefinitions(baseInstrument, element);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this configuration defines a radar altimeter. */
    get hasRadarAltimeter() {
        return this.radarAltimeterDefinitions.length > 1;
    }
    /**
     * Parses ADC definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of ADC definitions defined by the configuration document element.
     */
    parseAdcDefinitions(baseInstrument, element) {
        const adcElements = element.querySelectorAll(':scope>Adc');
        const defs = [];
        for (const adcElement of adcElements) {
            const index = Number(adcElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.adcCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC index (must be an integer between 1 and the number of supported ADCs)');
                continue;
            }
            const altimeterIndex = Number(adcElement.getAttribute('altimeter'));
            if (!Number.isInteger(altimeterIndex) || altimeterIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized altimeter index (must be a positive integer)');
                continue;
            }
            const airspeedIndicatorIndex = Number(adcElement.getAttribute('airspeed-indicator'));
            if (!Number.isInteger(airspeedIndicatorIndex) || airspeedIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized airspeed indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = adcElement.querySelector(':scope>Electric');
            defs[index] = {
                altimeterIndex,
                airspeedIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    altimeterIndex: i,
                    airspeedIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses AHRS definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of AHRS definitions defined by the configuration document element.
     */
    parseAhrsDefinitions(baseInstrument, element) {
        const ahrsElements = element.querySelectorAll(':scope>Ahrs');
        const defs = [];
        for (const ahrsElement of ahrsElements) {
            const index = Number(ahrsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.ahrsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const attitudeIndicatorIndex = Number(ahrsElement.getAttribute('attitude-indicator'));
            if (!Number.isInteger(attitudeIndicatorIndex) || attitudeIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized attitude indicator index (must be a positive integer)');
                continue;
            }
            const directionIndicatorIndex = Number(ahrsElement.getAttribute('direction-indicator'));
            if (!Number.isInteger(directionIndicatorIndex) || directionIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized direction indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = ahrsElement.querySelector(':scope>Electric');
            defs[index] = {
                attitudeIndicatorIndex,
                directionIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    attitudeIndicatorIndex: i,
                    directionIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses a radar altimeter definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of RA definitions defined by the configuration document element.
     */
    parseRadarAltimeterDefinitions(baseInstrument, element) {
        const radarAltimeterElements = element.querySelectorAll(':scope>RadarAltimeter');
        const defs = [];
        for (const radarAltimeterElement of radarAltimeterElements) {
            const index = Number(radarAltimeterElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.radarAltimeterCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const electricLogicElement = radarAltimeterElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.radarAltimeterCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
    /**
     * Parses a GPS receiver definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of GPS definitions defined by the configuration document element.
     */
    parseGpsDefinitions(baseInstrument, element) {
        const gpsElements = element.querySelectorAll(':scope>Gps');
        const defs = [];
        for (const gpsElement of gpsElements) {
            const index = Number(gpsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.gpsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS index (must be an integer between 1 and the number of supported GPS)');
                continue;
            }
            const electricLogicElement = gpsElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.gpsCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
}

/**
 * A configuration object which defines options for G3000/5000 avionics systems.
 */
class AvionicsConfig {
    /**
     * Creates an AvionicsConfig from an XML configuration document.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param xmlConfig An XML configuration document.
     */
    constructor(baseInstrument, xmlConfig) {
        const root = xmlConfig.getElementsByTagName('PlaneHTMLConfig')[0];
        this.sensors = this.parseSensorsConfig(baseInstrument, root.querySelector(':scope>Sensors'));
    }
    /**
     * Parses a sensors configuration object from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns The sensors configuration defined by the configuration document element.
     */
    parseSensorsConfig(baseInstrument, element) {
        if (element !== null) {
            try {
                return new SensorsConfig(baseInstrument, element);
            }
            catch (e) {
                console.warn(e);
            }
        }
        return new SensorsConfig(baseInstrument, undefined);
    }
}

/** Takeoff thrust modes. */
var TakeoffThrustMode;
(function (TakeoffThrustMode) {
    TakeoffThrustMode["TO"] = "TO";
    TakeoffThrustMode["TO1"] = "TO 1";
    TakeoffThrustMode["TO2"] = "TO 2";
    TakeoffThrustMode["DTO"] = "D-TO";
    TakeoffThrustMode["DTO1"] = "D-TO 1";
    TakeoffThrustMode["DTO2"] = "D-TO 2";
})(TakeoffThrustMode || (TakeoffThrustMode = {}));
/** Climb thrust modes. */
var ClimbThrustMode;
(function (ClimbThrustMode) {
    ClimbThrustMode["CLB"] = "CLB";
    ClimbThrustMode["CLB1"] = "CLB 1";
    ClimbThrustMode["CLB2"] = "CLB 2";
})(ClimbThrustMode || (ClimbThrustMode = {}));
/** Airborne thrust modes. */
var AirborneThrustMode;
(function (AirborneThrustMode) {
    /** Go-around thrust limit. */
    AirborneThrustMode["GA"] = "GA";
    /** Maximum continuous thrust limit. */
    AirborneThrustMode["CON"] = "CON";
    /** Cruise thrust limit. */
    AirborneThrustMode["CRZ"] = "CRZ";
})(AirborneThrustMode || (AirborneThrustMode = {}));
var GlideslopeStatus;
(function (GlideslopeStatus) {
    GlideslopeStatus[GlideslopeStatus["ON"] = 0] = "ON";
    GlideslopeStatus[GlideslopeStatus["OFF"] = 1] = "OFF";
})(GlideslopeStatus || (GlideslopeStatus = {}));
/** Speed modes. */
var SpeedMode;
(function (SpeedMode) {
    /** Economy speed. */
    SpeedMode["ECON"] = "ECON SPD";
    /** Select speed. Manually entered speed on the CDU or the VNAV speed target is the maneuvering speed for flaps zero. */
    SpeedMode["SEL"] = "SEL SPD";
    /** Long-range cruise speed. */
    SpeedMode["LRC"] = "LRC SPD";
    /** Engine-out long-range cruise speed. */
    SpeedMode["EOLRC"] = "EO LRC";
    /** Engine-out speed. */
    SpeedMode["EO"] = "EO SPD";
    /** Engine-out operations at airline specified engine out company speed. */
    SpeedMode["CO"] = "CO SPD";
    /** Speed is limited by VMO, MMO, flap limit, or buffet limit. */
    SpeedMode["LIM"] = "LIM SPD";
    /** Speed intervention entered on the MCP IAS/MACH indicator. */
    SpeedMode["MCP"] = "MCP SPD";
    /** Required time of arrival speed. */
    SpeedMode["RTA"] = "RTA";
})(SpeedMode || (SpeedMode = {}));
/** Runway conditions */
var RunwayCondition;
(function (RunwayCondition) {
    /** Dry */
    RunwayCondition["DRY"] = "DRY";
    /** Wet */
    RunwayCondition["WET"] = "WET";
    /** Wet, skid resistant */
    RunwayCondition["WET_SKID_RES"] = "WET SK-R";
})(RunwayCondition || (RunwayCondition = {}));

/**
 * Types of vertical flight path vectors.
 */
var VerticalFlightPathVectorType;
(function (VerticalFlightPathVectorType) {
    VerticalFlightPathVectorType["Climb"] = "Climb";
    VerticalFlightPathVectorType["ClimbLevel"] = "ClimbLevel";
    VerticalFlightPathVectorType["ClimbAcceleration"] = "ClimbAcceleration";
    VerticalFlightPathVectorType["ClimbLevelAcceleration"] = "ClimbLevelAcceleration";
    VerticalFlightPathVectorType["Cruise"] = "Cruise";
    VerticalFlightPathVectorType["CruiseAcceleration"] = "CruiseAcceleration";
    VerticalFlightPathVectorType["CruiseDeceleration"] = "CruiseDeceleration";
    VerticalFlightPathVectorType["LevelDeceleration"] = "LevelDeceleration";
    VerticalFlightPathVectorType["IdleDescent"] = "IdleDescent";
    VerticalFlightPathVectorType["IdleDescentDeceleration"] = "IdleDescentDeceleration";
    VerticalFlightPathVectorType["GeometricDescent"] = "GeometricDescent";
})(VerticalFlightPathVectorType || (VerticalFlightPathVectorType = {}));
/**
 * Sources from which a flight path vector's target speed is derived.
 */
var VerticalFlightPathVectorSpeedSource;
(function (VerticalFlightPathVectorSpeedSource) {
    VerticalFlightPathVectorSpeedSource["None"] = "None";
    VerticalFlightPathVectorSpeedSource["Schedule"] = "Schedule";
    VerticalFlightPathVectorSpeedSource["FlightPlan"] = "FlightPlan";
    VerticalFlightPathVectorSpeedSource["Transition"] = "Transition";
    VerticalFlightPathVectorSpeedSource["Restriction"] = "Restriction";
})(VerticalFlightPathVectorSpeedSource || (VerticalFlightPathVectorSpeedSource = {}));
/**
 * The current VNAV altitude capture type.
 */
var BoeingVNavAltCaptureType;
(function (BoeingVNavAltCaptureType) {
    /** Altitude capture is not armed. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["VNAV"] = 2] = "VNAV";
    /** Altitude will capture the cruise altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Cruise"] = 3] = "Cruise";
})(BoeingVNavAltCaptureType || (BoeingVNavAltCaptureType = {}));

/**
 * A manager and calculator for vertical flight plans for Boeing avionics systems.
 */
class BoeingPathCalculator extends SmoothingPathCalculator {
    /**
     * Creates an instance of BoeingPathCalculator.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param perfProvider A provider of airplane performance data.
     * @param engineDataProvider A provider of airplane engine data.
     * @param perfPlanRepository The performance plan repository.
     * @param windPlanner The wind planner.
     * @param options Options for the calculator. Options that are not explicitly provided default to the following:
     * * `defaultFpa`: 3 degrees.
     * * `minFpa`: 1.5 degrees.
     * * `maxFpa`: 6 degrees.
     * * `excludeFirstLegConstraint`: `false`.
     * * `forceFirstApproachAtConstraint`: `false`.
     * * `directToLegOffset`: `3`.
     * * `isLegEligible`: a function which designates a leg as eligible if and only if it is not a discontinuity leg or
     * a manual termination leg that ends in a discontinuity.
     * * `shouldUseConstraint`: a function which always returns `true`.
     * * `invalidateClimbConstraint`: a function which does not invalidate any climb constraint.
     * * `invalidateDescentConstraint`: a function which invalidates a descent constraint if and only if it requires an
     * ascending path or a flight path angle greater than the maximum in order to meet it from the preceding constraint.
     * * `engineCount`: `2`.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, perfProvider, engineDataProvider, perfPlanRepository, windPlanner, options) {
        var _a;
        super(bus, flightPlanner, primaryPlanIndex, options);
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.perfPlanRepository = perfPlanRepository;
        this.windPlanner = windPlanner;
        this.speedConstraintLists = [];
        this.verticalFlightPaths = [];
        this.verticalFlightPathsNeedRebuild = [];
        this.perfPlanSubscriptions = [];
        this.accelerationResult = Vec2Math.create();
        this.engineCount = (_a = options === null || options === void 0 ? void 0 : options.engineCount) !== null && _a !== void 0 ? _a : 2;
        const sub = bus.getSubscriber();
        // TODO: Maybe support ADC system?
        this.indicatedAltitude = ConsumerValue.create(sub.on('indicated_alt'), 0);
        this.lnavTrackedLegIndex = ConsumerValue.create(sub.on('lnav_tracked_leg_index'), 0);
        this.lnavLegDistanceRemaining = ConsumerValue.create(sub.on('lnav_leg_distance_remaining'), 0);
        this.fob = ConsumerValue.create(sub.on('fuel_usable_total_weight'), 0);
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /**
     * Gets the speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The speed constraint list for the specified flight plan.
     */
    getSpeedConstraintList(planIndex) {
        var _a;
        return (_a = this.speedConstraintLists[planIndex]) !== null && _a !== void 0 ? _a : this.createSpeedConstraintList(planIndex);
    }
    /**
     * Gets the calculated vertical flight path for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The calculated vertical flight path for the specified flight plan.
     */
    getVerticalFlightPath(planIndex) {
        var _a;
        return (_a = this.verticalFlightPaths[planIndex]) !== null && _a !== void 0 ? _a : this.createVerticalFlightPath(planIndex);
    }
    /**
     * Gets the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The speed constraint in effect for the specified flight plan leg and vertical flight phase, or
     * `undefined` if there is no speed constraint in effect.
     */
    getCurrentSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        return speedConstraints[this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach)];
    }
    /**
     * Gets the next speed constraint to take effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The next speed constraint to take effect for the specified flight plan leg and vertical flight phase,
     * or `undefined` if there is no speed constraint in effect.
     */
    getNextSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        const currentIndex = this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach);
        if (currentIndex < 0) {
            if (flightPhase === VerticalFlightPhase.Climb) {
                // If there is no current constraint in effect during climb, there can be no next climb constraint because
                // either we have sequenced all climb constraints or there is at least one non-climb constraint to sequence
                // before the next climb constraint.
                return undefined;
            }
            else {
                // If there is no current constraint in effect during descent, it is still possible that the next upcoming
                // constraint to be sequenced is the next descent constraint. This constraint, if it exists, is located at the
                // index where the current constraint would be located if it existed, so we need to check if the constraint at
                // that index is a descent constraint and has yet to be sequenced.
                const constraint = speedConstraints[-currentIndex - 1];
                if (constraint !== undefined && flightPhase === constraint.flightPhase && constraint.globalLegIndex >= globalLegIndex) {
                    return constraint;
                }
                else {
                    return undefined;
                }
            }
        }
        const isMapr = speedConstraints[currentIndex].isMissedApproach;
        const constraint = speedConstraints[currentIndex + 1];
        if (constraint !== undefined && flightPhase === constraint.flightPhase && isMapr === constraint.isMissedApproach) {
            return constraint;
        }
        return undefined;
    }
    /**
     * Gets the index of the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param speedConstraintList The speed constraint list for the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The index of the speed constraint in effect for the specified flight plan leg and vertical flight phase.
     * If there is no speed constraint in effect, `-(i + 1)` is returned instead, where `i` is the index at which the
     * constraint would be located if it existed.
     */
    getCurrentSpeedConstraintIndex(planIndex, speedConstraintList, globalLegIndex, flightPhase, isMissedApproach) {
        var _a, _b;
        if (flightPhase === VerticalFlightPhase.Climb) {
            const inMissedApproach = isMissedApproach !== null && isMissedApproach !== void 0 ? isMissedApproach : (this.flightPlanner.hasFlightPlan(planIndex)
                && BitFlags.isAll((_b = (_a = this.flightPlanner.getFlightPlan(planIndex).tryGetLeg(globalLegIndex)) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, LegDefinitionFlags.MissedApproach));
            // During climb, the next upcoming climb speed constraint to be sequenced is in effect.
            for (let i = 0; i < speedConstraintList.length; i++) {
                const constraint = speedConstraintList[i];
                // Speed constraints in the missed approach are not active until we are in the missed approach.
                if (constraint.isMissedApproach && !inMissedApproach) {
                    return -(i + 1);
                }
                if (constraint.globalLegIndex >= globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 1);
                }
            }
            return -(speedConstraintList.length + 1);
        }
        else {
            // During descent, the last sequenced descent speed constraint is in effect.
            for (let i = speedConstraintList.length - 1; i >= 0; i--) {
                const constraint = speedConstraintList[i];
                if (constraint.globalLegIndex < globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 2);
                }
            }
            return -1;
        }
    }
    /**
     * Creates a new, empty speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created speed constraint list.
     */
    createSpeedConstraintList(planIndex) {
        return this.speedConstraintLists[planIndex] = [];
    }
    /**
     * Creates a new, empty vertical path for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created vertical path.
     */
    createVerticalFlightPath(planIndex) {
        const verticalFlightPath = BoeingPathCalculator.createVerticalPath(planIndex);
        this.verticalFlightPaths[planIndex] = verticalFlightPath;
        this.verticalFlightPathsNeedRebuild[planIndex] = false;
        return verticalFlightPath;
    }
    /** @inheritdoc */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        super.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.buildSpeedConstraints(lateralPlan, this.getSpeedConstraintList(verticalPlan.planIndex));
        this.buildVerticalFlightPath(lateralPlan, this.getVerticalFlightPath(verticalPlan.planIndex));
    }
    /**
     * Builds a speed constraint list from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param speedConstraints The speed constraint list to build.
     */
    buildSpeedConstraints(lateralPlan, speedConstraints) {
        var _a;
        let speedConstraintIndex = 0;
        for (let segmentIndex = 0; segmentIndex < lateralPlan.segmentCount; segmentIndex++) {
            const segment = lateralPlan.tryGetSegment(segmentIndex);
            if (segment) {
                for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                    const leg = segment.legs[segmentLegIndex];
                    const isDirectToLeg = BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo)
                        && lateralPlan.directToData.segmentIndex === segmentIndex
                        && lateralPlan.directToData.segmentLegIndex === segmentLegIndex - this.directToLegOffset;
                    // If the leg is a direct-to leg with an associated direct-to target leg, skip it since its constraint is
                    // duplicated from that of the target leg.
                    if (leg.verticalData.speedDesc !== SpeedRestrictionType.Unused && !isDirectToLeg) {
                        const isMissedApproach = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
                        const isCursorDepartureOrMissedApproach = segment.segmentType === FlightPlanSegmentType.Departure || isMissedApproach;
                        // If the constraint leg is a direct-to target, shift the leg index to that of the direct-to leg.
                        const isDirectToTarget = lateralPlan.directToData.segmentIndex === segmentIndex
                            && lateralPlan.directToData.segmentLegIndex === segmentLegIndex;
                        const constraint = (_a = speedConstraints[speedConstraintIndex]) !== null && _a !== void 0 ? _a : (speedConstraints[speedConstraintIndex] = BoeingPathCalculator.createSpeedConstraintListItem());
                        constraint.globalLegIndex = segment.offset + segmentLegIndex + (isDirectToTarget ? this.directToLegOffset : 0);
                        constraint.flightPhase = isCursorDepartureOrMissedApproach ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent;
                        constraint.speedConstraint.speedDesc = leg.verticalData.speedDesc;
                        constraint.speedConstraint.speed = leg.verticalData.speed;
                        constraint.speedConstraint.speedUnit = leg.verticalData.speedUnit;
                        constraint.isMissedApproach = isMissedApproach;
                        let useMin = false;
                        let useMax = false;
                        switch (constraint.speedConstraint.speedDesc) {
                            case SpeedRestrictionType.At:
                            case SpeedRestrictionType.Between:
                                useMin = true;
                                useMax = true;
                                break;
                            case SpeedRestrictionType.AtOrAbove:
                                useMin = true;
                                break;
                            case SpeedRestrictionType.AtOrBelow:
                                useMax = true;
                                break;
                        }
                        constraint.minCas = -Infinity;
                        constraint.maxCas = Infinity;
                        constraint.minMach = -Infinity;
                        constraint.maxMach = Infinity;
                        if (useMin) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.minMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.minCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        if (useMax) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.maxMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.maxCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        speedConstraintIndex++;
                    }
                }
            }
        }
        speedConstraints.length = speedConstraintIndex;
    }
    /**
     * Builds an empty vertical flight path from a lateral flight plan. After the path is built, it will contain one
     * leg (containing zero vectors) for each leg in the lateral flight plan, and all TOC/TOD data will be undefined.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPath The vertical flight path to build.
     */
    buildVerticalFlightPath(lateralPlan, verticalPath) {
        this.verticalFlightPathsNeedRebuild[verticalPath.planIndex] = false;
        verticalPath.legs.length = lateralPlan.length;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            if (leg) {
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
            else {
                verticalPath.legs[i] = BoeingPathCalculator.createVerticalPathLeg();
            }
        }
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
    }
    /**
     * Initializes performance plan subscriptions for an indexed flight plan. Once these subscriptions are initialized,
     * the vertical path for the flight plan will be flagged to be rebuilt during the next flight plan calculation cycle
     * whenever certain performance plan values change. If subscriptions are already initialized for the specified flight
     * plan, then this method does nothing.
     * @param planIndex The index of the flight plan for which to initialize performance plan subscriptions.
     */
    initPerfPlanSubscriptions(planIndex) {
        if (this.perfPlanSubscriptions[planIndex]) {
            return;
        }
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(planIndex);
        const handler = () => { this.verticalFlightPathsNeedRebuild[planIndex] = true; };
        const speedHandler = (mode, activeMode) => {
            if (mode.get() === activeMode) {
                this.verticalFlightPathsNeedRebuild[planIndex] = true;
            }
        };
        const climbSelSpeedHandler = speedHandler.bind(this, perfPlan.speedClimbMode, SpeedMode.SEL);
        const cruiseSelSpeedHandler = speedHandler.bind(this, perfPlan.speedCruiseMode, SpeedMode.SEL);
        const descentSelSpeedHandler = speedHandler.bind(this, perfPlan.speedDescentMode, SpeedMode.SEL);
        this.perfPlanSubscriptions[planIndex] = [
            perfPlan.speedClimbMode.sub(handler),
            perfPlan.speedClimbSelectCas.sub(climbSelSpeedHandler),
            perfPlan.speedClimbSelectMach.sub(climbSelSpeedHandler),
            perfPlan.speedCruiseMode.sub(handler),
            perfPlan.speedCruiseSelectCas.sub(cruiseSelSpeedHandler),
            perfPlan.speedCruiseSelectMach.sub(cruiseSelSpeedHandler),
            perfPlan.speedDescentMode.sub(handler),
            perfPlan.speedDescentSelectCas.sub(descentSelSpeedHandler),
            perfPlan.speedDescentSelectMach.sub(descentSelSpeedHandler),
            perfPlan.cruiseAltitude.sub(handler),
            perfPlan.climbSpeedLimitAltitude.sub(handler),
            perfPlan.climbSpeedLimitCas.sub(handler),
            perfPlan.climbSpeedRestrAltitude.sub(handler),
            perfPlan.climbSpeedRestrCas.sub(handler),
            perfPlan.descentSpeedLimitAltitude.sub(handler),
            perfPlan.descentSpeedLimitCas.sub(handler),
            perfPlan.descentSpeedRestrAltitude.sub(handler),
            perfPlan.descentSpeedRestrCas.sub(handler),
        ];
    }
    /** @inheritdoc */
    computePath(lateralPlan, verticalPlan) {
        var _a, _b;
        if (verticalPlan.constraints.length < 1) {
            return false;
        }
        const verticalPath = this.getVerticalFlightPath(verticalPlan.planIndex);
        this.initPerfPlanSubscriptions(verticalPlan.planIndex);
        if (this.verticalFlightPathsNeedRebuild[verticalPlan.planIndex]) {
            this.buildVerticalFlightPath(lateralPlan, verticalPath);
        }
        const activeLegIndex = this.lnavTrackedLegIndex.get();
        const activeDistanceToLegEnd = Math.max(0, UnitType.NMILE.convertTo(this.lnavLegDistanceRemaining.get(), UnitType.METER));
        // TODO: Support engine-out ops.
        const engineCount = this.engineCount;
        // Compute FPAs for geometric descent segment.
        this.computeDescentPath(lateralPlan, verticalPlan);
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(verticalPlan.planIndex);
        const climbSpeedMode = perfPlan.speedClimbMode.get();
        const cruiseSpeedMode = perfPlan.speedCruiseMode.get();
        const descentSpeedMode = perfPlan.speedDescentMode.get();
        let cruiseAltitude = perfPlan.cruiseAltitude.get();
        const zfw = perfPlan.manualZfw.get();
        let climbCas, climbMach;
        let cruiseCas, cruiseMach;
        let descentCas, descentMach;
        if (climbSpeedMode === SpeedMode.SEL) {
            climbCas = perfPlan.speedClimbSelectCas.get();
            climbMach = perfPlan.speedClimbSelectMach.get();
        }
        else {
            climbCas = perfPlan.speedClimbEconCas.get();
            climbMach = perfPlan.speedClimbEconMach.get();
        }
        if (cruiseSpeedMode === SpeedMode.SEL) {
            cruiseCas = perfPlan.speedCruiseSelectCas.get();
            cruiseMach = perfPlan.speedCruiseSelectMach.get();
        }
        else {
            cruiseCas = perfPlan.speedCruiseEconCas.get();
            cruiseMach = perfPlan.speedCruiseEconMach.get();
        }
        if (descentSpeedMode === SpeedMode.SEL) {
            descentCas = perfPlan.speedDescentSelectCas.get();
            descentMach = perfPlan.speedDescentSelectMach.get();
        }
        else {
            descentCas = perfPlan.speedDescentEconCas.get();
            descentMach = perfPlan.speedDescentEconMach.get();
        }
        if (cruiseAltitude === null
            || zfw === null
            || (climbCas === null && climbMach === null)
            || (cruiseCas === null && cruiseMach === null)
            || (descentCas === null && descentMach === null)) {
            this.clearVerticalPath(verticalPath);
            return true;
        }
        const maprStartLegIndex = (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : -1;
        const firstDescentConstraintLegIndex = (_b = verticalPlan.firstDescentConstraintLegIndex) !== null && _b !== void 0 ? _b : -1;
        const lastSimulatedLegIndex = maprStartLegIndex < 0 ? lateralPlan.length : maprStartLegIndex;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const isPastCalculatedTod = verticalPath.todLegIndex !== undefined && verticalPath.todDistanceToLegEnd !== undefined
            && (activeLegIndex > verticalPath.todLegIndex
                || (activeLegIndex === verticalPath.todLegIndex && activeDistanceToLegEnd <= verticalPath.todDistanceToLegEnd));
        climbCas !== null && climbCas !== void 0 ? climbCas : (climbCas = Infinity);
        climbMach !== null && climbMach !== void 0 ? climbMach : (climbMach = Infinity);
        cruiseCas !== null && cruiseCas !== void 0 ? cruiseCas : (cruiseCas = Infinity);
        cruiseMach !== null && cruiseMach !== void 0 ? cruiseMach : (cruiseMach = Infinity);
        descentCas !== null && descentCas !== void 0 ? descentCas : (descentCas = Infinity);
        descentMach !== null && descentMach !== void 0 ? descentMach : (descentMach = Infinity);
        cruiseAltitude = UnitType.FOOT.convertTo(cruiseAltitude, UnitType.METER);
        climbCas = UnitType.KNOT.convertTo(climbCas, UnitType.MPS);
        cruiseCas = UnitType.KNOT.convertTo(cruiseCas, UnitType.MPS);
        descentCas = UnitType.KNOT.convertTo(descentCas, UnitType.MPS);
        const currentAltitude = UnitType.FOOT.convertTo(this.indicatedAltitude.get(), UnitType.METER);
        const currentWeight = zfw + this.fob.get();
        let climbTransitionAltitude = perfPlan.climbSpeedLimitAltitude.get();
        if (climbTransitionAltitude !== null) {
            climbTransitionAltitude = UnitType.FOOT.convertTo(climbTransitionAltitude, UnitType.METER);
        }
        let climbTransitionCas = perfPlan.climbSpeedLimitCas.get();
        if (climbTransitionCas !== null) {
            climbTransitionCas = UnitType.KNOT.convertTo(climbTransitionCas, UnitType.MPS);
        }
        let climbRestrictionAltitude = perfPlan.climbSpeedRestrAltitude.get();
        if (climbRestrictionAltitude !== null) {
            climbRestrictionAltitude = UnitType.FOOT.convertTo(climbRestrictionAltitude, UnitType.METER);
        }
        let climbRestrictionCas = perfPlan.climbSpeedRestrCas.get();
        if (climbRestrictionCas !== null) {
            climbRestrictionCas = UnitType.KNOT.convertTo(climbRestrictionCas, UnitType.MPS);
        }
        let descentTransitionAltitude = perfPlan.descentSpeedLimitAltitude.get();
        if (descentTransitionAltitude !== null) {
            descentTransitionAltitude = UnitType.FOOT.convertTo(descentTransitionAltitude, UnitType.METER);
        }
        let descentTransitionCas = perfPlan.descentSpeedLimitCas.get();
        if (descentTransitionCas !== null) {
            descentTransitionCas = UnitType.KNOT.convertTo(descentTransitionCas, UnitType.MPS);
        }
        let descentRestrictionAltitude = perfPlan.descentSpeedRestrAltitude.get();
        if (descentRestrictionAltitude !== null) {
            descentRestrictionAltitude = UnitType.FOOT.convertTo(descentRestrictionAltitude, UnitType.METER);
        }
        let descentRestrictionCas = perfPlan.descentSpeedRestrCas.get();
        if (descentRestrictionCas !== null) {
            descentRestrictionCas = UnitType.KNOT.convertTo(descentRestrictionCas, UnitType.MPS);
        }
        const lateralLegs = [...lateralPlan.legs()];
        if (!isPastCalculatedTod) {
            const clearEndIndex = Math.min(verticalPath.legs.length, activeLegIndex);
            for (let i = 0; i < clearEndIndex; i++) {
                verticalPath.legs[i].vectors.length = 0;
                verticalPath.legs[i].simDistance = 0;
            }
            verticalPath.tocLegIndex = undefined;
            verticalPath.tocDistanceToLegEnd = undefined;
            verticalPath.tocWeight = undefined;
            // Only simulate the climb if we have not yet sequenced the first descent constraint (if one exists).
            if (firstDescentConstraintLegIndex < 0 || activeLegIndex <= firstDescentConstraintLegIndex) {
                this.simulateClimb(lateralLegs, verticalPlan, verticalPath, perfPlan.climbThrustMode.get(), climbCas, climbMach, climbTransitionAltitude, climbTransitionCas, climbRestrictionAltitude, climbRestrictionCas, cruiseAltitude, activeLegIndex, activeDistanceToLegEnd, currentAltitude, currentWeight, lastSimulatedLegIndex, false, engineCount);
            }
            this.simulateCruise(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, cruiseCas, cruiseMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, lastSimulatedLegIndex, engineCount);
            // If there exists at least one descent constraint and we have not yet sequenced it, then we need to simulate
            // the descent, beginning with the performance descent.
            if (firstDescentConstraintIndex >= 0 && activeLegIndex <= firstDescentConstraintLegIndex) {
                const firstDescentConstraintAltitude = firstDescentConstraint.legs[0].altitude;
                if (isFinite(firstDescentConstraintAltitude)) {
                    if (cruiseAltitude > firstDescentConstraintAltitude) {
                        // Cruise altitude is above the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist of a level deceleration segment + an idle descent segment that intercepts
                        // the geometric descent path at the first descent constraint.
                        this.computePerformanceDescent(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount);
                    }
                    else {
                        // Cruise altitude is at or below the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist only of a level deceleration segment that intercepts the geometric
                        // descent path at some point past the first descent constraint. Alternatively, if the geometric descent
                        // path never descends below the cruise altitude, there will be no descent.
                        this.computeLevelDeceleration(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount);
                    }
                }
            }
        }
        else {
            // We are past the calculated TOD. In this case, we will not recalculate the TOD. However, if we are still in
            // the performance descent segment, we need to adjust the vertical path vectors to account for any changes in
            // lateral leg distances.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && (activeLegIndex < verticalPath.geoDescentSimInterceptLegIndex
                    || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex
                        && activeDistanceToLegEnd > verticalPath.geoDescentSimInterceptDistanceToLegEnd))) {
                this.adjustPerformanceDescent(lateralLegs, verticalPath);
            }
        }
        if (maprStartLegIndex < 0 || activeLegIndex < maprStartLegIndex) {
            // We are not in the missed approach.
            // If a geometric descent intercept was calculated, simulate the geometric descent.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && verticalPath.geoDescentInterceptWeight !== undefined) {
                this.simulateGeometricDescent(lateralLegs, verticalPlan, verticalPath, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
            }
        }
        return true;
    }
    /**
     * Clears a vertical flight path of all vectors and resets all computed TOC, TOD, and performance descent data.
     * @param verticalPath The vertical flight path to clear.
     */
    clearVerticalPath(verticalPath) {
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            leg.vectors.length = 0;
            leg.simDistance = 0;
        }
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
    }
    /**
     * Calculates the top of descent and simulates the performance (off-idle) descent phase for a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the calculation and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param engineCount The number of operational engines to simulate.
     */
    computePerformanceDescent(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount) {
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const firstDescentConstraintLegIndex = firstDescentConstraint.index;
        const targetAltitude = firstDescentConstraint.legs[0].altitude;
        if (cruiseAltitude <= targetAltitude) {
            // Cruise altitude is below the target altitude, so there is no path to be calculated (we will transition
            // immediately from cruise to geometric descent when we intercept the first descent path).
            return;
        }
        // Now we will iteratively solve for the TOD. In each iteration, we will choose a TOD along the flight path,
        // then simulate the entire performance descent segment down to the first descent constraint. If the lateral
        // distance covered brings us to within tolerance to the constraint fix, we are done. Otherwise, we adjust
        // the TOD by a lateral distance equal to the difference between the simulated lateral distance and the required
        // lateral distance and run another iteration.
        // TODO: Support speed restriction
        // If the performance descent was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use a crude estimate based on constant FPA.
        let estimatedTodDistanceFromFirstConstraint;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromFirstConstraint = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromFirstConstraint = VNavUtils.distanceForAltitude(-3, targetAltitude - cruiseAltitude);
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        let simulatedVerticalPath;
        let estimatedDescentDistance = estimatedTodDistanceFromFirstConstraint;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the first descent constraint fix to find the lateral position of the TOD
            // -----------------------------
            let todLeg = undefined;
            let todLegIndex = firstDescentConstraintLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDescentDistance;
            while (todLegIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[todLegIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLeg = leg;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        todDistanceToLegEnd = distanceToGo;
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                todLegIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs before the first descent constraint.
                return;
            }
            // In case we hit the FROM leg or the beginning of the flight plan before reaching the TOD, add any remaining
            // distance to the last iterated leg
            todDistanceToLegEnd += distanceToGo;
            simulatedVerticalPath = BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, targetAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDescentDistance, todLegIndex, todDistanceToLegEnd, firstDescentConstraintLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDescentDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDescentDistance, prevEstimate);
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = firstDescentConstraintLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = 0;
    }
    /**
     * Calculates the top of descent and simulates the level deceleration segment for a flight plan in which the cruise
     * altitude intercepts the geometric descent path after the first descent altitude constraint.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the calculation and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param engineCount The number of operational engines to simulate.
     */
    computeLevelDeceleration(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount) {
        // Find the constraint that defines the vertical path we will intercept. This must be a non-flat constraint with a
        // target altitude lower than the cruise altitude.
        let constraintToIntercept = undefined;
        for (let i = firstDescentConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                break;
            }
            if (constraint.targetAltitude <= cruiseAltitude && constraint.fpa > 0) {
                constraintToIntercept = constraint;
                break;
            }
        }
        // If there is no constraint to intercept, then we will remain in cruise until the end of the flight plan.
        if (!constraintToIntercept) {
            return;
        }
        // Find the point along the flight plan at which the cruise altitude intercepts the geometric descent path.
        let distanceToIntercept = VNavUtils.distanceForAltitude(constraintToIntercept.fpa, cruiseAltitude - constraintToIntercept.targetAltitude);
        let interceptLegIndex = constraintToIntercept.index;
        let interceptDistanceToLegEnd = 0;
        let interceptLeg = lateralLegs[interceptLegIndex];
        while (interceptLeg && distanceToIntercept > 0) {
            const legDistance = interceptLeg.calculated ? interceptLeg.calculated.distanceWithTransitions : 0;
            if (legDistance > distanceToIntercept) {
                interceptDistanceToLegEnd = distanceToIntercept;
                break;
            }
            else {
                distanceToIntercept -= legDistance;
                interceptLeg = lateralLegs[--interceptLegIndex];
            }
        }
        // Now we will iteratively solve for the TOD, which in this context is the beginning of level deceleration.
        // If the level deceleration was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use an arbitrary estimate of 10km.
        let estimatedTodDistanceFromIntercept;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromIntercept = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromIntercept = 10000;
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        let simulatedVerticalPath;
        let estimatedDecelerationDistance = estimatedTodDistanceFromIntercept;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the intercept point to find the lateral position of the TOD
            // -----------------------------
            let todLeg = undefined;
            let todLegIndex = interceptLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDecelerationDistance + interceptDistanceToLegEnd;
            while (todLegIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[todLegIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLeg = leg;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        todDistanceToLegEnd = distanceToGo;
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                todLegIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs before the intercept point.
                return;
            }
            // In case we hit the FROM leg or the beginning of the flight plan before reaching the TOD, add any remaining
            // distance to the last iterated leg
            todDistanceToLegEnd += distanceToGo;
            simulatedVerticalPath = BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDecelerationDistance, todLegIndex, todDistanceToLegEnd, interceptLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDecelerationDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDecelerationDistance, prevEstimate);
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = interceptLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = interceptDistanceToLegEnd;
    }
    /**
     * Adjusts the vertical flight path vectors in the performance (off-idle) descent to account for changes in lateral
     * flight plan leg distances since the vectors were simulated.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPath The vertical flight path containing the vectors to adjust.
     */
    adjustPerformanceDescent(lateralLegs, verticalPath) {
        var _a, _b, _c;
        if (verticalPath.todLegIndex === undefined
            || verticalPath.todDistanceToLegEnd === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined) {
            return;
        }
        let distanceCovered = verticalPath.todDistanceToLegEnd;
        const endLegIndex = Math.min(verticalPath.legs.length, verticalPath.geoDescentSimInterceptLegIndex + 1);
        for (let i = verticalPath.todLegIndex + 1; i < endLegIndex; i++) {
            const leg = verticalPath.legs[i];
            if (leg.vectors.length === 0) {
                continue;
            }
            const isInterceptLeg = i === verticalPath.geoDescentSimInterceptLegIndex;
            const endDistanceToLegEnd = isInterceptLeg ? verticalPath.geoDescentSimInterceptDistanceToLegEnd : 0;
            const lerpEndDistanceToLegEnd = Math.max(0, endDistanceToLegEnd);
            const newLegDistance = (_c = (_b = (_a = lateralLegs[i]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            for (let j = 0; j < leg.vectors.length; j++) {
                const vector = leg.vectors[j];
                if (isInterceptLeg && vector.simStartDistanceToLegEnd <= endDistanceToLegEnd) {
                    break;
                }
                vector.startDistanceToLegEnd = MathUtils.lerp(vector.simStartDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
                vector.endDistanceToLegEnd = MathUtils.lerp(vector.simEndDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
            }
            distanceCovered += newLegDistance - endDistanceToLegEnd;
        }
        verticalPath.perfDescentTodDistance = distanceCovered;
    }
    /**
     * Simulates the VNAV climb phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param climbThrustMode The thrust mode to use during the climb phase.
     * @param climbCas The climb calibrated airspeed to use, in meters per second.
     * @param climbMach The climb mach number to use.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param bocLegIndex The global index of the flight plan leg containing the start of the climb.
     * @param bocDistanceToLegEnd The lateral distance, in meters, from the start of the climb to the end of its
     * containing leg.
     * @param bocAltitude The altitude, in meters above MSL, of the start of the climb.
     * @param bocWeight The airplane weight, in pounds, at the start of the climb.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the climb, exclusive. If the
     * climb is simulated to end past the last eligible leg, then the simulation will proceed along the last eligible leg
     * as if it were infinitely extended until the top of climb is reached.
     * @param isMissedApproach Whether the simulated climb is part of the missed approach.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateClimb(lateralLegs, verticalPlan, verticalPath, climbThrustMode, climbCas, climbMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, cruiseAltitude, bocLegIndex, bocDistanceToLegEnd, bocAltitude, bocWeight, endLegIndex, isMissedApproach, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var _k, _l;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        if (bocAltitude >= cruiseAltitude || bocLegIndex >= endLegIndex) {
            return;
        }
        let climbN1MethodName;
        switch (climbThrustMode) {
            case ClimbThrustMode.CLB1:
                climbN1MethodName = 'getClb1N1';
                break;
            case ClimbThrustMode.CLB2:
                climbN1MethodName = 'getClb2N1';
                break;
            default:
                climbN1MethodName = 'getClbMaxN1';
        }
        const wingArea = this.perfProvider.getWingArea();
        let currentVerticalPathLegIndex = bocLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        // Simulate climb steps. Each step covers the distance to the end of the next lateral leg, the next AT OR BELOW
        // climb altitude restriction to be sequenced, the next speed restriction or speed transition to be sequenced, or
        // 1000 feet of climb, whichever is shorter.
        let currentAltitude = bocAltitude;
        let currentLegIndex = bocLegIndex;
        let currentLeg = lateralLegs[bocLegIndex];
        let distanceToLegEnd = bocDistanceToLegEnd;
        let currentWeight = bocWeight;
        const getNextTargetConstraint = isMissedApproach ? VNavUtils.getNextMaprTargetConstraint : VNavUtils.getNextClimbTargetConstraint;
        let currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, bocLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = climbCas;
        const defaultTargetCasSource = isFinite(climbCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = climbMach;
        const defaultTargetMachSource = isFinite(climbMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let casToUse = Infinity;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude < cruiseAltitude) {
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedClimbWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_a = this.windPlanner.getInterpolatedClimbIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (currentTargetAltitudeConstraint && currentLegIndex > currentTargetAltitudeConstraint.index) {
                // We passed the current target altitude constraint that we were tracking, so we need to get the new current
                // target altitude constraint.
                currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
            }
            // Do not apply flight plan leg altitude restriction if we are past the end of the last eligible leg to be
            // simulated. Otherwise we might get stuck below the cruise altitude forever.
            const targetAltitude = currentTargetAltitudeConstraint && (currentLegIndex < endLegIndex - 1 || distanceToLegEnd > 0)
                ? Math.min(cruiseAltitude, currentTargetAltitudeConstraint.maxAltitude)
                : cruiseAltitude;
            if (currentSpeedConstraint && currentLegIndex > currentSpeedConstraint.globalLegIndex) {
                // We passed the current speed constraint that we were tracking, so we need to get the new current speed
                // constraint.
                currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
                // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed constraint
                // increased our target speed.
                if (!isAccelerating) {
                    isAccelerating = true;
                    accelerationCas = casToUse;
                }
            }
            if (useTransitionCas) {
                if (currentAltitude >= transitionAltitude) {
                    useTransitionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed transition
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            if (useRestrictionCas) {
                if (currentAltitude >= restrictionAltitude) {
                    useRestrictionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed restriction
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
            let distanceStep;
            let timeStep;
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
                altitudeStep = Math.min(altitudeStep, restrictionAltitude - currentAltitude);
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
                altitudeStep = Math.min(altitudeStep, transitionAltitude - currentAltitude);
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = casToTarget);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || casToTarget <= accelerationCas + 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            casToUse = isAccelerating ? accelerationCas : casToTarget;
            // If we are on the last eligible leg to be simulated, we will run the simulation even if the leg does not have
            // a non-zero calculated distance in order to guarantee that the simulation eventually reaches cruise altitude.
            if (currentLegIndex === endLegIndex - 1 || (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0)) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let vs;
                let engineFuelFlow;
                if (altitudeStep <= 0) {
                    // The current altitude is at or above the current target climb altitude (if it were at or above the cruise
                    // altitude we would have exited the while loop already). In this case, we will hold the current altitude
                    // until we sequence the altitude constraint.
                    altitudeStep = 0;
                    vs = 0;
                    const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl);
                    if (isAccelerating) {
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                        const targetNetThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, targetCl);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(targetNetThrustRequired, currentWeight, cl, tas, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        timeStep = tasStep / acceleration;
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                        timeStep = distanceStep / gs;
                    }
                    const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                }
                else {
                    // The current altitude is below the current target climb altitude, so we will climb using the selected climb
                    // climb thrust rating.
                    const temperatureK = temperature + 273.15;
                    const n1 = this.engineDataProvider[climbN1MethodName](currentAltitude, temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                    const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                    const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                    const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                    if (isAccelerating) {
                        vs = BoeingPathCalculator.CLIMB_ACCEL_VS_MPS;
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, vs));
                        const tasStep = Math.min(targetTas - tas, 3);
                        const accelTimeStep = tasStep / acceleration;
                        const accelAltitudeStep = vs * accelTimeStep;
                        // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the current climb target altitude).
                        if (accelAltitudeStep > altitudeStep) {
                            // vs cannot be 0 here
                            timeStep = altitudeStep / vs;
                        }
                        else {
                            altitudeStep = accelAltitudeStep;
                            timeStep = accelTimeStep;
                        }
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas), 1);
                        timeStep = altitudeStep / vs;
                        distanceStep = timeStep * gs;
                    }
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd && currentLegIndex < endLegIndex - 1) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined || (currentLegIndex === endLegIndex - 1 && distanceToLegEnd > 0 && distanceStep > distanceToLegEnd)) {
                    // We are either advancing legs or we are about to cross the end of the last eligible leg to be simulated.
                    // Either way we need to end the current step at the end of the current leg.
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * vs;
                    if (advanceLegIndexTo !== undefined) {
                        currentLegIndex = advanceLegIndexTo;
                        currentLeg = lateralLegs[currentLegIndex];
                        distanceToLegEnd = (_e = (_d = currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                    }
                    else {
                        distanceToLegEnd = 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentAltitude += altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.ClimbLevelAcceleration;
                    }
                    else {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.Climb : VerticalFlightPathVectorType.ClimbLevel;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from a level acceleration into a climb
                        // acceleration or vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_f = (_k = pathLeg.vectors)[vectorIndex]) !== null && _f !== void 0 ? _f : (_k[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_g = (_l = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_l[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = isAccelerating ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.Climb;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
        verticalPath.tocLegIndex = currentLegIndex;
        verticalPath.tocDistanceToLegEnd = distanceToLegEnd;
        verticalPath.tocWeight = currentWeight;
    }
    /**
     * Simulates the VNAV cruise phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param cruiseCas The cruise calibrated airspeed to use, in meters per second.
     * @param cruiseMach The cruise mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the cruise, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCruise(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, cruiseCas, cruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        endLegIndex = Math.min(endLegIndex, lateralLegs.length);
        let tocLegIndex;
        let tocDistanceToLegEnd;
        let tocWeight = activeWeight;
        let currentVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let tocCasToUse;
        // If a TOC is defined in the vertical flight path, then we need to make sure we start writing cruise vectors after
        // the TOC. Otherwise, the simulation starts in the cruise phase at the airplane's current along-track position, so
        // we will start writing vectors at index 0 for the active leg.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            // Check if the TOC lies past the end of its containing leg. If it does, then we need to start our simulation at
            // the beginning of the next leg.
            if (verticalPath.tocDistanceToLegEnd < 0) {
                tocLegIndex = verticalPath.tocLegIndex + 1;
                tocDistanceToLegEnd = (_c = (_b = (_a = lateralLegs[tocLegIndex]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
            }
            else {
                tocLegIndex = verticalPath.tocLegIndex;
                tocDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
                const tocPathLeg = verticalPath.legs[tocLegIndex];
                for (let i = 0; i < tocPathLeg.vectors.length; i++) {
                    const vector = tocPathLeg.vectors[i];
                    if (vector.startDistanceToLegEnd <= tocDistanceToLegEnd) {
                        // The current vector starts at or after the TOC -> start inserting cruise vectors at this index.
                        currentVerticalPathVectorIndex = i;
                        tocCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                        break;
                    }
                    if (vector.endDistanceToLegEnd <= tocDistanceToLegEnd) {
                        // The current vector ends at or after the TOC -> change the vector to end at the TOC if necessary and start
                        // inserting cruise vectors at the next index.
                        if (vector.endDistanceToLegEnd < tocDistanceToLegEnd) {
                            vector.endAltitude = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                            vector.endWeight = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                            // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                            // vector will be. For non-acceleration vectors, the end speed stays the same.
                            if (vector.endCas !== vector.startCas) {
                                // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                                // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                                // stays constant.
                                vector.endMach = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                                vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                            }
                            // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                            // vectors, but the absolute magnitude of the error should still be acceptable.
                            vector.duration = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                            vector.simStartDistanceToLegEnd = tocDistanceToLegEnd;
                            vector.endDistanceToLegEnd = tocDistanceToLegEnd;
                        }
                        currentVerticalPathVectorIndex = i + 1;
                        currentVerticalPathLegDuration += vector.duration;
                        tocCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                        break;
                    }
                    currentVerticalPathVectorIndex = i + 1;
                    currentVerticalPathLegDuration += vector.duration;
                    tocCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                }
            }
        }
        else {
            tocLegIndex = activeLegIndex;
            tocDistanceToLegEnd = activeDistanceToLegEnd;
            currentVerticalPathLegIndex = tocLegIndex;
        }
        if (tocLegIndex >= endLegIndex) {
            return;
        }
        const wingArea = this.perfProvider.getWingArea();
        const pressure = AeroMath.isaPressure(cruiseAltitude);
        const isaTemperature = AeroMath.isaTemperature(cruiseAltitude);
        const cruiseAltitudeFeet = UnitType.METER.convertTo(cruiseAltitude, UnitType.FOOT);
        // Simulate cruise steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction, or 100 NM, whichever is shorter.
        let currentLegIndex = tocLegIndex;
        let currentLeg = lateralLegs[tocLegIndex];
        let distanceToLegEnd = tocDistanceToLegEnd;
        let currentWeight = tocWeight;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        let defaultTargetCas = cruiseCas;
        let defaultTargetCasSource = isFinite(cruiseCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        if (restrictionAltitude !== null && restrictionCas !== null && cruiseAltitude < restrictionAltitude && restrictionCas < defaultTargetCas) {
            defaultTargetCas = restrictionCas;
            defaultTargetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
        }
        if (transitionAltitude !== null && transitionCas !== null && cruiseAltitude < transitionAltitude && transitionCas < defaultTargetCas) {
            defaultTargetCas = transitionCas;
            defaultTargetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
        }
        const defaultTargetMach = cruiseMach;
        const defaultTargetMachSource = isFinite(cruiseMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        while (currentLegIndex < endLegIndex) {
            // Check if we need to update winds and delta ISA offset.
            if (currentLegIndex !== lastWeatherLegIndex) {
                const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_d = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg)) !== null && _d !== void 0 ? _d : 0;
                lastWeatherLegIndex = currentLegIndex;
            }
            const temperature = isaTemperature + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            const useSpeedConstraint = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            if (useSpeedConstraint) {
                // Speed transition and restriction have higher priority than flight plan speed constraints
                if (useSpeedConstraint.minCas > targetCas && targetCasSource === VerticalFlightPathVectorSpeedSource.Schedule) {
                    targetCas = useSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxCas < targetCas) {
                    targetCas = useSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.minMach > targetMach) {
                    targetMach = useSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxMach < targetMach) {
                    targetMach = useSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            tocCasToUse !== null && tocCasToUse !== void 0 ? tocCasToUse : (tocCasToUse = casToTarget);
            let distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
            let timeStep;
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = tocCasToUse);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || Math.abs(casToTarget - accelerationCas) <= 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            const casToUse = isAccelerating ? accelerationCas : casToTarget;
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (windVector && windVector[1] > 0 && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl);
                if (isAccelerating) {
                    const accelerationSign = casToTarget - accelerationCas >= 0 ? 1 : -1;
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    // Assume that the airplane decelerates as quickly as possible by using idle thrust.
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                    let tasStep;
                    if (accelerationSign === 1) {
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0));
                        tasStep = Math.min(targetTas - tas, 3);
                    }
                    else {
                        acceleration = Math.min(-0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0));
                        tasStep = Math.max(targetTas - tas, -3);
                    }
                    timeStep = tasStep / acceleration;
                    distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                }
                else {
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 150 NM. This threshold is
                            // chosen because it guarantees that we don't overshoot any anticipated distance less than or equal to
                            // 50 NM (50 NM + 100 NM maximum step distance).
                            if (distanceToNextSpeedConstraint <= BoeingPathCalculator.MAX_DISTANCE_STEP + 92600) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                // Assume that the airplane decelerates as quickly as possible by using idle thrust.
                                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                                const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, 0, engineNetThrust, engineCount, wingArea, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // distance step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters before the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isAccelerating = true;
                                    accelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    distanceStep = Math.min(distanceStep, distanceToNextSpeedConstraint - distanceToDecel - 500);
                                }
                            }
                        }
                    }
                }
                const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = distanceStep / gs);
                // Check if we reach the end of the current leg before the end of the distance step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceToLegEnd <= distanceStep) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = currentLeg.calculated.distanceWithTransitions;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    distanceStep = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[advanceLegIndexTo];
                    distanceToLegEnd = (_f = (_e = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepEndDistanceToLegEnd = distanceToLegEnd - distanceStep;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - distanceStep / gs * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = acceleration >= 0 ? VerticalFlightPathVectorType.CruiseAcceleration : VerticalFlightPathVectorType.CruiseDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.Cruise;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from an acceleration to a deceleration or
                        // vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = cruiseAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = cruiseAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isAccelerating) {
                    vectorType = acceleration >= 0 ? VerticalFlightPathVectorType.CruiseAcceleration : VerticalFlightPathVectorType.CruiseDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.Cruise;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
    }
    /**
     * Simulates the VNAV performance (off-idle) descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param targetAltitude The altitude to target, in meters above MSL, at the end of the performance descent phase.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param estimatedTodDistance The lateral distance, in meters, from the top of descent to the first descent altitude
     * constraint along the flight plan.
     * @param todLegIndex The global index of the flight plan leg containing the top of descent.
     * @param todDistanceToLegEnd The lateral distance, in meters, from the top of descent to the end of its containing
     * leg.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the descent, exclusive.
     * @param engineCount The number of operational engines to simulate.
     * @returns The total simulated distance, in meters, of the performance descent phase.
     */
    simulatePerformanceDescent(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, targetAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedTodDistance, todLegIndex, todDistanceToLegEnd, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        if (todLegIndex >= lateralLegs.length) {
            verticalPath.todLegIndex = todLegIndex;
            verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
            verticalPath.perfDescentTodDistance = estimatedTodDistance;
            verticalPath.perfDescentSimDistance = 0;
            return 0;
        }
        const wingArea = this.perfProvider.getWingArea();
        // Find the vertical path vector
        let currentVerticalPathLegIndex = todLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let todCasToUse;
        let todWeight = 0;
        const todPathLeg = verticalPath.legs[todLegIndex];
        for (let i = 0; i < todPathLeg.vectors.length; i++) {
            const vector = todPathLeg.vectors[i];
            if (vector.startDistanceToLegEnd <= todDistanceToLegEnd) {
                // The current vector starts at or after the TOD -> start inserting descent vectors at this index.
                currentVerticalPathVectorIndex = i;
                todCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                todWeight = vector.startWeight;
                break;
            }
            if (vector.endDistanceToLegEnd < todDistanceToLegEnd) {
                // The current vector ends after the TOD -> change the vector to end at the TOD and start inserting descent
                // vectors at the next index.
                vector.endAltitude = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                vector.endWeight = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                // vector will be. For non-acceleration vectors, the end speed stays the same.
                if (vector.endCas !== vector.startCas) {
                    // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                    // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                    // stays constant.
                    vector.endMach = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                    vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                }
                // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                // vectors, but the absolute magnitude of the error should still be acceptable.
                vector.duration = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                vector.simEndDistanceToLegEnd = todDistanceToLegEnd;
                vector.endDistanceToLegEnd = todDistanceToLegEnd;
                currentVerticalPathVectorIndex = i + 1;
                currentVerticalPathLegDuration += vector.duration;
                todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                todWeight = vector.endWeight;
                break;
            }
            currentVerticalPathVectorIndex = i + 1;
            currentVerticalPathLegDuration += vector.duration;
            todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
            todWeight = vector.endWeight;
        }
        // If a TOC is defined, then check if the TOD lies before the TOC. If it does, then use the TOC weight as the weight
        // at TOD instead of the estimated weight at the TOD.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            if (todLegIndex < verticalPath.tocLegIndex
                || (todLegIndex === verticalPath.tocLegIndex && todDistanceToLegEnd > verticalPath.tocDistanceToLegEnd)) {
                todWeight = verticalPath.tocWeight;
            }
        }
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction or speed transition, or 1000 feet of descent, whichever is shorter.
        let currentAltitude = cruiseAltitude;
        let currentLegIndex = todLegIndex;
        let currentLeg = lateralLegs[todLegIndex];
        let distanceToLegEnd = todDistanceToLegEnd;
        let advanceLegIndexTo = undefined;
        let lastVectorLegIndex = currentVerticalPathLegIndex;
        let lastDistanceToLegEnd = todDistanceToLegEnd;
        let currentWeight = todWeight;
        let totalDistanceCovered = 0;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = descentCas;
        const defaultTargetCasSource = isFinite(descentCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = descentMach;
        const defaultTargetMachSource = isFinite(descentMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        let isInLevelDecelerationPhase = true;
        let isDecelerating = true;
        let decelerationCas = undefined;
        let decelerationAccel = 0;
        let decelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude > targetAltitude || isInLevelDecelerationPhase) {
            // If the current leg is the leg that we want to advance to, reset the advance leg index so that we don't skip
            // the current leg.
            if (advanceLegIndexTo === currentLegIndex) {
                advanceLegIndexTo = undefined;
            }
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                // If we are still at cruise altitude (i.e. level deceleration), then use cruise winds. Otherwise use descent
                // winds.
                if (currentAltitude === cruiseAltitude) {
                    const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_a = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg)) !== null && _a !== void 0 ? _a : 0;
                }
                else {
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                }
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, currentAltitude - targetAltitude);
            let distanceStep;
            let timeStep;
            let mach;
            let tas;
            let gs;
            let cl;
            let n1;
            let vs;
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            useTransitionCas || (useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude);
            useRestrictionCas || (useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude);
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            const useSpeedConstraint = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            if (useSpeedConstraint) {
                if (useSpeedConstraint.minCas > targetCas) {
                    targetCas = useSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxCas < targetCas) {
                    targetCas = useSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.minMach > targetMach) {
                    targetMach = useSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxMach < targetMach) {
                    targetMach = useSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            todCasToUse !== null && todCasToUse !== void 0 ? todCasToUse : (todCasToUse = casToTarget);
            decelerationCas !== null && decelerationCas !== void 0 ? decelerationCas : (decelerationCas = todCasToUse);
            // Check if we need to continue to decelerate
            if (isDecelerating && (!isFinite(decelerationCas) || casToTarget >= decelerationCas - 0.1)) {
                isDecelerating = false;
                isInLevelDecelerationPhase = false;
                decelerationCas = casToTarget;
                // If we were only simulating the level deceleration phase, then end the simulation now that we are no longer
                // in it.
                if (currentAltitude <= targetAltitude) {
                    break;
                }
            }
            if (advanceLegIndexTo === undefined) {
                // We are not skipping the current leg.
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                let casToUse;
                if (isDecelerating) {
                    vs = isInLevelDecelerationPhase ? 0 : BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                    casToUse = decelerationCas;
                    mach = AeroMath.casToMach(decelerationCas, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    decelerationAccel = Math.min(-0.1, this.perfProvider.getAcceleration(this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) * engineCount, currentWeight, cl, tas, vs));
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    const tasStep = Math.min(tas - targetTas, 3);
                    const accelTimeStep = tasStep / -decelerationAccel;
                    const accelAltitudeStep = -vs * accelTimeStep;
                    // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the first descent constraint).
                    if (accelAltitudeStep > altitudeStep) {
                        // vs cannot be 0 here
                        timeStep = altitudeStep / -vs;
                    }
                    else {
                        altitudeStep = accelAltitudeStep;
                        timeStep = accelTimeStep;
                    }
                    distanceStep = gs * timeStep + decelerationAccel / 2 * timeStep * timeStep;
                }
                else {
                    altitudeStep = Math.min(304.8, currentAltitude - targetAltitude);
                    casToUse = casToTarget;
                    mach = AeroMath.casToMach(casToUse, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 100 NM.
                            if (distanceToNextSpeedConstraint <= 185200) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineNetThrust, engineCount, wingArea, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // altitude step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters prior to the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isDecelerating = true;
                                    decelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    vs = Math.min(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas), -1);
                                    altitudeStep = Math.min(altitudeStep, (distanceToNextSpeedConstraint - distanceToDecel - 500) / gs * -vs);
                                }
                            }
                        }
                    }
                    // If we are not yet using the speed restriction limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the restriction altitude, check if we need to start anticipating the speed restriction.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseRestrictionCas && !useRestrictionCas && restrictionCas < casToUse && currentAltitude - restrictionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(restrictionCas, pressure, temperature);
                        const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineNetThrust, engineCount, wingArea, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToRestriction = currentAltitude - restrictionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the restriction altitude.
                        if (altitudeToDecel >= altitudeToRestriction - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToRestriction - altitudeToDecel - 100);
                        }
                    }
                    // If we are not yet using the speed transition limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the transition altitude, check if we need to start anticipating the speed transition.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseTransitionCas && !useTransitionCas && transitionCas < casToUse && currentAltitude - transitionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(transitionCas, pressure, temperature);
                        const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineNetThrust, engineCount, wingArea, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToTransition = currentAltitude - transitionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // transition, immediately start decelerating towards the transition speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the transition altitude.
                        if (altitudeToDecel >= altitudeToTransition - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToTransition - altitudeToDecel - 100);
                        }
                    }
                }
                const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                vs !== null && vs !== void 0 ? vs : (vs = Math.min(this.perfProvider.getVerticalSpeed((engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature)) * engineCount, currentWeight, cl, tas), -1));
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = altitudeStep / -vs);
                distanceStep !== null && distanceStep !== void 0 ? distanceStep : (distanceStep = timeStep * gs);
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                if (distanceStep >= distanceToLegEnd) {
                    // Search forward in the lateral plan for a leg with a non-zero calculated distance until we are past the
                    // last eligible leg.
                    let searchLegIndex = currentLegIndex;
                    while (++searchLegIndex < endLegIndex) {
                        const searchLeg = lateralLegs[searchLegIndex];
                        if (searchLeg.calculated && searchLeg.calculated.distanceWithTransitions > 0) {
                            advanceLegIndexTo = searchLegIndex;
                            break;
                        }
                    }
                }
                const currentLegDistance = (_d = (_c = currentLeg.calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isDecelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, decelerationAccel);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * -vs;
                    currentLegIndex++;
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_f = (_e = currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isDecelerating) {
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                }
                totalDistanceCovered += stepDistance;
                currentVerticalPathLegDuration += timeStep;
                currentAltitude -= altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isInLevelDecelerationPhase) {
                        vectorType = VerticalFlightPathVectorType.LevelDeceleration;
                    }
                    else if (isDecelerating) {
                        vectorType = VerticalFlightPathVectorType.IdleDescentDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.IdleDescent;
                    }
                    if (isDecelerating) {
                        // If we are decelerating, we need to check if we went straight from a level deceleration into a descent
                        // deceleration. If so, we need to insert a new vector.
                        if (!decelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            decelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not decelerating, we need to check if the current vector is a deceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = decelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        decelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    if (!isDecelerating || !decelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        decelerationVectorStarted = isDecelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isDecelerating) {
                        vector.endCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(decelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    lastVectorLegIndex = currentVerticalPathLegIndex;
                    lastDistanceToLegEnd = stepEndDistanceToLegEnd;
                    if (!isDecelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex++;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    decelerationVectorStarted = false;
                }
            }
            else {
                // The current leg is being skipped, which can only happen if it has no calculated lateral path or the lateral
                // path has a distance of zero. Therefore we insert one zero-length vector into the vertical path for the leg
                // and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isDecelerating) {
                    vectorType = isInLevelDecelerationPhase ? VerticalFlightPathVectorType.LevelDeceleration : VerticalFlightPathVectorType.IdleDescentDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.IdleDescent;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isDecelerating) {
                    vector.startCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(decelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                lastVectorLegIndex = currentVerticalPathLegIndex;
                lastDistanceToLegEnd = 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                decelerationVectorStarted = false;
            }
        }
        verticalPath.todLegIndex = todLegIndex;
        verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
        verticalPath.perfDescentTodDistance = estimatedTodDistance;
        verticalPath.perfDescentSimDistance = totalDistanceCovered;
        verticalPath.geoDescentSimInterceptLegIndex = lastVectorLegIndex;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = lastDistanceToLegEnd;
        verticalPath.geoDescentInterceptWeight = currentWeight;
        return totalDistanceCovered;
    }
    /**
     * Simulates the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateGeometricDescent(lateralLegs, verticalPlan, verticalPath, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        var _p, _q;
        if (verticalPlan.firstDescentConstraintLegIndex === undefined
            || verticalPlan.lastDescentConstraintLegIndex === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined) {
            return;
        }
        const firstDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const lastDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        if (!firstDescentConstraint || !lastDescentConstraint) {
            return;
        }
        // Start simulation at the active leg, or the start of the geometric descent, whichever one comes later.
        const startAtActive = activeLegIndex > verticalPath.geoDescentSimInterceptLegIndex
            || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex && activeDistanceToLegEnd < verticalPath.geoDescentSimInterceptDistanceToLegEnd);
        const startLegIndex = startAtActive ? activeLegIndex : verticalPath.geoDescentSimInterceptLegIndex;
        // Simulate until the MAP or the end of the flight plan, whichever one comes first.
        const endLegIndex = Math.min(lateralLegs.length, (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : Infinity);
        if (startLegIndex >= endLegIndex) {
            return;
        }
        let startDistanceToLegEnd;
        let startWeight;
        let currentVerticalPathLegIndex = startLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        if (startAtActive) {
            startDistanceToLegEnd = activeDistanceToLegEnd;
            startWeight = activeWeight;
        }
        else {
            startDistanceToLegEnd = verticalPath.geoDescentSimInterceptDistanceToLegEnd;
            startWeight = (_b = verticalPath.geoDescentInterceptWeight) !== null && _b !== void 0 ? _b : activeWeight;
            const interceptPathLeg = verticalPath.legs[startLegIndex];
            for (let i = 0; i < interceptPathLeg.vectors.length; i++) {
                const vector = interceptPathLeg.vectors[i];
                if (vector.startDistanceToLegEnd <= startDistanceToLegEnd) {
                    // The current vector starts at or after the intercept -> start inserting descent vectors at this index.
                    currentVerticalPathVectorIndex = i;
                    break;
                }
                if (vector.endDistanceToLegEnd < startDistanceToLegEnd) {
                    // The current vector ends after the TOD -> change the vector to end at the TOD and start inserting descent
                    // vectors at the next index.
                    vector.endAltitude = MathUtils.lerp(startDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                    vector.endWeight = MathUtils.lerp(startDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                    // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                    // vector will be. For non-acceleration vectors, the end speed stays the same.
                    if (vector.endCas !== vector.startCas) {
                        // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                        // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                        // stays constant.
                        vector.endMach = MathUtils.lerp(startDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                    }
                    // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                    // vectors, but the absolute magnitude of the error should still be acceptable.
                    vector.duration = MathUtils.lerp(startDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                    vector.simEndDistanceToLegEnd = startDistanceToLegEnd;
                    vector.endDistanceToLegEnd = startDistanceToLegEnd;
                    currentVerticalPathVectorIndex = i + 1;
                    currentVerticalPathLegDuration += vector.duration;
                    break;
                }
                currentVerticalPathVectorIndex = i + 1;
                currentVerticalPathLegDuration += vector.duration;
            }
        }
        const wingArea = this.perfProvider.getWingArea();
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // speed restriction or speed transition, or 1000 feet of descent, whichever is shorter.
        let currentAltitude;
        let currentLegIndex = startLegIndex;
        let currentLeg = lateralLegs[startLegIndex];
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentWeight = startWeight;
        // If the current leg is not calculated, we are already at or past the end of the leg, or we are initially
        // intercepting the geometric descent at the first descent constraint, advance to the next leg.
        if (!currentLeg.calculated
            || distanceToLegEnd <= 0
            || (currentLegIndex === verticalPath.geoDescentInterceptLegIndex
                && verticalPath.geoDescentInterceptLegIndex === verticalPlan.firstDescentConstraintLegIndex
                && verticalPath.geoDescentInterceptDistanceToLegEnd === 0)) {
            currentLegIndex++;
            currentLeg = lateralLegs[currentLegIndex];
            distanceToLegEnd = (_d = (_c = currentLeg.calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0;
            const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
            pathLeg.vectors.length = currentVerticalPathVectorIndex;
            pathLeg.simDuration = currentVerticalPathLegDuration;
            currentVerticalPathLegIndex = currentLegIndex;
            currentVerticalPathVectorIndex = 0;
            currentVerticalPathLegDuration = 0;
        }
        // Negative = descending path.
        let currentFpa;
        let currentAltitudeConstraintIndex = -1;
        let priorAltitudeConstraintIndex = -1;
        let currentAltitudeConstraint = undefined;
        let priorAltitudeConstraint = undefined;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        let useTransitionCas = false;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useRestrictionCas = false;
        const defaultTargetCas = descentCas;
        const defaultTargetCasSource = isFinite(descentCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = descentMach;
        const defaultTargetMachSource = isFinite(descentMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentLegIndex < endLegIndex) {
            // Update the current and prior altitude constraints for the current leg.
            if (currentLegIndex <= verticalPlan.lastDescentConstraintLegIndex) {
                if (!currentAltitudeConstraint || currentLegIndex > currentAltitudeConstraint.index) {
                    currentAltitudeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, currentLegIndex);
                    priorAltitudeConstraintIndex = currentAltitudeConstraintIndex + 1;
                }
            }
            else {
                currentAltitudeConstraintIndex = -1;
                priorAltitudeConstraintIndex = -1;
            }
            currentAltitudeConstraint = verticalPlan.constraints[currentAltitudeConstraintIndex];
            priorAltitudeConstraint = verticalPlan.constraints[priorAltitudeConstraintIndex];
            let altitudeStep;
            let distanceStep;
            // Calculate our current desired altitude and FPA.
            if (currentAltitudeConstraint && priorAltitudeConstraint) {
                const verticalLeg = currentAltitudeConstraint.legs[currentAltitudeConstraint.index - currentLegIndex];
                const desiredAltitude = VNavUtils.altitudeForDistance(verticalLeg.fpa, distanceToLegEnd) + verticalLeg.altitude;
                if (desiredAltitude > priorAltitudeConstraint.targetAltitude) {
                    // The desired altitude on the current leg's vertical path exceeds the prior constraint's target altitude.
                    // Therefore we will hold the prior constraint's target altitude until we intercept the vertical path.
                    currentAltitude = priorAltitudeConstraint.targetAltitude;
                    currentFpa = 0;
                    altitudeStep = 0;
                    distanceStep = Math.min(BoeingPathCalculator.MAX_DISTANCE_STEP, verticalLeg.fpa > 0 ? MathUtils.lerp(currentAltitude, verticalLeg.altitude, desiredAltitude, distanceToLegEnd, 0) : Infinity);
                }
                else {
                    // The desired altitude on the current leg's vertical path does not exceed the prior constraint's target
                    // altitude. Therefore we will follow the vertical path.
                    currentAltitude = desiredAltitude;
                    const altitudeRemainingToTarget = currentAltitude - currentAltitudeConstraint.targetAltitude;
                    if (verticalLeg.fpa > 0 && altitudeRemainingToTarget > 0) {
                        currentFpa = -verticalLeg.fpa;
                        altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, altitudeRemainingToTarget);
                    }
                    else {
                        currentFpa = 0;
                        altitudeStep = 0;
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                    }
                }
            }
            else {
                // We are past the last descent constraint. Therefore we will hold the target altitude of the last constraint.
                currentAltitude = lastDescentConstraint.targetAltitude;
                currentFpa = 0;
                altitudeStep = 0;
                distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
            }
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedClimbWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_e = this.windPlanner.getInterpolatedClimbIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _e !== void 0 ? _e : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (!useTransitionCas && canUseTransitionCas) {
                if (currentAltitude < transitionAltitude) {
                    useTransitionCas = true;
                }
                else {
                    altitudeStep = Math.min(altitudeStep, currentAltitude - transitionAltitude + 1);
                }
            }
            if (!useRestrictionCas && canUseRestrictionCas) {
                if (currentAltitude < restrictionAltitude) {
                    useRestrictionCas = true;
                }
                else {
                    altitudeStep = Math.min(altitudeStep, currentAltitude - restrictionAltitude + 1);
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToTarget, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const vs = gs * Math.tan(currentFpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let timeStep;
                if (distanceStep === undefined) {
                    timeStep = altitudeStep / -vs;
                    distanceStep = gs * timeStep;
                }
                else {
                    timeStep = distanceStep / gs;
                }
                const netThrustRequired = vs === 0
                    ? this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl)
                    : this.perfProvider.getRequiredThrust(currentWeight, cl, tas, vs);
                const engineGrossThrust = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = (_g = (_f = currentLeg.calculated) === null || _f === void 0 ? void 0 : _f.distanceWithTransitions) !== null && _g !== void 0 ? _g : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    timeStep = distanceToLegEnd / gs;
                    altitudeStep = timeStep * -vs;
                    currentLegIndex = advanceLegIndexTo;
                    if (currentLegIndex < endLegIndex) {
                        currentLeg = lateralLegs[advanceLegIndexTo];
                        distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                }
                currentVerticalPathLegDuration += timeStep;
                currentAltitude -= altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    const vector = (_k = (_p = pathLeg.vectors)[currentVerticalPathVectorIndex]) !== null && _k !== void 0 ? _k : (_p[currentVerticalPathVectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.type = VerticalFlightPathVectorType.GeometricDescent;
                    vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = targetCasSource;
                    vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                    vector.targetMachSource = targetMachSource;
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                    vector.endCas = vector.startCas;
                    vector.endMach = vector.startMach;
                    vector.duration = timeStep;
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    currentVerticalPathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_l = (_q = pathLeg.vectors)[0]) !== null && _l !== void 0 ? _l : (_q[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = VerticalFlightPathVectorType.GeometricDescent;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                if (currentLegIndex < endLegIndex) {
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_o = (_m = currentLeg.calculated) === null || _m === void 0 ? void 0 : _m.distanceWithTransitions) !== null && _o !== void 0 ? _o : 0;
                }
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
            }
        }
    }
    /**
     * Gets the time required to travel a given distance with constant acceleration.
     * @param distance The distance to travel.
     * @param v0 The initial velocity. The value should be expressed in units of `distance` per unit time.
     * @param acceleration The acceleration. The value should be expressed in units of `distance` per unit time squared.
     * @returns The time required to travel the specified distance given the specified constant acceleration from the
     * initial velocity. The value is expressed in the unit of time chosen for `v0` and `acceleration`.
     */
    static timeToDistance(distance, v0, acceleration) {
        if (acceleration === 0) {
            return distance / v0;
        }
        const a = acceleration / 2;
        const b = v0;
        const c = -distance;
        return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    /**
     * Creates a new speed constraint list item.
     * @returns A new speed constraint list item.
     */
    static createSpeedConstraintListItem() {
        return {
            globalLegIndex: 0,
            flightPhase: VerticalFlightPhase.Climb,
            speedConstraint: {
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS
            },
            isMissedApproach: false,
            minCas: -Infinity,
            maxCas: Infinity,
            minMach: -Infinity,
            maxMach: Infinity
        };
    }
    /**
     * Creates a new vertical flight path.
     * @param planIndex The index of the path's associated flight plan. Defaults to `0`.
     * @returns A new vertical flight path.
     */
    static createVerticalPath(planIndex = 0) {
        return {
            planIndex,
            legs: [],
            tocLegIndex: undefined,
            tocDistanceToLegEnd: undefined,
            tocWeight: undefined,
            todLegIndex: undefined,
            todDistanceToLegEnd: undefined,
            perfDescentTodDistance: undefined,
            perfDescentSimDistance: undefined,
            geoDescentInterceptLegIndex: undefined,
            geoDescentInterceptDistanceToLegEnd: undefined,
            geoDescentSimInterceptLegIndex: undefined,
            geoDescentSimInterceptDistanceToLegEnd: undefined,
            geoDescentInterceptWeight: undefined
        };
    }
    /**
     * Creates a new vertical flight path leg.
     * @returns A new vertical flight path leg.
     */
    static createVerticalPathLeg() {
        return {
            vectors: [],
            simDistance: 0,
            simDuration: 0
        };
    }
    /**
     * Creates a new vertical flight path vector.
     * @returns A new vertical flight path vector.
     */
    static createVerticalPathVector() {
        return {
            type: VerticalFlightPathVectorType.Climb,
            simStartDistanceToLegEnd: 0,
            simEndDistanceToLegEnd: 0,
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: NaN,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: NaN,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            startCas: 0,
            startMach: 0,
            endCas: 0,
            endMach: 0,
            startWeight: 0,
            endWeight: 0,
            duration: 0
        };
    }
    /**
     * Copies a vertical flight path.
     * @param source The path to copy from.
     * @param target The path to copy to. If not defined, a new vertical flight path will be created.
     * @returns The vertical flight path that was copied to.
     */
    static copyVerticalPath(source, target) {
        if (!target) {
            target = BoeingPathCalculator.createVerticalPath(source.planIndex);
        }
        target.legs.length = source.legs.length;
        for (let i = 0; i < source.legs.length; i++) {
            target.legs[i] = BoeingPathCalculator.copyVerticalPathLeg(source.legs[i], target.legs[i]);
        }
        target.tocLegIndex = source.tocLegIndex;
        target.tocDistanceToLegEnd = source.tocDistanceToLegEnd;
        target.tocWeight = source.tocWeight;
        target.todLegIndex = source.todLegIndex;
        target.todDistanceToLegEnd = source.todDistanceToLegEnd;
        target.perfDescentTodDistance = source.perfDescentTodDistance;
        target.perfDescentSimDistance = source.perfDescentSimDistance;
        target.geoDescentInterceptLegIndex = source.geoDescentInterceptLegIndex;
        target.geoDescentInterceptDistanceToLegEnd = source.geoDescentInterceptDistanceToLegEnd;
        target.geoDescentSimInterceptLegIndex = source.geoDescentSimInterceptLegIndex;
        target.geoDescentSimInterceptDistanceToLegEnd = source.geoDescentSimInterceptDistanceToLegEnd;
        target.geoDescentInterceptWeight = source.geoDescentInterceptWeight;
        return target;
    }
    /**
     * Copies a vertical flight path leg.
     * @param source The leg to copy from.
     * @param target The leg to copy to. If not defined, a new vertical flight path leg will be created.
     * @returns The vertical flight path leg that was copied to.
     */
    static copyVerticalPathLeg(source, target) {
        var _a;
        if (!target) {
            target = BoeingPathCalculator.createVerticalPathLeg();
        }
        target.vectors.length = source.vectors.length;
        for (let i = 0; i < source.vectors.length; i++) {
            target.vectors[i] = Object.assign((_a = target.vectors[i]) !== null && _a !== void 0 ? _a : {}, source.vectors[i]);
        }
        target.simDistance = source.simDistance;
        target.simDuration = source.simDuration;
        return target;
    }
    /**
     * Gets the lateral distance, in meters, from a given query point along a flight plan to a speed constraint in the
     * same flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param speedConstraint The speed constraint to get the distance to.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of its containing leg.
     * @returns The lateral distance, in meters, from the specified query point to the specified speed constraint.
     * @throws RangeError if `globalLegIndex` is out of bounds.
     */
    static getDistanceToSpeedConstraint(lateralLegs, speedConstraint, globalLegIndex, distanceToLegEnd) {
        var _a, _b, _c, _d, _e, _f;
        if (globalLegIndex < 0 || globalLegIndex >= lateralLegs.length) {
            throw new RangeError();
        }
        if (globalLegIndex <= speedConstraint.globalLegIndex) {
            let distance = distanceToLegEnd;
            const end = Math.min(speedConstraint.globalLegIndex + 1, lateralLegs.length);
            for (let i = globalLegIndex + 1; i < end; i++) {
                distance += (_b = (_a = lateralLegs[i].calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
            }
            return distance;
        }
        else {
            let distance = distanceToLegEnd - ((_d = (_c = lateralLegs[globalLegIndex].calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0);
            const end = Math.max(speedConstraint.globalLegIndex, 0);
            for (let i = globalLegIndex - 1; i > end; i--) {
                distance -= (_f = (_e = lateralLegs[i].calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            }
            return distance;
        }
    }
    /**
     * Gets the geo circle representation of the course at and the position vector of a point along a flight plan leg's
     * lateral flight path.
     * @param legCalc The lateral flight path calculations for a flight plan leg.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of the flight plan leg.
     * @param courseOut The geo circle to which write the flight path course at the query point.
     * @param positionOut The 3D vector to which to write the position vector of the query point.
     * @returns Whether a course and position vector were successfully found for the query point.
     */
    static getCourseAndPositionAlongLeg(legCalc, distanceToLegEnd, courseOut, positionOut) {
        // Iterate over all vectors (including transitions) in the leg in forward order until we reach the query point.
        let distanceToGo = legCalc.distanceWithTransitions - distanceToLegEnd;
        let vectors = legCalc.ingress;
        let vectorIndex = 0;
        let vector = vectors[vectorIndex];
        let lastVector = undefined;
        // ingress vectors
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // ingress to egress vectors
        vectors = legCalc.ingressToEgress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // egress vectors
        vectors = legCalc.egress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // If we have exhausted all vectors on the leg without reaching the query point, advance past the end of the last
        // vector (if it exists).
        if (lastVector) {
            FlightPathUtils.setGeoCircleFromVector(lastVector, courseOut);
            courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(lastVector.endLat, lastVector.endLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
            return true;
        }
        return false;
    }
}
BoeingPathCalculator.MAX_DISTANCE_STEP = 185200; // meters (100 nautical miles)
BoeingPathCalculator.MAX_ALTITUDE_STEP = 304.8; // meters (1000 feet)
BoeingPathCalculator.CLIMB_ACCEL_VS_MPS = UnitType.FPM.convertTo(500, UnitType.MPS);
BoeingPathCalculator.DESCENT_DECEL_VS_MPS = UnitType.FPM.convertTo(-500, UnitType.MPS);
BoeingPathCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingPathCalculator.vec3Cache = [Vec3Math.create()];
BoeingPathCalculator.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
BoeingPathCalculator.windCache = [Vec2Math.create()];
BoeingPathCalculator.getCourseAndPositionAlongLegCache = {
    geoPoint: [new GeoPoint(0, 0)]
};

var BoeingVNavVars;
(function (BoeingVNavVars) {
    BoeingVNavVars["VNAVDesiredState"] = "L:WTAP_Boeing_VNav_Desired_State";
    BoeingVNavVars["RNP"] = "L:WTAP_Boeing_VNav_RNP";
    BoeingVNavVars["PerformanceTODDistance"] = "L:WTAP_VNav_Distance_To_Performance_TOD";
    BoeingVNavVars["PerformanceTODLegIndex"] = "L:WTAP_VNav_Performance_TOD_Leg_Index";
    BoeingVNavVars["PerformanceTODDistanceInLeg"] = "L:WTAP_VNav_Performance_TOD_Distance_In_Leg";
})(BoeingVNavVars || (BoeingVNavVars = {}));
/** A publisher for Boeing VNAV sim var events. */
class BoeingVNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(BoeingVNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
BoeingVNavSimVarPublisher.simvars = new Map([
    ['boeingvnav_desired_state', { name: BoeingVNavVars.VNAVDesiredState, type: SimVarValueType.Enum }],
    ['boeingvnav_rnp', { name: BoeingVNavVars.RNP, type: SimVarValueType.Number }],
    ['boeingvnav_performance_tod_distance', { name: BoeingVNavVars.PerformanceTODDistance, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_leg_distance', { name: BoeingVNavVars.PerformanceTODDistanceInLeg, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_global_leg_index', { name: BoeingVNavVars.PerformanceTODLegIndex, type: SimVarValueType.Number }],
]);

/** Utils for BoeingFmaData. */
class BoeingFmaDataUtils {
    /**
     * Creates a new BoeingFmaData object.
     * @returns a new BoeingFmaData object.
     */
    static createBoeingFmaData() {
        return {
            verticalActive: APVerticalModes.NONE,
            verticalArmed: APVerticalModes.NONE,
            verticalDegraded: false,
            lateralActive: APLateralModes.NONE,
            lateralArmed: APLateralModes.NONE,
            lateralDegraded: false,
        };
    }
}

/**
 * Valid CDI scale labels for the LVar scale enum.
 */
var CDIScaleLabel;
(function (CDIScaleLabel) {
    CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
    CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
    CDIScaleLabel[CDIScaleLabel["TerminalDeparture"] = 2] = "TerminalDeparture";
    CDIScaleLabel[CDIScaleLabel["TerminalArrival"] = 3] = "TerminalArrival";
    CDIScaleLabel[CDIScaleLabel["Enroute"] = 4] = "Enroute";
    CDIScaleLabel[CDIScaleLabel["Oceanic"] = 5] = "Oceanic";
    CDIScaleLabel[CDIScaleLabel["Approach"] = 6] = "Approach";
    CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 7] = "MissedApproach";
})(CDIScaleLabel || (CDIScaleLabel = {}));
/**
 * Sim var names for Boeing LNAV-related data.
 */
var BoeingLNavDataVars;
(function (BoeingLNavDataVars) {
    /** The global leg index of the flight plan leg that is nominally being tracked by LNAV. */
    BoeingLNavDataVars["NominalLegIndex"] = "L:WTBoeing_LNavData_Nominal_Leg_Index";
    /** The current CDI scale label. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    BoeingLNavDataVars["CDIScaleLabel"] = "L:WTBoeing_LNavData_CDI_Scale_Label";
    /** The current lateral RNP in nautical miles */
    BoeingLNavDataVars["RNP"] = "L:WTBoeing_LNavData_RNP";
    /** The nominal distance remaining to the end of the currently tracked flight plan leg. */
    BoeingLNavDataVars["TrackedLegEndDistance"] = "L:WTBoeing_LNavData_Tracked_Leg_End_Distance";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Distance_Direct";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationRunwayDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Runway_Distance_Direct";
    /** The flight plan distance to the final approach fix, in nautical miles. */
    BoeingLNavDataVars["FafDistance"] = "L:WTBoeing_LNavData_Faf_Distance";
    /** The total flight plan distance in nautical miles. */
    BoeingLNavDataVars["TotalDistance"] = "L:WTBoeing_LNavData_Total_Distance";
})(BoeingLNavDataVars || (BoeingLNavDataVars = {}));
/**
 * A publisher for Boeing LNAV-related data sim var events.
 */
class BoeingLNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(BoeingLNavDataSimVarPublisher.simvars, bus);
    }
}
BoeingLNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale_label', { name: BoeingLNavDataVars.CDIScaleLabel, type: SimVarValueType.Number }],
    ['lnavdata_rnp', { name: BoeingLNavDataVars.RNP, type: SimVarValueType.Number }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }],
    ['lnavdata_total_distance', { name: BoeingLNavDataVars.TotalDistance, type: SimVarValueType.NM }],
    ['lnavdata_nominal_leg_index', { name: BoeingLNavDataVars.NominalLegIndex, type: SimVarValueType.Number }],
    ['lnavdata_tracked_leg_end_distance', { name: BoeingLNavDataVars.TrackedLegEndDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance_direct', { name: BoeingLNavDataVars.DestinationDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_destination_runway_distance_direct', { name: BoeingLNavDataVars.DestinationRunwayDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_faf', { name: BoeingLNavDataVars.FafDistance, type: SimVarValueType.NM }]
]);

/** The state of the altitude alerter. */
var AltAlertState;
(function (AltAlertState) {
    /** Disabled Mode */
    AltAlertState[AltAlertState["DISABLED"] = 0] = "DISABLED";
    /** Armed Mode. */
    AltAlertState[AltAlertState["ARMED"] = 1] = "ARMED";
    /** Within 900 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_900"] = 2] = "WITHIN_900";
    /** Within 300 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_300"] = 3] = "WITHIN_300";
    /** Within 200 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_200"] = 4] = "WITHIN_200";
    /** Captured the preselected altitude. */
    AltAlertState[AltAlertState["CAPTURED"] = 5] = "CAPTURED";
    /** Outside of the 200ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_200"] = 6] = "DEVIATION_200";
    /** Outside of the 300ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_300"] = 7] = "DEVIATION_300";
    /** Outside of the 900ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_900"] = 8] = "DEVIATION_900";
})(AltAlertState || (AltAlertState = {}));
/** Navigation sources for lateral and vertical guidance */
var NavigationSource;
(function (NavigationSource) {
    NavigationSource[NavigationSource["NONE"] = 0] = "NONE";
    /** FMC/non-precision source i.e. LNAV or VNAV */
    NavigationSource[NavigationSource["NPS"] = 1] = "NPS";
    NavigationSource[NavigationSource["IAN"] = 2] = "IAN";
    NavigationSource[NavigationSource["ILS"] = 3] = "ILS";
    NavigationSource[NavigationSource["GLS"] = 4] = "GLS";
})(NavigationSource || (NavigationSource = {}));
/** Approach frequency tuning mode for the ILS radio */
var ApproachTuningMode;
(function (ApproachTuningMode) {
    ApproachTuningMode[ApproachTuningMode["Park"] = 0] = "Park";
    ApproachTuningMode[ApproachTuningMode["ParkTuned"] = 1] = "ParkTuned";
    ApproachTuningMode[ApproachTuningMode["Autotuned"] = 2] = "Autotuned";
    ApproachTuningMode[ApproachTuningMode["ManuallyTuned"] = 3] = "ManuallyTuned";
})(ApproachTuningMode || (ApproachTuningMode = {}));
var VorTuningMode;
(function (VorTuningMode) {
    /** The FMC isn't currently tuning a VOR */
    VorTuningMode[VorTuningMode["None"] = 0] = "None";
    /** The FMC is tuning the VOR manually entered on the CDU by the pilots */
    VorTuningMode[VorTuningMode["ManuallyTuned"] = 1] = "ManuallyTuned";
    /** The FMC is tuning a VOR required by the current procedure */
    VorTuningMode[VorTuningMode["ProcedureTuned"] = 2] = "ProcedureTuned";
    /** The FMC is tuning a VOR that features as a waypoint on the current route */
    VorTuningMode[VorTuningMode["RouteTuned"] = 3] = "RouteTuned";
    /** The FMC is tuning a suitable nearby VOR */
    VorTuningMode[VorTuningMode["AutoTuned"] = 4] = "AutoTuned";
})(VorTuningMode || (VorTuningMode = {}));
var AutolandCapability;
(function (AutolandCapability) {
    AutolandCapability[AutolandCapability["None"] = 0] = "None";
    AutolandCapability[AutolandCapability["FailPassive"] = 1] = "FailPassive";
    AutolandCapability[AutolandCapability["FailOperational"] = 2] = "FailOperational";
})(AutolandCapability || (AutolandCapability = {}));

var FmsHEvent;
(function (FmsHEvent) {
    FmsHEvent["UPPER_INC"] = "UpperKnobInc";
    FmsHEvent["UPPER_DEC"] = "UpperKnobDec";
    FmsHEvent["LOWER_INC"] = "LowerKnobInc";
    FmsHEvent["LOWER_DEC"] = "LowerKnobDec";
    FmsHEvent["MENU"] = "Menu";
    FmsHEvent["ENT"] = "Enter";
    FmsHEvent["CLR"] = "Clr";
    FmsHEvent["DIRECTTO"] = "DirectTo";
    FmsHEvent["UPPER_PUSH"] = "UpperKnobPush";
    FmsHEvent["FPL"] = "FPL";
    FmsHEvent["PROC"] = "Proc";
    FmsHEvent["RANGE_INC"] = "RangeInc";
    FmsHEvent["RANGE_DEC"] = "RangeDec";
    FmsHEvent["JOYSTICK_PUSH"] = "JoystickPush";
    FmsHEvent["JOYSTICK_LEFT"] = "JoystickLeft";
    FmsHEvent["JOYSTICK_UP"] = "JoystickUp";
    FmsHEvent["JOYSTICK_RIGHT"] = "JoystickRight";
    FmsHEvent["JOYSTICK_DOWN"] = "JoystickDown";
    FmsHEvent["CLR_LONG"] = "ClrLong";
})(FmsHEvent || (FmsHEvent = {}));
/**
 * A component that forms the base of the Boeing UI control system.
 */
class B787UiControl extends HardwareUiControl {
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_INC:
                if (this.props.innerKnobScroll) {
                    return this.scroll('forward');
                }
                break;
            case FmsHEvent.UPPER_DEC:
                if (this.props.innerKnobScroll) {
                    return this.scroll('backward');
                }
                break;
            case FmsHEvent.LOWER_INC:
                return this.scroll('forward');
            case FmsHEvent.LOWER_DEC:
                return this.scroll('backward');
        }
        return this.triggerEvent(evt, this);
    }
    /**
     * Handles FMS upper knob increase events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onUpperKnobInc(source) {
        return this.props.onUpperKnobInc ? this.props.onUpperKnobInc(source) : false;
    }
    /**
     * Handles FMS upper knob decrease events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onUpperKnobDec(source) {
        return this.props.onUpperKnobDec ? this.props.onUpperKnobDec(source) : false;
    }
    /**
     * Handles FMS lower knob increase events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onLowerKnobInc(source) {
        return this.props.onLowerKnobInc ? this.props.onLowerKnobInc(source) : false;
    }
    /**
     * Handles FMS lower knob decrease events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onLowerKnobDec(source) {
        return this.props.onLowerKnobDec ? this.props.onLowerKnobDec(source) : false;
    }
    /**
     * Handles FMS upper knob push events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onUpperKnobPush(source) {
        return this.props.onUpperKnobPush ? this.props.onUpperKnobPush(source) : false;
    }
    /**
     * Handles MENU button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onMenu(source) {
        return this.props.onMenu ? this.props.onMenu(source) : false;
    }
    /**
     * Handles ENTER button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onEnter(source) {
        return this.props.onEnter ? this.props.onEnter(source) : false;
    }
    /**
     * Handles CLR button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onClr(source) {
        return this.props.onClr ? this.props.onClr(source) : false;
    }
    /**
     * Handles CLR button long press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onClrLong(source) {
        return this.props.onClrLong ? this.props.onClrLong(source) : false;
    }
    /**
     * Handles DRCT button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onDirectTo(source) {
        return this.props.onDirectTo ? this.props.onDirectTo(source) : false;
    }
    /**
     * Handles FPL button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onFPL(source) {
        return this.props.onFPL ? this.props.onFPL(source) : false;
    }
    /**
     * Handles PROC button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onProc(source) {
        return this.props.onProc ? this.props.onProc(source) : false;
    }
    /**
     * Handles range joystick increase events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onRangeInc(source) {
        return this.props.onRangeInc ? this.props.onRangeInc(source) : false;
    }
    /**
     * Handles range joystick decrease events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onRangeDec(source) {
        return this.props.onRangeDec ? this.props.onRangeDec(source) : false;
    }
    /**
     * Handles range joystick push events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickPush(source) {
        return this.props.onJoystickPush ? this.props.onJoystickPush(source) : false;
    }
    /**
     * Handles range joystick left deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickLeft(source) {
        return this.props.onJoystickLeft ? this.props.onJoystickLeft(source) : false;
    }
    /**
     * Handles range joystick up deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickUp(source) {
        return this.props.onJoystickUp ? this.props.onJoystickUp(source) : false;
    }
    /**
     * Handles range joystick right deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickRight(source) {
        return this.props.onJoystickRight ? this.props.onJoystickRight(source) : false;
    }
    /**
     * Handles range joystick down deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickDown(source) {
        return this.props.onJoystickDown ? this.props.onJoystickDown(source) : false;
    }
}
/**
 * A component that holds lists of BoeingUiControls.
 */
class BoeingUiControlList extends HardwareUiControlList {
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_INC:
                if (this.props.innerKnobScroll) {
                    return this.scroll('forward');
                }
                break;
            case FmsHEvent.UPPER_DEC:
                if (this.props.innerKnobScroll) {
                    return this.scroll('backward');
                }
                break;
            case FmsHEvent.LOWER_INC:
                return this.scroll('forward');
            case FmsHEvent.LOWER_DEC:
                return this.scroll('backward');
        }
        return this.triggerEvent(evt, this);
    }
    /**
     * Handles FMS upper knob increase events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onUpperKnobInc(source) {
        return this.props.onUpperKnobInc ? this.props.onUpperKnobInc(source) : false;
    }
    /**
     * Handles FMS upper knob decrease events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onUpperKnobDec(source) {
        return this.props.onUpperKnobDec ? this.props.onUpperKnobDec(source) : false;
    }
    /**
     * Handles FMS lower knob increase events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onLowerKnobInc(source) {
        return this.props.onLowerKnobInc ? this.props.onLowerKnobInc(source) : false;
    }
    /**
     * Handles FMS lower knob decrease events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onLowerKnobDec(source) {
        return this.props.onLowerKnobDec ? this.props.onLowerKnobDec(source) : false;
    }
    /**
     * Handles FMS upper knob push events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onUpperKnobPush(source) {
        return this.props.onUpperKnobPush ? this.props.onUpperKnobPush(source) : false;
    }
    /**
     * Handles MENU button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onMenu(source) {
        return this.props.onMenu ? this.props.onMenu(source) : false;
    }
    /**
     * Handles ENTER button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onEnter(source) {
        return this.props.onEnter ? this.props.onEnter(source) : false;
    }
    /**
     * Handles CLR button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onClr(source) {
        return this.props.onClr ? this.props.onClr(source) : false;
    }
    /**
     * Handles CLR button long press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onClrLong(source) {
        return this.props.onClrLong ? this.props.onClrLong(source) : false;
    }
    /**
     * Handles DRCT button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onDirectTo(source) {
        return this.props.onDirectTo ? this.props.onDirectTo(source) : false;
    }
    /**
     * Handles FPL button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onFPL(source) {
        return this.props.onFPL ? this.props.onFPL(source) : false;
    }
    /**
     * Handles PROC button press events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onProc(source) {
        return this.props.onProc ? this.props.onProc(source) : false;
    }
    /**
     * Handles range joystick increase events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onRangeInc(source) {
        return this.props.onRangeInc ? this.props.onRangeInc(source) : false;
    }
    /**
     * Handles range joystick decrease events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onRangeDec(source) {
        return this.props.onRangeDec ? this.props.onRangeDec(source) : false;
    }
    /**
     * Handles range joystick push events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickPush(source) {
        return this.props.onJoystickPush ? this.props.onJoystickPush(source) : false;
    }
    /**
     * Handles range joystick left deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickLeft(source) {
        return this.props.onJoystickLeft ? this.props.onJoystickLeft(source) : false;
    }
    /**
     * Handles range joystick up deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickUp(source) {
        return this.props.onJoystickUp ? this.props.onJoystickUp(source) : false;
    }
    /**
     * Handles range joystick right deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickRight(source) {
        return this.props.onJoystickRight ? this.props.onJoystickRight(source) : false;
    }
    /**
     * Handles range joystick down deflection events.
     * @param source The source of the event.
     * @returns Whether the event was handled.
     */
    onJoystickDown(source) {
        return this.props.onJoystickDown ? this.props.onJoystickDown(source) : false;
    }
    /** @inheritdoc */
    renderScrollbar() {
        return (FSComponent.buildComponent("div", null));
    }
}

// TODO consider getting limits from game vars
// add game var to get slat angles for each handle position => no config needed?
/**
 *
 */
class FlapComputer {
    /**
     * Constructor a new FlapComputer
     * @param bus Event bus
     * @param config Flap Computer configuration
     */
    constructor(bus, config) {
        this.bus = bus;
        this.flapsLeftAngle = ConsumerSubject.create(null, 0);
        this.flapsRightAngle = ConsumerSubject.create(null, 0);
        this.slatsLeftAngle = ConsumerSubject.create(null, 0);
        this.slatsRightAngle = ConsumerSubject.create(null, 0);
        /** total gross weight in lbs */
        this.grossWeight = ConsumerSubject.create(null, 0);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.flapInterpolatedPosition = Subject.create(0);
        this.flapInterpolatedLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapLimitPosition = Subject.create(0);
        this.flapLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapManeuverSpeed = Subject.create(0);
        this.holdingSpeed = Subject.create(0);
        this.needUpdate = true;
        this.flapPositionConfig = [...config.flap_positions].sort((a, b) => a.flapAngle === b.flapAngle ? a.slatAngle - b.slatAngle : a.flapAngle - b.flapAngle);
        this.flapSpeedLimitLookup = new LerpLookupTable(this.flapPositionConfig.filter((c) => isFinite(c.speedLimit)).map((c) => [c.speedLimit, c.label]));
        this.speedData = config.speed_data;
        const pub = this.bus.getPublisher();
        this.flapInterpolatedPosition.sub((pos) => pub.pub('flap_computer_interpolated_position', pos));
        this.flapInterpolatedLimitSpeed.sub((pos) => pub.pub('flap_computer_interpolated_limit_speed', pos));
        this.flapLimitPosition.sub((pos) => pub.pub('flap_computer_limit_position', pos));
        this.flapLimitSpeed.sub((speed) => pub.pub('flap_computer_limit_speed', speed));
        this.flapManeuverSpeed.sub((speed) => pub.pub('flap_computer_maneuver_speed', speed));
        this.holdingSpeed.sub((speed) => pub.pub('flap_computer_holding_speed', speed));
        this.listenToEvents();
    }
    /** Update the flap setting from the flap and slat angles */
    updateFlapPosition() {
        if (!this.needUpdate) {
            return;
        }
        this.needUpdate = false;
        // we consider the highest out of the two sides
        const actualFlapAngle = Math.max(this.flapsLeftAngle.get(), this.flapsRightAngle.get());
        const actualSlatAngle = Math.max(this.slatsLeftAngle.get(), this.slatsRightAngle.get());
        // find the flap position used for speed limit calculation (increments just after passing each position)
        let flapLimitIndex = this.flapPositionConfig.findIndex((p) => actualFlapAngle <= p.flapAngle + FlapComputer.ANGLE_TOLERANCE);
        const firstFlapPos = this.flapPositionConfig[flapLimitIndex];
        for (; flapLimitIndex < this.flapPositionConfig.length - 1; flapLimitIndex++) {
            const nextLimitPos = this.flapPositionConfig[flapLimitIndex + 1];
            if (nextLimitPos.flapAngle !== firstFlapPos.flapAngle) {
                break;
            }
            const limitPos = this.flapPositionConfig[flapLimitIndex];
            if (actualSlatAngle <= limitPos.slatAngle + FlapComputer.ANGLE_TOLERANCE) {
                break;
            }
        }
        const flapLimitPosition = this.flapPositionConfig[flapLimitIndex];
        this.flapLimitPosition.set(flapLimitPosition.label);
        this.flapLimitSpeed.set(isFinite(flapLimitPosition.speedLimit) ? flapLimitPosition.speedLimit : -1);
        this.flapManeuverSpeed.set(this.speedData.getFlapManeuverSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        this.holdingSpeed.set(this.speedData.getHoldingSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        // interpolate a position for display on the EICAS
        let interpolatedLabel = 0;
        // if we're clean, no need for interpolation
        if (flapLimitIndex > 0) {
            // choose the next index (lower flap position/angle)
            const nextLowerFlapPosition = this.flapPositionConfig[flapLimitIndex - 1];
            let k;
            if ((flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle) < FlapComputer.ANGLE_TOLERANCE) {
                // flap position doesn't change... interpolate slat angle
                k = (flapLimitPosition.slatAngle - actualSlatAngle) / (flapLimitPosition.slatAngle - nextLowerFlapPosition.slatAngle);
            }
            else {
                k = (flapLimitPosition.flapAngle - actualFlapAngle) / (flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle);
            }
            interpolatedLabel = MathUtils.clamp(Avionics.Utils.lerpAngle(flapLimitPosition.label, nextLowerFlapPosition.label, k), nextLowerFlapPosition.label, flapLimitPosition.label);
        }
        this.flapInterpolatedPosition.set(interpolatedLabel);
        if (interpolatedLabel > 0) {
            this.flapInterpolatedLimitSpeed.set(this.flapSpeedLimitLookup.get(interpolatedLabel));
        }
        else {
            this.flapInterpolatedLimitSpeed.set(-1);
        }
    }
    /** Setup event listeners */
    listenToEvents() {
        const sub = this.bus.getSubscriber();
        this.flapsLeftAngle.setConsumer(sub.on('flaps_left_angle').withPrecision(2));
        this.flapsRightAngle.setConsumer(sub.on('flaps_right_angle').withPrecision(2));
        this.slatsLeftAngle.setConsumer(sub.on('slats_left_angle').withPrecision(2));
        this.slatsRightAngle.setConsumer(sub.on('slats_right_angle').withPrecision(2));
        this.grossWeight.setConsumer(sub.on('total_weight').withPrecision(-3));
        this.pressureAlt.setConsumer(sub.on('pressure_alt').withPrecision(-3));
        sub.on('realTime').atFrequency(5).handle(this.updateFlapPosition.bind(this));
        MappedSubject.create(() => this.needUpdate = true, this.flapsLeftAngle, this.flapsRightAngle, this.slatsLeftAngle, this.slatsRightAngle, this.grossWeight, this.pressureAlt);
    }
}
FlapComputer.ANGLE_TOLERANCE = 0.25;

/**
 * FMC Simvar Definitions.
 */
var FmcSimVars;
(function (FmcSimVars) {
    /** FMC Exec State. */
    FmcSimVars["FmcExecActive"] = "L:FMC_EXEC_ACTIVE";
})(FmcSimVars || (FmcSimVars = {}));
/** A publisher to poll and publish FMC simvars. */
class FmcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a FmcSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(FmcSimVarPublisher.simvars, bus);
    }
}
FmcSimVarPublisher.simvars = new Map([
    ['fmcExecActive', { name: FmcSimVars.FmcExecActive, type: SimVarValueType.Number }]
]);

/**
 * Standard Boeing 787-10 names for backplane instruments and publishers.
 */
var InstrumentBackplaneNames;
(function (InstrumentBackplaneNames) {
    InstrumentBackplaneNames["Adc"] = "Adc";
    InstrumentBackplaneNames["Ahrs"] = "Ahrs";
    InstrumentBackplaneNames["Alert"] = "Alert";
    InstrumentBackplaneNames["Autopilot"] = "Autopilot";
    InstrumentBackplaneNames["AutopilotRadioNav"] = "AutopilotRadioNav";
    InstrumentBackplaneNames["B78Apu"] = "B78Apu";
    InstrumentBackplaneNames["B78Door"] = "B78Door";
    InstrumentBackplaneNames["B78Gear"] = "B78Gear";
    InstrumentBackplaneNames["B78Hydraulics"] = "B78Hydraulics";
    InstrumentBackplaneNames["Base"] = "Base";
    InstrumentBackplaneNames["BoeingAutopilot"] = "BoeingAutopilot";
    InstrumentBackplaneNames["Brakes"] = "Brakes";
    InstrumentBackplaneNames["Clock"] = "Clock";
    InstrumentBackplaneNames["ControlSurfaces"] = "ControlSurfaces";
    InstrumentBackplaneNames["CockpitVars"] = "CockpitVars";
    InstrumentBackplaneNames["Eis"] = "Eis";
    InstrumentBackplaneNames["Electrical"] = "Electrical";
    InstrumentBackplaneNames["Engine"] = "Engine";
    InstrumentBackplaneNames["Fadec"] = "Fadec";
    InstrumentBackplaneNames["FuelSystem"] = "FuelSystem";
    InstrumentBackplaneNames["FuelTotalizer"] = "FuelTotalizer";
    InstrumentBackplaneNames["Gnss"] = "Gnss";
    InstrumentBackplaneNames["HEvents"] = "HEvents";
    InstrumentBackplaneNames["Hydraulics"] = "Hydraulics";
    InstrumentBackplaneNames["LNav"] = "LNav";
    InstrumentBackplaneNames["LNavData"] = "LNavData";
    InstrumentBackplaneNames["Minimums"] = "Minimums";
    InstrumentBackplaneNames["NavCom"] = "NavCom";
    InstrumentBackplaneNames["NavEvents"] = "NavEvents";
    InstrumentBackplaneNames["NavProc"] = "NavProc";
    InstrumentBackplaneNames["Pressurization"] = "Pressurization";
    InstrumentBackplaneNames["SpeedLimit"] = "SpeedLimit";
    InstrumentBackplaneNames["Sound"] = "Sound";
    InstrumentBackplaneNames["Timer"] = "Timer";
    InstrumentBackplaneNames["Traffic"] = "Traffic";
    InstrumentBackplaneNames["VNav"] = "VNav";
    InstrumentBackplaneNames["BoeingVNav"] = "BoeingVNav";
    InstrumentBackplaneNames["WeightFuel"] = "WeightFuel";
    InstrumentBackplaneNames["Xpdr"] = "Xpdr";
    InstrumentBackplaneNames["WeightAndBalance"] = "WeightAndBalance";
    InstrumentBackplaneNames["Units"] = "Units";
})(InstrumentBackplaneNames || (InstrumentBackplaneNames = {}));

/**
 * A Garmin marker beacon receiver system.
 */
class MarkerBeaconSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a marker beacon system.
     * @param index The index of the marker beacon system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `marker_state_${index}`);
        const radioAltTopic = `marker_mkr_bcn_state_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's marker beacon state data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `marker_mkr_bcn_state_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.beaconStateSub = this.bus.getSubscriber().on('marker_beacon_state').handle(val => {
            this.publisher.pub(topic, val);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.beaconStateSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.beaconStateSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

/** The Boeing FADEC LVars. */
const BoeingFadecLVars = {
    FADEC_IDLE_N1: 'L:WT_FADEC_IDLE_N1',
    FADEC_IDLE_N2: 'L:WT_FADEC_IDLE_N2',
    FADEC_REF_N1: 'L:WT_FADEC_REF_N1',
    FADEC_TGT_N1: 'L:WT_FADEC_TGT_N1',
    FADEC_REF_TPR: 'L:WT_FADEC_REF_TPR',
    FADEC_TGT_TPR: 'L:WT_FADEC_TGT_TPR',
    FADEC_CLB_N1: 'L:WT_FADEC_CLB_N1',
    FADEC_CRU_N1: 'L:WT_FADEC_CRU_N1',
    FADEC_N1_RED: 'L:WT_FADEC_N1_RED',
    FADEC_N1_AMBER: 'L:WT_FADEC_N1_AMBER',
    FADEC_N2_RED: 'L:WT_FADEC_N2_RED',
    FADEC_N2_AMBER: 'L:WT_FADEC_N2_AMBER',
    FADEC_EGT_START_LIMIT: 'L:WT_FADEC_EGT_START_LIMIT',
    FADEC_EGT_AMBER: 'L:WT_FADEC_EGT_AMBER',
    FADEC_EGT_RED: 'L:WT_FADEC_EGT_RED',
    FADEC_OIL_TEMP_LOW_RED: 'L:WT_FADEC_OIL_TEMP_LOW_RED',
    FADEC_OIL_TEMP_LOW_AMBER: 'L:WT_FADEC_OIL_TEMP_LOW_AMBER',
    FADEC_OIL_TEMP_HIGH_AMBER: 'L:WT_FADEC_OIL_TEMP_HIGH_AMBER',
    FADEC_ENG_START_STATE: 'L:WT_FADEC_ENG_START_STATE',
};

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * FADEC modes for the Boeings.
 */
var BoeingFadecModes;
(function (BoeingFadecModes) {
    /** Engine not running. */
    BoeingFadecModes["STOP"] = "STOP";
    /** Engine start. */
    BoeingFadecModes["START"] = "START";
    /** Max Takeoff thrust. */
    BoeingFadecModes["NORMAL"] = "NORMAL";
    /** TO-1 Derated Takeoff thrust. */
    BoeingFadecModes["ENGINE_OUT"] = "ENGINE_OUT";
    /** Takeoff thrust scale while on the ground. */
    BoeingFadecModes["GROUND"] = "GROUND";
    /** Reverse thrust. */
    BoeingFadecModes["TR"] = "T/R";
    /** Default undefined state. */
    BoeingFadecModes["UNDEF"] = "UNDEF";
})(BoeingFadecModes || (BoeingFadecModes = {}));
/**
 * The possible boeing engine start states.
 */
var BoeingEngineStartState;
(function (BoeingEngineStartState) {
    // Leave this as the default number values so it can be set to an LVar.
    BoeingEngineStartState[BoeingEngineStartState["STOPPED"] = 0] = "STOPPED";
    BoeingEngineStartState[BoeingEngineStartState["AUTOSTART"] = 1] = "AUTOSTART";
    BoeingEngineStartState[BoeingEngineStartState["RUNNING"] = 2] = "RUNNING";
})(BoeingEngineStartState || (BoeingEngineStartState = {}));

/** A publisher that publishes Citation Longitude FADEC simvar events. */
class BoeingFadecPublisher extends SimVarPublisher {
    /**
     * Creates an instance of the CJ4FadecPublisher.
     * @param bus The event bus to use with this instance.
     * @param engineCount The number of engines on the plane
     */
    constructor(bus, engineCount) {
        const simvars = new Map();
        // eslint-disable-next-line jsdoc/require-jsdoc
        const indexedSimVars = {
            'fadec_idle_n1': { name: BoeingFadecLVars.FADEC_IDLE_N1, type: SimVarValueType.Percent },
            'fadec_idle_n2': { name: BoeingFadecLVars.FADEC_IDLE_N2, type: SimVarValueType.Percent },
            'fadec_ref_n1': { name: BoeingFadecLVars.FADEC_REF_N1, type: SimVarValueType.Percent },
            'fadec_target_n1': { name: BoeingFadecLVars.FADEC_TGT_N1, type: SimVarValueType.Percent },
            'fadec_ref_tpr': { name: BoeingFadecLVars.FADEC_REF_TPR, type: SimVarValueType.Percent },
            'fadec_target_tpr': { name: BoeingFadecLVars.FADEC_TGT_TPR, type: SimVarValueType.Percent },
            'fadec_clb_n1': { name: BoeingFadecLVars.FADEC_CLB_N1, type: SimVarValueType.Percent },
            'fadec_cru_n1': { name: BoeingFadecLVars.FADEC_CRU_N1, type: SimVarValueType.Percent },
            'fadec_n1_redline': { name: BoeingFadecLVars.FADEC_N1_RED, type: SimVarValueType.Percent },
            'fadec_n1_amberline': { name: BoeingFadecLVars.FADEC_N1_AMBER, type: SimVarValueType.Percent },
            'fadec_n2_redline': { name: BoeingFadecLVars.FADEC_N2_RED, type: SimVarValueType.Percent },
            'fadec_n2_amberline': { name: BoeingFadecLVars.FADEC_N2_AMBER, type: SimVarValueType.Percent },
            'fadec_egt_startline': { name: BoeingFadecLVars.FADEC_EGT_START_LIMIT, type: SimVarValueType.Celsius },
            'fadec_egt_amberline': { name: BoeingFadecLVars.FADEC_EGT_AMBER, type: SimVarValueType.Celsius },
            'fadec_egt_redline': { name: BoeingFadecLVars.FADEC_EGT_RED, type: SimVarValueType.Celsius },
            'fadec_oil_temp_low_redline': { name: BoeingFadecLVars.FADEC_OIL_TEMP_LOW_RED, type: SimVarValueType.Celsius },
            'fadec_oil_temp_low_amberline': { name: BoeingFadecLVars.FADEC_OIL_TEMP_LOW_AMBER, type: SimVarValueType.Celsius },
            'fadec_oil_temp_high_amberline': { name: BoeingFadecLVars.FADEC_OIL_TEMP_HIGH_AMBER, type: SimVarValueType.Celsius },
            'fadec_eng_start_state': { name: BoeingFadecLVars.FADEC_ENG_START_STATE, type: SimVarValueType.Number },
        };
        for (let i = 1; i <= engineCount; i++) {
            for (const [topic, simvar] of Object.entries(indexedSimVars)) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}_${i}`,
                    type: simvar.type,
                });
            }
        }
        super(simvars, bus);
    }
}

const SHORT_END_LLA_FORMAT_REGEX = /^([NS])(\d{2})(\d{2})([WE])(?:\/(\w{1,5}))?$/;
const SHORT_MID_LLA_FORMAT_REGEX = /^([NS])(\d{2})([WE])(\d{2})(?:\/(\w{1,5}))?$/;
const LONG_LLA_FORMAT_REGEX = /^([NS])(\d{2}(?:\d{1,2}(?:\.\d{1,2})?)?)\s*([WE])(\d{3}(?:\d{1,2}(?:\.\d{1,2})?)?)(?:\/(\w{1,5}))?$/;
/**
 * Utilities for parsing coordinates in the WT21 supported formats
 */
class BoeingCoordinatesUtils {
    /**
     * Parses a string according to the LAT LONG format
     *
     * @param str             the string to parse
     * @param acceptShortForm whether to accept the short (XYYZUU/XYYUUZ) formats
     *
     * @returns a {@link LatLongInterface} object if a valid PBPB definition and `null` otherwise
     */
    static parseLatLong(str, acceptShortForm = true) {
        if (acceptShortForm) {
            const shortEndMatch = SHORT_END_LLA_FORMAT_REGEX.exec(str);
            if (shortEndMatch) {
                const latDir = shortEndMatch[1];
                const latNum = shortEndMatch[2];
                const lonNum = shortEndMatch[3];
                const lonDir = shortEndMatch[4];
                const parsedLat = this.parseLatitude(latDir, latNum);
                const parsedLon = this.parseLongitude(lonDir, lonNum);
                if (!parsedLat || !parsedLon) {
                    return null;
                }
                const lla = { lat: parsedLat, long: parsedLon };
                let ident = shortEndMatch[5];
                if (!ident) {
                    ident = `${latDir}${latNum}${lonNum}${lonDir}`;
                }
                return { lla, ident };
            }
            const shortMidMatch = SHORT_MID_LLA_FORMAT_REGEX.exec(str);
            if (shortMidMatch) {
                const latDir = shortMidMatch[1];
                const latNum = shortMidMatch[2];
                const lonDir = shortMidMatch[3];
                const lonNum = shortMidMatch[4];
                const parsedLat = this.parseLatitude(latDir, latNum);
                const parsedLon = this.parseLongitude(lonDir, `1${lonNum}`);
                if (!parsedLat || !parsedLon) {
                    return null;
                }
                const lla = { lat: parsedLat, long: parsedLon };
                let ident = shortMidMatch[5];
                if (!ident) {
                    ident = `${latDir}${latNum}${lonDir}${lonNum}`;
                }
                return { lla, ident };
            }
        }
        const fullMatch = LONG_LLA_FORMAT_REGEX.exec(str);
        if (!fullMatch) {
            return null;
        }
        const latDir = fullMatch[1];
        const latNum = fullMatch[2];
        const lonDir = fullMatch[3];
        const lonNum = fullMatch[4];
        const parsedLat = this.parseLatitude(latDir, latNum);
        const parsedLon = this.parseLongitude(lonDir, lonNum);
        if (!parsedLat || !parsedLon) {
            return null;
        }
        const lla = { lat: parsedLat, long: parsedLon };
        const ident = fullMatch[5];
        return {
            lla,
            ident: ident !== null && ident !== void 0 ? ident : undefined,
        };
    }
    /**
     * Parses a latitude string
     *
     * @param dirStr the N or S string part
     * @param numStr the numerical string part
     *
     * @returns the latitude in degrees
     */
    static parseLatitude(dirStr, numStr) {
        let lat;
        const splitLatNum = numStr.split('.');
        const latLeft = splitLatNum[0];
        const latRight = splitLatNum[1];
        // Parse latitude degrees + minutes
        if (latLeft.length > 2) {
            const deg = parseInt(latLeft.substring(0, 2));
            const min = parseInt(latLeft.substring(2));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lat = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lat = parseInt(latLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (latRight) {
            const secs = parseFloat(`0.${latRight}`);
            const add = secs / 60;
            lat += add;
        }
        // If direction is S, negate latitude
        if (dirStr === 'S') {
            lat *= -1;
        }
        if (Math.abs(lat) > 90) {
            return null;
        }
        return lat;
    }
    /**
     * Parses a longitude string
     *
     * @param dirStr the W or E string part
     * @param numStr the numerical string part
     *
     * @returns the longitude in degrees
     */
    static parseLongitude(dirStr, numStr) {
        let lon;
        const splitLonNum = numStr.split('.');
        const lonLeft = splitLonNum[0];
        const lonRight = splitLonNum[1];
        // Parse longitude degrees + minutes
        if (lonLeft.length > 3) {
            const deg = parseInt(lonLeft.substring(0, 3));
            const min = parseInt(lonLeft.substring(3));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lon = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lon = parseInt(lonLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (lonRight) {
            const secs = parseFloat(`0.${lonRight}`);
            const add = secs / 60;
            lon += add;
        }
        // If direction is W, negate longitude
        if (dirStr === 'W') {
            lon *= -1;
        }
        if (Math.abs(lon) > 180) {
            return null;
        }
        return lon;
    }
}

/** Example match would be: `DEN270/22.5` */
const PBD_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
/** Example match would be: `DEN090/DVV180` */
const PBPB_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\w+)(\d{3}(?:\.\d)?)(?:\/(\w+))?$/;
const ATO_REGEX = /^(\w+)\/([+-]?\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
// This should technically be only TF, but that doesn't make much sense and seems like a mistake
const ATO_VALID_PREVIOUS_LEG_TYPES = [LegType.CF, LegType.DF, LegType.IF, LegType.TF, LegType.RF];
const ATO_VALID_NEXT_LEG_TYPES = [LegType.IF, LegType.TF];
/**
 * Error that can occur when creating an ATO waypoint
 */
var AlongTrackOffsetError;
(function (AlongTrackOffsetError) {
    AlongTrackOffsetError[AlongTrackOffsetError["NotAvailable"] = 0] = "NotAvailable";
    AlongTrackOffsetError[AlongTrackOffsetError["DistanceTooLarge"] = 1] = "DistanceTooLarge";
})(AlongTrackOffsetError || (AlongTrackOffsetError = {}));
/**
 * Utilities for Boeing pilot defined waypoints
 */
class BoeingPilotWaypointUtils {
    /**
     * Returns whether the limit number of pilot defined waypoints is reached
     *
     * @param facilities the existing user facilities
     *
     * @returns a boolean
     */
    static isLimitReached(facilities) {
        return facilities.length >= 50; // TODO 50 for RTE 1, 50 for RTE 2
    }
    /**
     * Returns the next available auto-generated name, given existing user facilities and an ident
     *
     * @param facilities the existing user facilities
     * @param ident      the ident of the facility
     *
     * @returns a string to be used as an ident for a user facility
     */
    static nextAutoGeneratedName(facilities, ident) {
        let suffix = 1;
        for (const facility of facilities) {
            const facIdent = ICAO.getIdent(facility.icao);
            if (facIdent.match(`${ident.substring(0, 3)}\\d\\d`)) {
                suffix++;
            }
        }
        return `${ident.substring(0, 3)}${suffix.toString().padStart(2, '0')}`;
    }
    /**
     * Returns the name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(0).padStart(2, '0');
        const longitudeSign = coordinates.lon > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.lon).toFixed(0).padStart(3, '0');
        return `${latitudeSign}${latitudeStr}${longitudeSign}${longitudeStr}`;
    }
    /**
     * Returns the internal name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongInternalIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(3);
        const longitudeSign = coordinates.long > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.long).toFixed(3);
        return `${latitudeSign}${latitudeStr}|${longitudeSign}${longitudeStr}`;
    }
    /**
     * Converts a scratchpad entry to a {@link UserFacility} if applicable
     *
     * @param fms                  the {@link BoeingFms} instance
     * @param selectWptFromIdent   the function called to select a facility
     * @param scratchpadContents   the scratchpad contents
     * @param targetGlobalLegIndex the target global leg index, if applicable
     *
     * @returns a user facility, or null if none is parsed
     */
    static async createFromScratchpadEntry(fms, selectWptFromIdent, scratchpadContents, targetGlobalLegIndex) {
        var _a, _b, _c, _d, _e;
        const pbdMatch = BoeingPilotWaypointUtils.parsePlaceBearingDistance(scratchpadContents);
        if (pbdMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facility = await selectWptFromIdent(pbdMatch.placeIdent, fms.ppos);
            if (facility) {
                const ident = (_a = pbdMatch.newIdent) !== null && _a !== void 0 ? _a : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facility.icao));
                const usrFacility = UserFacilityUtils.createFromRadialDistance(`U      ${ident}`, facility, pbdMatch.bearing, pbdMatch.distance);
                return [usrFacility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const pbpbMatch = BoeingPilotWaypointUtils.parsePlaceBearingPlaceBearing(scratchpadContents);
        if (pbpbMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facilityA = await selectWptFromIdent(pbpbMatch.placeAIdent, fms.ppos);
            const facilityB = await selectWptFromIdent(pbpbMatch.placeBIdent, fms.ppos);
            if (facilityA && facilityB) {
                const ident = (_b = pbpbMatch.newIdent) !== null && _b !== void 0 ? _b : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facilityA.icao));
                const facility = UserFacilityUtils.createFromRadialRadial(`U      ${ident}`, facilityA, pbpbMatch.bearingA, facilityB, pbpbMatch.bearingB);
                if (!facility) {
                    return Promise.reject('NO INTERSECTION');
                }
                return [facility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const atoMatch = BoeingPilotWaypointUtils.parseAlongTrackOffset(scratchpadContents);
        if (atoMatch) {
            if (targetGlobalLegIndex === undefined) {
                throw new Error('Along-track offset can only be created by createFromScratchpadEntry is a target global leg index is specified');
            }
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const plan = fms.getPlanForFmcRender();
            const lnavActiveLegIndex = SimVar.GetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number);
            const lnavActiveLegDistanceAlong = SimVar.GetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM);
            const result = await BoeingPilotWaypointUtils.createAlongTrackOffset(fms.facLoader, plan, targetGlobalLegIndex, lnavActiveLegIndex, lnavActiveLegDistanceAlong, atoMatch.distance);
            if (!Array.isArray(result)) {
                if (result === AlongTrackOffsetError.DistanceTooLarge) {
                    return Promise.reject('DISTANCE TOO LARGE');
                }
                else {
                    return Promise.reject('ALONG TRK WPT N/A');
                }
            }
            const [usrPos, insertAfter] = result;
            const leg = plan.getLeg(targetGlobalLegIndex);
            const ident = (_c = atoMatch.newIdent) !== null && _c !== void 0 ? _c : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, (_d = leg.name) !== null && _d !== void 0 ? _d : 'USR');
            return [UserFacilityUtils.createFromLatLon(`U      ${ident}`, usrPos.lat, usrPos.lon), insertAfter];
        }
        const coordinatesMatch = BoeingCoordinatesUtils.parseLatLong(scratchpadContents);
        if (coordinatesMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
            // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
            // needed - in BoeingFmsUtils.buildBoeingLegName, we extract the values to reconstruct the short name
            const ident = (_e = coordinatesMatch.ident) !== null && _e !== void 0 ? _e : BoeingPilotWaypointUtils.latLongInternalIdent(coordinatesMatch.lla);
            return [UserFacilityUtils.createFromLatLon(`ULL    ${ident}`, coordinatesMatch.lla.lat, coordinatesMatch.lla.long), false];
        }
        return null;
    }
    /**
     * Parses a string according to the PB/D format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingDistanceInput} object if a valid PBD definition and `null` otherwise
     */
    static parsePlaceBearingDistance(str) {
        const match = str.match(PBD_REGEX);
        if (!match) {
            return null;
        }
        const bearing = parseFloat(match[2]);
        if (bearing < 0 || bearing > 360) {
            return null;
        }
        return {
            placeIdent: match[1],
            bearing,
            distance: parseFloat(match[3]),
            newIdent: match[4],
        };
    }
    /**
     * Parses a string according to the PB/PB format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingPlaceBearingInput} object if a valid PBPB definition and `null` otherwise
     */
    static parsePlaceBearingPlaceBearing(str) {
        const match = str.match(PBPB_REGEX);
        if (!match) {
            return null;
        }
        const bearingA = parseFloat(match[2]);
        const bearingB = parseFloat(match[4]);
        if (bearingA < 0 || bearingA > 360 || bearingA < 0 || bearingB > 360) {
            return null;
        }
        return {
            placeAIdent: match[1],
            bearingA,
            placeBIdent: match[3],
            bearingB,
            newIdent: match[5],
        };
    }
    /**
     * Parses a string according to the along-track offset format
     *
     * @param str the string to parse
     *
     * @returns a {@link AlongTrackOffsetInput} object if a valid ATO definition and `null` otherwise
     */
    static parseAlongTrackOffset(str) {
        const match = str.match(ATO_REGEX);
        if (!match) {
            return null;
        }
        return {
            placeIdent: match[1],
            distance: parseFloat(match[2]),
            newIdent: match[3],
        };
    }
    /**
     * Creates an along-track offset position with input data
     *
     * @param facLoader                  the facility loader
     * @param plan                       the flight plan the ATO is being created from
     * @param globalLegIndex             the global leg index in the plan the ATO is being created from (WT21: LSK position)
     * @param lnavActiveLegIndex         the active lnav leg index (not nominal)
     * @param lnavDistanceAlongActiveLeg the distance flown along the active lnav leg
     * @param distance                   the distance input
     *
     * @returns a {@link GeoPoint}
     */
    static async createAlongTrackOffset(facLoader, plan, globalLegIndex, lnavActiveLegIndex, lnavDistanceAlongActiveLeg, distance) {
        const planLeg = plan.tryGetLeg(globalLegIndex);
        if (planLeg) {
            const distanceNegative = distance < 0;
            // Check for the previous leg type being valid if the distance is negative
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    if (!ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType)) {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
                else {
                    return AlongTrackOffsetError.NotAvailable;
                }
            }
            let fixIcao1 = undefined;
            let fixIcao2 = undefined;
            let facility1 = undefined;
            let facility2 = undefined;
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    const legType = planLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType) && ATO_VALID_NEXT_LEG_TYPES.includes(legType)) {
                        let maxDistance = planLeg.calculated ? UnitType.NMILE.convertFrom(planLeg.calculated.distance, UnitType.METER) : -1;
                        if (lnavActiveLegIndex === globalLegIndex) {
                            maxDistance -= lnavDistanceAlongActiveLeg;
                            maxDistance = Math.max(0, maxDistance);
                        }
                        if (Math.abs(distance) < maxDistance) {
                            fixIcao1 = previousPlanLeg.leg.fixIcao;
                            fixIcao2 = planLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                }
            }
            else {
                const nextPlanLeg = plan.tryGetLeg(globalLegIndex + 1);
                if (nextPlanLeg) {
                    const legType = planLeg.leg.type;
                    const nextLegType = nextPlanLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(legType) && ATO_VALID_NEXT_LEG_TYPES.includes(nextLegType)) {
                        const maxDistance = nextPlanLeg.calculated ? UnitType.NMILE.convertFrom(nextPlanLeg.calculated.distance, UnitType.METER) : -1;
                        let minDistance = 0;
                        if (lnavActiveLegIndex === globalLegIndex + 1) {
                            minDistance = lnavDistanceAlongActiveLeg;
                        }
                        if (distance > minDistance && distance < maxDistance) {
                            fixIcao1 = planLeg.leg.fixIcao;
                            fixIcao2 = nextPlanLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                    else {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
            }
            if (fixIcao1 && fixIcao1 !== ICAO.emptyIcao && fixIcao2 && fixIcao2 !== ICAO.emptyIcao) {
                facility1 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao1), fixIcao1);
                facility2 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao2), fixIcao2);
                if (facility1 && facility2) {
                    const circle = GeoCircle.createGreatCircle(facility1, facility2);
                    const offsetOut = new Float64Array(3);
                    circle.offsetDistanceAlong(distanceNegative ? facility2 : facility1, UnitType.GA_RADIAN.convertFrom(distance, UnitType.NMILE), offsetOut);
                    const geoPoint = new GeoPoint(0, 0);
                    geoPoint.setFromCartesian(offsetOut);
                    return [geoPoint, !distanceNegative];
                }
            }
        }
        return AlongTrackOffsetError.NotAvailable;
    }
}

/**
 * Utility Methods for the Boeing FMS.
 */
class BoeingFmsUtils {
    /**
     * Gets the active segment in the Lateral Flight Plan.
     * @param plan The Lateral Flight Plan.
     * @returns The Active Flight Plan Segment or undefined.
     */
    static getActiveSegment(plan) {
        if (plan.length > 0 && plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            return plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
        }
        return undefined;
    }
    /**
     * Checks whether a leg exists in a segment with the specified ICAO and, if so, returns the leg index of that leg.
     * @param segment The segment to check for the icao.
     * @param icao The ICAO to check for in the segment.
     * @returns The segment leg index of the leg with the matching icao, or -1.
     */
    static findIcaoInSegment(segment, icao) {
        if (icao !== undefined) {
            for (let l = 0; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                if (leg !== undefined && leg.leg !== undefined && leg.leg.fixIcao && leg.leg.fixIcao === icao) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        return FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: isOriginRunway
                ? oneWayRunway.elevation
                : oneWayRunway.elevation + UnitType.METER.convertFrom(50, UnitType.FOOT) // Arrival runway leg altitude should be 50 feet above threshold
        });
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param facRepo is a facility repository in which to store the created faf leg facility
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param finalLegVpa is the vertical path angle selected for the final approach, or undefined if not applicable.
     * @returns an approach procedure.
     */
    static buildVisualApproach(facRepo, airport, runway, finalLegDistance, finalLegVpa) {
        const runwayVec = GeoPoint.sphericalToCartesian(runway.latitude, runway.longitude, BoeingFmsUtils.vec3Cache[0]);
        const approachPath = BoeingFmsUtils.geoCircleCache[0].setAsGreatCircle(runwayVec, runway.course);
        const runwayCode = RunwayUtils.getRunwayCode(runway.direction);
        const runwayLetter = RunwayUtils.getDesignatorLetter(runway.runwayDesignator).padStart(1, ' ');
        const fafLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(-finalLegDistance, UnitType.GA_RADIAN), BoeingFmsUtils.geoPointCache[0]);
        const runwayIdent = RunwayUtils.getRunwayNameString(runway.direction, runway.runwayDesignator);
        const finalLegIdent = `${finalLegVpa !== undefined ? 'FA' : 'RX'}${runwayIdent}`;
        const icao = `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`;
        // Add facility to facRepo
        const fafFacility = UserFacilityUtils.createFromLatLon(icao, fafLatLon.lat, fafLatLon.lon);
        facRepo.add(fafFacility);
        const fafLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: icao,
            course: MagVar.trueToMagnetic(approachPath.bearingAt(fafLatLon), fafLatLon),
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + (Math.tan(UnitType.DEGREE.convertTo(finalLegVpa !== null && finalLegVpa !== void 0 ? finalLegVpa : 3, UnitType.RADIAN)) * UnitType.NMILE.convertTo(finalLegDistance, UnitType.METER)),
        });
        const runwayLeg = BoeingFmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.verticalAngle = finalLegVpa !== undefined ? 360 - Math.abs(finalLegVpa) : 0;
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        return {
            name: `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [],
            finalLegs: finalLegs,
            missedLegs: [],
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approachType The approach type.
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a tunable localizer.
     * @param approachType The approach type.
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets the procedure index and transition index from procedure details of the lateral plan based on segment type.
     * @param segmentType The segment type.
     * @param lateralPlan The lateral flight plan.
     * @returns an array of procedureIndex, transitionIndex.
     */
    static getProcedureIndexAndTransitionIndexFromSegmentType(segmentType, lateralPlan) {
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return [lateralPlan.procedureDetails.departureIndex, lateralPlan.procedureDetails.departureTransitionIndex];
            case FlightPlanSegmentType.Arrival:
                return [lateralPlan.procedureDetails.arrivalIndex, lateralPlan.procedureDetails.arrivalTransitionIndex];
            case FlightPlanSegmentType.Approach:
                return [lateralPlan.procedureDetails.approachIndex, lateralPlan.procedureDetails.approachTransitionIndex];
        }
        return [-1, -1];
    }
    /**
     * Combiner method to get a procedure name as a string for the FPLN Page.
     * @param segmentType The segment type.
     * @param facility The facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The transition index.
     * @returns the name as a string.
     */
    static getProcedureNameAsString(segmentType, facility, procedureIndex, transitionIndex) {
        if (facility === undefined) {
            return 'NO FACILITY';
        }
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return this.getDepartureNameAsString(facility, procedureIndex);
            case FlightPlanSegmentType.Arrival:
                if (transitionIndex !== undefined) {
                    return this.getArrivalNameAsString(facility, procedureIndex, transitionIndex);
                }
                break;
            case FlightPlanSegmentType.Approach:
                if (procedureIndex === -1 && transitionIndex === -1) {
                    // must be visual
                    return 'VISUAL';
                }
                else if (transitionIndex !== undefined) {
                    return this.getApproachNameAsString(facility, procedureIndex, transitionIndex);
                }
        }
        return 'PROC NAME ERROR';
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @returns The name of the departure procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getDepartureNameAsString(facility, procedureIndex) {
        // let name = '';
        const departure = facility.departures[procedureIndex];
        // if (runway) {
        //   name += `RW${runway.designation}.`;
        // }
        // const transition = departure.enRouteTransitions[transitionIndex];
        // if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        // } else if (departure.commonLegs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        // } else {
        //   name += `${departure.name}`;
        // }
        return `${departure.name}`;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param facility The airport to which the arrival belongs.
     * @param procedureIndex An arrival procedure index.
     * @param transitionIndex The index of the arrival enroute transition.
     * @returns The name of the arrival procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getArrivalNameAsString(facility, procedureIndex, transitionIndex) {
        const arrival = facility.arrivals[procedureIndex];
        // TODO We may need to add back the transition name
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            return `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            return `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        // else if (arrival.commonLegs.length > 0) {
        //   name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival?.name}`;
        // }
        // if (runway) {
        //   name += `.RW${runway.designation}`;
        // }
        // return `${arrival?.name}`;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @param transitionIndex The transition index.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc, transitionIndex) {
        let type;
        // let subtype: string | undefined;
        // let rnavType: string | undefined;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNV';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'BCS';
                break; // no idea if this is the real format
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        const transition = transitionIndex > -1 && proc.transitions.length > 0 ? proc.transitions[transitionIndex].name
            : transitionIndex === 0 && proc.transitions.length === 0 && proc.finalLegs.length > 0 ? ICAO.getIdent(proc.finalLegs[0].fixIcao)
                : 'VECTORS';
        return {
            type: type,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            transition: transition
        };
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    /**
     * Utility method that gets an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param facility The Facility.
     * @param procedureIndex The approach index.
     * @param transitionIndex The index of the approach transition.
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(facility, procedureIndex, transitionIndex) {
        const approach = facility.approaches[procedureIndex];
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, transitionIndex);
        let name = parts.transition ? parts.transition + '.' + parts.type : parts.type;
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        // parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Get the name of an approach in the format used on the EFIS
     * @param facilityOrApproach Either an airport facility (if combined with a procedure as the second arg) or an approach procedure
     * @param procedureIndex Index of the desired approach if the first arg is an airport facility
     * @returns formatted approach name ready for EFIS display
     */
    static getApproachNameAsEfisString(facilityOrApproach, procedureIndex) {
        var _a, _b;
        const approach = 'airportPrivateType' in facilityOrApproach ? facilityOrApproach.approaches[procedureIndex !== null && procedureIndex !== void 0 ? procedureIndex : -1] : facilityOrApproach;
        if (!approach) {
            return '???';
        }
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, -1);
        if (parts.runway) {
            return `${parts.type}${(_a = parts.suffix) !== null && _a !== void 0 ? _a : ''} ${parts.runway}`;
        }
        else {
            return `${parts.type}${(_b = parts.suffix) !== null && _b !== void 0 ? _b : ''}`;
        }
    }
    /**
     * Checks whether an approach has a primary NAV frequency based on its type. Only approaches of the following types
     * have primary NAV frequencies: ILS, LOC (BC), LDA, SDF, VOR(DME).
     * @param approach The approach to check.
     * @returns Whether the specified approach has a primary NAV frequency based on its type.
     */
    static approachHasNavFrequency(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
     * which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLeg(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return undefined;
        }
        for (leg of plan.legs(true, plan.getLegIndexFromLeg(leg))) {
            if (!BitFlags.isAny(leg.flags, WT21LegDefinitionFlags.DirectTo | WT21LegDefinitionFlags.VectorsToFinal)) {
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
     * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return -1;
        }
        let index = plan.getLegIndexFromLeg(leg);
        for (leg of plan.legs(true, index)) {
            if (!BitFlags.isAny(leg.flags, WT21LegDefinitionFlags.DirectTo | WT21LegDefinitionFlags.VectorsToFinal)) {
                return index;
            }
            index--;
        }
        return -1;
    }
    /**
     * Gets an altitude for display with padding, Flight Level Handling
     * @param altitudeMeters the altitude IN METERS to evaluate
     * @param transitionAltitudeFeet the transition altitude IN FEET to evaluate
     * @returns A display string
     */
    static parseAltitudeForDisplay(altitudeMeters, transitionAltitudeFeet) {
        const altitudeFeet = Math.round(UnitType.METER.convertTo(altitudeMeters, UnitType.FOOT));
        transitionAltitudeFeet = Math.round(transitionAltitudeFeet);
        if (altitudeFeet >= transitionAltitudeFeet) {
            return 'FL' + (altitudeFeet / 100).toFixed(0).padStart(3, '0');
        }
        return altitudeFeet.toFixed(0).padStart(5, ' ');
    }
    /**
     * Checks if leg type is an "arc" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isArcLeg(legType) {
        return arcLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "heading to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return headingToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "hold at" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "hold at" leg type.
     */
    static isHoldAtLeg(legType) {
        return holdAtLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is an "to altitude" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return altitudeLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "course to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "course to" leg type.
     */
    static isCourseToLeg(legType) {
        return courseToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "discontinuity" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "discontinuity" leg type.
     */
    static isDiscontinuityLeg(legType) {
        return discontinuityLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "vectors" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "vectors" leg type.
     */
    static isVectorsLeg(legType) {
        return vectorsTypes.includes(legType);
    }
    /**
     * Gets the direct to magnetic course from the leg vectors.
     * @param leg The Leg Definition
     * @returns the magnetic course.
     */
    static getDirectToCourse(leg) {
        let course = 360;
        if (leg.leg.type === LegType.DF && leg.calculated !== undefined) {
            const vector = leg.calculated.flightPath[leg.calculated.flightPath.length - 1];
            if (vector !== undefined) {
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                // If it is a great circle, then it's basically the "straight" part of the path, so we want to get the bearing at the start,
                // otherwise it's the turn, so we want the bearing from the end of the turn.
                const point = circle.isGreatCircle()
                    ? BoeingFmsUtils.geoPointCache[0].set(vector.startLat, vector.startLon)
                    : BoeingFmsUtils.geoPointCache[0].set(vector.endLat, vector.endLon);
                course = circle.bearingAt(point, Math.PI);
                course = MagVar.trueToMagnetic(course, MagVar.get(point));
            }
        }
        else if (leg.leg.type === LegType.CF && leg.calculated !== undefined) {
            course = leg.leg.course;
        }
        return course;
    }
    /**
     * Checks for an airway at a leg and returns the airway or undefined
     * @param facLoader The facility loader.
     * @param icao The icao of the entry to check.
     * @param airwayName The airway to search for.
     * @returns The airway object or undefined
     */
    static async isAirwayAtLeg(facLoader, icao, airwayName) {
        const facility = await facLoader.getFacility(FacilityType.Intersection, icao);
        if (facility) {
            const matchedRoute = facility.routes.find((r) => r.name === airwayName);
            if (matchedRoute) {
                const airway = await facLoader.getAirway(matchedRoute.name, matchedRoute.type, icao);
                return airway;
            }
        }
        return undefined;
    }
    /**
     * Looks for an airway with name {@link airwayBName} crossing one of the fixes of airway {@link airwayA}
     *
     * @param facLoader the facility loader
     * @param airwayA the airway to look for intersections in
     * @param airwayBName the name of the second airway
     *
     * @returns a tuple of the found airway and the fix ICAO where the two airways cross
     */
    static async findAirwayCrossingAirway(facLoader, airwayA, airwayBName) {
        for (const fac of airwayA.waypoints) {
            const airwayBFacRoute = fac.routes.find((it) => it.name === airwayBName);
            if (airwayBFacRoute) {
                const airway = await facLoader.getAirway(airwayBFacRoute.name, airwayBFacRoute.type, fac.icao);
                return [airway, fac.icao];
            }
        }
    }
    /**
     * Checks for an airway exit at a given icao.
     * @param airway The Airway Object.
     * @param icao The icao of the entry to check.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static isLegValidAirwayExit(airway, icao) {
        return airway.waypoints.find((w) => w.icao === icao);
    }
    /**
     * Checks for an airway exit matching an input ident
     * @param airway The AirwayObject.
     * @param ident The Ident to search for.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static matchIdentToAirway(airway, ident) {
        return airway.waypoints.find((w) => ICAO.getIdent(w.icao) === ident);
    }
    /**
     * Checks whether a leg should appear on the Direct To Page based on leg type.
     * @param leg The FlightPlanLeg to evaluate.
     * @returns whether or not the leg should appear on the Direct To page.
     */
    static canLegBeSelectedOnDirectPage(leg) {
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
            case LegType.PI:
            case LegType.CI:
            case LegType.VI:
            case LegType.CR:
            case LegType.VR:
                return false;
            default:
                return true;
        }
    }
    /**
     * Checks whether a leg with a given type being active should cause LNAV to be auto unsuspended
     * @param legType the leg type
     * @returns a boolean
     */
    static canLegBeAutoUnsuspended(legType) {
        switch (legType) {
            case LegType.HM:
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * Builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildBoeingLegName(leg) {
        // Name for PPOS hold leg
        if (leg.fixIcao === ICAO.emptyIcao && BoeingFmsUtils.isHoldAtLeg(leg.type)) {
            return 'PPOS';
        }
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `(${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0).padEnd(5, ' ')})`;
            case LegType.FM:
            case LegType.VM:
                return 'VECTORS';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
            case LegType.PI:
                return '(INTC)';
            default:
                if (leg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(leg.fixIcao) === FacilityType.USR) {
                    const regionStr = ICAO.getRegionCode(leg.fixIcao);
                    // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
                    // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
                    // needed - here, we extract the values to reconstruct the short name
                    if (regionStr === 'LL') {
                        const ident = ICAO.getIdent(leg.fixIcao);
                        const [latStr, longStr] = ident.split('|');
                        const lat = parseFloat(latStr.replace('N', '').replace('S', '-'));
                        const long = parseFloat(longStr.replace('E', '').replace('W', '-'));
                        return BoeingPilotWaypointUtils.latLongIdent(BoeingFmsUtils.geoPointCache[1].set(lat, long));
                    }
                }
                return ICAO.getIdent(leg.fixIcao);
        }
    }
    /**
     * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
     * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
     * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
     * @param plan A flight plan.
     */
    static reconcileDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, WT21LegDefinitionFlags.DirectTo)) {
                    plan.directToData.segmentIndex = i;
                    plan.directToData.segmentLegIndex = j - 1;
                    return;
                }
            }
        }
        plan.directToData.segmentIndex = -1;
        plan.directToData.segmentLegIndex = -1;
    }
    /**
     * Removes all of a flight plan's Direct-To data, but from the DirectToData object and from any legs in the plan.
     * Scans the legs of the flight plan for Direct-To legs and removes them.
     * @param plan A flight plan.
     */
    static removeAllDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, WT21LegDefinitionFlags.DirectTo)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
        plan.setDirectToData(-1, true);
    }
    /**
     * Removes all of a flight plan's Displaced Active Legs,
     * which are flagged when a procedure is added and the active leg array is moved to enroute.
     * @param plan A flight plan.
     */
    static removeDisplacedActiveLegs(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, WT21LegDefinitionFlags.DisplacedActiveLeg)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
    }
    /**
     * Writes the calculated end coordinates of a leg to {@link out}, if the necessary calculated data exists
     *
     * @param leg the leg to find the end point for
     * @param out the {@link GeoPoint} to write the result to
     *
     * @returns whether anything was written
     */
    static writeLegCalculatedEndPoint(leg, out) {
        if (leg.calculated && leg.calculated.endLat && leg.calculated.endLon) {
            out.set(leg.calculated.endLat, leg.calculated.endLon);
            return true;
        }
        return false;
    }
    /**
     * Returns true if a leg is a vector of discontinuity.
     * @param leg The FlightPlanLeg
     * @returns Whether the leg is a vector of discontinuity
     */
    static isLegVectOrDisco(leg) {
        switch (leg.type) {
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return true;
            default:
                return false;
        }
    }
    /**
     * Returns hold legs in the flight plan. Used to determine and show appropriate HOLD pages.
     *
     * @param plan     the flight plan in question
     * @param inMissed whether to only include missed approach holds
     *
     * @returns the result
     */
    static getPlanHolds(plan, inMissed = false) {
        var _a;
        const holdLegs = [];
        for (const leg of plan.legs()) {
            const legSegment = (_a = plan.getSegmentFromLeg(leg)) === null || _a === void 0 ? void 0 : _a.segmentType;
            if (!inMissed && legSegment === FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (inMissed && legSegment !== FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (this.isHoldAtLeg(leg.leg.type)) {
                holdLegs.push(leg);
            }
        }
        return holdLegs;
    }
    /**
     * Returns the first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`.
     * @param plan The flight plan.
     * @param fixIcao The fix's ICAO.
     * @returns The first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`, or -1 if not found.
     * */
    static findHoldInPlan(plan, fixIcao) {
        let index = -1;
        for (const leg of plan.legs()) {
            if (leg.leg.type !== LegType.HM) {
                continue;
            }
            if (leg.leg.fixIcao === fixIcao) {
                index = plan.getLegIndexFromLeg(leg);
                break;
            }
        }
        return index;
    }
    /**
     * Calculates time in seconds to fly a certain distance at a ground speed
     *
     * @param distance distance to fly
     * @param groundSpeed GS to predict with
     *
     * @returns time in number of seconds
     */
    static estimateSecondsForDistance(distance, groundSpeed) {
        return (distance / groundSpeed) * 3600;
    }
    /**
     * Calculates distance flown for a number of seconds at a ground speed
     *
     * @param seconds time flown in number of seconds
     * @param groundSpeed GS to predict with
     *
     * @returns distance in nautical miles
     */
    static estimateDistanceForSeconds(seconds, groundSpeed) {
        return (seconds / 3600) * groundSpeed;
    }
    /**
     * Returns the index of the last non-missed approach leg in the flight plan
     *
     * @param plan the plan to use for lookup
     *
     * @returns array of index and ident, or undefined if no approach segment
     */
    static getLastNonMissedApproachLeg(plan) {
        if (plan.length === 0) {
            return -1;
        }
        let legIndex = plan.length - 1;
        while (BitFlags.isAll(plan.getLeg(legIndex).flags, LegDefinitionFlags.MissedApproach)) {
            legIndex--;
        }
        return legIndex;
    }
    /**
     * Returns the distance between the end of a leg before a discontinuity and the start of the leg after that discontinuity
     *
     * @param prevLeg the leg before the discontinuity
     * @param nextLeg the leg after the discontinuity
     *
     * @returns the great circle distance between the end of the previous leg and the start of the next leg, in metres
     */
    static distanceBetweenDiscontinuedLegs(prevLeg, nextLeg) {
        var _a, _b;
        let distance;
        if (prevLeg && nextLeg && ((_a = prevLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) && prevLeg.calculated.endLon && ((_b = nextLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLat) && nextLeg.calculated.endLon) {
            const term = new GeoPoint(prevLeg.calculated.endLat, prevLeg.calculated.endLon);
            const start = new GeoPoint(nextLeg.calculated.endLat, nextLeg.calculated.endLon);
            distance = UnitType.GA_RADIAN.convertTo(term.distance(start), UnitType.METER);
        }
        else {
            distance = 0;
        }
        return distance;
    }
    /**
     * Formats a facility frequency's type for display on the FMC
     *
     * @param frequency  the frequency
     * @param noneString (optional) the string to return when the type is "None"
     *
     * @returns a string
     */
    static formatFacilityFrequencyType(frequency, noneString = 'UNKNOWN') {
        switch (frequency.type) {
            case FacilityFrequencyType.ASOS:
                return 'ASOS';
            case FacilityFrequencyType.ATIS:
                return 'ATIS';
            case FacilityFrequencyType.AWOS:
                return 'AWOS';
            case FacilityFrequencyType.Approach:
                return 'APR';
            case FacilityFrequencyType.CPT:
            case FacilityFrequencyType.Clearance:
                return 'CLEARANCE';
            case FacilityFrequencyType.CTAF:
                return 'CTAF';
            case FacilityFrequencyType.Center:
                return 'CTR';
            case FacilityFrequencyType.Departure:
                return 'DEP';
            case FacilityFrequencyType.FSS:
                return 'FSS';
            case FacilityFrequencyType.GCO:
                return 'GCO';
            case FacilityFrequencyType.Ground:
                return 'GND';
            case FacilityFrequencyType.Multicom:
                return 'MULTICOM';
            case FacilityFrequencyType.Tower:
                return 'TWR';
            case FacilityFrequencyType.Unicom:
                return 'UNICOM';
            default:
                return noneString;
        }
    }
    /**
     * Formats a facility type (and, if applicable, VOR type) into a string
     *
     * Used on the SELECT DESIRED XXX page
     *
     * @param facility the facility
     *
     * @returns a string
     */
    static formatFacilityType(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            switch (facility.type) {
                default:
                case VorType.VOR:
                    return 'VOR';
                case VorType.VORDME:
                    return 'VORDME';
                case VorType.VORTAC:
                    return 'VORTAC';
                case VorType.TACAN:
                    return 'TACAN';
                case VorType.ILS:
                    return 'ILS';
                case VorType.DME:
                    return 'DME';
            }
        }
        else {
            switch (ICAO.getFacilityType(facility.icao)) {
                case FacilityType.Airport:
                    return 'APRT';
                case FacilityType.NDB:
                    return 'NDB';
                case FacilityType.Intersection:
                    return 'WAYPOINT';
                case FacilityType.RWY:
                    return 'RUNWAY';
                case FacilityType.USR:
                    return 'PILOT';
                case FacilityType.VIS:
                    return 'VISUAL';
                default:
                    return 'UNKNOWN';
            }
        }
    }
    /**
     * Returns the distance from PPOS to the end of a leg, given a lateral plan and a global leg index
     * @param lateralPlan the lateral plan
     * @param globalLegIndex the global leg index
     * @returns the distance, in metres
     */
    static getDistanceFromPposToLegEnd(lateralPlan, globalLegIndex) {
        var _a, _b;
        const legDistanceRemaining = SimVar.GetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM);
        const legDistanceRemainingMetres = UnitType.METER.convertFrom(legDistanceRemaining, UnitType.NMILE);
        const currentLeg = lateralPlan.getLeg(lateralPlan.activeLateralLeg);
        const targetLeg = lateralPlan.getLeg(globalLegIndex);
        if (currentLeg.calculated && targetLeg.calculated) {
            const cumulativeDistanceToCurrentLeg = (_a = currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTransitions;
            const cumulativeDistanceToTargetLeg = (_b = targetLeg.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions;
            const distanceBetweenLegs = cumulativeDistanceToTargetLeg - cumulativeDistanceToCurrentLeg;
            return legDistanceRemainingMetres + distanceBetweenLegs;
        }
        return undefined;
    }
    /**
     * Toggle assumed temp takeoff derate.
     * @param mode The takeoff thrust mode.
     * @returns The opposite derate mode of the passed fixed thrust mode.
     */
    static toggleAssumedTempDerate(mode) {
        switch (mode) {
            case TakeoffThrustMode.TO: return TakeoffThrustMode.DTO;
            case TakeoffThrustMode.TO1: return TakeoffThrustMode.DTO1;
            case TakeoffThrustMode.TO2: return TakeoffThrustMode.DTO2;
            case TakeoffThrustMode.DTO: return TakeoffThrustMode.TO;
            case TakeoffThrustMode.DTO1: return TakeoffThrustMode.TO1;
            case TakeoffThrustMode.DTO2: return TakeoffThrustMode.TO2;
        }
    }
    /**
     * Returns whether the passed takeoff thrust mode is an assumed temperature derate mode.
     * @param mode The takeoff thrust mode.
     * @returns Whether the passed takeoff thrust mode is an assumed temperature derate mode.
     */
    static thrustModeIsAssumedTemp(mode) {
        return (mode === TakeoffThrustMode.DTO ||
            mode === TakeoffThrustMode.DTO1 ||
            mode === TakeoffThrustMode.DTO2);
    }
    /**
     * Checks if two VHF frequencies are equal
     * @param frequencyA The first frequency to compare
     * @param frequencyB The second frequency to compare
     * @returns true if the frequencies are equal
     */
    static vhfFrequenciesEqual(frequencyA, frequencyB) {
        return Math.abs(frequencyA - frequencyB) < 0.0025;
    }
    /**
     * Check if a leg can contain wind data
     * @param legType Leg Type
     * @returns true if the leg is eligible for wind data
     */
    static legTypeCanHaveWind(legType) {
        switch (legType) {
            case LegType.AF:
            case LegType.CF:
            case LegType.DF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.IF:
            case LegType.RF:
            case LegType.TF:
                return true;
            default:
                return false;
        }
    }
}
BoeingFmsUtils.vec3Cache = [new Float64Array(3)];
BoeingFmsUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingFmsUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
BoeingFmsUtils.DTO_LEG_OFFSET = 3;
/**
 * Utility method to return a single RnavTypeFlag from multiple possible flags.
 * @param rnavTypeFlags The input RnavTypeFlags.
 * @returns A single RnavTypeFlag
 */
BoeingFmsUtils.getBestRnavType = ApproachUtils.getBestRnavType;
/**
 * Bitflags describing a leg definition specific to the WT21.
 *
 * FIXME we need this to be refactored into entirely separate flags, either higher in the bitfield or on another property entirely
 */
var WT21LegDefinitionFlags;
(function (WT21LegDefinitionFlags) {
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["None"] = 0] = "None";
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["DirectTo"] = 1] = "DirectTo";
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["MissedApproach"] = 2] = "MissedApproach";
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["Obs"] = 4] = "Obs";
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["VectorsToFinal"] = 8] = "VectorsToFinal";
    /**
     * A leg that was part of the active leg pair in a procedure when the procedure was removed,and was subsequently
     * moved to another segment in the plan.
     */
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["DisplacedActiveLeg"] = 536870912] = "DisplacedActiveLeg";
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["ProcedureLeg"] = 1073741824] = "ProcedureLeg";
    /**
     * Applied to the target leg of a direct to
     */
    WT21LegDefinitionFlags[WT21LegDefinitionFlags["DirectToTarget"] = -2147483648] = "DirectToTarget";
})(WT21LegDefinitionFlags || (WT21LegDefinitionFlags = {}));
/** Array of "arc" leg types. */
const arcLegTypes = [LegType.AF, LegType.RF];
/** Array of "heading to" leg types. */
const headingToLegTypes = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold at" leg types. */
const holdAtLegTypes = [LegType.HA, LegType.HF, LegType.HM];
/** Array of "to altitude" leg types. */
const altitudeLegTypes = [LegType.CA, LegType.FA, LegType.VA, LegType.HA];
/** Array of "course to" leg types. */
const courseToLegTypes = [LegType.CA, LegType.CF, LegType.CI];
/**
 * Array of "discontinuity" leg types
 */
const discontinuityLegTypes = [LegType.Discontinuity, LegType.ThruDiscontinuity];
/** Array of "vectors" leg types */
const vectorsTypes = [LegType.FM, LegType.VM];

/**
 * Sources of FMS-computed speed targets.
 */
var FmsSpeedTargetSource;
(function (FmsSpeedTargetSource) {
    /** No source. Used when FMS has no computed speed target. */
    FmsSpeedTargetSource["None"] = "None";
    /** Speed target is derived from aircraft configuration limits (flaps, gear, etc). */
    FmsSpeedTargetSource["Configuration"] = "Configuration";
    /** Speed target is derived from takeoff/go-around target */
    FmsSpeedTargetSource["ToGa"] = "ToGa";
    /** Speed target is derived from user-defined altitude speed limits (e.g. 250 knots below 10000 feet). */
    FmsSpeedTargetSource["Altitude"] = "Altitude";
    /** Speed target is derived from speed constraints in the flight plan. */
    FmsSpeedTargetSource["Constraint"] = "Constraint";
    /** Speed target is derived from VNAV climb schedule. */
    FmsSpeedTargetSource["ClimbSchedule"] = "ClimbSchedule";
    /** Speed target is derived from VNAV cruise. */
    FmsSpeedTargetSource["CruiseSchedule"] = "CruiseSchedule";
    /** Speed target is derived from VNAV descent schedule. */
    FmsSpeedTargetSource["DescentSchedule"] = "DescentSchedule";
})(FmsSpeedTargetSource || (FmsSpeedTargetSource = {}));

const TARGET_IAS_COMMANDED_TOLERANCE = 1;
const TARGET_MACH_COMMANDED_TOLERANCE = 0.01;
var BoeingAltitudeEntryType;
(function (BoeingAltitudeEntryType) {
    BoeingAltitudeEntryType["At"] = "At";
    BoeingAltitudeEntryType["Above"] = "Above";
    BoeingAltitudeEntryType["Below"] = "Below";
    BoeingAltitudeEntryType["Step"] = "Step";
})(BoeingAltitudeEntryType || (BoeingAltitudeEntryType = {}));
/**
 * Utilities for input/output of vertical leg data
 */
class BoeingVerticalIOUtils {
    /**
     * Generates vertical display data for a leg
     *
     * @param lateralLeg the lateral flight plan leg
     * @param verticalLeg the Boeing vertical leg
     * @param transitionAltitude the currently used transition altitude
     * @param transitionLevel the currently used transition level
     * @param commandedFmcAlt the currently commanded FMC altitude
     * @param commandedFmcSpeed the currently commanded FMC speed
     * @param commandedFmcSpeedIsMach whether the currently commanded FMC speed is a Mach value
     * @param commandedFmcSpeedSource the currently commanded FMC speed source
     *
     * @returns a {@link BoeingVerticalDisplayData}
     */
    static getDisplayDataForLeg(lateralLeg, verticalLeg, transitionAltitude, transitionLevel, commandedFmcAlt, commandedFmcSpeed, commandedFmcSpeedIsMach, commandedFmcSpeedSource) {
        const lastVector = verticalLeg.vectors[verticalLeg.vectors.length - 1];
        let speed = undefined;
        let speedIsMach = false;
        let speedIsPredicted = false;
        if (lateralLeg.verticalData.speed > 0) {
            speed = lateralLeg.verticalData.speed;
            speedIsMach = lateralLeg.verticalData.speedUnit === SpeedUnit.MACH;
            speedIsPredicted = lateralLeg.verticalData.speedDesc === SpeedRestrictionType.Unused;
        }
        else if (lastVector) {
            const predictedCas = lastVector.endCas;
            const predictedMach = lastVector.endMach;
            const targetCas = lastVector.targetCas;
            const targetMach = lastVector.targetMach;
            // TODO get pressure from vector
            const pressure = AeroMath.isaPressure(lastVector.endAltitude);
            const machCasEquivalent = AeroMath.machToCas(targetMach, pressure);
            const targetMachCasEquivalentKnots = UnitType.KNOT.convertFrom(machCasEquivalent, UnitType.MPS);
            if (targetMachCasEquivalentKnots < targetCas) {
                speed = predictedMach;
                speedIsMach = true;
            }
            else {
                speed = predictedCas;
                speedIsMach = false;
            }
            speedIsPredicted = true;
        }
        // TODO ECON/LRC/RTA
        let speedIsCommanded = false;
        if (speed !== undefined && !speedIsPredicted && commandedFmcSpeedSource === FmsSpeedTargetSource.Constraint) {
            if (commandedFmcSpeedIsMach && speedIsMach) {
                const targetMachValid = commandedFmcSpeed > 0;
                if (targetMachValid && Math.abs(speed - commandedFmcSpeed) < TARGET_MACH_COMMANDED_TOLERANCE) {
                    speedIsCommanded = true;
                }
            }
            else if (!commandedFmcSpeedIsMach && !speedIsMach) {
                const targetIasValid = commandedFmcSpeed > 0;
                if (targetIasValid && Math.abs(speed - commandedFmcSpeed) < TARGET_IAS_COMMANDED_TOLERANCE) {
                    speedIsCommanded = true;
                }
            }
        }
        const altitudes = [];
        const altitudeSuffixes = [];
        const altitudesAreFlightLevels = [];
        let altitudesArePredicted = false;
        const phase = lateralLeg.verticalData.phase;
        const alt1Feet = UnitType.FOOT.convertFrom(lateralLeg.verticalData.altitude1, UnitType.METER);
        const alt2Feet = UnitType.FOOT.convertFrom(lateralLeg.verticalData.altitude2, UnitType.METER);
        switch (lateralLeg.verticalData.altDesc) {
            case AltitudeRestrictionType.At: {
                altitudes.push(alt1Feet);
                altitudeSuffixes.push(' ');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            }
            case AltitudeRestrictionType.AtOrAbove:
                altitudes.push(alt1Feet);
                altitudeSuffixes.push('A');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            case AltitudeRestrictionType.AtOrBelow:
                altitudes.push(alt1Feet);
                altitudeSuffixes.push('B');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            case AltitudeRestrictionType.Between:
                if (lateralLeg.verticalData.phase === VerticalFlightPhase.Climb) {
                    altitudes.push(alt2Feet);
                    altitudeSuffixes.push('A');
                    altitudesAreFlightLevels.push(alt2Feet > transitionAltitude);
                    altitudes.push(alt1Feet);
                    altitudeSuffixes.push('B');
                    altitudesAreFlightLevels.push(alt1Feet > transitionAltitude);
                }
                else {
                    altitudes.push(alt1Feet);
                    altitudeSuffixes.push('B');
                    altitudesAreFlightLevels.push(alt1Feet > transitionLevel);
                    altitudes.push(alt2Feet);
                    altitudeSuffixes.push('A');
                    altitudesAreFlightLevels.push(alt2Feet > transitionLevel);
                }
                break;
            case AltitudeRestrictionType.Unused: {
                if (lastVector) {
                    const endAltitudeFeet = UnitType.FOOT.convertFrom(lastVector.endAltitude, UnitType.METER);
                    altitudes.push(endAltitudeFeet);
                    altitudeSuffixes.push(' ');
                    altitudesAreFlightLevels.push(endAltitudeFeet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                    altitudesArePredicted = true;
                }
                break;
            }
        }
        const alt1WholeFeet = MathUtils.round(alt1Feet);
        const alt2WholeFeet = MathUtils.round(alt2Feet);
        const altitudeIsCommanded = alt2Feet
            ? Math.min(alt1WholeFeet, alt2WholeFeet) <= commandedFmcAlt && commandedFmcAlt <= Math.max(alt1WholeFeet, alt2WholeFeet)
            : alt1WholeFeet === commandedFmcAlt;
        // TODO step climbs
        return {
            speed,
            speedIsMach,
            speedIsPredicted,
            speedIsCommanded,
            altitudes,
            altitudeSuffixes,
            altitudesAreFlightLevels,
            altitudesArePredicted,
            altitudeIsCommanded,
        };
    }
    /**
     * Applies a parsed modification to vertical display data to a vertical data object
     *
     * @param verticalData the vertical data object to modify
     * @param modification the modification to apply
     */
    static applyDisplayModificationToVerticalData(verticalData, modification) {
        // Handle speed modification
        if (modification.setSpeed) {
            if (typeof modification.setSpeed === 'string') ;
            else {
                verticalData.speed = modification.setSpeed;
                verticalData.speedUnit = modification.setSpeedIsMach ? SpeedUnit.MACH : SpeedUnit.IAS;
                verticalData.speedDesc = SpeedRestrictionType.At;
            }
        }
        // Handle altitude modification
        if (modification.setAltitudes.length > 0) {
            const firstEntryType = modification.setAltitudeTypes[0];
            if (firstEntryType === BoeingAltitudeEntryType.Step) ;
            else if (firstEntryType === BoeingAltitudeEntryType.At) {
                verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                verticalData.altDesc = AltitudeRestrictionType.At;
            }
            else if (firstEntryType === BoeingAltitudeEntryType.Above) {
                const secondEntryType = modification.setAltitudeTypes[1];
                // We know this must be Below
                if (secondEntryType) {
                    verticalData.altitude2 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[1], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.Between;
                }
                else {
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.AtOrAbove;
                }
            }
            else if (firstEntryType === BoeingAltitudeEntryType.Below) {
                const secondEntryType = modification.setAltitudeTypes[1];
                // We know this must be Above
                if (secondEntryType) {
                    verticalData.altitude2 = UnitType.METER.convertFrom(modification.setAltitudes[1], UnitType.FOOT);
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.Between;
                }
                else {
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.AtOrBelow;
                }
            }
        }
    }
    /**
     * Renders vertical display data for copying into the scratchpad of an FMC
     *
     * @param data the vertical display data
     *
     * @returns a string
     */
    static renderDataForScratchpad(data) {
        let str = '';
        if (data.speed !== undefined) {
            if (typeof data.speed === 'string') {
                str += data.speed.toUpperCase();
            }
            else if (data.speedIsMach) {
                str += data.speed.toFixed(3).substring(1);
            }
            else {
                str += data.speed.toFixed(0);
            }
        }
        str += '/';
        if (data.altitudes.length > 0) {
            for (let i = 0; i < data.altitudes.length; i++) {
                const altitude = data.altitudes[i];
                const isFlightLevel = data.altitudesAreFlightLevels[i];
                if (isFlightLevel) {
                    str += `FL${(altitude / 100).toFixed(0)}`;
                }
                else {
                    str += altitude.toFixed(0);
                }
                const suffix = data.altitudeSuffixes[i];
                if (suffix !== ' ') {
                    str += suffix;
                }
            }
        }
        return str;
    }
}

//import { DebounceTimer, EventBus, Subject } from '@microsoft/msfs-sdk';
/** FMS Operating Phases of flight */
var FmsOperatingPhase;
(function (FmsOperatingPhase) {
    FmsOperatingPhase[FmsOperatingPhase["PREFLIGHT"] = 0] = "PREFLIGHT";
    FmsOperatingPhase[FmsOperatingPhase["TAKEOFF"] = 1] = "TAKEOFF";
    FmsOperatingPhase[FmsOperatingPhase["CLIMB"] = 2] = "CLIMB";
    FmsOperatingPhase[FmsOperatingPhase["CRUISE"] = 3] = "CRUISE";
    FmsOperatingPhase[FmsOperatingPhase["DESCENT"] = 4] = "DESCENT";
    FmsOperatingPhase[FmsOperatingPhase["APPROACH"] = 5] = "APPROACH";
    FmsOperatingPhase[FmsOperatingPhase["COMPLETE"] = 6] = "COMPLETE";
})(FmsOperatingPhase || (FmsOperatingPhase = {}));

const VNAV_ETA_CALCS_DEBOUNCE = 750;
var CurrentFmsSpeedMode;
(function (CurrentFmsSpeedMode) {
    CurrentFmsSpeedMode["ECON"] = "ECON";
    CurrentFmsSpeedMode["LIM_SPD"] = "LIM SPD";
    CurrentFmsSpeedMode["MCP_SPD"] = "MCP SPD";
    CurrentFmsSpeedMode["EO"] = "EO";
    CurrentFmsSpeedMode["CAS"] = "CAS";
    CurrentFmsSpeedMode["MACH"] = "MACH";
})(CurrentFmsSpeedMode || (CurrentFmsSpeedMode = {}));
/**
 * Data provider for various vnav related data for the FMS VNAV Pages.
 */
class BoeingFmsVNavDataProvider {
    /**
     * CTOR
     * @param bus The event bus
     * @param fms The BoeingFms
     */
    constructor(bus, fms) {
        this.bus = bus;
        this.fms = fms;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.simTimeValue = ConsumerValue.create(this.bus.getSubscriber().on('simTime'), -1);
        this.lateralLegIndex = ConsumerSubject.create(null, -1);
        // private readonly nominalLegIndex = ConsumerSubject.create(this.bus.getSubscriber<BoeingLNavDataEvents>()
        //   .on('lnavdata_nominal_leg_index'), -1);
        // private readonly distRemainingInLeg = ConsumerSubject.create(this.bus.getSubscriber<LNavEvents>()
        //   .on('lnav_vector_distance_remaining'), -1);
        // private readonly groundSpeed = ConsumerSubject.create(this.bus.getSubscriber<GNSSEvents>()
        //   .on('ground_speed'), -1);
        this.fmsTargetType = ConsumerSubject.create(null, FmsSpeedTargetSource.None);
        this.fmsTargetIsMach = ConsumerSubject.create(null, false);
        this.mcpSpeedActive = ConsumerSubject.create(null, false);
        this._distanceDest = ConsumerSubject.create(null, -1);
        this._distanceToc = ConsumerSubject.create(null, -1);
        this._distanceTod = ConsumerSubject.create(null, -1);
        this._distanceBod = ConsumerSubject.create(null, -1);
        this._tocLegIndex = ConsumerSubject.create(null, -1);
        this._todLegIndex = ConsumerSubject.create(null, -1);
        this._eodLegIndex = ConsumerSubject.create(null, -1);
        this._distanceTodLeg = ConsumerSubject.create(null, -1);
        this.distanceDest = this._distanceDest;
        this.distanceToc = this._distanceToc;
        this.distanceTod = this._distanceTod;
        this.distanceBod = this._distanceBod;
        this.tocLegIndex = this._tocLegIndex;
        this.todLegIndex = this._todLegIndex;
        this.bodLegIndex = this._eodLegIndex;
        this.distanceTodLeg = this._distanceTodLeg;
        this.commandedFmsAlt = ConsumerSubject.create(this.bus.getSubscriber()
            .on('vnav_next_constraint_altitude').whenChanged(), 0);
        this.speedSub = this.bus.getSubscriber();
        this.commandedFmsSpeedIas = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_ias'), -1);
        this.commandedFmsSpeedMach = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_mach'), -1);
        this.commandedFmsSpeedIsMach = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_is_mach'), false);
        this.commandedFmsSpeedSource = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_source'), FmsSpeedTargetSource.None);
        this._currentFmsClimbSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsClimbMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.ClimbSchedule:
                    if (fmsClimbMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                case FmsSpeedTargetSource.ToGa:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    return CurrentFmsSpeedMode.ECON;
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedClimbMode, this.fmsTargetIsMach);
        this.currentFmsClimbSpeedMode = this._currentFmsClimbSpeedMode;
        this._currentFmsDescentSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsDescentMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.DescentSchedule:
                    if (fmsDescentMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                case FmsSpeedTargetSource.ToGa:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    return CurrentFmsSpeedMode.ECON;
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedDescentMode, this.fmsTargetIsMach);
        this.currentFmsDescentSpeedMode = this._currentFmsDescentSpeedMode;
        this._currentFmsCruiseSpeedMode = MappedSubject.create((([speedIsMcp, fmsCruiseMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            else {
                switch (fmsCruiseMode) {
                    case SpeedMode.SEL:
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    case SpeedMode.LIM:
                        return CurrentFmsSpeedMode.LIM_SPD;
                    default:
                        return CurrentFmsSpeedMode.ECON;
                }
            }
        }), this.mcpSpeedActive, this.fms.activePerformancePlan.speedCruiseMode, this.fmsTargetIsMach);
        this.currentFmsCruiseSpeedMode = this._currentFmsCruiseSpeedMode;
        this._destinationPredictions = Subject.create(null);
        this.destinationPredictions = this._destinationPredictions;
        this._currentClimbConstraint = Subject.create(null);
        this.currentClimbConstraint = this._currentClimbConstraint;
        this._currentClimbConstraintLegDef = Subject.create(null);
        this.currentClimbConstraintLegDef = this._currentClimbConstraintLegDef;
        this._currentClimbConstraintDisplayData = Subject.create(null);
        this.currentClimbConstraintDisplayData = this._currentClimbConstraintDisplayData;
        this._currentDescentConstraint = Subject.create(null);
        this.currentDescentConstraint = this._currentDescentConstraint;
        this._currentDescentConstraintLegDef = Subject.create(null);
        this.currentDescentConstraintLegDef = this._currentDescentConstraintLegDef;
        this._currentDescentConstraintDisplayData = Subject.create(null);
        this.currentDescentConstraintDisplayData = this._currentDescentConstraintDisplayData;
        this.fmsOperatingPhaseEvents = this.bus.getSubscriber();
        this._fmsOperatingPhase = ConsumerSubject.create(this.fmsOperatingPhaseEvents.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.fmsOperatingPhase = this._fmsOperatingPhase;
        this.nextConstraintLegDef = MappedSubject.create(([climbConstraint, descentConstraint, phase]) => {
            return BoeingFmsVNavDataProvider.phasesBeforeCruise.includes(phase)
                ? climbConstraint
                : descentConstraint;
        }, this.currentClimbConstraintLegDef, this.currentDescentConstraintLegDef, this.fmsOperatingPhase);
        this._destAirportFacility = Subject.create(null);
        this.destAirportFacility = this._destAirportFacility;
        this.planChanged = false;
        this._tocEta = Subject.create(null);
        this._todEta = Subject.create(null);
        this._eodEta = Subject.create(null);
        this.tocEta = this._tocEta;
        this.todEta = this._todEta;
        this.eodEta = this._eodEta;
        this.etaTimer = new DebounceTimer();
        const fmsSpeedEventsEventSubscriber = bus.getSubscriber();
        this.fmsTargetType.setConsumer(fmsSpeedEventsEventSubscriber.on('fms_speed_computed_target_source'));
        this.fmsTargetIsMach.setConsumer(fmsSpeedEventsEventSubscriber.on('fms_speed_active_target_is_mach'));
        const vnavSub = bus.getSubscriber();
        this._distanceDest.setConsumer(vnavSub.on('lnavdata_destination_distance'));
        this._distanceToc.setConsumer(vnavSub.on('vnav_toc_distance'));
        this._distanceTod.setConsumer(vnavSub.on('vnav_tod_distance'));
        this._distanceBod.setConsumer(vnavSub.on('vnav_bod_distance'));
        this._tocLegIndex.setConsumer(vnavSub.on('vnav_toc_global_leg_index'));
        this._todLegIndex.setConsumer(vnavSub.on('vnav_tod_global_leg_index'));
        this._eodLegIndex.setConsumer(vnavSub.on('vnav_bod_global_leg_index'));
        this._distanceTodLeg.setConsumer(vnavSub.on('vnav_tod_leg_distance'));
        this.mcpSpeedActive.setConsumer(bus.getSubscriber().on('ap_selected_speed_is_manual'));
        this.lateralLegIndex.setConsumer(bus.getSubscriber().on('lnav_tracked_leg_index'));
        this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => {
            var _a;
            this._destinationPredictions.set((_a = this.fms.activeRoutePredictor.getDestinationPredictions()) !== null && _a !== void 0 ? _a : null);
            this._destinationPredictions.notify();
        });
        const fpSub = bus.getSubscriber();
        fpSub.on('fplLegChange').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplLoaded').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplCopied').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplOriginDestChanged').handle(({ planIndex, type, airport }) => {
            if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                switch (type) {
                    case OriginDestChangeType.DestinationAdded:
                        airport && this._destAirportFacility.set(airport);
                        break;
                    case OriginDestChangeType.DestinationRemoved:
                        this._destAirportFacility.set(null);
                        break;
                }
            }
        });
        this.lateralLegIndex.sub(() => {
            if (!this.fms.hasPrimaryFlightPlan()) {
                return;
            }
            this.onPlanChanged(BoeingFms.ACT_RTE_PLAN_INDEX);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, BoeingFms.ACT_RTE_PLAN_INDEX), VNAV_ETA_CALCS_DEBOUNCE);
        });
        MappedSubject.create(this.commandedFmsSpeedIas, this.commandedFmsSpeedMach, this.commandedFmsSpeedIsMach, this.commandedFmsSpeedSource, this.commandedFmsAlt).sub(() => {
            this.planChanged = true;
            this.setCurrentConstraint();
        });
        // Update the current constraints each time the path is recalculated, every three seconds
        vnavSub.on('vnav_path_calculated').handle((planIndex) => {
            this.setCurrentConstraint();
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        this.setCurrentConstraint();
        this.calculateEtasForPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Handler for flight plan changing
     *
     * @param planIndex the index of the flight plan
     */
    onPlanChanged(planIndex) {
        var _a;
        this.planChanged = true;
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            const plan = this.fms.getFlightPlan(planIndex);
            this._destAirportFacility.set((_a = plan.destinationAirport) !== null && _a !== void 0 ? _a : null);
        }
    }
    /**
     * Sets the current constraints shown by VNAV pages
     */
    setCurrentConstraint() {
        // Only do the lookup if the flight plan has changed since the last lookup
        if (this.planChanged && this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const lateralPlan = this.fms.getFlightPlan(this.fms.getPlanIndexForFmcPage());
            const verticalPlan = this.fms.verticalPathCalculator.getVerticalFlightPlan(this.fms.getPlanIndexForFmcPage());
            const climbConstraint = VNavUtils.getCurrentClimbConstraint(verticalPlan, this.lateralLegIndex.get());
            this._currentClimbConstraint.set(climbConstraint ? climbConstraint : null);
            this._currentClimbConstraintLegDef.set(climbConstraint ? lateralPlan.tryGetLeg(climbConstraint.index) : null);
            this._currentClimbConstraintDisplayData.set(climbConstraint ? this.getVerticalDisplayData(climbConstraint.index) : null);
            const descentConstraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, this.lateralLegIndex.get());
            this._currentDescentConstraint.set(descentConstraint ? descentConstraint : null);
            this._currentDescentConstraintLegDef.set(descentConstraint ? lateralPlan.tryGetLeg(descentConstraint.index) : null);
            this._currentDescentConstraintDisplayData.set(descentConstraint ? this.getVerticalDisplayData(descentConstraint.index) : null);
            this.planChanged = false;
        }
    }
    /**
     * Calculates display data for a constraint.
     * @param globalLegIndex The global leg index of the VNAV constraint.
     * @returns An object used for rendering constraint data.
     */
    getVerticalDisplayData(globalLegIndex) {
        const legDefinition = this.fms.getPlanForFmcRender().tryGetLeg(globalLegIndex);
        const verticalPath = this.fms.verticalPathCalculator.getVerticalFlightPath(this.fms.getPlanIndexForFmcPage());
        const verticalPathLeg = verticalPath.legs[globalLegIndex] ? verticalPath.legs[globalLegIndex] : undefined;
        if (legDefinition && verticalPathLeg) {
            const fmsCommandedSpeedValue = this.commandedFmsSpeedIsMach.get() ?
                this.commandedFmsSpeedMach.get() : this.commandedFmsSpeedIas.get();
            return BoeingVerticalIOUtils.getDisplayDataForLeg(legDefinition, verticalPathLeg, this.fms.activePerformancePlan.transitionAltitude.get(), this.fms.activePerformancePlan.transitionLevel.get(), this.commandedFmsAlt.get(), fmsCommandedSpeedValue, this.commandedFmsSpeedIsMach.get(), this.commandedFmsSpeedSource.get());
        }
        else {
            return null;
        }
    }
    /**
     * Calculates leg and T/D ETAs for a plan at a given index
     *
     * @param planIndex the index of the flight plan
     */
    calculateEtasForPlan(planIndex) {
        if (!this.fms.hasFlightPlan(planIndex)) {
            return;
        }
        const lateralPlan = this.fms.getFlightPlan(planIndex);
        const verticalPath = this.fms.verticalPathCalculator.getVerticalFlightPath(this.fms.getPlanIndexForFmcPage());
        const tocLegIndex = this.tocLegIndex.get();
        const todLegIndex = this.todLegIndex.get();
        const eodLegIndex = this.bodLegIndex.get();
        if (tocLegIndex === -1) {
            this._tocEta.set(null);
        }
        if (todLegIndex === -1) {
            this._todEta.set(null);
        }
        if (eodLegIndex === -1) {
            this._eodEta.set(null);
        }
        let timestampAccumulator = this.simTimeValue.get();
        const unixDayStartMs = this.simTimeValue.get() - (this.simTimeValue.get() % (1000 * 60 * 60 * 24));
        for (let i = 0; i < lateralPlan.length; i++) {
            const leg = lateralPlan.tryGetLeg(i);
            if (leg) {
                const matchingVerticalLeg = verticalPath.legs[i];
                if (matchingVerticalLeg) {
                    let verticalLegDurationMs;
                    if (matchingVerticalLeg.vectors.length > 0) {
                        verticalLegDurationMs = matchingVerticalLeg.simDuration * 1000;
                    }
                    else {
                        const previousLeg = lateralPlan.tryGetLeg(i - 1);
                        const nextLeg = lateralPlan.tryGetLeg(i + 1);
                        const nextLegMatchingVerticalLeg = verticalPath.legs[i + 1];
                        // This is a special case for handling a situation where an IF leg is not predicted due to it following a discontinuity.
                        // We need to calculate this so that the T/D ETA can be roughly figured out (it is displayed on the VNAV CRZ page)
                        // Once BoeingVerticalPathCalculator handles predicting through discontinuities, we can remove this.
                        // FIXME remove this once the above is done
                        if (previousLeg && nextLeg && nextLegMatchingVerticalLeg && nextLegMatchingVerticalLeg.vectors.length > 0) {
                            const legEndPointExists = BoeingFmsUtils.writeLegCalculatedEndPoint(leg, this.geoPointCache[0]);
                            if (leg.leg.type === LegType.IF && legEndPointExists && BoeingFmsUtils.isDiscontinuityLeg(previousLeg.leg.type)) {
                                const legBeforeDiscontinuity = lateralPlan.tryGetLeg(i - 2);
                                const legBeforeDiscontinuityEndPointExists = legBeforeDiscontinuity && BoeingFmsUtils.writeLegCalculatedEndPoint(legBeforeDiscontinuity, this.geoPointCache[1]);
                                if (legBeforeDiscontinuityEndPointExists) {
                                    const distanceInDiscontinuity = this.geoPointCache[0].distance(this.geoPointCache[1]);
                                    const distanceInDiscontinuityNm = UnitType.NMILE.convertFrom(distanceInDiscontinuity, UnitType.GA_RADIAN);
                                    const nextLegStartAltitude = nextLegMatchingVerticalLeg.vectors[0].startAltitude;
                                    const nextLegStartPressure = AeroMath.isaPressure(nextLegStartAltitude);
                                    const nextLegSimulatedStartCas = nextLegMatchingVerticalLeg.vectors[0].startCas;
                                    const nextLegSimulatedStartTas = AeroMath.casToTas(nextLegSimulatedStartCas, nextLegStartPressure, AeroMath.isaTemperature(nextLegStartAltitude));
                                    // FIXME when we have wind/temp plan, we can use the right pressure + find ground speed
                                    const timeInDiscontinuitySeconds = (distanceInDiscontinuityNm / nextLegSimulatedStartTas) * 3600;
                                    verticalLegDurationMs = timeInDiscontinuitySeconds * 1000;
                                }
                            }
                        }
                    }
                    // Accumulate time
                    if (verticalLegDurationMs !== undefined) {
                        if (i === lateralPlan.activeLateralLeg) {
                            const activeLegPredictions = this.fms.activeRoutePredictor.getPredictionsForLeg(i);
                            if (activeLegPredictions) {
                                timestampAccumulator = activeLegPredictions.estimatedTimeOfArrival * 1000;
                            }
                        }
                        else if (i > lateralPlan.activeLateralLeg) {
                            timestampAccumulator += verticalLegDurationMs;
                        }
                    }
                    // Process TOC if on this leg
                    if (i === tocLegIndex && verticalLegDurationMs !== undefined) {
                        const tocLegDistance = this.distanceTodLeg.get();
                        let tocVector;
                        let durationToEndOfTocVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfTocVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < tocLegDistance) {
                                tocVector = vector;
                                break;
                            }
                        }
                        if (tocVector) {
                            this._tocEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfTocVectorMs);
                        }
                        else {
                            this._tocEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                    // Process TOD if on this leg
                    if (i === todLegIndex && verticalLegDurationMs !== undefined) {
                        const todLegDistance = this.distanceTodLeg.get();
                        let todVector;
                        let durationToEndOfTodVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfTodVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < todLegDistance) {
                                todVector = vector;
                                break;
                            }
                        }
                        if (todVector) {
                            this._todEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfTodVectorMs);
                        }
                        else {
                            this._todEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                    // Process EOD if on this leg
                    if (i === eodLegIndex && verticalLegDurationMs !== undefined) {
                        const eodLegDistance = this.distanceTodLeg.get();
                        let eodVector;
                        let durationToEndOfEodVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfEodVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < eodLegDistance) {
                                eodVector = vector;
                                break;
                            }
                        }
                        if (eodVector) {
                            this._eodEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfEodVectorMs);
                        }
                        else {
                            this._eodEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                }
            }
        }
    }
}
BoeingFmsVNavDataProvider.phasesBeforeCruise = [
    FmsOperatingPhase.PREFLIGHT,
    FmsOperatingPhase.TAKEOFF,
    FmsOperatingPhase.CLIMB,
];

// TODO Add FMS LVars to field jsdocs
/** These are the fields that should be exposed by NavSources and NavIndicators.
 * Not all fields will be used by all the different Nav Sources.
 * To add a new field, just add it to NavBaseFields,
 * then add some code to each of the different NavSources to keep that field updated.
 * Don't use this class directly.
 * Every Subject should be able to be set to null, so that when the source is set to null, all the fields cna be nulled.
 * This isn't abstract so that we can instantiate it in one place to help generate setters. */
class NavBaseFields {
    constructor() {
        /** Signal strength received from the reference. A value of zero indicates no signal. */
        this.signalStrength = Subject.create(null);
        /** Always points to the curently tuned station or next waypoint/fix.
         * NAV RADIAL, ADF RADIAL */
        this.bearing = Subject.create(null);
        /** Either points towards the next waypoint (GPS/FMS),
         * displays the course selected by the course knob (VOR),
         * or displays the fixed course of a localizer (ILS).
         * NAV OBS, L:WTAP_LNav_DTK_Mag */
        this.course = Subject.create(null);
        /** The fixed course of a localizer when available (ILS).
         * Is null when `hasLocalizer` is false.
         * Only for NAV source types.
         * NAV LOCALIZER */
        this.localizerCourse = Subject.create(null);
        /** Whether the tuned station is a localizer or not.
         * This can be true even if `hasLocalizer` is false,
         * because this can be based on the frequency alone.
         * Only for NAV source types.
         * NAV LOCALIZER. */
        this.isLocalizer = Subject.create(null);
        /** Whether the nav source is receiving a valid localizer signal.
         * Only for NAV source types.
         * NAV HAS LOCALIZER */
        this.hasLocalizer = Subject.create(null);
        /** DME, distance to the station or next waypoint.
         * Is null when source is NAV and `hasDme` is false.
         * NAV DME, ADF DISTANCE, L:WTAP_LNav_DIS */
        this.distance = Subject.create(null);
        /** Whether the source is receiving a valid DME signal.
         * Only for NAV source types.
         * NAV HAS DME */
        this.hasDme = Subject.create(null);
        /** The ICAO ident of the station or waypoint.
         * NAV IDENT, or flight plan */
        this.ident = Subject.create(null);
        /** Whether the source is receiving a nav signal.
         * Only for NAV source types.
         * NAV HAS NAV. */
        this.hasNav = Subject.create(null);
        /** The active frequency that the nav source is tuned to.
         * Only for NAV and ADF source types.
         * NAV ACTIVE FREQUENCY, ADF ACTIVE FREQUENCY. */
        this.activeFrequency = Subject.create(null);
        /** Normalized and scaled lateral deviation (-1, 1).
         * NAV CDI, L:WTAP_LNav_XTK */
        this.lateralDeviation = Subject.create(null);
        /** Normalized and scaled vertical deviation (-1, 1).
         * NAV GLIDE SLOPE ERROR, L:WTAP_VNav_Vertical_Deviation, L:WTAP_LPV_Vertical_Deviation */
        this.verticalDeviation = Subject.create(null);
        /** Whether the source is receiving glideslope information.
         * Only for NAV source types.
         * NAV HAS GLIDE SLOPE. */
        this.hasGlideSlope = Subject.create(null);
        /** TTG, estimated time remaining until aircraft reaches next fix. // TODO Implement this */
        this.timeToGo = Subject.create(null);
        /** Whether course is pointing TO or FROM the station (VOR),
         * or if the aircraft heading is within 90 degress of the desired track (GPS).
         * NAV TOFROM, // TODO FMS VAR? */
        this.toFrom = Subject.create(null);
        /** The current CDI scale, in nautical miles.
         * Only for GPS source types.
         * L:WTAP_LNav_CDI_Scale */
        this.lateralDeviationScaling = Subject.create(null);
        /** A readable string/enum that shows the name of current scaling being applied to lateral deviation.
         * Only for GPS source types.
         * L:WTAP_LNav_CDI_Scale_Label */
        this.lateralDeviationScalingLabel = Subject.create(null);
    }
}
/** Base class for NavSourceBase and NavIndicator. */
class NavBase extends NavBaseFields {
    /** Creates a Map of setters to make unsubbing and subbing easy. */
    constructor() {
        super();
        /** An automatically generated map of setters to make it easy to set, sub, and unsub,
         * getting around having to call .bind(). */
        this.setters = new Map();
        Object.keys(new NavBaseFields()).forEach((key) => {
            this.setters.set(key, this[key].set.bind(this[key]));
        });
    }
}

/* eslint-disable @typescript-eslint/ban-types */
/** Represent a navigation indicator, like a course needle or bearing pointer.
 * Can only be pointed to 1 nav source at a time.
 * Gives visual components a single thing to subscribe to, while the actual source can be easily changed. */
class NavIndicator extends NavBase {
    /** NavIndicator constructor.
     * @param navSources The possible nav sources that could be pointed to.
     * @param sourceName The initial source to use, if any.
     */
    constructor(navSources, sourceName = null) {
        super();
        this.navSources = navSources;
        this._source = Subject.create(null);
        /** The nav source that is feeding data into the indicator fields.
         * Can only be changed with the {@link setSource} function. */
        this.source = this._source;
        this.setSource(sourceName);
    }
    /** Changes the source of this indicator.
     * All subjects will be republished with the current info from the new source.
     * @param newSourceName Name of new source, if any.
     */
    setSource(newSourceName) {
        const oldSource = this.source.get();
        if (oldSource && oldSource.name === newSourceName) {
            return;
        }
        if (oldSource === null && newSourceName === null) {
            return;
        }
        const newSource = (newSourceName ? this.navSources.get(newSourceName) : null);
        if (oldSource) {
            this.setters.forEach((setter, key) => {
                oldSource[key].unsub(setter);
            });
        }
        this._source.set(newSource);
        if (newSource) {
            this.setters.forEach((setter, key) => {
                newSource[key].sub(setter, true);
            });
        }
        else {
            this.setters.forEach((setter) => {
                setter(null);
            });
        }
    }
}
/** Holds the nav indicators. */
class NavIndicators {
    /** NavIndicators constructor.
     * @param indicators The nav indicators to hold. */
    constructor(indicators = new Map()) {
        this.indicators = indicators;
    }
    /** @inheritdoc */
    init() {
        // todo
    }
    /** @inheritdoc */
    onUpdate() {
        // todo
    }
    /** Gets a nav indicator.
     * @param key The name of the indicator to get.
     * @returns The indicator.
     * @throws Error if indicator not found.
     */
    get(key) {
        const indicator = this.indicators.get(key);
        if (!indicator) {
            throw new Error('no nav indicator exists with given key: ' + key);
        }
        else {
            return indicator;
        }
    }
}

/* eslint-disable max-len */
/**
 * A class for syncing a flight plan with the game
 * HINT: This class always needs to run on an instrument that has bound bing maps
 * Otherwise the GET_IS_BUSHTRIP coherent call won't return
 */
class FlightPlanAsoboSync {
    /**
     * Inits flight plan asobo sync
     */
    static async init() {
        return new Promise((resolve) => {
            if (!FlightPlanAsoboSync.fpListenerInitialized) {
                RegisterViewListener('JS_LISTENER_FLIGHTPLAN', () => {
                    FlightPlanAsoboSync.fpListenerInitialized = true;
                    resolve();
                });
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Loads the flight plan from the sim.
     * @param fms an instance of the fms
     */
    static async loadFromGame(fms) {
        await FlightPlanAsoboSync.init();
        Coherent.call('LOAD_CURRENT_ATC_FLIGHTPLAN');
        // Coherent.call('LOAD_CURRENT_GAME_FLIGHT');
        await Wait.awaitDelay(3000);
        const data = await Coherent.call('GET_FLIGHTPLAN');
        const isDirectTo = data.isDirectTo;
        let lastEnrouteSegment = 1;
        if (isDirectTo) {
            return false;
        }
        if (data.waypoints.length === 0) {
            return false;
        }
        await fms.emptyFlightPlan();
        const plan = fms.getPlanToModify();
        let originFacilityType = undefined;
        if (ICAO.isFacility(data.waypoints[0].icao)) {
            originFacilityType = ICAO.getFacilityType(data.waypoints[0].icao);
        }
        if (originFacilityType === FacilityType.Airport) {
            const originFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[0].icao), data.waypoints[0].icao);
            if (originFac !== undefined) {
                FlightPlanAsoboSync.setDeparture(originFac, data, fms);
            }
        }
        else if (originFacilityType !== undefined) {
            FlightPlanAsoboSync.buildNonAirportOriginLeg(data, plan, fms);
        }
        const destIndex = data.waypoints.length - 1;
        let destFacilityType = undefined;
        if (ICAO.isFacility(data.waypoints[destIndex].icao)) {
            destFacilityType = ICAO.getFacilityType(data.waypoints[destIndex].icao);
        }
        if (destFacilityType === FacilityType.Airport) {
            const destFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[destIndex].icao), data.waypoints[destIndex].icao);
            if (destFac !== undefined) {
                await FlightPlanAsoboSync.setDestination(destFac, data, fms);
            }
        }
        lastEnrouteSegment = FlightPlanAsoboSync.setEnroute(data, plan, fms);
        if (destFacilityType !== FacilityType.Airport && destFacilityType !== undefined) {
            FlightPlanAsoboSync.buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment);
        }
        plan.calculate(0).then(() => {
            plan.setLateralLeg(0);
        });
        return true;
    }
    /**
     * Syncs the plan back to the sim as best as possible
     * @param fms an instance of FMS
     */
    static async SaveToGame(fms) {
        var _a, _b;
        try {
            await FlightPlanAsoboSync.init();
            const plan = fms.getPrimaryFlightPlan();
            // TODO: Disable until GET_IS_BUSHTRIP is not dependent on having a bound bing map
            // const isBushtrip = await Coherent.call('GET_IS_BUSHTRIP');
            // if (isBushtrip) {
            //   return;
            // }
            await Coherent.call('SET_CURRENT_FLIGHTPLAN_INDEX', 0).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('CLEAR_CURRENT_FLIGHT_PLAN').catch((err) => console.log(JSON.stringify(err)));
            if (fms.facilityInfo.originFacility) {
                await Coherent.call('SET_ORIGIN', fms.facilityInfo.originFacility.icao, false).catch((err) => console.log(JSON.stringify(err)));
            }
            if (fms.facilityInfo.destinationFacility) {
                await Coherent.call('SET_DESTINATION', fms.facilityInfo.destinationFacility.icao, false).catch((err) => console.log(JSON.stringify(err)));
            }
            if (plan.procedureDetails.originRunway) {
                await Coherent.call('SET_ORIGIN_RUNWAY_INDEX', (_a = plan.procedureDetails.originRunway) === null || _a === void 0 ? void 0 : _a.parentRunwayIndex).catch((err) => console.log(JSON.stringify(err)));
            }
            await Coherent.call('SET_DEPARTURE_RUNWAY_INDEX', plan.procedureDetails.departureRunwayIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_DEPARTURE_PROC_INDEX', plan.procedureDetails.departureIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_DEPARTURE_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.departureTransitionIndex === -1 ? 0 : plan.procedureDetails.departureTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            // Put in the enroute waypoints
            const enrouteSegments = plan.segmentsOfType(FlightPlanSegmentType.Enroute);
            const legsToAdd = [];
            for (const segment of enrouteSegments) {
                // get legs in segment and put them into a temp array of legs to sync
                for (const leg of segment.legs) {
                    if (FlightPlanAsoboSync.isSyncableLeg(leg.leg)) {
                        legsToAdd.push(leg);
                    }
                }
            }
            // check if the last leg to sync is the destination airport and, if so, remove that leg from the array of legs to sync.
            if (legsToAdd.length > 0 && legsToAdd[legsToAdd.length - 1].leg.fixIcao === plan.destinationAirport) {
                legsToAdd.pop();
            }
            let globalIndex = 1;
            // sync the array of legs to sync to the sim flight plan
            for (const leg of legsToAdd) {
                try {
                    const facType = ICAO.getFacilityType(leg.leg.fixIcao);
                    if (facType === FacilityType.USR) {
                        const usrFac = await fms.facLoader.getFacility(facType, leg.leg.fixIcao);
                        await Coherent.call('ADD_CUSTOM_WAYPOINT', (_b = leg.name) !== null && _b !== void 0 ? _b : leg.leg.fixIcao, globalIndex, usrFac.lat, usrFac.lon, false);
                    }
                    else {
                        await Coherent.call('ADD_WAYPOINT', leg.leg.fixIcao, globalIndex, false);
                    }
                    globalIndex++;
                }
                catch (error) {
                    console.warn(`Error during fp sync: ${JSON.stringify(error)}`);
                }
            }
            await Coherent.call('SET_ARRIVAL_RUNWAY_INDEX', plan.procedureDetails.arrivalRunwayTransitionIndex === -1 ? 0 : plan.procedureDetails.arrivalRunwayTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_ARRIVAL_PROC_INDEX', plan.procedureDetails.arrivalIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_ARRIVAL_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.arrivalTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_APPROACH_INDEX', plan.procedureDetails.approachIndex).then(() => {
                Coherent.call('SET_APPROACH_TRANSITION_INDEX', plan.procedureDetails.approachTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            }).catch((err) => console.log(JSON.stringify(err)));
            const activeSegment = BoeingFmsUtils.getActiveSegment(plan);
            if ((activeSegment === null || activeSegment === void 0 ? void 0 : activeSegment.segmentType) === FlightPlanSegmentType.Approach) {
                await Coherent.call('TRY_AUTOACTIVATE_APPROACH').catch((err) => console.log(JSON.stringify(err)));
            }
            Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX').catch((err) => console.log(JSON.stringify(err)));
        }
        catch (error) {
            console.error(`Error during fp sync: ${error}`);
        }
    }
    /**
     * Checks if a leg is syncable to the stock flight plan system.
     * @param leg the leg to check
     * @returns true if the leg is syncable, false otherwise
     */
    static isSyncableLeg(leg) {
        return FlightPlanAsoboSync.nonSyncableLegTypes.indexOf(leg.type) === -1;
    }
    /**
     * Sets the departure procedure or facility if specified
     * @param facility is the origin airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns whether a departure was set.
     */
    static setDeparture(facility, data, fms) {
        let originOneWayRunway = undefined;
        if (data.originRunwayIndex > -1) {
            const oneWayRunways = [];
            let index = 0;
            facility.runways.forEach((runway) => {
                for (const rw of RunwayUtils.getOneWayRunways(runway, index)) {
                    oneWayRunways.push(rw);
                }
                index++;
            });
            oneWayRunways.sort(RunwayUtils.sortRunways);
            originOneWayRunway = oneWayRunways[data.originRunwayIndex];
        }
        if (data.departureProcIndex !== -1) {
            if (data.departureRunwayIndex > -1) {
                const runwayTransition = facility.departures[data.departureProcIndex].runwayTransitions[data.departureRunwayIndex];
                const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                originOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
            }
            const enrouteTransitionIndex = data.departureEnRouteTransitionIndex === 0 &&
                facility.departures[data.departureProcIndex].enRouteTransitions.length < 1 ? -1 : data.departureEnRouteTransitionIndex;
            fms.insertDeparture(facility, data.departureProcIndex, data.departureRunwayIndex, enrouteTransitionIndex, originOneWayRunway);
            return true;
        }
        else if (facility !== undefined) {
            fms.setOrigin(facility, originOneWayRunway);
            return true;
        }
        return false;
    }
    /**
     * Sets the destination airport
     * @param facility is the destination airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns A Promise which is fulfilled with whether a destination was set.
     */
    static async setDestination(facility, data, fms) {
        let destOneWayRunway = undefined;
        let setDestination = false;
        if (data.arrivalProcIndex !== -1) {
            if (data.arrivalRunwayIndex > -1) {
                const runwayTransition = facility.arrivals[data.arrivalProcIndex].runwayTransitions[data.arrivalRunwayIndex];
                if (runwayTransition !== undefined) {
                    const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                    destOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
                }
            }
            const enrouteTransitionIndex = data.arrivalEnRouteTransitionIndex === 0 &&
                facility.arrivals[data.arrivalProcIndex].enRouteTransitions.length < 1 ? -1 : data.arrivalEnRouteTransitionIndex;
            fms.insertArrival(facility, data.arrivalProcIndex, data.arrivalRunwayIndex, enrouteTransitionIndex, destOneWayRunway);
            setDestination = true;
        }
        if (data.approachIndex !== -1) {
            const approachTransitionIndex = data.approachTransitionIndex === 0 &&
                facility.approaches[data.approachIndex].transitions.length < 1 ? -1 : data.approachTransitionIndex;
            await fms.insertApproach({ facility, approachIndex: data.approachIndex, approachTransitionIndex });
            setDestination = true;
        }
        if (facility !== undefined && data.arrivalProcIndex === -1 && data.approachIndex === -1) {
            fms.setDestination(facility);
            setDestination = true;
        }
        return setDestination;
    }
    /**
     * Sets the enroute portion of the flight plan
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of the fms
     * @returns the last enroute segment
     */
    static setEnroute(data, plan, fms) {
        const enrouteStart = (data.departureWaypointsSize == -1) ? 1 : data.departureWaypointsSize;
        const enroute = data.waypoints.slice(enrouteStart, -(Math.max(0, data.arrivalWaypointsSize) + 1));
        let custIdx = 1;
        let currentSegment = 1;
        let lastDepartureLegIcao = undefined;
        let lastLegWasAirway = false;
        if (data.departureProcIndex > -1) {
            const depSegment = plan.getSegment(0);
            if (depSegment.legs.length > 1) {
                lastDepartureLegIcao = depSegment.legs[depSegment.legs.length - 1].leg.fixIcao;
            }
        }
        for (let i = 0; i < enroute.length; i++) {
            const wpt = enroute[i];
            const segment = plan.getSegment(currentSegment);
            if (wpt.airwayIdent) {
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) ;
                else {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airwayIdent);
                        currentSegment += 1;
                        // plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                    }
                }
                for (let j = i + 1; j < enroute.length; j++) {
                    i++;
                    const airwayLeg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: enroute[j].icao
                    });
                    plan.addLeg(currentSegment, airwayLeg);
                    if (enroute[j].airwayIdent !== wpt.airwayIdent) {
                        lastLegWasAirway = enroute[j].airwayIdent ? true : false;
                        break;
                    }
                }
                plan.setAirway(currentSegment, wpt.airwayIdent + '.' + enroute[i].ident);
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? enroute[i].airwayIdent : undefined);
            }
            else {
                let skip = false;
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) {
                    skip = true;
                }
                let leg = undefined;
                if (!skip && wpt.icao.trim() == '') {
                    const re = /(?:[D][\d])|(?:DLast)|(?:TIMEVERT)|(?:TIMECLIMB)|(?:TIMECRUIS)|(?:TIMEDSCNT)|(?:TIMEAPPROACH)/;
                    skip = wpt.ident.match(re) !== null;
                }
                if (!skip && (wpt.ident === 'Custom' || wpt.icao.trim() == '')) {
                    const userFacility = UserFacilityUtils.createFromLatLon(`U      USR${custIdx.toString().padStart(2, '0')}`, wpt.lla.lat, wpt.lla.long, true, wpt.icao.trim() === '' ? wpt.ident : `Custom ${custIdx.toString().padStart(2, '0')}`);
                    fms.addUserFacility(userFacility);
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: userFacility.icao,
                        lat: wpt.lla.lat,
                        lon: wpt.lla.long
                    });
                    custIdx++;
                }
                else if (!skip && wpt.icao.trim() !== '') {
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                }
                if (leg) {
                    plan.addLeg(currentSegment, leg);
                    if (lastLegWasAirway) {
                        plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                        currentSegment += 1;
                        plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                    }
                    lastLegWasAirway = false;
                }
            }
        }
        if (plan.getSegment(currentSegment).airway) {
            currentSegment += 1;
            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
        }
        return currentSegment;
    }
    /**
     * Sets the first leg of the enroute plan as the first leg in the world map plan, but as an IF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     */
    static buildNonAirportOriginLeg(data, plan, fms) {
        const wpt = data.waypoints[0];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTD', wpt.lla.lat, wpt.lla.long, true, 'Custom Origin');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: 'U      CUSTD',
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(1, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: wpt.icao
            });
            plan.addLeg(1, leg);
        }
    }
    /**
     * Sets the last leg of the enroute plan as the last leg in the world map plan, but as an TF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     * @param lastEnrouteSegment is the last enroute segment
     */
    static buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment) {
        const wpt = data.waypoints[data.waypoints.length - 1];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTA', wpt.lla.lat, wpt.lla.long, true, 'Custom Destination');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: userFacility.icao,
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: wpt.icao
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
    }
}
// public static fpChecksum = 0;
FlightPlanAsoboSync.fpListenerInitialized = false;
FlightPlanAsoboSync.nonSyncableLegTypes = [
    LegType.Discontinuity,
    LegType.ThruDiscontinuity,
    LegType.Unknown,
    LegType.HM,
    LegType.HA,
    LegType.HF,
];

/** Base class for NavSources that are meant to be used by NavIndicators.
 * A NavSource subscribes to SimVars and updates the NavBaseFields accordingly. */
class NavSourceBase extends NavBase {
    /** The NavSourceBase constructor.
     * @param bus The event bus.
     * NavSources need to tell the publisher what to subscribe to.
     * @param name The name of the nav source. Ex: NAV1, ADF, FMS2.
     * @param index The index of the nav source. Ex: 1 for NAV1, or 2 for FMS2, or 1 for ADF.
     */
    constructor(bus, name, index) {
        super();
        this.bus = bus;
        this.name = name;
        this.index = index;
    }
}
// TODO Does this need to be an instrument?
/** Holds the available Nav Sources that NavIndicators can use. */
class NavSources {
    /** NavSources constructor.
     * @param sources The nav sources. */
    constructor(...sources) {
        this.sources = sources;
    }
    /** @inheritdoc */
    init() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // TODO
    }
    /** Gets a nav source.
     * @param name Name of source.
     * @returns The source.
     * @throws Error if name not found.
     */
    get(name) {
        const indicator = this.sources.find(x => x.name === name);
        if (!indicator) {
            throw new Error('no nav source exists with given name: ' + name);
        }
        else {
            return indicator;
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/** Represents a NAV radio, subscribes to the NAV SimVars. */
class NavRadioNavSource extends NavSourceBase {
    /** @inheritdoc */
    constructor(bus, name, index) {
        super(bus, name, index);
        this.glideSlopeErrorDegrees = Subject.create(0);
        this.navCdi = Subject.create(0);
        this.navDme = Subject.create(0);
        this.navRadial = Subject.create(0);
        this.updateDistance = () => {
            this.distance.set(this.hasDme.get() ? this.navDme.get() : null);
        };
        this.updateIsLocalizer = () => {
            var _a;
            const navHasLocalizer = this.hasLocalizer.get();
            const _isLocalizerFrequency = RadioUtils.isLocalizerFrequency((_a = this.activeFrequency.get()) !== null && _a !== void 0 ? _a : 0);
            this.isLocalizer.set(navHasLocalizer || _isLocalizerFrequency);
        };
        this.updateVerticalDeviation = () => {
            this.verticalDeviation.set(this.getVerticalDeviation());
        };
        this.updateBearing = () => {
            if (!this.hasNav.get()) {
                this.bearing.set(null);
            }
            else {
                const radialDegrees = this.navRadial.get();
                const bearing = (radialDegrees + 180) % 360;
                this.bearing.set(bearing);
            }
        };
        this.updateLateralDeviation = () => {
            this.lateralDeviation.set(this.getLateralDeviation());
        };
        const navComSubscriber = this.bus.getSubscriber();
        navComSubscriber.on(`nav_signal_${index}`).whenChanged().handle(this.signalStrength.set.bind(this.signalStrength));
        navComSubscriber.on(`nav_dme_${index}`).whenChanged().handle(this.navDme.set.bind(this.navDme));
        navComSubscriber.on(`nav_has_dme_${index}`).whenChanged().handle(this.setters.get('hasDme'));
        navComSubscriber.on(`nav_ident_${index}`).whenChanged().handle(this.setters.get('ident'));
        navComSubscriber.on(`nav_localizer_${index}`).whenChanged().handle(this.setters.get('hasLocalizer'));
        navComSubscriber.on(`nav_gs_error_${index}`).whenChanged().handle(this.glideSlopeErrorDegrees.set.bind(this.glideSlopeErrorDegrees));
        navComSubscriber.on(`nav_glideslope_${index}`).whenChanged().handle(this.setters.get('hasGlideSlope'));
        navComSubscriber.on(`nav_obs_${index}`).whenChanged().handle(this.setters.get('course'));
        navComSubscriber.on(`nav_radial_${index}`).whenChanged().handle(this.navRadial.set.bind(this.navRadial));
        navComSubscriber.on(`nav_cdi_${index}`).whenChanged().handle(this.navCdi.set.bind(this.navCdi));
        navComSubscriber.on(`nav_has_nav_${index}`).whenChanged().handle(this.setters.get('hasNav'));
        navComSubscriber.on(`nav_to_from_${index}`).whenChanged().handle(this.setters.get('toFrom'));
        navComSubscriber.on(`nav_active_frequency_${index}`).whenChanged().handle(this.setters.get('activeFrequency'));
        this.hasDme.sub(this.updateDistance);
        this.navDme.sub(this.updateDistance);
        this.hasLocalizer.sub(this.updateIsLocalizer);
        this.activeFrequency.sub(this.updateIsLocalizer);
        this.hasGlideSlope.sub(this.updateVerticalDeviation);
        this.glideSlopeErrorDegrees.sub(this.updateVerticalDeviation);
        this.navRadial.sub(this.updateBearing);
        this.hasNav.sub(this.updateBearing);
        this.navCdi.sub(this.updateLateralDeviation);
        this.hasNav.sub(this.updateLateralDeviation);
    }
    /** @inheritdoc */
    getType() {
        return NavSourceType.Nav;
    }
    /** @returns Deviation is in degrees, and standard glideslope is 1.4 degrees thick,
     * so the vdev indicator will max out when 0.7 degrees off the GS */
    getVerticalDeviation() {
        if (!this.hasGlideSlope.get()) {
            return null;
        }
        else {
            return this.glideSlopeErrorDegrees.get() / 0.7;
        }
    }
    /** @returns Deviation is in degrees, and standard glideslope is 1.4 degrees thick,
     * so the vdev indicator will max out when 0.7 degrees off the GS */
    getLateralDeviation() {
        if (!this.hasNav.get()) {
            return null;
        }
        else {
            // The NAV CDI simvar holds the deviation as a range from -127 to 127
            return this.navCdi.get() / 127;
        }
    }
}

/** Represents an ADF radio, subscribes to the ADF SimVars. */
class AdfRadioSource extends NavSourceBase {
    /** @inheritdoc */
    constructor(bus, name, index) {
        super(bus, name, index);
        this.heading = Subject.create(0);
        this.adfRadial = Subject.create(0);
        this.adfSignal = Subject.create(0);
        this.updateBearing = () => {
            if (this.adfSignal.get() === 0) {
                this.bearing.set(null);
            }
            else {
                const newBearing = this.adfRadial.get() + this.heading.get();
                this.bearing.set(newBearing);
            }
        };
        const adc = this.bus.getSubscriber();
        adc.on('hdg_deg')
            .withPrecision(2)
            .handle(this.heading.set.bind(this.heading));
        const navComSubscriber = this.bus.getSubscriber();
        navComSubscriber.on(`adf_bearing_${index}`).withPrecision(2).handle(this.adfRadial.set.bind(this.adfRadial));
        navComSubscriber.on(`adf_signal_${index}`).withPrecision(0).handle(this.adfSignal.set.bind(this.adfSignal));
        navComSubscriber.on(`adf_active_frequency_${index}`).whenChanged().handle(this.activeFrequency.set.bind(this.activeFrequency));
        this.adfSignal.pipe(this.signalStrength);
        this.heading.sub(this.updateBearing);
        this.adfRadial.sub(this.updateBearing);
        this.adfSignal.sub(this.updateBearing);
    }
    /** @inheritdoc */
    getType() {
        return NavSourceType.Adf;
    }
}

/* eslint-disable jsdoc/require-jsdoc */
/**
 * TODO: This needs to have the aircraft specific performance values split out from the static constants and methods.
 * Boeing Performance Math Utility Class.
 */
class BoeingAeroMath {
    // TODO: Clean up these various delta/pressure ratio methods....
    /**
     * Calculates the current dynamic pressure ratio.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg.
     * @param mach The current aircraft mach number.
     * @returns the current dynamic pressure ratio.
     */
    static calcDynamicPressureRatio(ambientPressure, mach) {
        return 1481.4 * Math.pow(mach, 2) * BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure);
    }
    /**
     * Calculate atmospheric pressure ratio from pressure altitude
     * @todo belongs somewhere else
     * @param zp Pressure altitude in feet
     * @param tropopause Tropopause altitude in feet
     * @returns Atmospheric pressure ratio (delta)
     */
    static deltaFromPressureAlt(zp, tropopause = 36089.24) {
        return zp < tropopause ? ((288.15 - 0.0019812 * zp) / 288.15) ** 5.25588 : 0.22336 * Math.E ** ((36089.24 - zp) / 20805.7);
    }
    /**
     * Calculate the Delta Pressure Ratio for a given altitude above sea level.
     * @param altitude The altitude, in Ft.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAltitude(altitude) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
        return isa[1] * 100 / BoeingAeroMath.slIsaPres;
    }
    /**
     * Calculate the Delta Pressure Ratio for a given ambient pressure.
     * @param ambientPressure The ambient pressure, in inHg.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAmbientPressure(ambientPressure) {
        return ambientPressure / 29.92;
    }
    /**
     * Calculate the Delta Total Pressure Ratio for a given Delta Pressure Ratio and Mach.
     * @param deltaPressureRatio The Delta Pressure Ratio.
     * @param mach The Mach.
     * @returns The Delta Total Pressure Ratio.
     */
    static calcDeltaTotalPressureRatio(deltaPressureRatio, mach) {
        return deltaPressureRatio * Math.pow(1 + 0.2 * (Math.pow(mach, 2)), 3.5);
    }
    /**
     * Calculates a thrust correction factor. Multiplying the correction factor by uncorrected thrust yields corrected
     * thrust.
     * @param mach The mach number.
     * @param ambientPressure The ambient pressure in inHg.
     * @returns The thrust correction factor for the specified parameters.
     */
    static calculateThrustCorrectionFactor(mach, ambientPressure) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        return 1 / (deltaPressureRatio * totalInletPressureMachRise);
    }
    /**
     * Gets the ISA Standard Temp and Press from Altitude.
     * @param altitude The altitude in feet.
     * @param isaPresDeviation Optional Pressure Deviation, in inHg.
     * @param isaTempDeviation Optional Temperature Deviation, in C.
     * @returns an array of [temp K, pressure HPA]
     */
    static calcIsaFromAltitude(altitude, isaPresDeviation, isaTempDeviation) {
        if (isaPresDeviation !== undefined) {
            altitude = BoeingAeroMath.calcPressureAltitude(altitude, 29.92 + isaPresDeviation);
        }
        let temp = 0.0;
        let pressure = 0.0;
        if (altitude <= 36089) {
            // 36089 is the altitude of the top of the troposphere
            temp = BoeingAeroMath.slIsaTemp + (-BoeingAeroMath.lapseFt * altitude);
            pressure = BoeingAeroMath.slIsaPres * Math.pow((BoeingAeroMath.slIsaTemp / temp), (0.034163203 / -0.0065));
        }
        else if (altitude <= 65616) {
            // 65616 is the altitude of the tropopause
            // 22335.6 is the pressure at the base of the tropopause in PA
            // const tropoPres = 22335.6;
            // tropoTemp = 216.65;
            temp = 216.65;
            pressure = 0.223356 * 101325 * Math.exp(-0.000157688 * (altitude - 36089));
        }
        else {
            temp = NaN;
            pressure = NaN;
        }
        return [temp + (isaTempDeviation !== null && isaTempDeviation !== void 0 ? isaTempDeviation : 0), pressure / 100];
    }
    /**
     * Calculate the speed of sound from temperature.
     * @param ambientTemperature The ambient temperature, in C.
     * @returns The speed of sound in ft/s.
     */
    static calcSpeedOfSoundFromTemp(ambientTemperature) {
        return Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE));
    }
    /**
     * Calculate the pressure altitude from Indicated Altitude and Sea Level Pressure.
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Pressure Altitude.
     */
    static calcPressureAltitude(indicatedAltitude, baroSettingInHg) {
        return indicatedAltitude + (1000 * (29.92 - baroSettingInHg));
    }
    /**
     * Calculate the static pre
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Static Pressure in inHg.
     */
    static calcStaticPressure(indicatedAltitude, baroSettingInHg) {
        return UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(BoeingAeroMath.calcPressureAltitude(indicatedAltitude, baroSettingInHg))[1], UnitType.IN_HG);
    }
    /**
     * Calculate the Impact Pressure from CAS.
     * @param cas Calibrated Airspeed in knots.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromCas(cas) {
        return BoeingAeroMath.airDensity * Math.pow(UnitType.KNOT.convertTo(cas, UnitType.MPS), 2) / 2;
    }
    /**
     * Calculate the Impact Pressure.
     * @param mach Mach Number.
     * @param ambientPressure The Ambient Pressure, in inHg.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromMach(mach, ambientPressure) {
        return 100 * (UnitType.IN_HG.convertTo(ambientPressure, UnitType.HPA) * (Math.pow(1 + Math.pow(0.2 * mach, 2), 2 / 7) - 1));
    }
    /**
     * Calculate the Mach number from airspeed, altitude and pressure.
     * @param cas Calibrated Airspeed in knots.
     * @param indicatedAltitude Indicated Altitude in Feet.
     * @param baroSettingInHg The local altimeter setting in inHg.
     * @returns The current Mach Number.
     */
    static calcMachFromCasAltitudePressure(cas, indicatedAltitude, baroSettingInHg) {
        const impactPressure = BoeingAeroMath.calcImpactPressureFromCas(cas);
        const staticPressure = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        return Math.sqrt(5 * (Math.pow((impactPressure / staticPressure) + 1, 2 / 7) - 1));
    }
    /**
     * Calculate static air temperature (SAT, also OAT), from total air temperature (TAT) and Mach.
     * @param tat Total Air Temp in degrees C.
     * @param mach Mach number.
     * @returns The Static Air Temperature in degrees C.
     */
    static calcSatFromTatAndMach(tat, mach) {
        // Gamma minus 1 / 2 = 0.2
        return UnitType.KELVIN.convertTo(UnitType.CELSIUS.convertTo(tat, UnitType.KELVIN) / (1 + (Math.pow(mach, 2) * 0.2)), UnitType.CELSIUS);
    }
    /**
     * Calculate the True Airspeed from Altitude, Temperature and Calibrated Airspeed.
     * @param altitude Altitude in Feet.
     * @param tat Total Air Temp in degrees C.
     * @param cas Calibrated Airspeed in KT.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns True Airspeed in KT.
     */
    static calcTasFromCas(altitude, tat, cas, baroSettingInHg) {
        const pressureAltitude = BoeingAeroMath.calcPressureAltitude(altitude, baroSettingInHg);
        const isa = BoeingAeroMath.calcIsaFromAltitude(pressureAltitude);
        const isaPres = isa[1];
        const mach = BoeingAeroMath.calcMachFromCasAltitudePressure(cas, altitude, baroSettingInHg);
        const temp = UnitType.CELSIUS.convertTo(BoeingAeroMath.calcSatFromTatAndMach(tat, mach), UnitType.KELVIN);
        const alpha = Math.sqrt(BoeingAeroMath.gammaGasVolume * temp);
        const tas = Math.sqrt(5) * alpha * Math.sqrt(Math.pow(((BoeingAeroMath.slIsaPres / isaPres) *
            (Math.pow((cas * cas / BoeingAeroMath.sqrtGammaGasSlNmSqd5) + 1, BoeingAeroMath.gammaOverGammaMinus1) - 1) + 1), BoeingAeroMath.gammaMinus1OverGamma) - 1);
        return UnitType.FPS.convertTo(tas, UnitType.KNOT);
    }
    /**
     * Calculate EAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientPressure Ambient Pressure, in inHg.
     * @returns The Equivalent Airspeed (EAS).
     */
    static calcEasFromMachAndAmbientPressure(mach, ambientPressure) {
        return UnitType.FPS.convertTo(BoeingAeroMath.sound * mach *
            Math.sqrt(BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure)), UnitType.KNOT);
    }
    /**
     * Calculate CAS from EAS.
     * @param eas Equivalent Airspeed in knots
     * @param pressureAlt The current pressure altitude, in Feet.
     * @returns Calibrated airspeed in knots
     */
    static easToCas(eas, pressureAlt) {
        const delta = BoeingAeroMath.deltaFromPressureAlt(pressureAlt);
        return 1479.1 * Math.sqrt((1 + delta * ((1 + 1 / delta * (eas / 1479.1) ** 2) ** 3.5 - 1)) ** (1 / 3.5) - 1);
    }
    /**
     * Calculate CAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientTemp Ambient Temperature, in C.
     * @returns The True Airspeed (TAS).
     */
    static calcTasFromMachAndTemp(mach, ambientTemp) {
        return mach * BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemp);
    }
    /**
     * Calculate density altitude from indicated altitude, barometer setting and static air temperature.
     * @param indicatedAltitude indicated altitude in feet (ft)
     * @param baroSettingInHg barometer setting in inches of mercury (inHg)
     * @param sat static air temperature in degrees celsius (°C)
     * @returns density altitude in feet (ft)
     */
    static calcDensityAltitude(indicatedAltitude, baroSettingInHg, sat) {
        const stationPressurePa = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        const stationPressureinHg = UnitType.HPA.convertTo(stationPressurePa / 100, UnitType.IN_HG);
        const tempR = 459.67 + UnitType.CELSIUS.convertTo(sat, UnitType.FAHRENHEIT);
        // NWS Calculation for ASOS/AWOS
        return 145422.16 * (1 - Math.pow(17.326 * stationPressureinHg / tempR, 0.235));
    }
    /**
     * Calculate observed wind from true airspeed, ground speed, magnetic heading and magnetic track.
     * @param tas The true airspeed in KT.
     * @param gs The ground speed in KT.
     * @param heading The current magnetic heading in degrees.
     * @param track The current magnetic ground track in degrees.
     * @returns Array of [wind direction degrees mag, wind speed kt].
     */
    static calcWind(tas, gs, heading, track) {
        const headingRad = UnitType.DEGREE.convertTo(heading, UnitType.RADIAN);
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windComponentNorth = gs * Math.cos(trackRad) - tas * Math.cos(headingRad);
        const windComponentEast = gs * Math.sin(trackRad) - tas * Math.sin(headingRad);
        const windDirection = NavMath.normalizeHeading(90 - Math.round(UnitType.RADIAN.convertTo(Math.atan2(-windComponentNorth, -windComponentEast), UnitType.DEGREE)));
        const windSpeed = Math.sqrt(Math.pow(windComponentNorth, 2) + Math.pow(windComponentEast, 2));
        return [windDirection, windSpeed];
    }
    /**
     * Calculate headwind and crosswind components from the current ground track, wind speed and wind direction.
     * @param track Current magnetic ground track.
     * @param windSpeed Current wind speed in kt.
     * @param windDirection Current wind direction in degrees magnetic.
     * @returns Array of [headwind component in kt (+ is headwind, - is tailwind),
     * crosswind component in kt (+ is Left crosswind, - is Right crosswind)].
     */
    static calcRelativeWindComponents(track, windSpeed, windDirection) {
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windDirectionRad = UnitType.DEGREE.convertTo(windDirection, UnitType.RADIAN);
        return [
            Math.round(windSpeed * (Math.cos(trackRad - windDirectionRad))),
            Math.round(windSpeed * (Math.sin(trackRad - windDirectionRad)))
        ];
    }
}
/** ISA temp at Sea Level in Kelvin  */
BoeingAeroMath.slIsaTemp = 288.15;
/** ISA pressure at Sea Level in Pascals  */
BoeingAeroMath.slIsaPres = 101325;
/** Specific heat ratio for air  */
BoeingAeroMath.gamma = 1.4;
/** Constant: gamma over gamma minus 1 */
BoeingAeroMath.gammaOverGammaMinus1 = BoeingAeroMath.gamma / (BoeingAeroMath.gamma - 1);
/** Constant: gamma minus 1 over gamma */
BoeingAeroMath.gammaMinus1OverGamma = (BoeingAeroMath.gamma - 1) / BoeingAeroMath.gamma;
/** Specific gas constant in Kelvin (from the world)  */
BoeingAeroMath.gasKelvin = 287.05;
/** Specific gas constant in Rankine (from sim code) */
BoeingAeroMath.gasRankine = 1716;
/** Specific heat ratio for air times gas constant.  */
BoeingAeroMath.gammaGas = BoeingAeroMath.gamma * BoeingAeroMath.gasKelvin;
/** Specific heat ratio for air times gas constant divided per cubic ft.  */
BoeingAeroMath.gammaGasVolume = BoeingAeroMath.gammaGas / Math.pow(UnitType.FOOT.convertTo(1, UnitType.METER), 2);
/** Constant: gammaGas * slIsaTemp */
BoeingAeroMath.gammaGasSl = BoeingAeroMath.gammaGas * BoeingAeroMath.slIsaTemp;
/** Constant: sqrt gammaGasSl * nm */
BoeingAeroMath.sqrtGammaGasSlNm = Math.sqrt(BoeingAeroMath.gammaGasSl) * UnitType.METER.convertTo(3600.0, UnitType.NMILE);
/** Constant: 5 * sqrtGammaGasSlNm squared  */
BoeingAeroMath.sqrtGammaGasSlNmSqd5 = 5.0 * BoeingAeroMath.sqrtGammaGasSlNm * BoeingAeroMath.sqrtGammaGasSlNm;
/** Atmospheric Lapse Rate Constant (Kelvin per foot)  */
BoeingAeroMath.lapseFt = 0.0019812;
/** Fluid density of Air in kg/m^3.  */
BoeingAeroMath.airDensity = 1.225;
/** Gravity at SL ft/s^2.  */
BoeingAeroMath.gravity = 32.17405;
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;
/** Speed of Sound at SL ft/s.  */
BoeingAeroMath.sound = Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE);

/* eslint-disable max-len */
/**
 * An interface for accessing aircraft specific performance data.
 */
class BoeingPerformanceDataProvider {
    constructor() {
        /** Aircraft Specific values from flight_model.cfg and engines.cfg files.  */
        this.aircraftFlightModel = this.getAircraftFlightModel();
        this.aspectRatio = Math.pow(this.aircraftFlightModel.wing_span, 2) / this.aircraftFlightModel.wing_area;
    }
    /**
     * Calculate the Optimum (best range) Altitude for a specific Mach.
     * @param mach The Mach number.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude, in FT.
     */
    calcOptimumAltitudeFromCruiseMach(mach, weight) {
        const rangeTable = [];
        let altitude = 25000;
        while (altitude <= 41000) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            altitude += 1000;
        }
        const maxRange = Math.max(...rangeTable);
        const optAltitude = 25000 + 1000 * rangeTable.findIndex(v => v === maxRange);
        return optAltitude;
    }
    /**
     * Calculate the Optimum (best range) Mach for a specific Altitude.
     * @param altitude The Altitude, in FT.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Mach.
     */
    calcOptimumCruiseMachFromAltitude(altitude, weight) {
        const rangeTable = [];
        let mach = .7;
        while (mach <= 0.9) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            mach += 0.01;
        }
        const maxRange = Math.max(...rangeTable);
        const optMach = .7 + (0.01 * rangeTable.findIndex(v => v === maxRange));
        return optMach;
    }
    /**
     * Calculate the Optimum (best range) Mach and Altitude for a specific aircraft weight.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude and Mach as [Alt in FT, Mach].
     */
    calcOptimumCruiseMachAndAltitude(weight) {
        const rangeTable = [];
        let mach = 70;
        let altitude = 25000;
        while (Math.round(altitude) <= 41000) {
            while (Math.round(mach) <= 90) {
                const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
                const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
                const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
                const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach / 100, ambientTemperature);
                const cl = this.calculateCL(weight, ambientPressure, mach / 100);
                const netThrust = this.calculateThrustRequired(weight, cl);
                const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach / 100, altitude, ambientTemperature, ambientPressure);
                const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
                const rangePerThousandPounds = (1000 / fuelFlow) * tas;
                rangeTable.push(rangePerThousandPounds);
                mach += 1;
            }
            altitude += 1000;
            mach = 70;
        }
        //21 values per altitude
        const maxRange = Math.max(...rangeTable);
        const index = rangeTable.findIndex(v => v === maxRange);
        const altIndex = Math.floor(index / 21);
        const machIndex = index - (altIndex * 21);
        const optMach = .7 + (0.01 * machIndex);
        const optAlt = 25000 + (altIndex * 1000);
        return [optAlt, optMach];
    }
    /**
     * Calculates the current Lift Coefficient.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg
     * @param mach The current aircraft mach number.
     * @returns the current lift coefficient.
     */
    calculateCL(aircraftWeight, ambientPressure, mach) {
        return aircraftWeight / (BoeingAeroMath.calcDynamicPressureRatio(ambientPressure, mach) * this.aircraftFlightModel.wing_area);
    }
    /**
     * Calculates the current drag coefficient.
     * @param cl The current Lift Coefficient.
     * @returns The Drag Coefficient
     */
    calculateCD(cl) {
        const correctedCl = cl - this.aircraftFlightModel.lift_coef_aoa_0;
        const parasiticDrag = this.aircraftFlightModel.drag_coef_zero_lift;
        const inducedDrag = (Math.pow(correctedCl, 2) * this.aircraftFlightModel.induced_drag_scalar) /
            (Math.PI * this.aircraftFlightModel.oswald_efficiency_factor * this.aspectRatio);
        return parasiticDrag + inducedDrag;
    }
    /**
     * Calculates the efficiency factor.
     * @param cl The current Lift Coefficient.
     * @returns the efficiency factor.
     */
    calculateEfficiency(cl) {
        return cl / this.calculateCD(cl);
    }
    /**
     * Calculates the best L/D speed by finding a mach value at the altitude that produces the highest L/D ratio.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param altitude Altitude to find the best econ speed for.
     * @returns The best Econ Speed in Mach.
     */
    calculateLDMaxSpeed(aircraftWeight, altitude) {
        const ambientPressure = UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(altitude)[1], UnitType.IN_HG);
        let machTarget = 0.5;
        let clTarget = 0;
        let ldTarget = 0;
        let iterations = 0;
        while (iterations < 300) {
            clTarget = this.calculateCL(aircraftWeight, ambientPressure, machTarget);
            const newldTarget = this.calculateEfficiency(clTarget);
            if (newldTarget > ldTarget) {
                ldTarget = newldTarget;
                machTarget += .01;
            }
            else {
                return machTarget -= .01;
            }
            iterations++;
        }
        return machTarget;
    }
    /**
     * Gets the best econ speed based on CAFE/Carson Speed multiplier against best L/D speed.
     * @param aircraftWeight The aircraft weight.
     * @param altitude The altitide to find the best speed at.
     * @returns The best econ speed.
     */
    calculateBestEconSpeed(aircraftWeight, altitude) {
        return 1.32 * this.calculateLDMaxSpeed(aircraftWeight, altitude);
    }
    /**
     * Calculates the total required net thrust to maintain the current speed and altitude.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param cl The current Lift Coefficient.
     * @returns The total required net thrust.
     */
    calculateThrustRequired(aircraftWeight, cl) {
        return aircraftWeight / this.calculateEfficiency(cl);
    }
    /**
     * Calculates an FPA for a total net thrust at a constant speed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @returns The predicted FPA in Degrees.
     */
    calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl) {
        return Avionics.Utils.RAD2DEG * Math.asin((totalNetThrust / aircraftWeight) - (1 / this.calculateEfficiency(cl)));
    }
    /**
     * Calculates a vertical speed for a total net thrust for a constant true airspeed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @returns the predicted VS in FPM
     */
    calculateConstantSpeedVerticalSpeedFromThrust(totalNetThrust, tas, aircraftWeight, cl) {
        return VNavUtils.getVerticalSpeedFromFpa(this.calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl), tas);
    }
    /**
     * Calculates a total net thrust at a constant speed for a given FPA
     * @param fpa Flight Path Angle in degrees (+ve = up)
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForFpa(fpa, aircraftWeight, cl) {
        return aircraftWeight * (Math.sin(fpa * Avionics.Utils.DEG2RAD) + 1 / this.calculateEfficiency(cl));
    }
    /**
     * Calculates a total net thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/sec
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl) {
        return this.calculateConstantSpeedThrustForFpa(VNavUtils.getFpaFromVerticalSpeed(vs, tas), aircraftWeight, cl);
    }
    /**
     * Calculates a gross thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/sec
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param enginesAvailable The number of engines currently running to provide the thrust
     * @param altitude Altitude in feet
     * @param isaDeviation ISA temperature deviation in °C
     * @returns Total Net Thrust in LBS.
     */
    calculateCorrectedN1ForVerticalSpeed(vs, tas, aircraftWeight, enginesAvailable, altitude, isaDeviation) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude, isaDeviation);
        const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
        const mach = AeroMath.tasToMach(UnitType.KNOT.convertTo(tas, UnitType.MPS), AeroMath.soundSpeedAir(ambientTemperature));
        const cl = this.calculateCL(aircraftWeight, ambientPressure, mach);
        const netThrust = this.calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl);
        const netThrustPerEngine = netThrust / Math.max(1, enginesAvailable);
        const grossThrustPerEngine = this.findGrossThrustFromNetThrust(netThrustPerEngine, mach, altitude, ambientTemperature, ambientPressure);
        return this.calculateCorrectedN1FromThrust(grossThrustPerEngine, mach);
    }
    /**
     * Calculates fuel flow from a corrected thrust and corrected ram drag.
     * @param thrust Corrected Net thrust (if ram drag is given) or corrected gross thrust, in LBS.
     * @param ramDrag An optional corrected ram drag, in LBS.
     * @returns The calculated fuel flow, in LBS/HR.
     */
    calculateFuelFlowFromThrust(thrust, ramDrag) {
        if (ramDrag !== undefined) {
            return (thrust + ramDrag) * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
        }
        return thrust * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param n1 The corrected N1 percent.
     * @param mach The mach number.
     * @returns The corrected gross thrust, in pounds, at the specified corrected N1 and mach.
     */
    calculateThrustFromCorrectedN1(n1, mach) {
        return this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(n1, mach) * this.aircraftFlightModel.static_thrust;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param grossThrust The corrected gross thrust, in pounds
     * @param mach The mach number.
     * @returns The corrected N1 percent.
     */
    calculateCorrectedN1FromThrust(grossThrust, mach) {
        return this.aircraftFlightModel.thrust_and_mach_on_n1_table.get(grossThrust / this.aircraftFlightModel.static_thrust, mach);
    }
    /**
     * Calculates idle corrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @returns The idle corrected N1 (%) at the specified mach number.
     */
    calculateIdleCorrectedN1(ambientTemperature, mach) {
        // TODO Should this use ambient or TAT? We call it with TAT right now
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        return (mach * this.aircraftFlightModel.mach_influence_on_n1) + (this.aircraftFlightModel.low_idle_n1 / Math.sqrt(thetaTotalTempRatio));
    }
    /**
     * Calculates uncorrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @param correctedN1 The corrected n1.
     * @returns The uncorrected N1 (%) at the specified mach number.
     */
    uncorrectN1(ambientTemperature, mach, correctedN1) {
        const totalInletTempMachRise = 1.0 + 0.2 * mach * mach;
        const StandardSeaLevelTemperature = BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        const ambientRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const theta_temperature_ratio = ambientRankine / StandardSeaLevelTemperature;
        const thetaTotalTempRatio = theta_temperature_ratio * totalInletTempMachRise;
        return correctedN1 * Math.sqrt(thetaTotalTempRatio);
    }
    /**
     * Calculates idle corrected gross thrust, in LBS, for one engine.
     * @param ambientTemperature The Ambient Temperature at the aircraft location in C.
     * @param mach The current aircraft mach number.
     * @returns The idle corrected gross thrust, in LBS, for one engine.
     */
    calculateIdleThrust(ambientTemperature, mach) {
        return this.calculateThrustFromCorrectedN1(this.calculateIdleCorrectedN1(ambientTemperature, mach), mach);
    }
    /**
     * Calculates engine uncorrected ram drag in LBS.
     * @param mach The aircraft mach number.
     * @param n1 The engine N1 value in %.
     * @param ambientTemperature The aircraft Ambient Temperature in C.
     * @param ambientPressure The aircraft Ambient Pressure in inHg.
     * @param inletTemp The aircraft Inlet Temperature in Rankine.
     * @returns The engine uncorrected ram drag in LBS.
     */
    calculateRamDrag(mach, n1, ambientTemperature, ambientPressure, inletTemp) {
        const airflowTableResult = this.aircraftFlightModel.corrected_airflow_table.get(n1, mach);
        const correctedAirflow = airflowTableResult * this.aircraftFlightModel.inlet_area;
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        const deltaTotalPressureRatio = deltaPressureRatio * totalInletPressureMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE; //Divide by sim normal SL temp constant to get thetaTTR
        const airflow = correctedAirflow * deltaTotalPressureRatio / Math.sqrt(thetaTotalTempRatio);
        const speedOfSound = BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemperature);
        return speedOfSound * mach * airflow / BoeingAeroMath.gravity; // Ram Drag in pounds
    }
    /**
     * Finds the gross thrust for a given net thrust, mach, and altitude.
     * @param netThrust The Net Thrust Value.
     * @param mach The Mach number.
     * @param altitude The altitude in FT.
     * @param ambientTemperature The ambient temperature in C.
     * @param ambientPressure The ambient pressure in inHg.
     * @returns Gross Thrust in LBS.
     */
    findGrossThrustFromNetThrust(netThrust, mach, altitude, ambientTemperature, ambientPressure) {
        if (!ambientTemperature || !ambientPressure) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            if (!ambientTemperature) {
                ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            }
            if (!ambientPressure) {
                ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            }
        }
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const thrustCorrectionFactor = BoeingAeroMath.calculateThrustCorrectionFactor(mach, ambientPressure);
        netThrust = netThrust * thrustCorrectionFactor;
        let lowN1 = 0;
        let highN1 = 110;
        let numIterations = 0;
        let estimatedGrossThrust = 0;
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const lowGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(lowN1, mach) * this.aircraftFlightModel.static_thrust;
        const highGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(highN1, mach) * this.aircraftFlightModel.static_thrust;
        let lowNetThrust = lowGrossThrust - this.calculateRamDrag(mach, lowN1, ambientTemperature, ambientPressure, inletTemp) / thrustCorrectionFactor;
        let highNetThrust = highGrossThrust - this.calculateRamDrag(mach, highN1, ambientTemperature, ambientPressure, inletTemp) / thrustCorrectionFactor;
        const epsilon = this.aircraftFlightModel.static_thrust * 0.001;
        while (numIterations < 100) {
            const estimatedN1 = MathUtils.lerp(netThrust, lowNetThrust, highNetThrust, lowN1, highN1);
            estimatedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(estimatedN1, mach)
                * this.aircraftFlightModel.static_thrust;
            const estimatedNetThrust = estimatedGrossThrust
                - (this.calculateRamDrag(mach, estimatedN1, ambientTemperature, ambientPressure, inletTemp) / thrustCorrectionFactor);
            if (Math.abs(estimatedNetThrust - netThrust) < epsilon) {
                return estimatedGrossThrust / thrustCorrectionFactor;
            }
            const errorSign = Math.sign(estimatedNetThrust - netThrust);
            if (errorSign < 0) {
                lowN1 = estimatedN1;
                lowNetThrust = estimatedNetThrust;
            }
            else {
                highN1 = estimatedN1;
                highNetThrust = estimatedNetThrust;
            }
            numIterations++;
        }
        return estimatedGrossThrust / thrustCorrectionFactor;
    }
}
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;

const definitions = {
    'manualZfw': {
        defaultValue: null,
    },
    'manualGw': {
        defaultValue: null,
    },
    'takeoffGw': {
        defaultValue: null,
    },
    'cruiseCg': {
        defaultValue: null,
    },
    'manualLateralRnp': {
        defaultValue: null,
    },
    'manualVerticalRnp': {
        defaultValue: null,
    },
    'takeoffFlaps': {
        defaultValue: null,
    },
    'takeoffCg': {
        defaultValue: null,
    },
    'takeoffAssumedTemp': {
        defaultValue: null,
    },
    'takeoffThrustMode': {
        defaultValue: TakeoffThrustMode.TO,
    },
    'takeoffThrustReductionPoint': {
        defaultValue: 1500,
    },
    'takeoffAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffEoAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffTemp': {
        defaultValue: null,
    },
    'takeoffWind': {
        defaultValue: null,
    },
    'takeoffRunwayWind': {
        defaultValue: null,
    },
    'takeoffRunwaySlope': {
        defaultValue: 0,
    },
    'takeoffRunwayCondition': {
        defaultValue: RunwayCondition.DRY,
    },
    'climbSpeedMaxAngle': {
        defaultValue: 215, // TODO Replace with actual value
    },
    'climbThrustMode': {
        defaultValue: ClimbThrustMode.CLB,
    },
    'climbSegmentExists': {
        defaultValue: false,
    },
    'cruiseRequiredTpr': {
        defaultValue: 0, // TODO Replace with actual value
    },
    'takeoffAirportIcao': {
        defaultValue: null,
    },
    'takeoffRunway': {
        defaultValue: null,
    },
    'approachAirportIcao': {
        defaultValue: null,
    },
    'approachRunway': {
        defaultValue: null,
    },
    'approachLandingRef': {
        defaultValue: 1,
    },
    'glideSlope': {
        defaultValue: GlideslopeStatus.ON,
        differentiateInModPlan: true,
    },
    'approachWindCorrection': {
        defaultValue: 5,
    },
    'approachFlapSpeed': {
        defaultValue: null,
    },
    'cruiseAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedLimitCas': {
        defaultValue: 240,
    },
    'climbSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'climbSpeedRestrCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedRestrAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'descentSpeedLimitCas': {
        defaultValue: 240,
    },
    'descentSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'descentSpeedRestrCas': {
        defaultValue: null,
    },
    'descentSpeedRestrAltitude': {
        defaultValue: null,
    },
    'transitionAltitude': {
        defaultValue: 18000,
    },
    'transitionLevel': {
        defaultValue: 18000,
    },
    'stepSize': {
        defaultValue: 'ICAO',
    },
    'reserveFuel': {
        defaultValue: null,
    },
    'costIndex': {
        defaultValue: null,
    },
    'currentThrustMode': {
        defaultValue: null,
    },
    'speedMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbMode': {
        defaultValue: SpeedMode.ECON,
    },
    'speedClimbEconCas': {
        defaultValue: 310, // TODO Replace with actual value
    },
    'speedClimbEconMach': {
        defaultValue: .85, // TODO Replace with actual value
    },
    'speedClimbSelectCas': {
        defaultValue: null,
    },
    'speedClimbSelectMach': {
        defaultValue: null,
    },
    'speedCruiseMode': {
        defaultValue: SpeedMode.ECON,
    },
    'speedCruiseEconCas': {
        defaultValue: 310, // TODO Replace with actual value
    },
    'speedCruiseEconMach': {
        defaultValue: .850, // TODO Replace with actual value
    },
    'speedCruiseEconUnit': {
        defaultValue: 'cas',
    },
    'speedCruiseSelectCas': {
        defaultValue: null,
    },
    'speedCruiseSelectMach': {
        defaultValue: null,
    },
    'speedDescentMode': {
        defaultValue: SpeedMode.ECON,
    },
    'speedDescentEconCas': {
        defaultValue: 290, // TODO Replace with actual value
    },
    'speedDescentEconMach': {
        defaultValue: .850, // TODO Replace with actual value
    },
    'speedDescentSelectCas': {
        defaultValue: null,
    },
    'speedDescentSelectMach': {
        defaultValue: null,
    },
    'thermalAntiIceAltitude': {
        defaultValue: null,
    },
    'alternateCruiseAltitude': {
        defaultValue: 37000,
    },
    'alternateSpeedValue': {
        defaultValue: 250,
    },
    'alternateSpeedIsMach': {
        defaultValue: false,
    },
};

/**
 * Proxied `MutableSubscribable` that mirrors a property desired to be accessed by {@link PerformancePlanProxy}
 */
class ProxiedPerformancePlanProperty extends AbstractSubscribable {
    /**
     * Ctor
     *
     * @param key property key
     * @param proxy the proxy this property belongs to
     * @param editInPlace whether the property can be edited without a new flight plan being created
     */
    constructor(key, proxy, editInPlace = false) {
        super();
        this.key = key;
        this.proxy = proxy;
        this.editInPlace = editInPlace;
        this.targetPlan = null;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subject = Subject.create(null);
        this.backSubjectSubscription = undefined;
    }
    /**
     * Switches the target plan
     *
     * @param plan the new target plan
     */
    switchToPlan(plan) {
        var _a;
        this.targetPlan = plan;
        (_a = this.backSubjectSubscription) === null || _a === void 0 ? void 0 : _a.destroy();
        this.backSubjectSubscription = this.backingSubject().sub((it) => {
            this.subject.set(it);
        }, true);
    }
    /**
     * Returns the backing subject in the target plan for the property
     *
     * @returns the subject
     *
     * @throws if no target plan exists
     */
    backingSubject() {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        return this.targetPlan[this.key];
    }
    /**
     * Resets the property to its default value according to the default values performance plan
     */
    resetToDefault() {
        const defaultValue = this.proxy.defaultValuesPlan[this.key];
        this.proxy.onBeforeEdit(this, defaultValue);
        this.backingSubject().set(defaultValue.get());
        this.proxy.onAfterEdit(this, defaultValue);
    }
    /** @inheritDoc */
    get() {
        if (!this.targetPlan) {
            return null;
        }
        return this.backingSubject().get();
    }
    /** @inheritDoc */
    set(value) {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        this.proxy.onBeforeEdit(this, value);
        this.backingSubject().set(value);
        this.proxy.onAfterEdit(this, value);
    }
    /** @inheritDoc */
    sub(handler, initialNotify, paused) {
        return this.subject.sub(handler, initialNotify, paused);
    }
    /** @inheritDoc */
    unsub(handler) {
        return this.subject.unsub(handler);
    }
}

/**
 * Utils for performance plans
 */
class PerformancePlanUtils {
    /**
     * Serializes a plan
     *
     * @param plan the plan to serialize
     *
     * @returns the serialized JSON string
     */
    static serialize(plan) {
        const tmpObj = {};
        Object.keys(plan).forEach((key) => {
            tmpObj[key] = plan[key].get();
        });
        return JSON.stringify(tmpObj);
    }
    /**
     * Deserializes a serialized performance plan into a plan
     *
     * @param data the serialized data string
     * @param plan the plan to deserialize into
     */
    static deserializeInto(data, plan) {
        const customData = JSON.parse(data);
        Object.keys(customData).forEach((key) => {
            const value = customData[key];
            if (value !== undefined) {
                plan[key].set(value);
            }
        });
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @returns a performance plan with default values filled
     */
    static createPlanFromDefinitions() {
        const plan = {};
        for (const [key, definition] of Object.entries(definitions)) {
            plan[key] = Subject.create(definition.defaultValue);
        }
        return plan;
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @param partialProxy an object containing the callbacks to attach to the proxy
     *
     * @returns a performance plan with default values filled
     */
    static createProxyFromDefinitions(partialProxy) {
        const proxy = {
            defaultValuesPlan: partialProxy.defaultValuesPlan,
            /** @inheritDoc */
            switchToPlan(plan, initial) {
                for (const [key, definition] of Object.entries(definitions)) {
                    if (initial || definition.differentiateInModPlan) {
                        this[key].switchToPlan(plan);
                    }
                }
            },
            /** @inheritDoc */
            onBeforeEdit(property, newValue) {
                partialProxy.onBeforeEdit(property, newValue);
            },
            /** @inheritDoc */
            onAfterEdit(property, newValue) {
                partialProxy.onAfterEdit(property, newValue);
            },
        };
        for (const [key, definition] of Object.entries(definitions)) {
            const property = new ProxiedPerformancePlanProperty(key, proxy, !definition.differentiateInModPlan);
            proxy[key] = property;
        }
        return proxy;
    }
}

/**
 * Correlates flight plan indices with performance plan objects
 */
class PerformancePlanRepository {
    /**
     * Ctor
     * @param flightPlanner a flight planner instance
     * @param bus the event bus
     */
    constructor(flightPlanner, bus) {
        this.flightPlanner = flightPlanner;
        this.bus = bus;
        this.repoId = Math.floor(Math.random() * 10000000);
        this._plans = [];
        this.plans = this._plans;
        this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[BoeingFms.ACT_RTE_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        const sub = this.bus.getSubscriber();
        sub.on('fplOriginDestChanged').handle((data) => {
            if (data.type === OriginDestChangeType.OriginAdded || data.type === OriginDestChangeType.OriginRemoved) {
                this.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, data.planIndex);
            }
        });
        sub.on('performancePlanChanged').handle((data) => {
            if (data.repoId !== this.repoId) {
                PerformancePlanUtils.deserializeInto(data.serializedPlan, this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX]);
                if (this.has(data.planIndex)) {
                    this.copy(PerformancePlanRepository.SYNC_PLAN_INDEX, data.planIndex, true);
                }
            }
        });
    }
    /**
     * Whether the repository has a performance plan already stored for a given index
     *
     * @param index the index
     *
     * @returns boolean
     */
    has(index) {
        return this._plans[index] !== undefined;
    }
    /**
     * Returns a performance plan for a given flight plan index, or creates it
     *
     * @param index flight plan index
     *
     * @throws if an invalid flight plan index is specified
     *
     * @returns the performance plan
     */
    forFlightPlanIndex(index) {
        const existing = this._plans[index];
        if (!existing) {
            return this.create(index);
        }
        return existing;
    }
    /**
     * Gets the active plan. This is the plan that always exists even if there is no valid flight plan yet.
     * @returns the active plan
     */
    getActivePlan() {
        return this._plans[0];
    }
    /**
     * Returns the performance plan containing default values
     *
     * @returns the plan
     */
    defaultValuesPlan() {
        return this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX];
    }
    /**
     * Returns whether this plan repository has nay valid plans
     *
     * @returns boolean
     */
    hasAnyPlan() {
        return this._plans.some((it, index) => !!it && this.flightPlanner.hasFlightPlan(index));
    }
    /**
     * Creates a performance plan at the given index if it doesn't exist, or returns the existing one
     *
     * @param atIndex the index
     *
     * @returns the created plan
     */
    create(atIndex) {
        if (!this.has(atIndex)) {
            const newPerformancePlan = PerformancePlanUtils.createPlanFromDefinitions();
            this._plans[atIndex] = newPerformancePlan;
            return newPerformancePlan;
        }
        else {
            return this._plans[atIndex];
        }
    }
    /**
     * Copies a performance plan onto another
     *
     * @param from from index
     * @param to to index
     * @param skipChecks whether to skip flight planner checks
     */
    copy(from, to, skipChecks = false) {
        const fromPlan = this._plans[from];
        const toPlan = skipChecks ? this._plans[to] : this.forFlightPlanIndex(to);
        // Copy data
        for (const key in toPlan) {
            const fromValue = fromPlan[key];
            const toValue = toPlan[key];
            if (fromValue instanceof Subject && toValue instanceof Subject) {
                toValue.set(fromValue.get());
            }
        }
    }
    /**
     * Triggers a synchronisation of the active plan performance plan over the EventBus.
     * @param planIndex the plan index
     */
    triggerSync(planIndex) {
        const packet = {
            repoId: this.repoId,
            planIndex,
            serializedPlan: PerformancePlanUtils.serialize(this._plans[planIndex]),
        };
        this.bus.getPublisher().pub('performancePlanChanged', packet, true, true);
    }
}
PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX = Number.MAX_SAFE_INTEGER;
PerformancePlanRepository.SYNC_PLAN_INDEX = PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX - 1;

const refsSettings = [
    {
        name: 'minimumsMode',
        defaultValue: MinimumsMode.OFF,
    },
    {
        name: 'decisionHeightFeet',
        defaultValue: 0,
    },
    {
        name: 'decisionAltitudeFeet',
        defaultValue: 0,
    },
    {
        name: 'metricAltitudeDisplay',
        defaultValue: false,
    },
    {
        name: 'fltNumber',
        defaultValue: '',
    },
    {
        name: 'posIsInitialized',
        defaultValue: false,
    },
    {
        name: 'fpvActive',
        defaultValue: false,
    },
];
/** Utility class for retrieving Refs user setting managers. */
class CockpitUserSettings {
    /**
     * Retrieves a manager for Refs user settings.
     * @param bus The event bus.
     * @returns a manager for Refs user settings.
     */
    static getManager(bus) {
        if (CockpitUserSettings.INSTANCE === undefined) {
            CockpitUserSettings.INSTANCE = new DefaultUserSettingManager(bus, refsSettings);
            CockpitUserSettings.wireSettings(CockpitUserSettings.INSTANCE);
        }
        return CockpitUserSettings.INSTANCE;
    }
    /**
     * Wires up any special setttings handlers.
     * @param settingsManager The settings manager.
     */
    static wireSettings(settingsManager) {
        CockpitUserSettings.subs.push(settingsManager.getSetting('fltNumber').sub(fltNumber => {
            // strip the first 1-3 letters from the callsign to get only the numbers to feed to the default ATC
            const justTheNumber = fltNumber.includes('-') || fltNumber.length === 0
                ? '0'
                : fltNumber.replace(/^([A-Z]{1,3})/, '');
            SimVar.SetSimVarValue('ATC FLIGHT NUMBER', SimVarValueType.String, justTheNumber);
        }));
    }
}
CockpitUserSettings.subs = [];

var VSpeedType;
(function (VSpeedType) {
    VSpeedType["V1"] = "V1";
    VSpeedType["Vr"] = "Vr";
    VSpeedType["V2"] = "V2";
    // Venr = 'Venr',
    // Vapp = 'Vapp',
    VSpeedType["Vref"] = "Vref";
})(VSpeedType || (VSpeedType = {}));
/** Utility class for retrieving the vspeeds user setting manager. */
class VSpeedUserSettings {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        const settingDefs = [];
        for (const vspeed in VSpeedType) {
            settingDefs.push({
                name: `vspeed_value_${vspeed}`,
                defaultValue: 0
            });
        }
        this.manager = new DefaultUserSettingManager(bus, settingDefs);
    }
    /**
     * Get an instance of VSpeedUserSettings.
     * @param bus The event bus.
     * @returns An instance of VSpeedUserSettings.
     */
    static getManager(bus) {
        if (VSpeedUserSettings.INSTANCE === undefined) {
            VSpeedUserSettings.INSTANCE = new VSpeedUserSettings(bus);
        }
        return VSpeedUserSettings.INSTANCE;
    }
    /** @inheritdoc */
    getSettings(type) {
        return {
            value: this.manager.getSetting(`vspeed_value_${type}`)
        };
    }
}

var _a$1;
/** A calculator for fix info intersections and predictions data */
class BoeingFixInfoCalculator {
    /**
     * Instantiates a Fix Info Calculator
     * @param bus The event bus
     * @param fms Boeing FMS
     * @param maxDistance Maximum distance in metres
     */
    constructor(bus, fms, maxDistance) {
        this.bus = bus;
        this.fms = fms;
        this.maxDistance = maxDistance;
        /** sim time as a unix timestamp in milliseconds */
        this.simTime = ConsumerValue.create(null, 0);
        /** Whether FMS position is currently available */
        this.fmsPositionAvailable = true;
        this.simTime.setConsumer(this.bus.getSubscriber().on('simTime'));
        this.bus.getSubscriber().on('fms_pos_anp_1').whenChangedBy(1).handle((anp) => this.fmsPositionAvailable = anp > 0);
    }
    /**
     * Calculates the time or altitude distance prediction
     * @param fixInfo The pilot-entered input data
     * @param out Output data for the CDU page
     */
    calculateEtaAltitudePrediction(fixInfo, out) {
        // calculate predicted distance to altitude or time
        if (fixInfo.predictedTime !== null && fixInfo.predictedTime > this.simTime.get()) {
            const prediction = this.fms.activeRoutePredictor.getPredictionsForTime(fixInfo.predictedTime / 1000);
            out.etaAltitudePrediction = prediction && isFinite(prediction.distance) ? prediction.distance : null;
        }
        else if (fixInfo.predictedAltitude !== null) {
            const prediction = this.fms.activeRoutePredictor.getPredictionsForAltitude(fixInfo.predictedAltitude);
            out.etaAltitudePrediction = prediction && isFinite(prediction.distance) ? prediction.distance : null;
        }
        else {
            out.etaAltitudePrediction = null;
        }
    }
    /**
     * Calculates fix info predictions and intersections
     * @param plan Active flight plan
     * @param fixInfo The pilot-entered input data
     * @param calcData Output data for the CDU page
     */
    calculateFixPredictions(plan, fixInfo, calcData) {
        if (fixInfo.fix === null || !plan) {
            this.clearCalculatedFixData(calcData);
            return;
        }
        calcData.fixIdent = fixInfo.fixIdent;
        // calculate the bearing/distance from the fix to ppos
        if (this.fmsPositionAvailable) {
            calcData.fixDistance = MathUtils.clamp(UnitType.GA_RADIAN.convertTo(this.fms.ppos.distance(fixInfo.fix.lat, fixInfo.fix.lon), UnitType.METER), 0, this.maxDistance);
            const trueBearing = this.fms.ppos.bearingFrom(fixInfo.fix.lat, fixInfo.fix.lon);
            calcData.fixBearing = this.fms.trueRef.get() ? trueBearing : MagVar.trueToMagnetic(trueBearing, fixInfo.fixMagVar);
        }
        else {
            calcData.fixDistance = null;
            calcData.fixBearing = null;
        }
        calcData.abeamCalculated = fixInfo.calculateAbeamPoint;
        this.predictIntersection(plan, fixInfo, fixInfo.abeamIntersection, calcData.abeamPredictions);
        for (const [i, intersection] of fixInfo.bearingDistanceIntersections.entries()) {
            const predictions = calcData.bearingDistancePredictions[i];
            this.predictIntersection(plan, fixInfo, intersection, predictions);
        }
    }
    /**
     * Clear all the calculated data from the object
     * @param calcData Calculated data object
     */
    clearCalculatedFixData(calcData) {
        calcData.abeamPredictions.bearing = null;
        calcData.abeamPredictions.distance = null;
        calcData.abeamPredictions.eta = null;
        calcData.abeamPredictions.dtg = null;
        calcData.abeamPredictions.altitude = null;
        calcData.bearingDistancePredictions.forEach((p) => {
            p.bearing = null;
            p.distance = null;
            p.eta = null;
            p.dtg = null;
            p.altitude = null;
        });
        calcData.fixBearing = null;
        calcData.fixDistance = null;
        calcData.fixIdent = null;
    }
    /**
     * Predict the bearing/distance/eta/dtg/altitude for a flight plan intersection
     * @param plan Flight plan
     * @param fixInfo Fix Info
     * @param intersection Intersection to predict
     * @param predictions Object to store the results
     */
    predictIntersection(plan, fixInfo, intersection, predictions) {
        if (!this.fmsPositionAvailable || !this.isIntersectionValid(intersection)) {
            this.resetIntersectionPrediction(predictions);
            return;
        }
        const distanceFromPpos = this.calculateDistanceFromPpos(plan, intersection);
        const prediction = distanceFromPpos !== null ? this.fms.activeRoutePredictor.getPredictionsForDistance(distanceFromPpos) : undefined;
        if (prediction === null || prediction === void 0 ? void 0 : prediction.valid) {
            predictions.eta = prediction.estimatedTimeOfArrival * 1000;
            predictions.dtg = prediction.distance;
            predictions.altitude = prediction.altitude;
        }
        else {
            this.resetIntersectionPrediction(predictions);
        }
    }
    /**
     * Reset on intersection prediction object to empty values
     * @param predictions Object to store the results
     */
    resetIntersectionPrediction(predictions) {
        predictions.eta = null;
        predictions.dtg = null;
        predictions.altitude = null;
    }
    /**
     * Checks if an intersection is valid
     * @param intersection Flight plan intersection data
     * @returns true if the intersection is valid/calculated
     */
    isIntersectionValid(intersection) {
        return intersection.distanceAlongLeg !== null && intersection.flightPlanLeg !== null;
    }
    /**
     * Calculate the cumulative distance for a distance along a flight plan leg
     * @param plan Flight plan
     * @param intersection Intersection to predict
     * @returns distance in metres or null
     */
    calculateDistanceFromPpos(plan, intersection) {
        if (intersection.flightPlanLeg === null || intersection.distanceAlongLeg === null) {
            return null;
        }
        const leg = plan.tryGetLeg(intersection.flightPlanLeg);
        if (!leg || !leg.calculated) {
            return null;
        }
        return leg.calculated.cumulativeDistanceWithTransitions - leg.calculated.distanceWithTransitions + intersection.distanceAlongLeg;
    }
    /**
     * Reset a flight plan intersection bearing and distance to null values
     * @param predictions The predictions object to reset bearing/distance on
     */
    resetIntersectionBearingDistance(predictions) {
        predictions.bearing = null;
        predictions.distance = null;
    }
    /**
     * Calculate the bearing and distance from the fix info fix to a flight plan intersection point
     * @param fixInfo The fix info this relates to
     * @param intersection The flight plan ntersection
     * @param predictions The predictions object for output
     * @param pilotBearing Pilot entered bearing in true degrees or null if none
     * @param pilotDistance Pilot entered distance in metres or null if none
     */
    calculateIntersectionBearingDistance(fixInfo, intersection, predictions, pilotBearing = null, pilotDistance = null) {
        let trueBearing = pilotBearing;
        let distance = pilotDistance;
        if (this.isIntersectionValid(intersection)) {
            if (trueBearing === null) {
                trueBearing = fixInfo.fixLocationSpherical.bearingTo(intersection.point);
            }
            if (distance === null) {
                distance = UnitType.METER.convertFrom(fixInfo.fixLocationSpherical.distance(intersection.point), UnitType.GA_RADIAN);
            }
        }
        predictions.bearing = this.fms.trueRef.get() || trueBearing === null ? trueBearing : MagVar.trueToMagnetic(trueBearing, fixInfo.fixMagVar);
        predictions.distance = distance;
    }
    /**
     * Calculates the bearings and distances from the fix to flight plan intersections
     * @param fixInfos All of the fix infos
     * @param calcDatas Corresponding calculated data objects
     */
    calculateIntersectionBearingDistances(fixInfos, calcDatas) {
        for (const [i, fixInfo] of fixInfos.entries()) {
            const calcData = calcDatas[i];
            if (fixInfo.calculateAbeamPoint) {
                this.calculateIntersectionBearingDistance(fixInfo, fixInfo.abeamIntersection, calcData.abeamPredictions);
            }
            else {
                this.resetIntersectionBearingDistance(calcData.abeamPredictions);
            }
            for (const [j, intersection] of fixInfo.bearingDistanceIntersections.entries()) {
                const [pilotBearing, pilotDistance] = fixInfo.bearingDistances[j];
                this.calculateIntersectionBearingDistance(fixInfo, intersection, calcData.bearingDistancePredictions[j], pilotBearing, pilotDistance);
            }
        }
    }
    /**
     * Clear data from a calculated flight plan intersection
     * @param intersection Flight plan intersection object to clear
     */
    clearIntersection(intersection) {
        intersection.distanceAlongLeg = null;
        intersection.flightPlanLeg = null;
    }
    /**
     * Clear data from a calculated flight plan intersection
     * @param fixInfo The fix info to clear
     */
    clearFixIntersections(fixInfo) {
        this.clearIntersection(fixInfo.abeamIntersection);
        for (const intersection of fixInfo.bearingDistanceIntersections) {
            this.clearIntersection(intersection);
        }
    }
    /**
     * Reset flight plan intersections to null values for all fix infos
     * @param fixInfos All of the fix infos
     */
    clearAllFixIntersections(fixInfos) {
        for (const fixInfo of fixInfos) {
            this.clearFixIntersections(fixInfo);
        }
    }
    /**
     * Calculates intersections with the active flight plan for fix infos
     * @param plan The active flight plan
     * @param fixInfos All of the fix infos
     */
    calculateAllIntersections(plan, fixInfos) {
        this.clearAllFixIntersections(fixInfos);
        if (plan.length < 2) {
            return;
        }
        for (let globalLegIndex = plan.activeLateralLeg - 1;; globalLegIndex++) {
            const leg = plan.tryGetLeg(globalLegIndex);
            if (!leg) {
                break;
            }
            const allIntersectionsFound = this.calculateIntersectionsForLeg(leg, globalLegIndex, fixInfos);
            if (allIntersectionsFound) {
                return;
            }
        }
    }
    /**
     * Calculates intersections with the flightplan for the given set of fix infos, where intersections don't already exist
     * @param leg Flight plan leg to intersect
     * @param globalLegIndex Index of this leg
     * @param fixInfos The fix infos that should try to intersect the vector
     * @returns true if there are no remaining intersections to find
     */
    calculateIntersectionsForLeg(leg, globalLegIndex, fixInfos) {
        if (!leg.calculated || leg.calculated.flightPath.length < 1) {
            return false;
        }
        let remainingIntersections = false;
        let accumulatedDistance = 0;
        for (const vector of leg.calculated.flightPath) {
            // make a great circle through the centre of the flight path arc, and the fix... find intercepts with the flight path circle
            const vectorCircle = FlightPathUtils.setGeoCircleFromVector(vector, BoeingFixInfoCalculator.geoCircleCache[0]);
            const vectorStart = BoeingFixInfoCalculator.geoPointCache[0].set(vector.startLat, vector.startLon);
            const vectorEnd = BoeingFixInfoCalculator.geoPointCache[1].set(vector.endLat, vector.endLon);
            const vectorDistance = FlightPathUtils.getAlongArcSignedDistance(vectorCircle, vectorStart, vectorEnd, vectorEnd);
            for (const fixInfo of fixInfos) {
                if (fixInfo.fix === null) {
                    continue;
                }
                if (fixInfo.calculateAbeamPoint && fixInfo.abeamIntersection.flightPlanLeg === null) {
                    const abeamCircle = this.calculateAbeamCircle(fixInfo, vectorCircle);
                    if (!this.calculateFlightPathIntersection(globalLegIndex, accumulatedDistance, vectorDistance, abeamCircle, vectorCircle, vectorStart, vectorEnd, fixInfo.abeamIntersection)) {
                        remainingIntersections = true;
                    }
                }
                for (const [i, [pilotBearing, pilotDistance]] of fixInfo.bearingDistances.entries()) {
                    let bearingDistanceCircle;
                    // intersections are only calculated if pilot enteres either bearing *or* distance, not both
                    if (pilotBearing !== null && pilotDistance === null) {
                        bearingDistanceCircle = this.calculateFixBearingCircle(fixInfo, pilotBearing);
                    }
                    else if (pilotBearing === null && pilotDistance !== null) {
                        bearingDistanceCircle = this.calculateFixDistanceCircle(fixInfo, pilotDistance);
                    }
                    else {
                        continue;
                    }
                    if (!this.calculateFlightPathIntersection(globalLegIndex, accumulatedDistance, vectorDistance, bearingDistanceCircle, vectorCircle, vectorStart, vectorEnd, fixInfo.bearingDistanceIntersections[i])) {
                        remainingIntersections = true;
                    }
                }
            }
            if (!remainingIntersections) {
                break;
            }
            accumulatedDistance += vectorDistance;
        }
        return !remainingIntersections;
    }
    /**
     * Create a great circle from a fix info fix through the centre of a flight path vector circle
     * @param fixInfo A fix info
     * @param pathCircle A flight path vector circle
     * @returns A great circle
     */
    calculateAbeamCircle(fixInfo, pathCircle) {
        return BoeingFixInfoCalculator.geoCircleCache[1].setAsGreatCircle(fixInfo.fixLocationCartesian, pathCircle.center);
    }
    /**
     * Create a great circle from a fix info fix at a true bearing
     * @param fixInfo A fix info
     * @param bearing Bearing from the fix info in true degrees
     * @returns A great circle
     */
    calculateFixBearingCircle(fixInfo, bearing) {
        return BoeingFixInfoCalculator.geoCircleCache[1].setAsGreatCircle(fixInfo.fixLocationCartesian, bearing);
    }
    /**
     * Create a small circle around a fix info fix at a given radius/distance
     * @param fixInfo A fix info
     * @param distance Distance from the fix info in metres
     * @returns A small circle
     */
    calculateFixDistanceCircle(fixInfo, distance) {
        return BoeingFixInfoCalculator.geoCircleCache[1].set(fixInfo.fixLocationCartesian, UnitType.GA_RADIAN.convertFrom(distance, UnitType.METER));
    }
    /**
     * Finds an intersection with a flight path vector
     * @param globalLegIndex index of the flight plan leg this vector belongs to
     * @param accumulatedDistance distance along the leg up to the start of this vector in great circle radians
     * @param vectorDistance distance along this vector in great circle radians
     * @param intersectionCircle the small or great circle defined by the fix info, must be centred at the fix info fix
     * @param vectorCircle the flight path circle
     * @param vectorStart starting point of the flight path vector
     * @param vectorEnd ending point of the flight path vector
     * @param intersectionData output data if an intersection is found
     * @returns true if intersection found
     */
    calculateFlightPathIntersection(globalLegIndex, accumulatedDistance, vectorDistance, intersectionCircle, vectorCircle, vectorStart, vectorEnd, intersectionData) {
        let foundIntersection = false;
        const numIntersections = intersectionCircle.intersection(vectorCircle, BoeingFixInfoCalculator.vec3Cache);
        if (numIntersections > 0) {
            for (let i = 0; i < numIntersections; i++) {
                const intersection = BoeingFixInfoCalculator.vec3Cache[i];
                const alongPathDistance = FlightPathUtils.getAlongArcNormalizedDistance(vectorCircle, vectorStart, vectorEnd, intersection);
                if (alongPathDistance >= 0 && alongPathDistance <= 1) {
                    const distanceAlongLeg = Math.abs(UnitType.METER.convertFrom(accumulatedDistance + alongPathDistance * vectorDistance, UnitType.GA_RADIAN));
                    // only take a closer intersection
                    if (intersectionData.distanceAlongLeg !== null && distanceAlongLeg >= intersectionData.distanceAlongLeg) {
                        continue;
                    }
                    intersectionData.flightPlanLeg = globalLegIndex;
                    intersectionData.distanceAlongLeg = Math.abs(UnitType.METER.convertFrom(accumulatedDistance + alongPathDistance * vectorDistance, UnitType.GA_RADIAN));
                    intersectionData.point.setFromCartesian(intersection);
                    foundIntersection = true;
                }
            }
        }
        return foundIntersection;
    }
}
_a$1 = BoeingFixInfoCalculator;
BoeingFixInfoCalculator.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
BoeingFixInfoCalculator.geoCircleCache = [new GeoCircle(_a$1.vec3Cache[0], 0), new GeoCircle(_a$1.vec3Cache[0], 0)];
BoeingFixInfoCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];

/** Boeing Fix Info Implementation */
class BoeingFixInfoManager {
    /**
     * Instantiates the Fix Info subsystem
     * @param bus Event Bus
     * @param fms Parent FMS
     * @param facLoader Facility Loader
     * @param activeRoutePlanIndex Index of the active route flight plan
     */
    constructor(bus, fms, facLoader, activeRoutePlanIndex) {
        this.bus = bus;
        this.fms = fms;
        this.facLoader = facLoader;
        this.activeRoutePlanIndex = activeRoutePlanIndex;
        this.needPredictionsUpdate = false;
        this.needIntersectionsUpdate = false;
        this.ignoreSync = false;
        this.syncDataCache = Array.from({ length: BoeingFixInfoManager.NUM_FIXES }, () => ({
            fixIcao: null,
            bearingDistances: [],
            predictedTime: null,
            predictedAltitude: null,
            calculateAbeamPoint: false,
        }));
        this.fixInfos = Array.from({ length: BoeingFixInfoManager.NUM_FIXES }, () => ({
            fixIcao: null,
            fix: null,
            fixIdent: null,
            fixLocationSpherical: new GeoPoint(0, 0),
            fixLocationCartesian: Vec3Math.create(),
            fixMagVar: 0,
            bearingDistances: Array.from({ length: BoeingFixInfoManager.NUM_BRG_DIST }, () => [null, null]),
            calculateAbeamPoint: false,
            predictedTime: null,
            predictedAltitude: null,
            bearingDistanceIntersections: Array.from({ length: BoeingFixInfoManager.NUM_BRG_DIST }, () => ({
                flightPlanLeg: null,
                distanceAlongLeg: null,
                point: new GeoPoint(0, 0),
            })),
            abeamIntersection: {
                flightPlanLeg: null,
                distanceAlongLeg: null,
                point: new GeoPoint(0, 0),
            },
        }));
        /** FIX INFO page data, {@link BoeingFixInfoManager.NUM_FIXES} elements */
        this.calculatedData = Array.from({ length: BoeingFixInfoManager.NUM_FIXES }, () => ({
            fixIdent: null,
            fixBearing: null,
            fixDistance: null,
            bearingDistancePredictions: Array.from({ length: BoeingFixInfoManager.NUM_BRG_DIST }, () => ({ bearing: null, distance: null, eta: null, dtg: null, altitude: null })),
            abeamCalculated: false,
            abeamPredictions: { bearing: null, distance: null, eta: null, dtg: null, altitude: null },
            etaAltitudePrediction: null,
        }));
        this.ndCache = [];
        this.ndData = ArraySubject.create();
        this.calculator = new BoeingFixInfoCalculator(this.bus, this.fms, BoeingFixInfoManager.MAX_DISTANCE);
        const sub = this.bus.getSubscriber();
        sub.on('simTime').atFrequency(1 / 3).handle(() => this.needPredictionsUpdate = true);
        sub.on('realTime').handle(this.onUpdate.bind(this));
        sub.on('fms_operating_phase').handle((phase) => phase === FmsOperatingPhase.COMPLETE && this.clearAllFixes());
        sub.on('fplCalculated').handle((ev) => ev.planIndex === this.activeRoutePlanIndex && (this.needIntersectionsUpdate = true));
        this.fms.trueRef.sub(() => this.needIntersectionsUpdate = true);
    }
    /**
     * Handle the flightplan user data changed event
     */
    onFlightPlanFixInfoDataChanged() {
        if (this.ignoreSync) {
            return;
        }
        this.readFixInfoFromUserData();
    }
    /**
     * Read the pilot-entered fix info data from the flightplan.
     * Used for syncing data from other FMS instances
     */
    async readFixInfoFromUserData() {
        const userData = this.fms.getFlightPlanFixInfos(this.activeRoutePlanIndex);
        if (!userData) {
            return;
        }
        for (let i = 0; i < BoeingFixInfoManager.NUM_FIXES; i++) {
            const planData = userData[i];
            const fixInfo = this.fixInfos[i];
            if (fixInfo.fixIcao !== (planData === null || planData === void 0 ? void 0 : planData.fixIcao)) {
                // fill in all the data that is cached locally
                if (planData === null || planData === void 0 ? void 0 : planData.fixIcao) {
                    const fix = await this.facLoader.getFacility(ICAO.getFacilityType(planData.fixIcao), planData.fixIcao);
                    fixInfo.fix = fix;
                    fixInfo.fixIdent = ICAO.getIdent(fix.icao);
                    fixInfo.fixLocationSpherical.set(fix.lat, fix.lon);
                    fixInfo.fixLocationSpherical.toCartesian(fixInfo.fixLocationCartesian);
                    fixInfo.fixMagVar = FacilityUtils.getMagVar(fix);
                }
                else {
                    fixInfo.fix = null;
                    fixInfo.fixIdent = null;
                    fixInfo.fixMagVar = 0;
                }
            }
            Object.assign(fixInfo, userData[i]);
        }
        this.needIntersectionsUpdate = true;
        this.needPredictionsUpdate = true;
    }
    /**
     * Write the pilot-entered fix info data to the flightplan.
     * Used for syncing data to other FMS instances.
     */
    writeFixInfoToUserData() {
        this.ignoreSync = true;
        for (const [i, fixInfo] of this.fixInfos.entries()) {
            this.syncDataCache[i].fixIcao = fixInfo.fixIcao;
            this.syncDataCache[i].bearingDistances = fixInfo.bearingDistances;
            this.syncDataCache[i].predictedAltitude = fixInfo.predictedAltitude;
            this.syncDataCache[i].predictedTime = fixInfo.predictedTime;
            this.syncDataCache[i].calculateAbeamPoint = fixInfo.calculateAbeamPoint;
        }
        this.fms.setFlightPlanFixInfos(this.activeRoutePlanIndex, this.syncDataCache);
        this.ignoreSync = false;
    }
    /**
     * Periodic update of fix info calculated data
     */
    onUpdate() {
        if (!this.fms.hasFlightPlan(this.activeRoutePlanIndex)) {
            return;
        }
        const plan = this.fms.getFlightPlan(this.activeRoutePlanIndex);
        if (this.needIntersectionsUpdate) {
            this.needIntersectionsUpdate = false;
            this.calculator.calculateAllIntersections(plan, this.fixInfos);
            this.calculator.calculateIntersectionBearingDistances(this.fixInfos, this.calculatedData);
            this.refreshNdData();
            this.needPredictionsUpdate = true;
            // punt the predictions onto another frame
            return;
        }
        if (!this.needPredictionsUpdate) {
            return;
        }
        this.needPredictionsUpdate = false;
        for (let i = 0; i < BoeingFixInfoManager.NUM_FIXES; i++) {
            const fixInfo = this.fixInfos[i];
            const calculated = this.calculatedData[i];
            // update the time/altitude prediction
            this.calculator.calculateEtaAltitudePrediction(fixInfo, calculated);
            // update CDU data
            this.calculator.calculateFixPredictions(plan, fixInfo, calculated);
            this.bus.getPublisher().pub('fix_info_calculated', i, false, false);
        }
    }
    /**
     * Refresh the set of ND data
     */
    refreshNdData() {
        const newData = this.gatherNdWaypoints();
        // remove any fixes no longer existing
        for (let i = this.ndData.length - 1; i >= 0; i--) {
            const ndData = this.ndData.get(i);
            if (newData.find((f) => f.fixIcao === ndData.fixIcao) === undefined) {
                this.ndData.removeAt(i);
            }
        }
        for (let i = 0; i < newData.length; i++) {
            const newFix = newData[i];
            const oldFixIndex = this.ndData.getArray().findIndex((f) => f.fixIcao === newFix.fixIcao);
            const oldFix = this.ndData.tryGet(oldFixIndex);
            // old data is equal to new, so no need to send anything to the ND/mangle the DOM
            if (oldFix && this.ndWaypointEquality(newFix, oldFix)) {
                continue;
            }
            // remove the stale data if it exists, and insert new data
            if (oldFixIndex >= 0) {
                this.ndData.removeAt(oldFixIndex);
            }
            const insertFix = oldFix ? oldFix : Object.assign({}, newFix);
            insertFix.abeamIntersections = [...newFix.abeamIntersections];
            insertFix.bearings = [...newFix.bearings];
            insertFix.circleRadii = [...newFix.circleRadii];
            this.ndData.insert(insertFix);
        }
    }
    /**
     * Get ND data for all of the fix infos
     * @returns ND data
     */
    gatherNdWaypoints() {
        // remove any fixes no longer existing, and reset calculated data
        for (let i = this.ndCache.length - 1; i >= 0; i--) {
            const ndData = this.ndCache[i];
            if (this.fixInfos.find((f) => f.fixIcao === ndData.fixIcao) === undefined) {
                this.ndCache.splice(i, 1);
            }
            else {
                ndData.abeamIntersections.length = 0;
                ndData.bearings.length = 0;
                ndData.circleRadii.length = 0;
            }
        }
        for (const fixInfo of this.fixInfos) {
            if (fixInfo.fixIdent === null || fixInfo.fixIcao === null) {
                continue;
            }
            let ndFix = this.ndCache.find((f) => f.fixIcao === fixInfo.fixIcao);
            if (!ndFix) {
                ndFix = {
                    fixIdent: fixInfo.fixIdent,
                    fixIcao: fixInfo.fixIcao,
                    location: fixInfo.fixLocationSpherical,
                    circleRadii: [],
                    bearings: [],
                    abeamIntersections: [],
                    magVar: fixInfo.fixMagVar,
                };
                this.ndCache.push(ndFix);
            }
            for (const [bearing, distance] of fixInfo.bearingDistances) {
                if (bearing !== null && distance === null && !ndFix.bearings.includes(Math.round(bearing))) {
                    ndFix.bearings.push(Math.round(bearing));
                }
                if (bearing === null && distance !== null && !ndFix.circleRadii.includes(Math.round(distance))) {
                    ndFix.circleRadii.push(Math.round(distance));
                }
            }
            if (this.calculator.isIntersectionValid(fixInfo.abeamIntersection)) {
                ndFix.abeamIntersections.push(fixInfo.abeamIntersection.point);
            }
        }
        return this.ndCache;
    }
    /**
     * Check if two {@link BoeingFixInfoWaypoint} instances are equal
     * @param a first instance
     * @param b second instance
     * @returns true if the two instances are equal
     */
    ndWaypointEquality(a, b) {
        return a.fixIcao === b.fixIcao
            && a.circleRadii.length === b.circleRadii.length
            && a.circleRadii.every((r, i) => r === b.circleRadii[i])
            && a.bearings.length === b.bearings.length
            && a.bearings.every((r, i) => r === b.bearings[i])
            && a.abeamIntersections.length === b.abeamIntersections.length
            && a.abeamIntersections.every((p, i) => p.equals(b.abeamIntersections[i]));
    }
    /** Clear all fixes on flight completion */
    clearAllFixes() {
        for (let i = 0; i < BoeingFixInfoManager.NUM_FIXES; i++) {
            this.clearFix(i, true);
        }
        // no sync to user data as we assume other FMS instances also got complete phase
    }
    /**
     * Set a pilot-entered bearing and/or distance.
     * @param fixIndex Index of the fix info/page (0-based).
     * @param brgDistIndex Index/row of the bearing/dist pair (0-based).
     * @param bearing Bearing in degrees, true or magnetic depending on reference mode,
     * or null to allow FMS intersection computation.
     * @param distance Distance/radius in metres, or null to allow FMS intersection
     * computation.
     * @returns true if the operation succeeded.
     */
    setBearingDistance(fixIndex, brgDistIndex, bearing, distance) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES || brgDistIndex >= BoeingFixInfoManager.NUM_BRG_DIST || this.fixInfos[fixIndex].fix === null) {
            return false;
        }
        const fixInfo = this.fixInfos[fixIndex];
        const trueBearing = (this.fms.trueRef.get() || bearing === null) ? bearing : MagVar.magneticToTrue(bearing, fixInfo.fixMagVar);
        fixInfo.bearingDistances[brgDistIndex][0] = trueBearing;
        fixInfo.bearingDistances[brgDistIndex][1] = distance;
        this.needIntersectionsUpdate = true;
        this.needPredictionsUpdate = true;
        this.writeFixInfoToUserData();
        return true;
    }
    /**
     * Clear a pilot-entered bearing/distance pair
     * @param fixIndex Index of the fix info/page (0-based).
     * @param brgDistIndex Index/row of the bearing/dist pair (0-based).
     * @returns true if the operation succeeded.
     */
    clearBearingDistance(fixIndex, brgDistIndex) {
        return this.setBearingDistance(fixIndex, brgDistIndex, null, null);
    }
    /**
     * Set the fix for a fix info page, clearing all other data on the page
     * @param fixIndex Index of the fix info/page (0-based).
     * @param fix The fix facility
     * @returns true if the operation succeeded.
     */
    setFix(fixIndex, fix) {
        var _a;
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES || !fix) {
            return false;
        }
        // don't clear data if it's the same fix... nothing to do
        if (((_a = this.fixInfos[fixIndex].fix) === null || _a === void 0 ? void 0 : _a.icao) === (fix === null || fix === void 0 ? void 0 : fix.icao)) {
            return true;
        }
        if (this.fixInfos[fixIndex].fix !== null) {
            this.clearFix(fixIndex, true);
        }
        const fixInfo = this.fixInfos[fixIndex];
        fixInfo.fix = fix;
        fixInfo.fixIcao = fix.icao;
        fixInfo.fixIdent = ICAO.getIdent(fix.icao);
        fixInfo.fixLocationSpherical = new GeoPoint(fix.lat, fix.lon);
        fixInfo.fixLocationSpherical.toCartesian(fixInfo.fixLocationCartesian);
        fixInfo.fixMagVar = FacilityUtils.getMagVar(fix);
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Clear a fix info page
     * @param fixIndex Index of the fix info/page (0-based).
     * @param omitSync true if the flight plan user data sync will be done later
     * @returns true if the operation succeeded.
     */
    clearFix(fixIndex, omitSync = false) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const fixInfo = this.fixInfos[fixIndex];
        fixInfo.fix = null;
        fixInfo.fixIcao = null;
        fixInfo.fixIdent = null;
        fixInfo.fixMagVar = 0;
        fixInfo.bearingDistances.forEach((v) => { v[0] = null; v[1] = null; });
        fixInfo.calculateAbeamPoint = false;
        this.calculator.clearFixIntersections(fixInfo);
        if (!omitSync) {
            this.writeFixInfoToUserData();
        }
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Set a time to predict the distance/along-track location for.
     * This will clear the altitude to predict if set.
     * @param fixIndex Index of the fix info/page (0-based).
     * @param time Unix timestamp in milliseconds
     * @returns true if the operation succeeded.
     */
    setTimePrediction(fixIndex, time) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const data = this.fixInfos[fixIndex];
        data.predictedAltitude = null;
        data.predictedTime = time;
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Set an altitude to predict the distance/along-track location for.
     * This will clear the time to predict if set.
     * @param fixIndex Index of the fix info/page (0-based).
     * @param altitude Altitude in metres.
     * @returns true if the operation succeeded.
     */
    setAltitudePrediction(fixIndex, altitude) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const data = this.fixInfos[fixIndex];
        data.predictedAltitude = altitude;
        data.predictedTime = null;
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Clear the time or altitude to predict along-track location for.
     * @param fixIndex Index of the fix info/page (0-based).
     * @returns true if the operation succeeded.
     */
    clearPrediction(fixIndex) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const data = this.fixInfos[fixIndex];
        data.predictedAltitude = null;
        data.predictedTime = null;
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Attempts to find the closest abeam intersection and saves it on this fix info
     * @param fixIndex of the fix info/page (0-based).
     * @returns true on success
     */
    createAbeamPoint(fixIndex) {
        const fixInfo = this.fixInfos[fixIndex];
        if (!fixInfo) {
            return false;
        }
        fixInfo.calculateAbeamPoint = true;
        this.needIntersectionsUpdate = true;
        this.needPredictionsUpdate = true;
        this.writeFixInfoToUserData();
        return true;
    }
    /**
     * Get the calculated data for CDU page rendering
     * @param fixIndex Index of the fix info/page (0-based).
     * @returns the calculated data
     */
    getCalculatedData(fixIndex) {
        return this.calculatedData[fixIndex];
    }
    /**
     * Get the entered data for CDU page rendering
     * @param fixIndex Index of the fix info/page (0-based).
     * @returns the entered data
     */
    getEnteredData(fixIndex) {
        return this.fixInfos[fixIndex];
    }
}
BoeingFixInfoManager.NUM_FIXES = 4;
BoeingFixInfoManager.NUM_BRG_DIST = 3;
/** Maximum distance that can be shown */
BoeingFixInfoManager.MAX_DISTANCE = UnitType.METER.convertFrom(9999, UnitType.NMILE);

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
/**
 * A Boeing FMS
 */
class BoeingFms {
    /**
     * Initialize an instance of the FMS.
     * @param bus is the event bus
     * @param flightPlanner is the flight planner
     * @param verticalPathCalculator is the VNAV Path Calculator.
     * @param performancePlanRepository the performance plan repository
     * @param windPlanner Handles wind and temperature entries and propagation for climb, cruise, and descent
     * @param perfProvider the BoeingPathPerformanceProvider
     * @param engineDataProvider the BoeingEngineDataProvider
     * @param isPrimaryFms Whether this is the primary FMS
     * @param activeRoutePredictor The active route predictions provider
     */
    constructor(bus, flightPlanner, verticalPathCalculator, performancePlanRepository, windPlanner, perfProvider, engineDataProvider, isPrimaryFms, activeRoutePredictor) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.windPlanner = windPlanner;
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.isPrimaryFms = isPrimaryFms;
        this.activeRoutePredictor = activeRoutePredictor;
        /** Set to true by FMC pages when the plan on this FMS instance is in modification and awaiting a cancel or exec. */
        this.planInMod = Subject.create(false);
        /**
         * Map of routes numbers to whether or not they are activated
         */
        this.routesActivated = {
            1: Subject.create(false),
            2: Subject.create(false),
        };
        this.route1Activated = this.routesActivated['1'];
        /** Set to true when an event is received from the bus indicating that another instrument is in MOD on the plan. */
        this.remotePlanInMod = false;
        this.ppos = new GeoPoint(0, 0);
        /** FIXME hook up when true ref exists */
        this.trueRef = Subject.create(false);
        this.alternates = new BoeingAlternates(this.bus, this);
        this.vnavData = new BoeingFmsVNavDataProvider(this.bus, this);
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.fixInfo = new BoeingFixInfoManager(this.bus, this, this.facLoader, BoeingFms.ACT_RTE_PLAN_INDEX);
        /** Information on our origin, arrival and destination facilities to save lookups.
         * When in MOD, this will reflect the current origin and destination in the MOD plan. */
        this.facilityInfo = {
            originFacility: undefined,
            destinationFacility: undefined
        };
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false,
            approachIsCircling: false,
            approachName: '',
            approachRunway: '',
            referenceFacility: null,
            finalApproachCourse: -1,
        };
        /** Current true aircraft track */
        this.aircraftTrack = undefined;
        /** Current aircraft indicated altitude */
        this.aircraftAltitude = undefined;
        this.approachFrequency = Subject.create(undefined);
        this._lastApproachFrequencyEventValue = undefined;
        this.cdiSource = { type: NavSourceType.Gps, index: 1 };
        this.missedApproachActive = false;
        this.tunedIlsFrequency = null;
        this.tunedIlsCourse = null;
        this.approachFrequencyMismatch = Subject.create(false);
        this.approachCourseMismatch = Subject.create(false);
        /** Set to true when a leg is activated,
         * meaning that sequencing should be resumed once EXEC is pressed.
         * Should be reset whenever leaving MOD. */
        this.legWasActivatedInModPlan = false;
        /** Set to true when a new DTO is created,
         * meaning its origin should be regularly updated while in MOD and when hitting EXEC.
         * Should be reset whenever leaving MOD. */
        this.dtoWasCreatedInModPlan = false;
        /** Set to true when a new vertical DTO is created,
         * meaning its origin should be regularly updated while in MOD and when hitting EXEC.
         * Should be reset whenever leaving MOD. */
        this.verticalDtoWasCreatedInModPlan = false;
        /**
         * Set to true when the vertical DTO in the mod flight plan was automatic
         */
        this.verticalDtoWasCreatedInModPlanWasAutomatic = false;
        this._performancePlanProxy = PerformancePlanUtils.createProxyFromDefinitions({
            defaultValuesPlan: this.performancePlanRepository.defaultValuesPlan(),
            /** @inheritDoc */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            onBeforeEdit: (property, newValue) => {
                if (!property.editInPlace) {
                    this.getPlanToModify();
                }
            },
            /** @inheritDoc */
            onAfterEdit: (property, newValue) => {
                if (property.editInPlace) {
                    // We edit all plans, since we do not want to involve an EXEC to confirm a value.
                    // This makes sure that if a value is modified while a MOD plan exists, we modify it, making a copy
                    // from ACT -> MOD not reset the value.
                    for (let i = 0; i < this.performancePlanRepository.plans.length; i++) {
                        const plan = this.performancePlanRepository.plans[i];
                        if (!plan) {
                            continue;
                        }
                        plan[property.key].set(newValue);
                        this.performancePlanRepository.triggerSync(i);
                    }
                }
            },
        });
        this.onOriginDestinationChanged = (e) => {
            if (e.planIndex === this.getPlanIndexForFmcPage()) {
                this.setFacilityInfo();
            }
        };
        /**
         * Called when 'fplProcDetailsChanged' event is fired from changes in procedure details of a flight plan.
         * @param e The event fired when flight plan procedure details change.
         */
        this.onProcedureDetailsChanged = (e) => {
            this.syncProcedureDetailsChangesToPerformancePlan(e);
        };
        this.onPlanCopied = (ev) => {
            this.setFacilityInfo();
            this.ensureActiveHMSuspended();
            this.applyCopyToPerformancePlans(ev);
            if (ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.tryUnsuspend();
                this.syncFlightPlanToPerformancePlan();
            }
            if (ev.planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX && ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.routesActivated[1].set(true);
            }
        };
        this.onPlanCreated = (ev) => {
            this.applyCreationToPerformancePlans(ev);
        };
        this.onPlanCalculated = (e) => {
            if (e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && this.planInMod.get()) {
                const plan = this.getPlanToModify();
                if (this.verticalDtoWasCreatedInModPlan) {
                    this.updateVerticalDtoOrigin(plan);
                }
                if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX)) {
                    this.updateDtoOrigin(plan);
                }
                this.tryUpdatePposHoldPosition(plan);
            }
        };
        this.onPlanLoaded = (ev) => {
            this.checkApproachState().then();
            this.switchPerformanceProxyToRenderPlan(true);
            this.syncFlightPlanToPerformancePlan();
            const plan = this.flightPlanner.getFlightPlan(ev.planIndex);
            const route = plan.getUserData(BoeingFms.USER_DATA_KEY_ROUTE);
            if (ev.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                if (typeof route === 'number') {
                    this.routesActivated[route].set(true);
                }
            }
        };
        this.onFmsOperatingPhaseChanged = (newPhase) => {
            if (newPhase === FmsOperatingPhase.COMPLETE) {
                // Reset performance plan
                this.performancePlanRepository.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, BoeingFms.ACT_RTE_PLAN_INDEX);
                this.performancePlanRepository.triggerSync(BoeingFms.ACT_RTE_PLAN_INDEX);
                // Reset flight plan
                this.emptyFlightPlan();
                this.routesActivated[1].set(false);
            }
        };
        this.insertApproachOpId = 0;
        /**
         * Sets the approach details when an approach_details_set event is received from the bus.
         * @param approachDetails The approachDetails received from the bus.
         */
        this.onApproachDetailsSet = (approachDetails) => {
            if (approachDetails !== this.approachDetails) {
                this.approachDetails = approachDetails;
                this.checkTunedIlsMismatch();
            }
            const canApproachActivate = this.canApproachActivate();
            if (!canApproachActivate && this.approachDetails.approachIsActive) {
                this.setApproachDetails(undefined, undefined, undefined, canApproachActivate);
            }
        };
        this.perfInitPageCompleted = MappedSubject.create(([hasZfw, hasReserves, hasCrzAlt, hasCostIndex]) => hasZfw && hasReserves && hasCrzAlt && hasCostIndex, this.activePerformancePlan.manualZfw.map((val) => val !== null), this.activePerformancePlan.reserveFuel.map((val) => val !== null), this.activePerformancePlan.cruiseAltitude.map((val) => val !== null), this.activePerformancePlan.costIndex.map((val) => val !== null));
        this.perfIsInitialized = MappedSubject.create(([posIsInit, routeIsAct, perfInitDone]) => posIsInit && routeIsAct && perfInitDone, CockpitUserSettings.getManager(this.bus).getSetting('posIsInitialized'), this.routesActivated['1'], this.perfInitPageCompleted);
        this.takeoffRefPageCompleted = MappedSubject.create(([hasTakeoffFlaps, hasCog]) => hasTakeoffFlaps && hasCog, this.activePerformancePlan.takeoffFlaps.map((val) => val !== null), this.activePerformancePlan.takeoffCg.map((val) => val !== null));
        this.preflightComplete = MappedSubject.create(([perfInitDone, takeoffRefDone]) => perfInitDone && takeoffRefDone, this.perfIsInitialized, this.takeoffRefPageCompleted);
        this.cdiScaleLabel = ConsumerSubject.create(this.bus.getSubscriber().on('lnavdata_cdi_scale_label'), 4);
        this.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
        this.bus.getSubscriber().on('track_deg_true').handle((track) => this.aircraftTrack = track);
        this.bus.getSubscriber().on('indicated_alt').handle((track) => this.aircraftAltitude = track);
        this.bus.getSubscriber().on('cdi_select').handle(source => this.cdiSource = source);
        const planEvents = this.bus.getSubscriber();
        planEvents.on('fplActiveLegChange').handle(data => this.onActiveLegChanged(data.type, data.planIndex));
        planEvents.on('fplLoaded').handle(this.onPlanLoaded);
        planEvents.on('fplCalculated').handle(this.onPlanCalculated);
        planEvents.on('fplCopied').handle(this.onPlanCopied);
        planEvents.on('fplCreated').handle(this.onPlanCreated);
        planEvents.on('fplOriginDestChanged').handle(this.onOriginDestinationChanged);
        planEvents.on('fplProcDetailsChanged').handle(this.onProcedureDetailsChanged);
        planEvents.on('fplUserDataSet').handle(this.onPlanUserDataSet.bind(this));
        const fmsOperatingPhaseEvents = this.bus.getSubscriber();
        fmsOperatingPhaseEvents.on('fms_operating_phase').handle((phase) => this.onFmsOperatingPhaseChanged(phase));
        this.planInMod.sub((v) => {
            if (v) {
                SimVar.SetSimVarValue('L:FMC_EXEC_ACTIVE', 'number', 1);
            }
            else {
                SimVar.SetSimVarValue('L:FMC_EXEC_ACTIVE', 'number', 0);
            }
        }, true);
        this.planInMod.sub((v) => {
            if (!v) {
                // Need to update facility info on ERASE
                this.setFacilityInfo();
            }
        });
        this.planInMod.sub(() => {
            this.switchPerformanceProxyToRenderPlan();
        });
        this.bus.getSubscriber().on('fmcExecActive').whenChanged().handle((v) => {
            const state = v === 1;
            this.remotePlanInMod = state;
        });
        this.bus.getSubscriber().on('approach_details_set').handle(this.onApproachDetailsSet);
        this.cdiScaleLabel.sub(v => {
            const canApproachActivate = this.canApproachActivate(v);
            if (canApproachActivate !== this.approachDetails.approachIsActive) {
                this.setApproachDetails(undefined, undefined, undefined, canApproachActivate);
            }
        });
        this.bus.getSubscriber().on('altimeter_baro_is_std_1').whenChanged().handle((std) => {
            if (std) {
                // Reset QFE if set
                this.activePerformancePlan.approachLandingRef.set(1);
            }
        });
        this.bus.getSubscriber().on('nav_active_frequency_3').handle((frequency) => {
            this.tunedIlsFrequency = frequency;
            this.checkTunedIlsMismatch();
        });
        this.bus.getSubscriber().on('nav_obs_3').handle((obs) => {
            this.tunedIlsCourse = obs;
            this.checkTunedIlsMismatch();
        });
        this.approachFrequencyMismatch.sub((v) => this.bus.getPublisher().pub('approach_frequency_mismatch', v, true));
        this.approachCourseMismatch.sub((v) => this.bus.getPublisher().pub('approach_course_mismatch', v, true));
        this.activePerformancePlan.glideSlope.sub((v) => this.bus.getPublisher().pub('boeing_glideslope_selected', v === GlideslopeStatus.ON));
        this.activePerformancePlan.approachLandingRef.sub((v) => this.bus.getPublisher().pub('boeing_qfe_approach_selected', v === 0));
    }
    /**
     * Obtain the performance plan for FMC render
     * @returns the plan
     */
    get performancePlanForFmcRender() {
        let index;
        if (this.planInMod.get()) {
            index = BoeingFms.RTE_1_MOD_PLAN_INDEX;
        }
        else {
            index = BoeingFms.ACT_RTE_PLAN_INDEX;
        }
        return this.performancePlanRepository.forFlightPlanIndex(index);
    }
    /**
     * Returns the active performance plan
     *
     * @returns the performance plan for the active flight plan index
     */
    get activePerformancePlan() {
        return this.performancePlanRepository.getActivePlan();
    }
    /**
     * Returns the performance plan proxy
     *
     * @returns the performance plan proxy
     */
    get performancePlanProxy() {
        return this._performancePlanProxy;
    }
    /**
     * Syncs the primary flight plan data to the relevant performance plan values
     */
    syncFlightPlanToPerformancePlan() {
        var _a, _b, _c, _d;
        if (this.hasPrimaryFlightPlan()) {
            const plan = this.getPrimaryFlightPlan();
            this.activePerformancePlan.takeoffAirportIcao.set((_a = plan.originAirport) !== null && _a !== void 0 ? _a : null);
            this.activePerformancePlan.takeoffRunway.set((_b = plan.procedureDetails.originRunway) !== null && _b !== void 0 ? _b : null);
            this.activePerformancePlan.approachAirportIcao.set((_c = plan.destinationAirport) !== null && _c !== void 0 ? _c : null);
            this.activePerformancePlan.approachRunway.set((_d = plan.procedureDetails.destinationRunway) !== null && _d !== void 0 ? _d : null);
        }
    }
    /**
     * Switches the performance proxy to use the FMC render plan
     *
     * @param initial whether this is a call on the initial plan load
     */
    switchPerformanceProxyToRenderPlan(initial = false) {
        this._performancePlanProxy.switchToPlan(this.performancePlanForFmcRender, initial);
    }
    /**
     * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
     */
    async initPrimaryFlightPlan() {
        if (this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX)) {
            // Plan was synced
            await this.setFacilityInfo();
            return;
        }
        this.flightPlanner.createFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        const inactivePlanRte1 = this.flightPlanner.createFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        const modPlanRte1 = this.flightPlanner.createFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        inactivePlanRte1.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        modPlanRte1.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        this.emptyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        this.emptyFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        const simPlaneLoaded = await FlightPlanAsoboSync.loadFromGame(this);
        if (simPlaneLoaded) {
            this.activate(1);
            this.execute();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCdiSource() {
        return this.cdiSource;
    }
    /**
     * Checks whether an indexed flight plan exists.
     * @param index A flight plan index.
     * @returns Whether a flight plan at the specified index exists.
     */
    hasFlightPlan(index) {
        return this.flightPlanner.hasFlightPlan(index);
    }
    /**
     * Gets a specified flightplan, or by default the primary flight plan.
     * @param index The index of the flight plan.
     * @returns the requested flight plan
     * @throws Error if no flight plan exists at the specified index.
     */
    getFlightPlan(index = BoeingFms.ACT_RTE_PLAN_INDEX) {
        return this.flightPlanner.getFlightPlan(index);
    }
    /**
     * Checks whether the primary flight plan exists.
     * @returns Whether the primary flight plan exists.
     */
    hasPrimaryFlightPlan() {
        return this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Gets the primary lateral flight plan.
     * @returns The primary flight plan.
     * @throws Error if the primary flight plan does not exist.
     */
    getPrimaryFlightPlan() {
        return this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Gets the primary vertical flight plan.
     * @returns the primary vertical flight plan.
     */
    getPrimaryVerticalFlightPlan() {
        return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Checks whether the Primary Mod Flight Plan Exists - when modifications to the plan are being made.
     * @returns Whether the Primary Mod Flight Plan Exists flight plan exists.
     */
    hasPrimaryModFlightPlan() {
        return this.flightPlanner.hasFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Gets the Primary Mod Flight Plan Exists - when modifications to the plan are being made.
     * @returns The Primary Mod Flight Plan.
     * @throws Error if the Primary Mod Flight Plan flight plan does not exist.
     */
    getPrimaryModFlightPlan() {
        return this.flightPlanner.getFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Gets the primary mod vertical flight plan.
     * @returns the primary mod vertical flight plan.
     */
    getPrimaryModVerticalFlightPlan() {
        return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Returns whether the route is activated
     * @param route the route
     * @returns a boolean
     */
    isRouteActivated(route) {
        return this.routesActivated[route].get();
    }
    /**
     * Returns a subscribable the route is activated
     * @param route the route
     * @returns a subscribable
     */
    routeActivated(route) {
        return this.routesActivated[route];
    }
    /**
     * Handles when the EXEC button is pressed and copies the MOD plan back to the PRIMARY plan
     */
    execute() {
        if (this.planInMod.get()) {
            const modPlan = this.getPlanToModify();
            if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX) === DirectToState.TOEXISTING) {
                this.updateDtoOrigin(modPlan);
            }
            if (this.verticalDtoWasCreatedInModPlan) {
                this.updateVerticalDtoOrigin(modPlan);
            }
            // Make sure this is only reset after the call to updateDTOOrigin
            this.dtoWasCreatedInModPlan = false;
            this.verticalDtoWasCreatedInModPlan = false;
            this.verticalDtoWasCreatedInModPlanWasAutomatic = false;
            if (typeof modPlan.getUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN) === 'boolean') {
                // In this case the user changed the origin on an active route, causing a new inactive plan to be created
                modPlan.deleteUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN);
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, true);
                this.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX).calculate(0);
                this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                this.emptyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
                this.routesActivated[1].set(false);
                this.planInMod.set(false);
                this.legWasActivatedInModPlan = false;
            }
            else {
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.ACT_RTE_PLAN_INDEX, true);
                this.getPrimaryFlightPlan().calculate(0);
                this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                this.planInMod.set(false);
                // make sure ACT performance plan has new values
                this.syncFlightPlanToPerformancePlan();
                // sync ACT performance plan
                this.performancePlanRepository.triggerSync(BoeingFms.ACT_RTE_PLAN_INDEX);
                if (this.legWasActivatedInModPlan) {
                    this.legWasActivatedInModPlan = false;
                    this.resumeSequencing();
                }
                FlightPlanAsoboSync.SaveToGame(this);
            }
            // TODO listen to f-pln events to calculate this
            // If the selected approach is not LOC-based, and there is an approach selected, the lateral approach guidance should be FMS LOC
            this.bus.getPublisher().pub('boeing_fms_loc_approach_selected', !BoeingFmsUtils.isLocalizerApproach(this.approachDetails.approachType) && this.approachDetails.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN);
        }
    }
    /**
     * Activates the indicated route
     * @param route the route index, 1-based
     */
    activate(route) {
        this.flightPlanner.copyFlightPlan(BoeingFms[`RTE_${route}_INACTIVE_PLAN_INDEX`], BoeingFms[`RTE_${route}_MOD_PLAN_INDEX`], true);
        this.planInMod.set(true);
        this.emptyFlightPlan(BoeingFms[`RTE_${route}_INACTIVE_PLAN_INDEX`]);
    }
    /** Resumes flight plan sequencing. */
    resumeSequencing() {
        this.bus.getPublisher().pub('suspend_sequencing', false, true);
    }
    /**
     * Handles when the ERASE button is pressed.
     */
    cancelMod() {
        if (this.planInMod.get()) {
            if (!this.isRouteActivated(1)) {
                // Copy mod back to inactive when there is no active plan yet
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, true);
            }
            this.legWasActivatedInModPlan = false;
            this.dtoWasCreatedInModPlan = false;
            this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
            this.planInMod.set(false);
        }
    }
    /**
     * Handles when a modification is being made to the plan to ensure the plan is in MOD mode
     * @param routeNumber the route number (currently always RTE 1)
     * @returns The Flight Plan to modify
     */
    getPlanToModify(routeNumber = 1) {
        if (this.planInMod.get()) {
            return this.getFlightPlan(BoeingFms[`RTE_${routeNumber}_MOD_PLAN_INDEX`]);
        }
        const isRouteActivated = this.isRouteActivated(routeNumber);
        if (!isRouteActivated) {
            return this.getFlightPlan(BoeingFms[`RTE_${routeNumber}_INACTIVE_PLAN_INDEX`]);
        }
        // Active route going into MOD
        this.flightPlanner.copyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX, BoeingFms[`RTE_${routeNumber}_MOD_PLAN_INDEX`], true);
        this.getPrimaryModFlightPlan().calculate(0);
        this.planInMod.set(true);
        return this.getPrimaryModFlightPlan();
    }
    /**
     * Gets the plan index FMC pages should use to monitor events.
     * @returns A Flight Plan Index
     */
    getPlanIndexForFmcPage() {
        if (this.planInMod.get()) {
            return BoeingFms.RTE_1_MOD_PLAN_INDEX;
        }
        else if (this.isRouteActivated(1)) {
            return BoeingFms.ACT_RTE_PLAN_INDEX;
        }
        else {
            return BoeingFms.RTE_1_INACTIVE_PLAN_INDEX;
        }
    }
    /**
     * Gets the current lateral flight plan for the FMC pages based on whether the plan is in MOD or ACT.
     * @returns A Lateral Flight Plan
     */
    getPlanForFmcRender() {
        if (this.planInMod.get()) {
            return this.getPrimaryModFlightPlan();
        }
        else if (this.isRouteActivated(1)) {
            return this.getPrimaryFlightPlan();
        }
        else {
            return this.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        }
    }
    /**
     * Gets the current vertical flight plan for the FMC pages based on whether the plan is in MOD or ACT.
     * @returns A Vertical Flight Plan
     */
    getVerticalPlanForFmcRender() {
        if (this.planInMod.get()) {
            return this.getPrimaryModVerticalFlightPlan();
        }
        else if (this.isRouteActivated(1)) {
            return this.getPrimaryVerticalFlightPlan();
        }
        else {
            return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        }
    }
    /**
     * Checks whether the plan can go into MOD/be edited on this instance of WT21Fms.
     * @returns Whether to allow plan edits or not
     */
    canEditPlan() {
        if (this.remotePlanInMod && !this.planInMod.get()) {
            return false;
        }
        return true;
    }
    /**
     * Sync the procedure details changes from a flight plan to its respective performance plan.
     * Only sync departureFacilityIcao and originRunway changes at the moment.
     * @param e The event fired when flight plan procedure details change.
     */
    syncProcedureDetailsChangesToPerformancePlan(e) {
        var _a, _b;
        const targetPerfPlan = this.performancePlanRepository.forFlightPlanIndex(e.planIndex);
        targetPerfPlan.takeoffAirportIcao.set((_a = e.details.departureFacilityIcao) !== null && _a !== void 0 ? _a : null);
        targetPerfPlan.takeoffRunway.set((_b = e.details.originRunway) !== null && _b !== void 0 ? _b : null);
    }
    /**
     * Sets the Facility Info cache in the Fms.
     */
    async setFacilityInfo() {
        var _a, _b;
        const plan = this.getPlanForFmcRender();
        if (((_a = this.facilityInfo.originFacility) === null || _a === void 0 ? void 0 : _a.icao) !== plan.originAirport) {
            if (plan.originAirport) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
                this.facilityInfo.originFacility = facility !== null && facility !== void 0 ? facility : undefined;
            }
            else {
                this.facilityInfo.originFacility = undefined;
            }
        }
        if (((_b = this.facilityInfo.destinationFacility) === null || _b === void 0 ? void 0 : _b.icao) !== plan.destinationAirport) {
            if (plan.destinationAirport) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                this.facilityInfo.destinationFacility = facility !== null && facility !== void 0 ? facility : undefined;
            }
            else {
                this.facilityInfo.destinationFacility = undefined;
            }
        }
    }
    /**
     * Gets the ALTN airport of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingAlternates` instead
     *
     * @param planIndex the flight plan index
     *
     * @returns the ALTN airport FS ICAO, or undefined
     */
    getFlightPlanAlternates(planIndex) {
        const plan = this.getFlightPlan(planIndex);
        return plan.getUserData(BoeingFms.USER_DATA_KEY_ALTN);
    }
    /**
     * Sets the ALTN airports of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingAlternates` instead
     *
     * @param planIndex the plan index to use
     * @param alternates the ALTN airports
     */
    setFlightPlanAlternates(planIndex, alternates) {
        const plan = this.getFlightPlan(planIndex);
        plan.setUserData(BoeingFms.USER_DATA_KEY_ALTN, alternates);
    }
    /**
     * Returns a flight plan's visual approach, as the runway designator of the approach
     *
     * @param planIndex the plan index
     *
     * @returns a string
     */
    getFlightPlanVisualApproach(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH);
    }
    /**
     * Returns a flight plan's visual approach, as the runway designator of the approach
     *
     * @param planIndex the plan index
     * @param runwayDesignator the visual approach's runway designator
     */
    setFlightPlanVisualApproach(planIndex, runwayDesignator) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH, runwayDesignator);
    }
    /**
     * Deletes a flight plan's visual approach
     *
     * @param planIndex the plan index
     */
    deleteFlightPlanVisualApproach(planIndex) {
        this.getFlightPlan(planIndex).deleteUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH);
    }
    /**
     * Returns a flight plan's visual approach VFR vertical path angle
     *
     * @param planIndex the plan index
     *
     * @returns a number, in degrees
     */
    getFlightPlanVisualApproachVfrVpa(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA);
    }
    /**
     * Sets a flight plan's visual approach VFR vertical path angle
     *
     * @param planIndex the plan index
     * @param vpa the visual approach's VFR vertical path angle, in degrees
     */
    setFlightPlanVisualApproachVfrVpa(planIndex, vpa) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA, vpa);
    }
    /**
     * Gets the fix infos of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingFixInfo` instead
     *
     * @param planIndex the flight plan index
     *
     * @returns the fix infos, or undefined
     */
    getFlightPlanFixInfos(planIndex) {
        const plan = this.getFlightPlan(planIndex);
        return plan.getUserData(BoeingFms.USER_DATA_KEY_FIX_INFO);
    }
    /**
     * Sets the fix infos of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingFixInfo` instead
     *
     * @param planIndex the plan index to use
     * @param fixInfos the fix info data
     */
    setFlightPlanFixInfos(planIndex, fixInfos) {
        const plan = this.getFlightPlan(planIndex);
        plan.setUserData(BoeingFms.USER_DATA_KEY_FIX_INFO, fixInfos);
    }
    /**
     * Handle the flightplan user data changed event
     * @param event User data event
     */
    onPlanUserDataSet(event) {
        if (event.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && event.key === BoeingFms.USER_DATA_KEY_FIX_INFO) {
            this.fixInfo.onFlightPlanFixInfoDataChanged();
        }
    }
    /**
     * After a plan copy, ensure that a now active HM causes a suspend
     */
    ensureActiveHMSuspended() {
        const activeLegIndex = this.getPlanForFmcRender().activeLateralLeg;
        const activeLeg = this.getPlanForFmcRender().tryGetLeg(activeLegIndex === 0 ? 1 : activeLegIndex);
        // TODO considerations for hold exit
        if ((activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.leg.type) === LegType.HM) {
            this.bus.getPublisher().pub('suspend_sequencing', true);
        }
    }
    /**
     * After a plan copy, ensure that we unsuspend if necessary
     */
    tryUnsuspend() {
        if (this.isPrimaryFms) {
            const activeLegIndex = this.getPrimaryFlightPlan().activeLateralLeg;
            if (activeLegIndex >= 0) {
                const activeLeg = this.getPrimaryFlightPlan().tryGetLeg(activeLegIndex);
                if (activeLeg && BoeingFmsUtils.canLegBeAutoUnsuspended(activeLeg.leg.type)) {
                    this.resumeSequencing();
                }
            }
        }
    }
    /**
     * Applies flight plan copy events to the performance plan repository
     *
     * @param ev plan copied event
     */
    applyCopyToPerformancePlans(ev) {
        if (ev.targetPlanIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX || ev.targetPlanIndex === BoeingFms.RTE_2_MOD_PLAN_INDEX) {
            this.performancePlanRepository.copy(BoeingFms.ACT_RTE_PLAN_INDEX, ev.targetPlanIndex);
        }
        else if (ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.performancePlanRepository.copy(ev.planIndex, BoeingFms.ACT_RTE_PLAN_INDEX);
        }
    }
    /**
     * Applies flight plan copy events to the performance plan repository
     *
     * @param ev plan copied event
     */
    applyCreationToPerformancePlans(ev) {
        if (ev.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.performancePlanRepository.create(BoeingFms.ACT_RTE_PLAN_INDEX);
            this._performancePlanProxy.switchToPlan(this.activePerformancePlan, true);
        }
        if (!this.performancePlanRepository.hasAnyPlan()) {
            this.performancePlanRepository.forFlightPlanIndex(ev.planIndex);
        }
    }
    /**
     * Handles when a flight plan active leg changes.
     * @param legType The type of flight plan active leg change.
     * @param planIndex The index of the plan whose active leg changed.
     */
    onActiveLegChanged(legType, planIndex) {
        if (legType === ActiveLegType.Lateral && planIndex === 0) {
            const activePlan = this.flightPlanner.getActiveFlightPlan();
            if (activePlan.length < 1 || this.missedApproachActive) {
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
            this.tryUnsuspend();
        }
    }
    /**
     * A method to check the current approach state.
     */
    async checkApproachState() {
        var _a;
        const plan = this.getFlightPlan();
        let approachLoaded = false;
        let approachIsActive = false;
        let approachType;
        let approachRnavType;
        let approachIsCircling = false;
        let approachName = '';
        let approachRunway = '';
        let referenceFacility = null;
        let finalApproachCourse = -1;
        if (plan.destinationAirport && (plan.procedureDetails.approachIndex > -1 || this.getFlightPlanVisualApproach(plan.planIndex) !== undefined)) {
            approachLoaded = true;
            if (plan.length > 0 && plan.activeLateralLeg < plan.length && plan.activeLateralLeg > 0) {
                const segment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                approachIsActive = segment.segmentType === FlightPlanSegmentType.Approach;
            }
            if (plan.procedureDetails.approachIndex > -1) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                const approach = facility.approaches[plan.procedureDetails.approachIndex];
                if (approach) {
                    approachType = approach.approachType;
                    approachRnavType = BoeingFmsUtils.getBestRnavType(approach.rnavTypeFlags);
                    approachIsCircling = !approach.runway;
                    approachName = BoeingFmsUtils.getApproachNameAsEfisString(approach);
                    approachRunway = RunwayUtils.getRunwayNameString(approach.runwayNumber, approach.runwayDesignator, true, 'RW');
                    if (BoeingFmsUtils.approachHasNavFrequency(approach)) {
                        referenceFacility = (_a = await ApproachUtils.getReferenceFacility(approach, this.facLoader)) !== null && _a !== void 0 ? _a : null;
                    }
                    finalApproachCourse = await this.getFinalApproachCourse(facility, approach);
                }
            }
            else {
                approachType = AdditionalApproachType.APPROACH_TYPE_VISUAL;
                approachRnavType = RnavTypeFlags.None;
            }
        }
        this.setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling, approachName, approachRunway, referenceFacility, finalApproachCourse);
    }
    /**
     * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
     * this will effectively cancel it.
     * @param planIndex The flight plan index.
     * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
     * @param calculate Whether to calculate the flight plan
     * to the index of the current active primary flight plan leg.
     */
    removeDirectToExisting(planIndex = BoeingFms.RTE_1_MOD_PLAN_INDEX, lateralLegIndex, calculate = true) {
        const plan = this.getFlightPlan(planIndex);
        const directToData = plan.directToData;
        if (directToData && directToData.segmentIndex > -1) {
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            const activateIndex = lateralLegIndex !== null && lateralLegIndex !== void 0 ? lateralLegIndex : plan.activeLateralLeg;
            const adjustedActivateIndex = activateIndex - Utils.Clamp(activateIndex - (plan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex), 0, 3);
            plan.setDirectToData(-1, true);
            plan.setCalculatingLeg(adjustedActivateIndex);
            plan.setLateralLeg(adjustedActivateIndex);
            if (calculate) {
                plan.calculate(0);
            }
        }
    }
    /**
     * Method to cleanup any legs in segments that exist after the Approach/Arrival Segments.
     * @param plan The Mod Flight Plan.
     */
    cleanupLegsAfterApproach(plan) {
        if (plan.procedureDetails.arrivalIndex > -1 || plan.procedureDetails.approachIndex > -1 || this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            while (plan.getSegment(plan.segmentCount - 1).segmentType === FlightPlanSegmentType.Enroute) {
                this.planRemoveSegment(plan.segmentCount - 1);
            }
        }
    }
    /**
     * Checks whether a leg in the primary flight plan can be manually activated.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg can be manually activated.
     */
    canActivateLeg(segmentIndex, segmentLegIndex) {
        const plan = this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || BitFlags.isAll(leg.flags, WT21LegDefinitionFlags.DirectTo) || leg === plan.getLeg(0)) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.CF:
            case LegType.FC:
            case LegType.FD:
                return true;
            case LegType.CI:
            case LegType.VI:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.VM:
                return false;
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        switch (prevLeg.leg.type) {
            case LegType.VA:
            case LegType.CA:
            case LegType.VM:
            case LegType.Discontinuity:
                return false;
        }
        return true;
    }
    /**
     * Checks whether a leg in the primary flight plan is a valid direct to target.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg is a valid direct to target.
     * @throws Error if a leg could not be found at the specified location.
     */
    canDirectTo(segmentIndex, segmentLegIndex) {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || leg.leg.fixIcao === '' || leg.leg.fixIcao === ICAO.emptyIcao) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
                return true;
        }
        return false;
    }
    /**
     * Gets the current Direct To State.
     * @param planIndex The Plan Index to check.
     * @returns the DirectToState.
     */
    getDirectToState(planIndex = BoeingFms.ACT_RTE_PLAN_INDEX) {
        if (!this.hasFlightPlan(planIndex)) {
            return DirectToState.NONE;
        }
        const plan = this.getFlightPlan(planIndex);
        const directDataExists = plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1;
        if (!directDataExists) {
            return DirectToState.NONE;
        }
        // Guarding against rare cases where the segment with the dto has been removed and the dt odata hasn't been updated yet.
        const isDtoSegmentInPlan = plan.segmentCount >= plan.directToData.segmentIndex;
        if (!isDtoSegmentInPlan) {
            return DirectToState.NONE;
        }
        const dtoLegGlobalIndex = plan.getLegIndexFromLeg(plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex]);
        // We subtract 3 to get the index of the original DTO target leg
        const doesDtoLegMatchActiveLeg = dtoLegGlobalIndex === plan.activeLateralLeg - 3;
        // TODO This seems to be returning false positives when in MOD in certain scenarios,
        // TODO like after passing the TO leg of a DTO, then trying to add a new DTO
        if (doesDtoLegMatchActiveLeg) {
            return DirectToState.TOEXISTING;
        }
        else {
            return DirectToState.NONE;
        }
    }
    /**
     * Gets the ICAO string of the current Direct To target.
     * @returns The ICAO string of the current Direct To target, or undefined if Direct To is not active.
     */
    getDirectToTargetIcao() {
        var _a;
        return (_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao;
    }
    /**
     * Gets the current DTO Target Flight Plan Leg.
     * @returns the FlightPlanLeg.
     */
    getDirectToLeg() {
        switch (this.getDirectToState()) {
            case DirectToState.TOEXISTING: {
                const plan = this.getFlightPlan();
                return plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg;
            }
        }
        return undefined;
    }
    /**
     * Checks if a segment is the first enroute segment that is not an airway.
     * @param segmentIndex is the segment index of the segment to check
     * @returns whether or not the segment is the first enroute segment that is not an airway.
     */
    isFirstEnrouteSegment(segmentIndex) {
        const plan = this.getFlightPlan();
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && !segment.airway) {
                return i === segmentIndex;
            }
        }
        return false;
    }
    /**
     * Adds a user facility.
     * @param userFacility the facility to add.
     */
    addUserFacility(userFacility) {
        this.facRepo.add(userFacility);
    }
    /**
     * Removes a user facility.
     * @param userFacility the facility to remove.
     */
    removeUserFacility(userFacility) {
        this.facRepo.remove(userFacility);
    }
    /**
     * Gets all user facilities.
     *
     * @returns an array of user facilities
     */
    getUserFacilities() {
        const ret = [];
        // FIXME no.
        this.facRepo.forEach((fac) => {
            if (FacilityUtils.isFacilityType(fac, FacilityType.USR)) {
                ret.push(fac);
            }
        });
        return ret;
    }
    /**
     * Adds a visual or runway facility from the FlightPlanLeg.
     * @param leg the leg to build the facility from.
     * @param visualRunwayDesignation is the visual runway this facility belongs to.
     */
    addVisualFacilityFromLeg(leg, visualRunwayDesignation) {
        const fac = {
            icao: leg.fixIcao,
            lat: leg.lat !== undefined ? leg.lat : 0,
            lon: leg.lon !== undefined ? leg.lon : 0,
            approach: `VISUAL ${visualRunwayDesignation}`,
            city: '',
            name: `${visualRunwayDesignation} - ${ICAO.getIdent(leg.fixIcao)}`,
            region: '',
            magvar: 0
        };
        this.facRepo.add(fac);
    }
    /**
     * Method to insert a waypoint to the flightplan.
     * @param facility is the new facility to add a leg to.
     * @param segmentIndex is index of the segment to add the waypoint to
     * @param legIndex is the index to insert the waypoint (if none, append)
     * @returns whether the waypoint was successfully inserted.
     */
    insertWaypoint(facility, segmentIndex, legIndex) {
        var _a;
        const leg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: facility.icao
        });
        let plan = this.getPlanForFmcRender();
        let createdModPlan = false;
        if (segmentIndex === undefined) {
            const lastSegment = plan.segmentCount > 0 ? plan.getSegment(plan.segmentCount - 1) : undefined;
            if (lastSegment) {
                if (lastSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, lastSegment.segmentIndex + 1);
                    if (plan.planIndex !== BoeingFms.RTE_1_MOD_PLAN_INDEX && plan.planIndex !== BoeingFms.RTE_2_MOD_PLAN_INDEX) {
                        createdModPlan = true;
                    }
                    plan = this.getPlanToModify();
                }
                else {
                    segmentIndex = lastSegment.segmentIndex;
                }
            }
            else {
                return false;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, legIndex !== null && legIndex !== void 0 ? legIndex : Infinity);
        const nextLeg = plan.getNextLeg(segmentIndex, legIndex === undefined ? Infinity : legIndex - 1);
        // Make sure we are not inserting a duplicate leg
        if ((prevLeg && this.isDuplicateLeg(prevLeg.leg, leg)) || (nextLeg && this.isDuplicateLeg(leg, nextLeg.leg))) {
            if (createdModPlan) {
                this.cancelMod();
            }
            return false;
        }
        // Make sure we are not inserting a leg into a direct to sequence
        if (prevLeg) {
            const isInDirectTo = BitFlags.isAll(prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.flags, WT21LegDefinitionFlags.DirectTo);
            const isDirectToTarget = BitFlags.isAll(prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.flags, WT21LegDefinitionFlags.DirectToTarget);
            if (isInDirectTo && !isDirectToTarget) {
                if (createdModPlan) {
                    this.cancelMod();
                }
                return false;
            }
        }
        plan = this.getPlanToModify();
        // Deal with whether this insert is in an airway segment
        if (segment.airway) {
            //check to see if this insert will leave more than 1 airway leg
            if (!legIndex || segment.legs.length - legIndex < 3) {
                // we don't need another airway segment,
                // we just need to add the inserted segment, the remaining airway segments into the next enroute segment
                const nextSegment = plan.getSegment(segmentIndex + 1);
                if (nextSegment.airway || nextSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    //the next segment is an airway, arrival, approach or destination, so we need to add an enroute segment
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                }
                //now we can add the new leg into the next enroute segment
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                for (let k = 0; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 1, legsToMove[k]);
                }
            }
            else {
                //we need to create a new airway segment
                //split the segment into three
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                const newAirwaySegment = plan.getSegment(segmentIndex + 2);
                //add the leg to the new enroute segment (between the old and new airway segments)
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                this.planAddLeg(segmentIndex + 1, legsToMove[0]);
                for (let k = 1; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 2, legsToMove[k]);
                }
                const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[legIndex - 1].name : segment.airway;
                plan.setAirway(segmentIndex, segment.airway);
                newAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + newAirwaySegment.legs[newAirwaySegment.legs.length - 1].name : segment.airway;
                plan.setAirway(segmentIndex + 2, newAirwaySegment.airway);
            }
            return true;
        }
        else {
            // WT21 Addition; manage where legs are added from the legs page
            // TODO this maybe needs to go before the airway section
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Arrival:
                    if (legIndex === 0) {
                        segmentIndex -= 1;
                        legIndex = undefined;
                    }
                    else if (!legIndex) {
                        if (segmentIndex === plan.segmentCount - 1 || plan.getSegment(segmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                        }
                        else {
                            segmentIndex += 1;
                        }
                        legIndex = 0;
                    }
                    break;
                case FlightPlanSegmentType.Approach:
                    if (legIndex === 0) {
                        if (plan.procedureDetails.arrivalIndex > -1 && plan.getSegment(segmentIndex - 1).segmentType !== FlightPlanSegmentType.Enroute) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                            legIndex = undefined;
                        }
                        else {
                            segmentIndex -= 1;
                            legIndex = undefined;
                        }
                    }
                    else if (!legIndex) {
                        if (segmentIndex === plan.segmentCount - 1) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute);
                        }
                    }
                    break;
            }
            const addedLeg = this.planAddLeg(segmentIndex, leg, legIndex);
            const addedLegGlobalIndex = plan.getLegIndexFromLeg(addedLeg);
            const addedLegSegment = plan.getSegmentFromLeg(addedLeg);
            if (addedLegSegment) {
                const addedLegLocalIndex = plan.getSegmentLegIndex(addedLegGlobalIndex);
                const legAfter = plan.getNextLeg(addedLegSegment === null || addedLegSegment === void 0 ? void 0 : addedLegSegment.segmentIndex, addedLegLocalIndex);
                if (legAfter && !BoeingFmsUtils.isDiscontinuityLeg(legAfter.leg.type)) {
                    this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), addedLegLocalIndex + 1);
                }
            }
            return true;
        }
    }
    /**
     * Removes a leg to a waypoint from the primary flight plan.
     * @param segmentIndex The index of the segment containing the leg to remove.
     * @param segmentLegIndex The index of the leg to remove in its segment.
     * @param skipFafMapCheck Whether to force deletion regardless of FAF/MAP flags
     * @param skipHoldDelete Whether to skip deleting holds associated with this leg
     * @returns Whether the waypoint was successfully removed.
     */
    removeWaypoint(segmentIndex, segmentLegIndex, skipFafMapCheck = false, skipHoldDelete = false) {
        let plan = this.getPlanForFmcRender();
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return false;
        }
        const legGlobalIndex = plan.getLegIndexFromLeg(leg);
        if (!skipFafMapCheck && (!leg || BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF | FixTypeFlags.MAP))) {
            return false;
        }
        const legDeleted = this.planRemoveLeg(segmentIndex, segmentLegIndex);
        if (legDeleted) {
            plan = this.getPlanToModify();
            const prevLeg = plan.tryGetLeg(legGlobalIndex - 1);
            let nextLeg = plan.tryGetLeg(legGlobalIndex);
            if (!skipHoldDelete && legDeleted && nextLeg && BoeingFmsUtils.isHoldAtLeg(nextLeg.leg.type)) {
                if (plan.tryGetLeg(segmentIndex, segmentLegIndex)) {
                    this.planRemoveLeg(segmentIndex, segmentLegIndex, true, true, true);
                }
                nextLeg = plan.tryGetLeg(legGlobalIndex);
            }
            const alreadyDisco = (prevLeg && BoeingFmsUtils.isDiscontinuityLeg(prevLeg.leg.type)) || (nextLeg && BoeingFmsUtils.isDiscontinuityLeg(nextLeg.leg.type));
            if (!BoeingFmsUtils.isDiscontinuityLeg(leg.leg.type) && !alreadyDisco) {
                this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), segmentLegIndex);
            }
        }
        return legDeleted;
    }
    /**
     * Sets the speed and altitude constraints for a log.
     * @param globalLegIndex Global leg index of the leg to modify.
     * @param verticalData The vertical data to set on the leg. Will be merged with existing data.
     * @returns Whether the data was set.
     */
    setUserConstraint(globalLegIndex, verticalData) {
        const plan = this.hasPrimaryFlightPlan() && this.getPlanToModify();
        if (!plan) {
            return false;
        }
        const segment = plan.tryGetSegment(plan.getSegmentIndex(globalLegIndex));
        const leg = segment === null || segment === void 0 ? void 0 : segment.legs[globalLegIndex - segment.offset];
        if (segment === null || leg === undefined) {
            return false;
        }
        const isDeparture = segment.segmentType === FlightPlanSegmentType.Departure || segment.segmentType === FlightPlanSegmentType.Origin;
        const isMapr = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
        plan.setLegVerticalData(globalLegIndex, Object.assign({ phase: isDeparture || isMapr ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent }, verticalData), true);
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Gets the airway leg type of a flight plan leg.
     * @param plan The flight plan containing the query leg.
     * @param segmentIndex The index of the flight plan segment containing the query leg.
     * @param segmentLegIndex The index of the query leg in its segment.
     * @returns The airway leg type of the query leg.
     */
    getAirwayLegType(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        const segmentIsAirway = segment.airway !== undefined;
        const nextSegmentIsAirway = segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined;
        const legIsLast = segmentLegIndex == segment.legs.length - 1;
        if ((segmentIsAirway && legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.EXIT_ENTRY;
        }
        if ((legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.ENTRY;
        }
        if (segmentIsAirway) {
            if (legIsLast) {
                return AirwayLegType.EXIT;
            }
            return AirwayLegType.ONROUTE;
        }
        return AirwayLegType.NONE;
    }
    /**
     * Method to get the distance of an airway segment.
     * @param segmentIndex is the index of the segment of the airway.
     * @returns the cumulative distance for the airway segment.
     */
    getAirwayDistance(segmentIndex) {
        var _a, _b, _c, _d;
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const entrySegment = plan.getSegment(segmentIndex - 1);
        const entryCumulativeDistance = (_b = (_a = entrySegment.legs[entrySegment.legs.length - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance;
        const exitCumulativeDistance = (_d = (_c = segment.legs[segment.legs.length - 1]) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.cumulativeDistance;
        return exitCumulativeDistance && entryCumulativeDistance ? exitCumulativeDistance - entryCumulativeDistance : -1;
    }
    /**
     * Method to add a new origin airport and runway to the flight plan.
     * @param airport is the facility of the origin airport.
     * @param runway is the onewayrunway
     */
    setOrigin(airport, runway) {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        if (airport) {
            if (plan.originAirport !== airport.icao) {
                plan.setOriginAirport(airport.icao);
            }
            plan.setOriginRunway(runway);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, segmentIndex, airport, runway);
            const prevLeg = plan.getPrevLeg(segmentIndex, 1);
            const nextLeg = plan.getNextLeg(segmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        else {
            plan.removeOriginAirport();
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, -1);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        }
        this.facilityInfo.originFacility = airport;
        plan.calculate(0);
    }
    /**
     * Method to add a new destination airport and runway to the flight plan.
     * @param airport is the facility of the destination airport.
     * @param runway is the selected runway at the destination facility.
     */
    setDestination(airport, runway) {
        const plan = this.getPlanToModify();
        plan.setProcedureDetails({
            arrivalIndex: -1,
            arrivalRunway: undefined,
            arrivalTransitionIndex: -1,
            arrivalRunwayTransitionIndex: -1,
            approachIndex: -1,
            approachTransitionIndex: -1,
        });
        if (airport) {
            plan.setDestinationAirport(airport.icao);
            plan.setDestinationRunway(runway);
        }
        else {
            plan.removeDestinationAirport();
        }
        this.facilityInfo.destinationFacility = airport;
        plan.calculate(0);
        this.performancePlanForFmcRender.transitionLevel.set(definitions.transitionLevel.defaultValue);
    }
    /**
     * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
     * @param segmentType is the segment type we want to evaluate.
     * @param insert is whether to insert the segment if missing
     * @returns segmentIndex of the only segment of this type in the flight plan, -1 if insert is false and and the segment does not exist.
     */
    ensureOnlyOneSegmentOfType(segmentType, insert = true) {
        const plan = this.getPlanToModify();
        let segmentIndex;
        const selectedSegments = plan.segmentsOfType(segmentType);
        const segmentIndexArray = [];
        for (const element of selectedSegments) {
            segmentIndexArray.push(element.segmentIndex);
        }
        if (segmentIndexArray.length === 0) {
            if (insert) {
                segmentIndex = this.planInsertSegmentOfType(segmentType);
            }
            else {
                segmentIndex = -1;
            }
        }
        else if (segmentIndexArray.length > 1) {
            for (let i = 0; i < segmentIndexArray.length; i++) {
                this.planRemoveSegment(segmentIndexArray[i]);
            }
            segmentIndex = this.planInsertSegmentOfType(segmentType);
        }
        else {
            segmentIndex = segmentIndexArray[0];
        }
        return segmentIndex;
    }
    /**
     * Method to invert the flightplan.
     * TODO Does the WT21 support this?
     */
    invertFlightplan() {
        var _a;
        const plan = this.getPlanToModify();
        if (plan.directToData.segmentIndex >= 0 && plan.directToData.segmentLegIndex >= 0) {
            this.removeDirectToExisting();
        }
        const newOriginIcao = plan.destinationAirport;
        const newDestinationIcao = plan.originAirport;
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (lastEnrouteSegmentIndex === 1 && plan.getSegment(1).legs.length > 0) {
            //case for when there is only 1 enroute segment and it has at least 1 waypoint, a simple reversal is all that's required.
            const segment = Object.assign({}, plan.getSegment(1));
            this.emptyFlightPlan();
            for (let l = segment.legs.length - 1; l >= 0; l--) {
                plan.addLeg(1, segment.legs[l].leg);
            }
        }
        else if (lastEnrouteSegmentIndex > 1) {
            //case for when there is more than 1 enroute segment we know we have to deal with airways
            const legs = [];
            for (let i = 1; i <= lastEnrouteSegmentIndex; i++) {
                //create a temporary list of legs that looks like what a flight plan import looks like with ICAO and the airway
                //we fly FROM the leg on.
                const oldSegment = plan.getSegment(i);
                const airway = oldSegment.airway ? (_a = oldSegment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0] : undefined;
                for (const leg of oldSegment.legs) {
                    const legListItem = { icao: leg.leg.fixIcao, airway: airway };
                    legs.push(legListItem);
                }
            }
            //after the array of legs is complete, we just reverse it
            legs.reverse();
            this.emptyFlightPlan();
            let currentSegment = 1;
            let lastLegWasAirway = false;
            //last we go through each leg and use the same logic we use for the flight plan import to go through each leg and create airway
            //segments as appropriate for these legs.
            for (let i = 0; i < legs.length; i++) {
                const wpt = legs[i];
                const segment = plan.getSegment(currentSegment);
                if (wpt.airway) {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airway);
                        currentSegment += 1;
                    }
                    for (let j = i + 1; j < legs.length; j++) {
                        i++;
                        const airwayLeg = FlightPlan.createLeg({
                            type: LegType.TF,
                            fixIcao: legs[j].icao
                        });
                        plan.addLeg(currentSegment, airwayLeg);
                        if (legs[j].airway !== wpt.airway) {
                            lastLegWasAirway = legs[j].airway ? true : false;
                            break;
                        }
                    }
                    plan.setAirway(currentSegment, wpt.airway + '.' + ICAO.getIdent(legs[i].icao));
                    currentSegment += 1;
                    plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? legs[i].airway : undefined);
                }
                else {
                    let leg = undefined;
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    if (leg) {
                        plan.addLeg(currentSegment, leg);
                        if (lastLegWasAirway) {
                            plan.setAirway(currentSegment, segment.airway + '.' + ICAO.getIdent(wpt.icao));
                            currentSegment += 1;
                            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                        }
                        lastLegWasAirway = false;
                    }
                }
            }
            if (plan.getSegment(currentSegment).airway) {
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
            }
        }
        else {
            this.emptyFlightPlan();
        }
        if (newOriginIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newOriginIcao).then((facility) => {
                this.setOrigin(facility);
            });
        }
        if (newDestinationIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newDestinationIcao).then((facility) => {
                this.setDestination(facility);
            });
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, -1);
        plan.calculate(0);
    }
    /**
     * Checks whether the procedure being modified contains the currently active from and to legs and, if so,
     * returns those two legs. If the active leg is a direct to, this returns the entire direct to sequence (3 legs)
     * @param plan The flight plan.
     * @param segmentIndex The Segment Index.
     * @returns The array of active legs.
     */
    getActiveLegsInCurrentProcedure(plan, segmentIndex) {
        if (plan.getSegmentIndex(plan.activeLateralLeg) === segmentIndex) {
            const currentToLeg = plan.tryGetLeg(plan.activeLateralLeg);
            const currentFromLeg = plan.tryGetLeg(plan.activeLateralLeg - 1);
            if (!currentToLeg || !currentFromLeg) {
                return undefined;
            }
            const newToLeg = Object.assign({}, currentToLeg.leg);
            const newFromLeg = Object.assign({}, currentFromLeg.leg);
            if (BitFlags.isAll(currentToLeg.flags, WT21LegDefinitionFlags.DirectTo)) {
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                return [discoLeg, newFromLeg, newToLeg];
            }
            else {
                return [newFromLeg, newToLeg];
            }
        }
        return undefined;
    }
    /**
     * Method to add or replace a departure procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param departureIndex is the index of the departure
     * @param departureRunwayIndex is the index of the runway transition
     * @param enrouteTransitionIndex is the index of the enroute transition
     * @param oneWayRunway is the one way runway to set as the origin leg.
     */
    insertDeparture(facility, departureIndex, departureRunwayIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getPlanToModify();
        plan.setDeparture(facility.icao, departureIndex, enrouteTransitionIndex, departureRunwayIndex);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        // Grabbing the active legs (if there are any) in the existing departure semgent,
        // so that we can put them somewhere after clearing the segment.
        const activeLegArray = !Simplane.getIsGrounded() && plan.activeLateralLeg > 0 ? this.getActiveLegsInCurrentProcedure(plan, segmentIndex) : undefined;
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        const insertProcedureObject = this.buildDepartureLegs(facility, departureIndex, enrouteTransitionIndex, departureRunwayIndex, oneWayRunway);
        if (plan.originAirport !== facility.icao) {
            plan.setOriginAirport(facility.icao);
        }
        plan.setOriginRunway(oneWayRunway);
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l, undefined, WT21LegDefinitionFlags.ProcedureLeg));
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const depSegment = plan.getSegment(segmentIndex);
        const lastDepLeg = depSegment.legs[depSegment.legs.length - 1];
        if (nextLeg && lastDepLeg && this.isDuplicateLeg(lastDepLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastDepLeg, nextLeg);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(depSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        this.setVerticalData(plan, segmentIndex);
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildDepartureLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const departure = facility.departures[procedureIndex];
        const enRouteTransition = departure.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = departure.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        let originLeg;
        if (oneWayRunway) {
            originLeg = BoeingFmsUtils.buildRunwayLeg(facility, oneWayRunway, true);
        }
        else {
            originLeg = FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.IF,
                fixIcao: facility.icao
            });
        }
        insertProcedureObject.procedureLegs.push(originLeg);
        if (runwayTransition !== undefined && runwayTransition.legs.length > 0) {
            for (const leg of runwayTransition.legs) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            }
        }
        for (let i = 0; i < departure.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(departure.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (enRouteTransition) {
            for (let i = 0; i < enRouteTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(enRouteTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(enRouteTransition.legs[i]);
            }
        }
        return insertProcedureObject;
    }
    /**
     * Method to add or replace an arrival procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param arrivalIndex is the index of the arrival procedure.
     * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
     * @param enrouteTransitionIndex is the index of the enroute transition.
     * @param oneWayRunway is the one way runway to set as the destination leg.
     */
    insertArrival(facility, arrivalIndex, arrivalRunwayTransitionIndex, enrouteTransitionIndex, oneWayRunway) {
        var _a, _b;
        const plan = this.getPlanToModify();
        const activeSegment = BoeingFmsUtils.getActiveSegment(plan);
        if (plan.procedureDetails.approachIndex < 0) {
            if (plan.destinationAirport !== facility.icao) {
                plan.setDestinationAirport(facility.icao);
            }
            plan.setDestinationRunway(oneWayRunway);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        let arrivalActiveLegIcao;
        if (arrivalIndex > -1 && arrivalIndex === plan.procedureDetails.arrivalIndex && activeSegment !== undefined && activeLegArray !== undefined) {
            arrivalActiveLegIcao = (_b = (_a = plan.tryGetLeg(plan.activeLateralLeg)) === null || _a === void 0 ? void 0 : _a.leg) === null || _b === void 0 ? void 0 : _b.fixIcao;
        }
        plan.setArrival(facility.icao, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Arrival);
        }
        const insertProcedureObject = this.buildArrivalLegs(facility, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex, oneWayRunway);
        let directTargetLeg;
        let handleDirectToDestination = false;
        const directToState = this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        if (directToState === DirectToState.TOEXISTING) {
            directTargetLeg = this.getDirectToLeg();
            if ((directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === plan.destinationAirport &&
                (directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1].fixIcao) {
                handleDirectToDestination = true;
            }
        }
        if (!handleDirectToDestination) {
            this.tryMoveDestinationLeg(plan);
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l, undefined, WT21LegDefinitionFlags.ProcedureLeg));
        const arrSegment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstArrLeg = arrSegment.legs[0];
        let deduplicatedEnrouteLeg = null;
        if (prevLeg && firstArrLeg && this.isDuplicateLeg(prevLeg.leg, firstArrLeg.leg)) {
            deduplicatedEnrouteLeg = this.planRemoveDuplicateLeg(prevLeg, firstArrLeg);
        }
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const lastArrLeg = arrSegment.legs[arrSegment.legs.length - 1];
        if (nextLeg && lastArrLeg && this.isDuplicateLeg(lastArrLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastArrLeg, nextLeg);
        }
        if (handleDirectToDestination) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Arrival, segmentIndex);
            this.activateLeg(segmentIndex, arrSegment.legs.length - 1);
        }
        // If we didn't remove a duplicate, insert a discontinuity at the start of the arrival
        if (!deduplicatedEnrouteLeg && (!prevLeg || !BoeingFmsUtils.isVectorsLeg(prevLeg.leg.type))) {
            this.tryInsertDiscontinuity(plan, segmentIndex);
        }
        const matchingActiveProcedureLegIndex = BoeingFmsUtils.findIcaoInSegment(arrSegment, arrivalActiveLegIcao);
        if (activeLegArray && matchingActiveProcedureLegIndex === undefined) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(arrSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        else if (matchingActiveProcedureLegIndex !== undefined) {
            plan.setLateralLeg(arrSegment.offset + matchingActiveProcedureLegIndex);
        }
        this.setVerticalData(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.tryConnectProcedures(plan);
        plan.calculate(0);
    }
    /**
     * Tries to add a discontinuity when needed at the start of a procedure.
     * @param plan The Flight Plan
     * @param segmentIndex The procedure segment index.
     */
    tryInsertDiscontinuity(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.legs.length > 0) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Arrival:
                case FlightPlanSegmentType.Approach:
                    this.insertDiscontinuity(plan, segmentIndex, 0);
            }
        }
    }
    /**
     * Method to connect an arrival and approach when the approach begins at a leg that exists in the arrival.
     * @param plan The Lateral Flight Plan.
     */
    tryConnectProcedures(plan) {
        if (plan.procedureDetails.approachIndex > -1 && plan.procedureDetails.arrivalIndex > -1) {
            // find the first leg in the approach
            let firstApproachLeg;
            let firstApproachSegmentLegIndex;
            let matchedArrivalLegSegmentLegIndex;
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
            const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival, false);
            if (approachSegmentIndex > -1 && arrivalSegmentIndex > -1) {
                const approachSegment = plan.getSegment(approachSegmentIndex);
                const arrivalSegment = plan.getSegment(arrivalSegmentIndex);
                for (let l = 0; l < approachSegment.legs.length; l++) {
                    const approachLeg = approachSegment.legs[l];
                    if (approachLeg.leg.type !== LegType.Discontinuity && approachLeg.leg.type !== LegType.ThruDiscontinuity) {
                        firstApproachLeg = approachLeg;
                        firstApproachSegmentLegIndex = l;
                        break;
                    }
                }
                for (let i = arrivalSegment.legs.length - 1; i > 0; i--) {
                    const arrivalLeg = arrivalSegment.legs[i];
                    if ((arrivalLeg === null || arrivalLeg === void 0 ? void 0 : arrivalLeg.name) && (firstApproachLeg === null || firstApproachLeg === void 0 ? void 0 : firstApproachLeg.name) && arrivalLeg.name === firstApproachLeg.name) {
                        matchedArrivalLegSegmentLegIndex = i;
                        break;
                    }
                }
                if (firstApproachSegmentLegIndex !== undefined && matchedArrivalLegSegmentLegIndex !== undefined) {
                    while (arrivalSegment.legs.length > matchedArrivalLegSegmentLegIndex) {
                        plan.removeLeg(arrivalSegmentIndex, matchedArrivalLegSegmentLegIndex);
                    }
                    for (let j = 0; j < firstApproachSegmentLegIndex; j++) {
                        plan.removeLeg(approachSegmentIndex, j);
                    }
                }
            }
        }
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildArrivalLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    oneWayRunway) {
        const arrival = facility.arrivals[procedureIndex];
        const enRouteTransition = arrival.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = arrival.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (enRouteTransition !== undefined && enRouteTransition.legs.length > 0) {
            for (const leg of enRouteTransition.legs) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            }
        }
        for (let i = 0; i < arrival.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(arrival.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (runwayTransition) {
            for (let i = 0; i < runwayTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(runwayTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        this.tryInsertIFLeg(insertProcedureObject);
        return insertProcedureObject;
    }
    /**
     * Method to move a direct to destination to a specified target segment.
     * @param plan is the primary flight plan.
     * @param targetSegmentType is the target segment type.
     * @param arrivalSegmentIndex is the arrival segment index
     * @returns whether a direct to destination was moved.
     */
    moveDirectToDestinationLeg(plan, targetSegmentType, arrivalSegmentIndex) {
        const directTargetSegmentIndex = targetSegmentType === FlightPlanSegmentType.Arrival ? arrivalSegmentIndex : this.findLastEnrouteSegmentIndex(plan);
        if (directTargetSegmentIndex !== undefined && directTargetSegmentIndex > 0 && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport) {
            const destinationLeg = Object.assign({}, plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex].leg);
            const directTargetLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg).leg);
            const directOriginLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 1).leg);
            const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
            const newDirectLegIndex = plan.getSegment(directTargetSegmentIndex).legs.length;
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.setDirectToData(directTargetSegmentIndex, newDirectLegIndex);
            plan.addLeg(directTargetSegmentIndex, destinationLeg);
            plan.addLeg(directTargetSegmentIndex, discoLeg, undefined, WT21LegDefinitionFlags.DirectTo);
            plan.addLeg(directTargetSegmentIndex, directOriginLeg, undefined, WT21LegDefinitionFlags.DirectTo);
            const newActiveLeg = plan.addLeg(directTargetSegmentIndex, directTargetLeg, undefined, WT21LegDefinitionFlags.DirectTo | WT21LegDefinitionFlags.DirectToTarget);
            const newActiveLegIndex = plan.getLegIndexFromLeg(newActiveLeg);
            plan.setCalculatingLeg(newActiveLegIndex);
            plan.setLateralLeg(newActiveLegIndex);
            plan.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX && plan.calculate(newActiveLegIndex);
            return true;
        }
        return false;
    }
    /**
     * Checks if the last leg in the last enroute segment is the destination airport and, if so, moves it into the approach segment.
     * @param plan The lateral flight plan.
     */
    tryMoveDestinationLeg(plan) {
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
        if (lastEnrouteSegment !== undefined && lastEnrouteSegment.legs.length > 0 &&
            lastEnrouteSegment.legs[lastEnrouteSegment.legs.length - 1].leg.fixIcao === plan.destinationAirport) {
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, true);
            const approachSegment = plan.getSegment(approachSegmentIndex);
            if (approachSegment.legs.length < 1) {
                const destinationLeg = Object.assign({}, lastEnrouteSegment.legs[lastEnrouteSegment.legs.length - 1].leg);
                plan.removeLeg(lastEnrouteSegmentIndex);
                plan.addLeg(approachSegmentIndex, destinationLeg);
            }
        }
    }
    /**
     * Method to find the last enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the last enroute segment in.
     * @returns a segment index.
     */
    findLastEnrouteSegmentIndex(plan) {
        let enrouteSegmentFound = 0;
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute) {
                enrouteSegmentFound = i;
            }
        }
        return enrouteSegmentFound;
    }
    /**
     * Method to check whether an approach can load, or only activate.
     * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
     */
    canApproachLoad() {
        const plan = this.getFlightPlan();
        if (plan.length > 0) {
            const activeSegment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
            if (activeSegment.segmentType !== FlightPlanSegmentType.Approach && plan.length > 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to add or replace an approach procedure in the flight plan.
     *
     * @param description the approach procedure description
     *
     * @returns A Promise which is fulfilled with whether the approach was inserted.
     */
    async insertApproach(description) {
        var _a, _b, _c, _d;
        const plan = this.getPlanToModify();
        if (plan.length > 0 && plan.procedureDetails.approachIndex < 0) {
            const lastLeg = plan.tryGetLeg(plan.length - 1);
            if ((lastLeg === null || lastLeg === void 0 ? void 0 : lastLeg.leg.fixIcao) === plan.destinationAirport) {
                plan.removeLeg(plan.getSegmentIndex(plan.length - 1));
            }
        }
        let visualRunway;
        if (description.visualRunwayNumber !== undefined && description.visualRunwayDesignator !== undefined) {
            visualRunway = RunwayUtils.matchOneWayRunway(description.facility, description.visualRunwayNumber, description.visualRunwayDesignator);
            if (!visualRunway) {
                return false;
            }
        }
        let approach;
        if (visualRunway) {
            approach = BoeingFmsUtils.buildVisualApproach(this.facRepo, description.facility, visualRunway, (_a = description.visualRunwayOffset) !== null && _a !== void 0 ? _a : 5, description.vfrVerticalPathAngle);
        }
        else {
            approach = description.facility.approaches[description.approachIndex];
        }
        const opId = ++this.insertApproachOpId;
        const insertProcedureObject = await this.buildApproachLegs(description, approach, visualRunway);
        if (visualRunway) {
            this.setFlightPlanVisualApproach(plan.planIndex, visualRunway.designation);
            this.setFlightPlanVisualApproachVfrVpa(plan.planIndex, description.vfrVerticalPathAngle);
        }
        else if (this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            this.setFlightPlanVisualApproach(plan.planIndex, undefined);
            this.setFlightPlanVisualApproachVfrVpa(plan.planIndex, undefined);
        }
        plan.setApproach(description.facility.icao, description.approachIndex, description.approachTransitionIndex);
        const directToState = this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        let skipDestinationLegCheck = false;
        if (directToState === DirectToState.TOEXISTING) {
            if (((_b = this.getDirectToLeg()) === null || _b === void 0 ? void 0 : _b.fixIcao) === plan.destinationAirport) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                skipDestinationLegCheck = true;
            }
        }
        if (directToState === DirectToState.TOEXISTING && plan.procedureDetails.arrivalIndex < 0 && !skipDestinationLegCheck) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute);
        }
        if (plan.destinationAirport !== description.facility.icao) {
            plan.setDestinationAirport(description.facility.icao);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        const apprSegment = plan.getSegment(segmentIndex);
        if (apprSegment.legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Approach);
        }
        if (opId !== this.insertApproachOpId) {
            return false;
        }
        if (insertProcedureObject.runway) {
            plan.setDestinationRunway(insertProcedureObject.runway);
        }
        else {
            plan.setDestinationRunway(undefined);
        }
        let haveAddedMap = false;
        insertProcedureObject.procedureLegs.forEach((l) => {
            var _a;
            let isMissedLeg = false;
            if (visualRunway !== undefined) {
                this.addVisualFacilityFromLeg(l, visualRunway.designation);
                if (haveAddedMap) {
                    isMissedLeg = true;
                }
                if (l.fixTypeFlags & FixTypeFlags.MAP) {
                    haveAddedMap = true;
                }
            }
            let flags = (_a = l.WT21LegDefinitionFlags) !== null && _a !== void 0 ? _a : WT21LegDefinitionFlags.None;
            flags |= WT21LegDefinitionFlags.ProcedureLeg;
            if (isMissedLeg) {
                flags |= WT21LegDefinitionFlags.MissedApproach;
            }
            this.planAddLeg(segmentIndex, l, undefined, flags);
        });
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstAppLeg = apprSegment.legs[0];
        let deduplicatedArrivalLeg = null;
        if (prevLeg && firstAppLeg && this.isDuplicateLeg(prevLeg.leg, firstAppLeg.leg)) {
            deduplicatedArrivalLeg = this.planRemoveDuplicateLeg(prevLeg, firstAppLeg);
        }
        // Adds missed approach legs
        if (!visualRunway && insertProcedureObject.procedureLegs.length > 0) {
            const missedLegs = (_c = description.facility.approaches[description.approachIndex].missedLegs) !== null && _c !== void 0 ? _c : [];
            if (missedLegs.length > 0) {
                let maphIndex = -1;
                for (let m = missedLegs.length - 1; m >= 0; m--) {
                    switch (missedLegs[m].type) {
                        case LegType.HA:
                        case LegType.HF:
                        case LegType.HM:
                            maphIndex = m - 1;
                            break;
                    }
                }
                let flags = WT21LegDefinitionFlags.MissedApproach;
                flags |= WT21LegDefinitionFlags.ProcedureLeg;
                for (let n = 0; n < missedLegs.length; n++) {
                    const newLeg = FlightPlan.createLeg(missedLegs[n]);
                    if (maphIndex >= 0 && n === maphIndex) {
                        newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                        this.planAddLeg(segmentIndex, newLeg, undefined, flags);
                    }
                    else {
                        this.planAddLeg(segmentIndex, newLeg, undefined, flags);
                    }
                }
            }
        }
        const rnavTypeFlag = BoeingFmsUtils.getBestRnavType(approach.rnavTypeFlags);
        const approachIsCircling = !visualRunway && !(approach === null || approach === void 0 ? void 0 : approach.runway);
        const approachName = BoeingFmsUtils.getApproachNameAsEfisString(approach);
        const approachRunway = RunwayUtils.getRunwayNameString(approach.runwayNumber, approach.runwayDesignator, true, 'RW');
        let referenceFacility = null;
        if (approach && BoeingFmsUtils.approachHasNavFrequency(approach)) {
            referenceFacility = (_d = await ApproachUtils.getReferenceFacility(approach, this.facLoader)) !== null && _d !== void 0 ? _d : null;
        }
        const finalApproachCourse = await this.getFinalApproachCourse(description.facility, approach);
        this.setApproachDetails(true, approach.approachType, rnavTypeFlag, false, approachIsCircling, approachName, approachRunway, referenceFacility, finalApproachCourse);
        // set the G/S flag default state
        this.performancePlanProxy.glideSlope.set(approach.approachType === ApproachType.APPROACH_TYPE_ILS ? GlideslopeStatus.ON : GlideslopeStatus.OFF);
        // If we didn't remove a duplicate, insert a discontinuity at the start of the approach
        if (!deduplicatedArrivalLeg && (!prevLeg || !BoeingFmsUtils.isVectorsLeg(prevLeg.leg.type))) {
            this.tryInsertDiscontinuity(plan, segmentIndex);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(apprSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                // We should really never get into the scenario where this leg is a discontinuity, but let's be safe
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, WT21LegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        this.setVerticalData(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.tryConnectProcedures(plan);
        plan.calculate();
        return true;
    }
    /**
     * Method to build the approach legs.
     *
     * @param description the approach procedure description
     * @param resolvedApproach the resolved approach procedure
     * @param resolvedVisualRunway the resolved visual runway, if applicable
     *
     * @returns A Promise which is fulfilled with an `InsertProcedureObject` containing the flight plan legs to insert
     * into the flight plan.
     */
    async buildApproachLegs(description, resolvedApproach, resolvedVisualRunway) {
        const isVisual = resolvedApproach.approachType === AdditionalApproachType.APPROACH_TYPE_VISUAL;
        const transition = resolvedApproach.transitions[description.approachTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (transition !== undefined && transition.legs.length > 0) {
            const startIndex = description.transStartIndex !== undefined ? description.transStartIndex : 0;
            for (let t = startIndex; t < transition.legs.length; t++) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(transition.legs[t]));
            }
        }
        const lastTransitionLeg = insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1];
        const finalLegs = resolvedApproach.finalLegs;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = FlightPlan.createLeg(finalLegs[i]);
            if (i === 0 && lastTransitionLeg && this.isDuplicateIFLeg(lastTransitionLeg, leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] = this.mergeDuplicateLegData(lastTransitionLeg, leg);
                continue;
            }
            if (!isVisual && leg.fixIcao[0] === 'R') {
                const approachRunway = RunwayUtils.matchOneWayRunway(description.facility, resolvedApproach.runwayNumber, resolvedApproach.runwayDesignator);
                if (approachRunway) {
                    insertProcedureObject.runway = approachRunway;
                    const runwayLeg = BoeingFmsUtils.buildRunwayLeg(description.facility, approachRunway, false);
                    runwayLeg.verticalAngle = leg.verticalAngle;
                    insertProcedureObject.procedureLegs.push(runwayLeg);
                }
            }
            else if (isVisual && i === finalLegs.length - 1) {
                insertProcedureObject.runway = resolvedVisualRunway;
                insertProcedureObject.procedureLegs.push(leg);
                if (resolvedApproach.missedLegs.length > 0) {
                    insertProcedureObject.procedureLegs.push(resolvedApproach.missedLegs[0]);
                }
            }
            else {
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        if (!isVisual) {
            this.tryInsertIFLeg(insertProcedureObject);
            this.tryReconcileIAFLeg(insertProcedureObject);
            this.manageFafAltitudeRestriction(insertProcedureObject);
            this.tryCleanupHold(insertProcedureObject);
            this.tryInsertMap(insertProcedureObject);
            if (!insertProcedureObject.runway && resolvedApproach.runway) {
                insertProcedureObject.runway = RunwayUtils.matchOneWayRunway(description.facility, resolvedApproach.runwayNumber, resolvedApproach.runwayDesignator);
            }
            return insertProcedureObject;
        }
        return insertProcedureObject;
    }
    /**
     * Manages the altitude constraints when adding a procedure by creating a VerticalData object for each leg.
     * @param plan The Flight Plan.
     * @param segmentIndex The segment index for the inserted procedure.
     */
    setVerticalData(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        for (let l = 0; l < segment.legs.length; l++) {
            const leg = segment.legs[l];
            const altitude1 = leg.leg.altitude1;
            const altitude2 = leg.leg.altitude2;
            const altDesc = (BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.MAP) && altitude1 !== 0) ? AltitudeRestrictionType.At : leg.leg.altDesc;
            const speedRestriction = leg.leg.speedRestriction;
            const verticalData = {
                phase: segment.segmentType === FlightPlanSegmentType.Departure || BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)
                    ? VerticalFlightPhase.Climb
                    : VerticalFlightPhase.Descent,
                altDesc: altDesc,
                altitude1: altitude1,
                altitude2: altitude2,
                speed: speedRestriction <= 0 ? 0 : speedRestriction,
                speedDesc: speedRestriction <= 0 ? SpeedRestrictionType.Unused : SpeedRestrictionType.AtOrBelow,
                speedUnit: SpeedUnit.IAS
            };
            plan.setLegVerticalData(segmentIndex, l, verticalData);
        }
    }
    /**
     * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    manageFafAltitudeRestriction(proc) {
        proc.procedureLegs.forEach(leg => {
            if (leg.fixTypeFlags === FixTypeFlags.FAF && leg.altitude2 > 0) {
                const alt = leg.altitude1 <= leg.altitude2 ? leg.altitude1 : leg.altitude2;
                leg.altDesc = AltitudeRestrictionType.At;
                leg.altitude1 = alt;
                leg.altitude2 = alt;
            }
            else if (leg.fixTypeFlags === FixTypeFlags.FAF) {
                leg.altDesc = AltitudeRestrictionType.At;
                leg.altitude2 = leg.altitude1;
            }
        });
        return proc;
    }
    /**
     * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertIFLeg(proc) {
        const firstLeg = proc.procedureLegs[0];
        let icao;
        switch (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) {
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
            case LegType.FD:
            case LegType.FC:
                icao = firstLeg.fixIcao;
                break;
            case LegType.FM:
            case LegType.VM:
                icao = firstLeg.originIcao;
                break;
        }
        if (icao && icao !== ICAO.emptyIcao) {
            proc.procedureLegs.unshift(FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: icao,
                fixTypeFlags: firstLeg.fixTypeFlags & (FixTypeFlags.IF | FixTypeFlags.IAF)
            }));
            if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.HF || (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.PI) {
                proc.procedureLegs[0].altDesc = firstLeg.altDesc;
                proc.procedureLegs[0].altitude1 = firstLeg.altitude1;
                proc.procedureLegs[0].altitude2 = firstLeg.altitude2;
            }
            // need to remove IF/IAF flags from the original first leg (now the second leg)
            const replacementLeg = FlightPlan.createLeg(proc.procedureLegs[1]);
            replacementLeg.fixTypeFlags = replacementLeg.fixTypeFlags & ~(FixTypeFlags.IF | FixTypeFlags.IAF);
            proc.procedureLegs[1] = replacementLeg;
        }
        return proc;
    }
    /**
     * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
     * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
     * an IF leg type.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryReconcileIAFLeg(proc) {
        let iafIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                iafIndex = i;
                switch (leg.type) {
                    case LegType.HA:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.PI:
                    case LegType.FD:
                    case LegType.FC:
                        if (iafIndex > 0) {
                            leg.fixTypeFlags &= ~FixTypeFlags.IAF;
                            proc.procedureLegs[iafIndex - 1].fixTypeFlags |= FixTypeFlags.IAF;
                            iafIndex--;
                        }
                }
                break;
            }
        }
        return proc;
    }
    /**
     * Inserts a MAP fix type flag if none exists on the approach.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertMap(proc) {
        let addMap = true;
        let runwayIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.MAP) {
                addMap = false;
                break;
            }
            if (leg.fixIcao.search('R') === 0) {
                runwayIndex = i;
                break;
            }
        }
        if (addMap && runwayIndex > -1) {
            proc.procedureLegs[runwayIndex].fixTypeFlags = FixTypeFlags.MAP;
        }
        return proc;
    }
    /**
     * Method to remove the duplicate leg after the hold leg.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryCleanupHold(proc) {
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.type === LegType.HF) {
                const next = proc.procedureLegs[i + 1];
                if (leg.fixIcao === next.fixIcao && next.type === LegType.IF) {
                    proc.procedureLegs.splice(i + 1, 1);
                }
            }
        }
        return proc;
    }
    /**
     * Method to remove a course reversal in an approach procedure.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryRemoveCourseReversal(proc) {
        let canRemove = false;
        if (proc.procedureLegs.length > 2) {
            const leg = proc.procedureLegs[1];
            switch (leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    canRemove = true;
            }
        }
        if (canRemove) {
            proc.procedureLegs.splice(1, 1);
        }
        return proc;
    }
    /**
     * Method to remove the departure from the flight plan.
     */
    async removeDeparture() {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        plan.setDeparture();
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        if (plan.originAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
            const updatedSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, updatedSegmentIndex, airport, plan.procedureDetails.originRunway);
            const prevLeg = plan.getPrevLeg(updatedSegmentIndex, 1);
            const nextLeg = plan.getNextLeg(updatedSegmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the arrival from the flight plan.
     */
    async removeArrival() {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        plan.setArrival();
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.planRemoveSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (activeLegArray && activeLegArray.length === 2) {
            this.addActiveLegsToEnroute(plan, activeLegArray);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the approach from the flight plan.
     */
    async removeApproach() {
        const plan = this.getPlanToModify();
        if (this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            this.deleteFlightPlanVisualApproach(plan.planIndex);
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, -1);
        // set the G/S enabled for non-FMS approach
        this.performancePlanProxy.glideSlope.set(GlideslopeStatus.ON);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        plan.procedureDetails.arrivalRunwayTransitionIndex = -1;
        plan.setDestinationRunway(undefined, false);
        plan.setApproach();
        this.cleanupLegsAfterApproach(plan);
        this.planRemoveSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            this.addActiveLegsToEnroute(plan, activeLegArray, true);
        }
        plan.calculate(0);
    }
    /**
     * Adds active leg pair to the last enroute segment when a procedure is deleted and the current activeLateralLeg is in that procedure.
     * @param plan The FlightPlan.
     * @param activeLegArray The Active Leg Pair.
     * @param checkForArrivalSegment Whether to check first for an arrival segment to add the legs to.
     */
    addActiveLegsToEnroute(plan, activeLegArray, checkForArrivalSegment = false) {
        let segmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (checkForArrivalSegment && plan.procedureDetails.arrivalIndex > -1) {
            const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival, false);
            if (arrivalSegmentIndex > -1) {
                segmentIndex = arrivalSegmentIndex;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        if (activeLegArray.length === 2) {
            plan.addLeg(segmentIndex, activeLegArray[0], undefined, WT21LegDefinitionFlags.DisplacedActiveLeg);
            plan.addLeg(segmentIndex, activeLegArray[1], undefined, WT21LegDefinitionFlags.DisplacedActiveLeg);
            this.planAddLeg(segmentIndex, FlightPlan.createLeg({
                type: LegType.Discontinuity
            }), undefined, WT21LegDefinitionFlags.DisplacedActiveLeg);
            plan.setLateralLeg(segment.offset + segment.legs.length - 2);
        }
        else if (activeLegArray.length === 3) {
            plan.addLeg(segmentIndex, activeLegArray[1]);
            this.planAddLeg(segmentIndex, FlightPlan.createLeg({
                type: LegType.Discontinuity
            }), undefined, WT21LegDefinitionFlags.DisplacedActiveLeg);
            this.createDirectTo(segmentIndex, segment.legs.length - 2);
        }
    }
    /**
     * Method to activate a leg in the flight plan.
     * @param segmentIndex is the index of the segment containing the leg to activate.
     * @param legIndex is the index of the leg in the selected segment activate.
     * @param removeExistingDTO Whether to check for and remove the existing direct to legs.
     */
    activateLeg(segmentIndex, legIndex, removeExistingDTO = true) {
        const modPlan = this.getPlanToModify();
        const indexInFlightplan = modPlan.getSegment(segmentIndex).offset + legIndex;
        if (removeExistingDTO && this.getDirectToState(modPlan.planIndex) === DirectToState.TOEXISTING) {
            this.removeDirectToExisting(modPlan.planIndex, indexInFlightplan);
            // The call above handles setting the active leg
        }
        else {
            modPlan.setCalculatingLeg(indexInFlightplan);
            modPlan.setLateralLeg(indexInFlightplan);
            modPlan.calculate(Math.max(0, indexInFlightplan - 1));
        }
        this.legWasActivatedInModPlan = true;
    }
    /**
     * Method to create a direct to in the plan. This method will also then call activateLeg.
     * A DTO consists of 4 legs:
     * 1. The original leg that was used to create the DTO.
     * a. We preserve this leg so that we will have a vlid FROM leg in case the DTO needs to be removed.
     * 2. A DISCO leg, because a DTO is not connected to any legs that came before it.
     * 3. The FROM leg, initializes to the present position (PPOS).
     * 4. The TO leg.
     * @param segmentIndex is the index of the segment containing the leg to activate as direct to.
     * @param segmentLegIndex is the index of the leg in the specified segment to activate as direct to.
     * @param isNewDTO whether to treat this as a new directo to or not.
     * @param course is the course for this direct to in magnetic degrees, if specified.
     * @param facility is the new facility to add to the plan and then create a direct to for, for the case of a direct to random.
     */
    createDirectTo(segmentIndex, segmentLegIndex, isNewDTO = true, course, facility) {
        var _a, _b;
        let newLeg;
        if (isNewDTO) {
            this.dtoWasCreatedInModPlan = true;
            if (facility !== undefined) {
                newLeg = FlightPlan.createLeg({
                    type: LegType.TF,
                    fixIcao: facility.icao
                });
            }
        }
        const plan = this.getPlanToModify();
        if (segmentIndex === undefined) {
            const lastSegment = plan.segmentCount > 0 ? plan.getSegment(plan.segmentCount - 1) : undefined;
            if (lastSegment) {
                if (lastSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, lastSegment.segmentIndex + 1);
                }
                else {
                    segmentIndex = lastSegment.segmentIndex;
                }
            }
            else {
                return;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        if (segmentLegIndex === undefined) {
            segmentLegIndex = Math.max(0, segment.legs.length - 1);
        }
        let modLegVerticalData;
        if (!isNewDTO && this.dtoWasCreatedInModPlan) {
            const existingModDtoTargetLeg = segment.legs[segmentLegIndex + 3];
            if (existingModDtoTargetLeg !== undefined) {
                modLegVerticalData = existingModDtoTargetLeg.verticalData;
                if (existingModDtoTargetLeg.leg.type === LegType.CF) {
                    if (existingModDtoTargetLeg.leg.trueDegrees) {
                        // FIXME we give up if no magvar available from calculations
                        course = MagVar.trueToMagnetic(existingModDtoTargetLeg.leg.course, (_b = (_a = existingModDtoTargetLeg.calculated) === null || _a === void 0 ? void 0 : _a.courseMagVar) !== null && _b !== void 0 ? _b : 0);
                    }
                    else {
                        course = existingModDtoTargetLeg.leg.course;
                    }
                }
            }
        }
        let legIndexDelta = 0;
        if (plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1) {
            legIndexDelta -= plan.directToData.segmentIndex === segmentIndex && segmentLegIndex > plan.directToData.segmentLegIndex ? 3 : 0;
            if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX) === DirectToState.TOEXISTING) {
                this.removeDirectToExisting(BoeingFms.RTE_1_MOD_PLAN_INDEX, undefined, false);
            }
            else {
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
            }
        }
        if (newLeg !== undefined) {
            this.planAddLeg(segmentIndex, newLeg, segmentLegIndex + legIndexDelta);
        }
        const leg = segment.legs[segmentLegIndex + legIndexDelta];
        plan.setDirectToData(segmentIndex, segmentLegIndex + legIndexDelta);
        if (segment && leg) {
            let originPos = this.ppos;
            if (course) {
                originPos = this.ppos.offset(NavMath.normalizeHeading(course + 180), UnitType.NMILE.convertTo(50, UnitType.GA_RADIAN), new GeoPoint(0, 0));
            }
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            const dtoOriginLeg = this.createDTOOriginLeg(originPos);
            const dtoTargetLeg = this.createDTODirectLeg(leg.leg.fixIcao, leg.leg, course);
            // We do a +1,2,3 here so that the original TO leg is preserved, in case the DTO gets removed
            plan.addLeg(segmentIndex, discoLeg, segmentLegIndex + legIndexDelta + 1, WT21LegDefinitionFlags.DirectTo);
            plan.addLeg(segmentIndex, dtoOriginLeg, segmentLegIndex + legIndexDelta + 2, WT21LegDefinitionFlags.DirectTo);
            const directToTargetLegDefinition = plan.addLeg(segmentIndex, dtoTargetLeg, segmentLegIndex + legIndexDelta + 3, (leg.flags & WT21LegDefinitionFlags.MissedApproach) | WT21LegDefinitionFlags.DirectTo | WT21LegDefinitionFlags.DirectToTarget);
            const newVerticalData = modLegVerticalData !== null && modLegVerticalData !== void 0 ? modLegVerticalData : leg.verticalData;
            plan.setLegVerticalData(segmentIndex, segmentLegIndex + legIndexDelta + 3, newVerticalData);
            if (isNewDTO) {
                if (directToTargetLegDefinition.verticalData.altDesc !== AltitudeRestrictionType.Unused) {
                    const globalLegIndex = segment.offset + segmentLegIndex + legIndexDelta + 3;
                    // We need to calculate the direct to leg before we can find out its length (we are in MOD at this point)
                    plan.calculate(globalLegIndex - 2).then(() => {
                        const finalAltitude = newVerticalData.altitude1;
                        this.createVerticalDirectTo(plan, globalLegIndex, finalAltitude, true);
                    });
                }
            }
            this.activateLeg(segmentIndex, segmentLegIndex + legIndexDelta + 3, false);
        }
    }
    /**
     * Method to create a direct to in the flight plan to an arbitrary airport.
     *
     * This:
     *
     * - empties out the flight plan;
     * - sets the destination as the provided airport facility;
     * - creates a direct-to sequence to that facility.
     *
     * @param airportFacility the airport facility to go direct to
     */
    createDirectToAirport(airportFacility) {
        const plan = this.getPlanToModify();
        const segmentCount = plan.segmentCount;
        for (let i = segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i, true);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, true);
        plan.addSegment(1, FlightPlanSegmentType.Enroute, undefined, true);
        BoeingFmsUtils.reconcileDirectToData(plan);
        this.setDestination(airportFacility);
        this.createDirectTo(undefined, undefined, true, undefined, airportFacility);
    }
    /**
     * Method to create a direct to in the flight plan to an arbitrary airport+runway using a visual approach.
     *
     * This:
     *
     * - empties out the flight plan;
     * - sets the destination as the provided airport facility;
     * - inserts a visual approach to the provided runway;
     * - creates a direct-to sequence to the FAF of that approach.
     *
     * @param airportFacility the airport facility to go direct to
     * @param runway the one way runway to insert a visual approach for
     */
    async createDirectToRunwayVisualApproach(airportFacility, runway) {
        const plan = this.getPlanToModify();
        const segmentCount = plan.segmentCount;
        for (let i = segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i, true);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, true);
        plan.addSegment(1, FlightPlanSegmentType.Enroute, undefined, true);
        BoeingFmsUtils.reconcileDirectToData(plan);
        await this.insertApproach({
            facility: airportFacility,
            approachIndex: -1,
            approachTransitionIndex: -1,
            visualRunwayNumber: runway.direction,
            visualRunwayDesignator: runway.runwayDesignator,
        });
        const approachSegment = Array.from(plan.segmentsOfType(FlightPlanSegmentType.Approach))[0];
        if (approachSegment) {
            let activateIndex = -1;
            for (let i = 0; i < approachSegment.legs.length; i++) {
                activateIndex = i;
                const leg = approachSegment.legs[i];
                const isFaf = BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.FAF);
                if (isFaf) {
                    break;
                }
            }
            if (activateIndex !== -1) {
                this.createDirectTo(approachSegment.segmentIndex, activateIndex, true, undefined);
            }
        }
    }
    /**
     * Creates a Direct-To origin IF leg.
     * @param ppos The current plane position.
     * @returns a Direct-To origin IF leg.
     */
    createDTOOriginLeg(ppos) {
        return FlightPlan.createLeg({
            type: LegType.IF,
            lat: ppos.lat,
            lon: ppos.lon
        });
    }
    /**
     * Creates a Direct-To target leg.
     * @param icao is the icao.
     * @param leg The FlightPlanLeg.
     * @param course The magnetic course for the Direct To.
     * @returns a Direct-To leg.
     */
    createDTODirectLeg(icao, leg, course) {
        let legType;
        if (course === undefined) {
            legType = LegType.DF;
            const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES MAGNETIC', 'degrees');
            course = planeHeading === 0 ? 360 : planeHeading;
        }
        else {
            legType = LegType.CF;
        }
        if (leg) {
            const directLeg = Object.assign({}, leg);
            directLeg.type = legType;
            directLeg.course = course;
            directLeg.trueDegrees = false;
            return directLeg;
        }
        else {
            return FlightPlan.createLeg({
                type: legType,
                fixIcao: icao,
                course,
                trueDegrees: false
            });
        }
        // const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
        // if (leg) {
        //   const directLeg = Object.assign({}, leg);
        //   directLeg.type = LegType.DF;
        //   directLeg.course = planeHeading === 0 ? 360 : planeHeading;
        //   return directLeg;
        // } else {
        //   return FlightPlan.createLeg({
        //     type: LegType.DF,
        //     fixIcao: icao,
        //     course: planeHeading === 0 ? 360 : planeHeading
        //   });
        // }
    }
    /**
     * Updates the DTO Origin Leg Lat/Lon with the PPOS.
     * @param plan The Flight Plan.
     */
    updateDtoOrigin(plan) {
        // We only want to update the DTO origin if the DTO was created in this current MOD plan
        if (!this.dtoWasCreatedInModPlan) {
            return;
        }
        const pposLeg = plan.tryGetLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 2);
        // Making sure that we are in a DTO
        if (!pposLeg) {
            return;
        }
        // We need to recreate the DTO so that the proper events get sent and legs get recreated and what not
        this.createDirectTo(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex, false);
    }
    /**
     * Creates a vertical direct-to to a leg. This creates a manual constraint with an fpa that reaches
     * the desired altitude using a continuous descent from the present position and altitude.
     *
     * **NOTE:** This will not delete any constraints - it is the responsibility of the caller to do so.
     *
     * @param plan the plan to use
     * @param globalIndex the global leg index to apply the constraint to
     * @param finalAltitude the altitude to target, in metres.
     * @param isAutomatic whether this was an automatic VDTO (created with a lateral DTO)
     *
     * @returns whether the vdto was successfully created
     */
    createVerticalDirectTo(plan, globalIndex, finalAltitude, isAutomatic = false) {
        var _a;
        const distanceToConstraint = isAutomatic
            ? (_a = plan.getLeg(globalIndex).calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions
            : BoeingFmsUtils.getDistanceFromPposToLegEnd(plan, globalIndex);
        if (distanceToConstraint === undefined) {
            return false;
        }
        const currentAltitude = this.aircraftAltitude;
        if (currentAltitude === undefined) {
            return false;
        }
        const currentAltitudeMetres = UnitType.METER.convertFrom(currentAltitude, UnitType.FOOT);
        const fpa = VNavUtils.getFpa(distanceToConstraint, 75 + currentAltitudeMetres - finalAltitude);
        const isFpaValid = fpa > 1 && fpa <= 6;
        if (!isFpaValid) {
            return false;
        }
        plan.setLegVerticalData(globalIndex, {
            phase: VerticalFlightPhase.Descent,
            altDesc: AltitudeRestrictionType.At,
            altitude1: finalAltitude,
            altitude2: undefined,
            fpa: isAutomatic ? Math.max(3, fpa) : fpa,
        });
        this.verticalPathCalculator.requestPathCompute(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        this.verticalDtoWasCreatedInModPlan = true;
        this.verticalDtoWasCreatedInModPlanWasAutomatic = isAutomatic;
        return true;
    }
    /**
     * Updates the vertical DTO origin with the current altitude and distance to constraint.
     * @param plan The Flight Plan.
     * @returns whether the vertical DTO is still valid
     */
    updateVerticalDtoOrigin(plan) {
        const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(this.getVerticalPlanForFmcRender(), plan.activeLateralLeg);
        if (constraintIndex === -1) {
            return false;
        }
        const constraint = this.getVerticalPlanForFmcRender().constraints[constraintIndex];
        return this.createVerticalDirectTo(plan, constraint.index, constraint.targetAltitude, this.verticalDtoWasCreatedInModPlanWasAutomatic);
    }
    /**
     * Creates a direct to existing to the next valid leg in the plan after the input global leg index.
     * @param globalLegIndex The global leg index.
     * @returns Whether a direct to existing was created.
     */
    createDirectToExistingNextValidLeg(globalLegIndex) {
        const modPlan = this.getPrimaryModFlightPlan();
        for (let l = globalLegIndex + 1; l < modPlan.length; l++) {
            const leg = modPlan.tryGetLeg(l);
            if ((leg === null || leg === void 0 ? void 0 : leg.leg.type) !== LegType.Discontinuity && (leg === null || leg === void 0 ? void 0 : leg.leg.type) !== LegType.ThruDiscontinuity) {
                const targetSegmentIndex = modPlan.getSegmentIndex(l);
                const targetSegment = modPlan.getSegment(targetSegmentIndex);
                const targetSegmentLegIndex = l - targetSegment.offset;
                this.createDirectTo(targetSegmentIndex, targetSegmentLegIndex, true);
                return true;
            }
        }
        return false;
    }
    /**
     * Creates an alternate diversion in the MOD plan based on provided alternate data
     *
     * @param alternateData the alternate data to use
     *
     * @throws if the alternate diversion mode is unknown or not implemented yet
     */
    createAlternateDiversion(alternateData) {
        const plan = this.getPlanToModify();
        // Always create a direct diversion if no legs in front of us
        if (((plan.length - 1) - plan.activeLateralLeg) < 0) {
            this.createDirectAlternateDiversion(plan, alternateData.facilityIcao).then();
            return;
        }
        switch (alternateData.diversion.mode) {
            case AlternateDiversionMode.Direct:
                this.createDirectAlternateDiversion(plan, alternateData.facilityIcao).then();
                break;
            case AlternateDiversionMode.Overhead:
                this.createOverheadAlternateDiversion(plan, alternateData.facilityIcao, alternateData.diversion.legIndex);
                break;
            default: throw new Error(`Unknown or unimplemented alternate diversion mode: ${alternateData.diversion.mode}`);
        }
    }
    /**
     * Creates a DIRECT alternate diversion
     *
     * @param plan the flight plan to create the diversion in
     * @param alternateFacilityIcao the ICAO of the alternate facility to divert to
     */
    async createDirectAlternateDiversion(plan, alternateFacilityIcao) {
        const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, alternateFacilityIcao);
        this.createDirectToAirport(airportFacility);
    }
    /**
     * Creates an OVERHEAD alternate diversion. This should only be called with an {@link overheadLegIndex} that is
     * in the flight plan, or if `undefined`, with a flight plan that contains an active leg.
     *
     * @param plan the flight plan to create the diversion in
     * @param alternateFacilityIcao the ICAO of the alternate facility to divert to
     * @param overheadLegIndex the leg index of the overhead point, or `undefined` if the active leg shall be used
     */
    async createOverheadAlternateDiversion(plan, alternateFacilityIcao, overheadLegIndex) {
        const segmentCount = plan.segmentCount;
        // Find leg index of the overhead fix
        const overheadFixLegIndex = overheadLegIndex !== null && overheadLegIndex !== void 0 ? overheadLegIndex : plan.activeLateralLeg; // TODO what if there are no legs in the plan after active?
        const activeSegmentIndex = plan.getSegmentIndex(overheadFixLegIndex);
        // Remove all next segments
        for (let i = segmentCount - 1; i > activeSegmentIndex + 1; i--) {
            plan.removeSegment(i, true);
        }
        // Remove everything after that leg
        while ((plan.length - 1) > overheadFixLegIndex) {
            const lastLegGlobalIndex = plan.length - 1;
            const lastLegSegmentIndex = plan.getSegmentIndex(lastLegGlobalIndex);
            const lastLegLocalIndex = plan.getSegmentLegIndex(lastLegGlobalIndex);
            plan.removeLeg(lastLegSegmentIndex, lastLegLocalIndex);
        }
        // Create a DF leg to that airport
        const dfLeg = this.createDTODirectLeg(alternateFacilityIcao);
        // Add that DF leg at the end of the plan
        const lastLegGlobalIndex = plan.length - 1;
        const lastLegSegmentIndex = plan.getSegmentIndex(lastLegGlobalIndex);
        plan.addLeg(lastLegSegmentIndex, dfLeg);
        const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, alternateFacilityIcao);
        this.setDestination(airportFacility);
    }
    /**
     * Updates an existing PPOS hold if it exists and is in the MOD flight plan
     *
     * @param plan the plan
     */
    tryUpdatePposHoldPosition(plan) {
        const modPlan = this.getPrimaryModFlightPlan();
        const activePlan = this.getPrimaryFlightPlan();
        const modActiveLeg = modPlan.tryGetLeg(modPlan.activeLateralLeg);
        const activeActiveLeg = activePlan.tryGetLeg(activePlan.activeLateralLeg);
        // We don't wanna update any PPOS hold in the mod flight plan if that hold is already confirmed (in the active flight plan)
        const pposHoldInActive = activeActiveLeg && activeActiveLeg.leg.type === LegType.HM && activeActiveLeg.leg.fixIcao === ICAO.emptyIcao;
        const notPposHold = modActiveLeg && (modActiveLeg.leg.type !== LegType.HM || modActiveLeg.leg.fixIcao !== ICAO.emptyIcao);
        if (plan.planIndex !== BoeingFms.RTE_1_MOD_PLAN_INDEX || pposHoldInActive || !modActiveLeg || notPposHold) {
            // Not in MOD or no PPOS hold at FROM leg
            return;
        }
        this.insertPposHold();
    }
    /**
     * Empties the primary flight plan.
     * @param planIndex The plan index to empty. Defaults to the active plan index.
     */
    emptyFlightPlan(planIndex = BoeingFms.ACT_RTE_PLAN_INDEX) {
        if (!this.flightPlanner.hasFlightPlan(planIndex)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure);
        plan.addSegment(1, FlightPlanSegmentType.Enroute);
        plan.addSegment(2, FlightPlanSegmentType.Destination);
        plan.removeOriginAirport();
        plan.removeDestinationAirport();
        plan.setDirectToData(-1);
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, -1);
        }
        plan.setCalculatingLeg(0);
        plan.setLateralLeg(0);
        plan.setVerticalLeg(0);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_ALTN);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_ROUTE);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN);
        // Just making sure that these plans still have their route key set
        if (planIndex === BoeingFms.RTE_1_INACTIVE_PLAN_INDEX || planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX) {
            plan.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        }
        else if (planIndex === BoeingFms.RTE_2_INACTIVE_PLAN_INDEX || planIndex === BoeingFms.RTE_2_MOD_PLAN_INDEX) {
            plan.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 2);
        }
    }
    /**
     * Adds an airway and airway segment to the flight plan.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     */
    insertAirwaySegment(airway, entry, exit, segmentIndex, legIndex) {
        const plan = this.getPlanToModify();
        const airwaySegmentIndex = this.prepareAirwaySegment(`${airway.name}`, segmentIndex, legIndex);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        const airwayLegs = airwayLegObject.procedureLegs;
        for (let i = 1; i < airwayLegs.length; i++) {
            this.planAddLeg(airwaySegmentIndex, airwayLegs[i]);
        }
        // handle duplicates
        const airwaySegment = plan.getSegment(airwaySegmentIndex);
        const lastLeg = airwaySegment.legs[airwaySegment.legs.length - 1];
        const nextLeg = plan.getNextLeg(airwaySegmentIndex + 1, -1);
        if (lastLeg && nextLeg && this.isDuplicateLeg(lastLeg.leg, nextLeg.leg)) {
            const nextLegIndex = plan.getLegIndexFromLeg(nextLeg);
            const nextLegSegmentIndex = plan.getSegmentIndex(nextLegIndex);
            const nextLegSegment = plan.getSegment(nextLegSegmentIndex);
            if (this.getAirwayLegType(plan, nextLegSegmentIndex, nextLegIndex - nextLegSegment.offset) === AirwayLegType.ENTRY) {
                // the duplicated leg is an airway entry -> remove the segment containing it (the segment is guaranteed to
                // contain just the one leg)
                this.planRemoveSegment(nextLegSegmentIndex);
            }
            else {
                this.planRemoveDuplicateLeg(lastLeg, nextLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
     * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
     * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
     * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
     * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
     * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
     * removed.
     * @param airwayName The name of the airway.
     * @param entrySegmentIndex The index of the segment containing the airway entry leg.
     * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
     * @returns The index of the new airway segment.
     */
    prepareAirwaySegment(airwayName, entrySegmentIndex, entrySegmentLegIndex) {
        const plan = this.getPlanToModify();
        if (entrySegmentIndex < plan.directToData.segmentIndex
            || (entrySegmentIndex === plan.directToData.segmentIndex && entrySegmentLegIndex < plan.directToData.segmentLegIndex)) {
            this.removeDirectToExisting();
        }
        const entrySegment = plan.getSegment(entrySegmentIndex);
        const nextSegment = entrySegmentIndex + 1 < plan.segmentCount ? plan.getSegment(entrySegmentIndex + 1) : undefined;
        let airwaySegmentIndex = entrySegmentIndex + 1;
        let removeLegsSegmentIndex = -1;
        let removeLegsFromIndex = -1;
        if (entrySegment.airway !== undefined) {
            // the entry leg is within an existing airway segment -> remove all legs in the same segment after the entry leg
            removeLegsSegmentIndex = entrySegmentIndex;
            removeLegsFromIndex = entrySegmentLegIndex + 1;
        }
        else if (entrySegmentLegIndex === entrySegment.legs.length - 1 && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.airway) !== undefined) {
            // the entry leg is the entry leg for an existing airway segment -> remove all legs from the existing airway segment
            removeLegsSegmentIndex = entrySegmentIndex + 1;
            removeLegsFromIndex = 0;
        }
        // remove legs as required
        if (removeLegsSegmentIndex >= 0) {
            const removeLegsSegment = plan.getSegment(removeLegsSegmentIndex);
            if (this.getAirwayLegType(plan, removeLegsSegmentIndex, removeLegsSegment.legs.length - 1) === AirwayLegType.EXIT_ENTRY) {
                // preserve the airway entry leg
                const lastLeg = removeLegsSegment.legs[removeLegsSegment.legs.length - 1];
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, removeLegsSegmentIndex + 1);
                this.planAddLeg(removeLegsSegmentIndex + 1, lastLeg.leg, 0);
            }
            if (removeLegsFromIndex > 0) {
                while (removeLegsSegment.legs.length > removeLegsFromIndex) {
                    this.planRemoveLeg(removeLegsSegmentIndex, removeLegsSegment.legs.length - 1, true, true);
                }
            }
            else {
                this.planRemoveSegment(removeLegsSegmentIndex);
            }
        }
        if (entrySegment.legs.length - 1 > entrySegmentLegIndex) {
            // entry leg is not the last leg in its segment -> split the segment after the entry leg
            airwaySegmentIndex = this.splitSegment(plan, entrySegmentIndex, entrySegmentLegIndex);
        }
        else if (plan.getSegment(entrySegmentIndex).segmentType === FlightPlanSegmentType.Enroute
            && ((nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) !== FlightPlanSegmentType.Enroute)) {
            // entry leg is the last leg in its segment and the following segment doesn't exist or is not an enroute segment
            plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute);
        }
        plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
        return airwaySegmentIndex;
    }
    /**
     * Splits a segment into two segments if type is enroute; if departure, remove legs after the legIndex, else do nothing.
     * @param plan is the flight plan to edit.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     * @returns the segment number of the new airway segment if one was created, else the current segment or if no action was taken.
     */
    splitSegment(plan, segmentIndex, legIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.segmentType === FlightPlanSegmentType.Enroute) {
            const nextSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            // Move legs after leg index to new segment
            // It's funky without the i++, but it works correctly because the length of the segment is changing
            for (let i = legIndex + 1; i < segment.legs.length;) {
                const leg = segment.legs[i].leg;
                this.planAddLeg(nextSegmentIndex, leg);
                this.planRemoveLeg(segmentIndex, i);
            }
            return nextSegmentIndex;
        }
        else if (segment.segmentType === FlightPlanSegmentType.Departure) {
            // Remove legs after leg index
            // It's funky without the i++, but it works correctly because the length of the segment is changing
            for (let i = legIndex + 1; i < segment.legs.length;) {
                this.planRemoveLeg(segmentIndex, i);
            }
        }
        return segmentIndex;
    }
    /**
     * Builds a legs for an airway.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the InsertProcedureObject.
     */
    buildAirwayLegs(airway, entry, exit) {
        const insertAirwayObject = { procedureLegs: [] };
        const waypoints = airway.waypoints;
        const entryIndex = waypoints.findIndex((w) => w.icao === entry.icao);
        const exitIndex = waypoints.findIndex((w) => w.icao === exit.icao);
        const ascending = exitIndex > entryIndex;
        if (ascending) {
            for (let i = entryIndex; i <= exitIndex; i++) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        else {
            for (let i = entryIndex; i >= exitIndex; i--) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        return insertAirwayObject;
    }
    /**
     * Method to remove an airway from the flight plan.
     * @param segmentIndex is the segment index of the airway to remove.
     */
    removeAirway(segmentIndex) {
        const plan = this.getPlanToModify();
        let combineSegments = false;
        const segment = plan.getSegment(segmentIndex);
        const exitLeg = segment.legs[segment.legs.length - 1].leg;
        if (segmentIndex > 0) {
            const priorSegmentEnrouteNonAirway = plan.getSegment(segmentIndex - 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex - 1).airway === undefined;
            const nextSegmentEnrouteNonAirway = plan.getSegment(segmentIndex + 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex + 1).airway === undefined;
            if (priorSegmentEnrouteNonAirway && nextSegmentEnrouteNonAirway) {
                combineSegments = true;
            }
            // Add the exit leg as a direct in the prior segment if it is enroute and not an airway.
            if (priorSegmentEnrouteNonAirway) {
                this.planAddLeg(segmentIndex - 1, exitLeg);
            }
            // Remove the airway segment
            this.planRemoveSegment(segmentIndex);
            // If we have two adjacent enroute non-airway segments, merge them.
            if (combineSegments) {
                this.mergeSegments(plan, segmentIndex - 1);
            }
            // If we need to add a non-airway enroute segment
            if (!priorSegmentEnrouteNonAirway) {
                if (!nextSegmentEnrouteNonAirway) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                }
                this.planAddLeg(segmentIndex, exitLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
     * first, and the second segment is removed from the flight plan.
     * @param plan The flight plan to modify.
     * @param segmentIndex The index of the first segment to merge.
     */
    mergeSegments(plan, segmentIndex) {
        const segmentToGrow = plan.getSegment(segmentIndex);
        const segmentToRemove = plan.getSegment(segmentIndex + 1);
        const segmentToGrowOrigLength = segmentToGrow.legs.length;
        segmentToRemove.legs.forEach((l) => {
            plan.addLeg(segmentIndex, l.leg, undefined, l.flags);
        });
        if (plan.directToData.segmentIndex === segmentIndex + 1) {
            plan.setDirectToData(segmentIndex, segmentToGrowOrigLength + plan.directToData.segmentLegIndex);
        }
        this.planRemoveSegment(segmentIndex + 1);
    }
    /**
     * Insert a hold into the flight plan.
     * @param globalLegIndex The global index of the parent leg.
     * @returns Whether the hold was inserted in the flight plan.
     * */
    createHold(globalLegIndex) {
        const plan = this.getPlanToModify();
        const parentLeg = plan.getLeg(globalLegIndex);
        const parentLegIndex = plan.getLegIndexFromLeg(parentLeg);
        const parentLegSegmentIndex = plan.getSegmentIndex(parentLegIndex);
        const parentLegSegment = plan.getSegment(parentLegSegmentIndex);
        let course = 100;
        if (parentLeg.calculated) {
            const trueCourse = FlightPathUtils.getLegFinalCourse(parentLeg.calculated);
            if (trueCourse !== undefined) {
                course = MagVar.trueToMagnetic(trueCourse, parentLeg.calculated.courseMagVar);
            }
        }
        const holdLeg = FlightPlan.createLeg({
            type: LegType.HM,
            fixIcao: parentLeg.leg.fixIcao,
            turnDirection: LegTurnDirection.Right,
            distanceMinutes: true,
            distance: 1,
            course,
        });
        return this.insertHold(parentLegSegmentIndex, parentLegIndex - parentLegSegment.offset, holdLeg);
    }
    /**
     * Inserts a hold-at-waypoint leg to the primary flight plan. The hold leg will be inserted immediately after the
     * specified parent leg. The hold leg must have the same fix as the parent leg.
     * @param segmentIndex The index of the segment that contains the hold's parent leg.
     * @param legIndex The index of the hold's parent leg in its segment.
     * @param holdLeg The hold leg to add.
     * @returns Whether the hold-at-waypoint leg was successfully inserted.
     */
    insertHold(segmentIndex, legIndex, holdLeg) {
        const plan = this.getPlanForFmcRender();
        if (!plan) {
            return false;
        }
        const modPlan = this.getPlanToModify();
        const prevLeg = modPlan.getPrevLeg(segmentIndex, legIndex + 1);
        if ((prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.fixIcao) !== holdLeg.fixIcao) {
            return false;
        }
        const nextLeg = modPlan.getNextLeg(segmentIndex, legIndex);
        // If we are editing a hold, delete the old leg.
        if (nextLeg && BoeingFmsUtils.isHoldAtLeg(nextLeg.leg.type) && nextLeg.leg.fixIcao === holdLeg.fixIcao) {
            const segment = modPlan.getSegmentFromLeg(nextLeg);
            segment && modPlan.removeLeg(segment.segmentIndex, segment.legs.indexOf(nextLeg));
        }
        this.planAddLeg(segmentIndex, holdLeg, legIndex + 1);
        return true;
    }
    /**
     * Inserts a PPOS hold as the active leg
     *
     * @param partial an object to modify the PPOS hold leg with, if applicable
     *
     * @returns whether the leg was inserted
     */
    insertPposHold(partial) {
        const activeLegIndex = this.getPlanForFmcRender().activeLateralLeg;
        const activeLeg = this.getPlanForFmcRender().tryGetLeg(activeLegIndex);
        let activeSegmentIndex = this.getPlanForFmcRender().getSegmentIndex(activeLegIndex);
        const plan = this.getPlanToModify();
        if (activeSegmentIndex === -1) {
            plan.addSegment(0, FlightPlanSegmentType.Enroute);
            activeSegmentIndex = 0;
        }
        const { lon, lat } = this.ppos;
        const magVar = MagVar.get(lat, lon);
        const insertAfterActive = activeLegIndex === 0;
        const activeLegSegment = plan.getSegment(activeSegmentIndex);
        let insertIndex = activeLegIndex - activeLegSegment.offset + (insertAfterActive ? 1 : 0);
        const parentLeg = FlightPlan.createLeg({ type: LegType.IF, fixIcao: 'W      PPOS', lat, lon });
        if (!activeLeg) {
            plan.addLeg(activeSegmentIndex, parentLeg);
            // There was no active leg, meaning an empty plan - we want to add at the end of the newly created segment
            insertIndex = undefined;
        }
        else {
            if (activeLeg.leg.type === LegType.HM && activeLeg.leg.fixIcao === ICAO.emptyIcao) {
                activeLegSegment && this.removeWaypoint(activeLegSegment.segmentIndex, activeLegIndex - activeLegSegment.offset);
            }
            else {
                plan.addLeg(activeSegmentIndex, parentLeg, insertIndex);
                insertIndex++;
            }
        }
        const pposHold = FlightPlan.createLeg(Object.assign({ type: LegType.HM, fixIcao: ICAO.emptyIcao, turnDirection: LegTurnDirection.Right, distanceMinutes: true, distance: 1, course: this.aircraftTrack ? this.aircraftTrack - magVar : 100, lat: lat, lon: lon }, partial !== null && partial !== void 0 ? partial : {}));
        let insertHoldLeg;
        try {
            // If the active leg is 0 (only airport or runway in the flight plan), we want to insert the hold after the active leg
            insertHoldLeg = plan.addLeg(activeSegmentIndex, pposHold, insertIndex);
        }
        catch (e) {
            console.error(e);
            return false;
        }
        plan.setLateralLeg(plan.getLegIndexFromLeg(insertHoldLeg));
        return true;
    }
    /**
     * Returns the index of the last element in the array where predicate is true, and -1
     * otherwise.
     * @param array The source array to search in
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
     * @param defaultReturn is the default value
     * @returns either the index or the default if the predicate criteria is not met
     */
    findLastSegmentIndex(array, predicate, defaultReturn = -1) {
        let l = array.length;
        while (l--) {
            if (predicate(array[l], l, array)) {
                return array[l].segmentIndex;
            }
        }
        return defaultReturn;
    }
    /**
     * Method to insert a discontinuity in a provided plan at a specified position.
     * @param plan The FlightPlan to modify.
     * @param segmentIndex The segment index to insert the disco in.
     * @param segmentLegIndex The leg index to insert the disco at.
     */
    insertDiscontinuity(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segmentLegIndex === undefined) {
            segmentLegIndex = Math.max(0, segment.legs.length - 1);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if ((prevLeg && prevLeg.leg.type === LegType.Discontinuity) || (leg && leg.leg.type === LegType.Discontinuity)) {
            return;
        }
        this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), segmentLegIndex);
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the {@link LegDefinition} that was added to the plan
     */
    planAddLeg(segmentIndex, leg, index, flags = 0, notify = true) {
        const plan = this.getPlanToModify();
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        // TODO Removed the segmentIndex < dtoSegmentIndex from Garmin as it does not apply to WT21 (I think, but want to verify)
        // if (
        //   dtoSegmentIndex >= 0
        //   && (
        //     segmentIndex < dtoSegmentIndex
        //     || (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex)
        //   )
        // ) {
        //   this.removeDirectToExisting(plan.planIndex);
        // }
        if (dtoSegmentIndex >= 0
            && (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex)) {
            this.removeDirectToExisting(plan.planIndex);
        }
        const segment = plan.getSegment(segmentIndex);
        const addIndex = index !== undefined ? index : Math.max(segment.legs.length - 1, 0);
        if (segment.segmentType === FlightPlanSegmentType.Approach
            && addIndex > 0
            && BitFlags.isAll(segment.legs[addIndex - 1].flags, WT21LegDefinitionFlags.MissedApproach)) {
            flags |= WT21LegDefinitionFlags.MissedApproach;
        }
        const legDefinition = plan.addLeg(segmentIndex, leg, index, flags, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (activeSegmentIndex !== -1) {
            const activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (segmentIndex < activeSegmentIndex || (index && segmentIndex == activeSegmentIndex && index < activeLegIndex)) {
                const newActiveLegIndex = plan.activeLateralLeg + 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        else {
            console.error('planAddLeg: activeSegmentIndex was -1');
        }
        return legDefinition;
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove.
     * @param notify Whether or not to send notifications after the operation. True by default.
     * @param skipDupCheck Whether to skip checking for duplicates. False by default.
     * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
     * located before the direct to target. False by default.
     * @returns whether a leg was removed.
     */
    planRemoveLeg(segmentIndex, segmentLegIndex, notify = true, skipDupCheck = false, skipCancelDirectTo = false) {
        let plan = this.getPlanForFmcRender();
        if (segmentIndex < 0 || segmentIndex >= plan.segmentCount) {
            return false;
        }
        const toRemoveLeg = plan.getSegment(segmentIndex).legs[segmentLegIndex];
        if (!toRemoveLeg) {
            return false;
        }
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.getDirectToState() === DirectToState.TOEXISTING;
        plan = this.getPlanToModify();
        let removed = false;
        const airwayLegType = this.getAirwayLegType(plan, segmentIndex, segmentLegIndex);
        if (airwayLegType !== AirwayLegType.NONE) {
            removed = this.removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex);
        }
        else {
            removed = plan.removeLeg(segmentIndex, segmentLegIndex, notify) !== null;
            if (!removed) {
                return false;
            }
            const dtoLegIndex = plan.directToData.segmentLegIndex;
            const dtoSegmentIndex = plan.directToData.segmentIndex;
            if (!skipCancelDirectTo
                && dtoSegmentIndex >= 0
                && (segmentIndex < dtoSegmentIndex
                    || (segmentIndex === dtoSegmentIndex && segmentLegIndex <= dtoLegIndex))) {
                // Need to adjust direct to data to compensate for removed leg.
                if (segmentIndex === dtoSegmentIndex) {
                    plan.directToData.segmentLegIndex--;
                }
                // if (isDirectToExistingActive && segmentIndex === dtoSegmentIndex && segmentLegIndex === dtoLegIndex) {
                // Create a DTO random to replace the canceled DTO existing if we are directly removing the target leg of the DTO existing.
                //   const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg.fixIcao;
                //   this.createDirectToRandom(directIcao);
                // }
                this.removeDirectToExisting(plan.planIndex, plan.activeLateralLeg - 1);
            }
            else if (removeLegGlobalIndex < plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        const prevLeg = removeLegGlobalIndex - 1 >= 0 ? plan.getLeg(removeLegGlobalIndex - 1) : null;
        const nextLeg = removeLegGlobalIndex < plan.length ? plan.getLeg(removeLegGlobalIndex) : null;
        // Detect if we have created consecutive duplicate legs. If we have, we need to delete one of them.
        if (!skipDupCheck && prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (!skipDupCheck) {
            this.checkAndRemoveEmptySegment(plan, segmentIndex);
        }
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Method to handle a remove leg request t.
     * @param plan is the flight plan.
     * @param airwayLegType is the airwayLegType returned from the checkIfAirwayLeg method.
     * @param segmentIndex The segment we are removing from.
     * @param segmentLegIndex is the leg index in the segment we are removing.
     * @returns whether this handler processed the remove request.
     */
    removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex) {
        var _a, _b;
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        let removed = false;
        let needReconcileDto = plan.directToData.segmentIndex >= 0;
        if (segmentIndex < plan.directToData.segmentIndex
            || (segmentIndex === plan.directToData.segmentIndex && segmentLegIndex <= plan.directToData.segmentLegIndex)) {
            this.removeDirectToExisting();
            needReconcileDto = false;
        }
        switch (airwayLegType) {
            case AirwayLegType.ONROUTE: {
                const segment = plan.getSegment(segmentIndex);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex > 0) {
                    // Need to rename the airway segment with the new exit (if we removed the first leg after the entry, the
                    // airway segment will be deleted so no need to bother)
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    plan.setAirway(segmentIndex, segment.airway.replace(/\..*/, `.${segment.legs[segmentLegIndex - 1].name}`));
                }
                // We need to move the leg immediately after the removed leg to the next enroute segment
                // (if the next enroute segment does not exist we will create one)
                if (plan.segmentCount <= segmentIndex + 1 || plan.getSegment(segmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                }
                const legAfterRemoved = segment.legs[segmentLegIndex].leg;
                plan.addLeg(segmentIndex + 1, legAfterRemoved, 0);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex < segment.legs.length) {
                    // There is at least one more leg in the original airway segment after the one we moved to the next enroute
                    // segment -> move these remaining legs into a new airway segment
                    const newEntrySegment = plan.getSegment(segmentIndex + 1);
                    let newAirwaySegmentIndex = segmentIndex + 2;
                    if (newEntrySegment.legs.length > 1) {
                        // need to split the segment containing the entry leg of the new airway segment
                        newAirwaySegmentIndex = this.splitSegment(plan, segmentIndex + 1, 0);
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const airwayName = segment.airway.replace(/\..*/, `.${segment.legs[segment.legs.length - 1].name}`);
                    plan.insertSegment(newAirwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
                    while (segment.legs.length > segmentLegIndex) {
                        const leg = segment.legs[segmentLegIndex].leg;
                        plan.removeLeg(segmentIndex, segmentLegIndex);
                        plan.addLeg(newAirwaySegmentIndex, leg);
                    }
                    // If the newly added airway segment is the last enroute segment, we need to insert an empty enroute segment
                    // after it to ensure that the last enroute segment in the plan is not an airway segment
                    if (newAirwaySegmentIndex >= plan.segmentCount - 1 || plan.getSegment(newAirwaySegmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                        plan.insertSegment(newAirwaySegmentIndex + 1, FlightPlanSegmentType.Enroute);
                    }
                }
                removed = true;
                break;
            }
            case AirwayLegType.ENTRY: {
                if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Enroute) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into the previous enroute segment to serve as the new entry leg.
                    const segment = plan.getSegment(segmentIndex + 1);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 1, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 1);
                    this.planAddLeg(segmentIndex, leg);
                }
                else if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Departure) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into a newly created enroute segment placed before the airway segment to serve as the new entry leg.
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const segment = plan.getSegment(segmentIndex + 2);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 2, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 2);
                    this.planAddLeg(segmentIndex + 1, leg, 0);
                }
                removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                break;
            }
            case AirwayLegType.EXIT: {
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the airway segment, so just delete the segment.
                    this.removeAirway(segmentIndex);
                    return true;
                }
                else {
                    // Remove the leg, then change the name of the airway segment to reflect the new exit waypoint.
                    const segment = plan.getSegment(segmentIndex);
                    const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                    segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[segmentLegIndex - 1].name : segment.airway;
                    plan.setAirway(segmentIndex, segment.airway);
                    removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                }
                break;
            }
            case AirwayLegType.EXIT_ENTRY: {
                // We need to move the first leg in the next airway segment out of that segment and into an enroute segment
                // before the next airway segment.
                const segment = plan.getSegment(segmentIndex + 1);
                const leg = segment.legs[0].leg;
                plan.removeLeg(segmentIndex + 1, 0);
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the first airway segment, so just remove the segment.
                    plan.removeSegment(segmentIndex);
                    let prevSegmentIndex = segmentIndex - 1;
                    const prevSegment = plan.getSegment(prevSegmentIndex);
                    if (prevSegment.segmentType !== FlightPlanSegmentType.Enroute || prevSegment.airway !== undefined) {
                        plan.insertSegment(segmentIndex, FlightPlanSegmentType.Enroute);
                        prevSegmentIndex = segmentIndex;
                    }
                    plan.addLeg(prevSegmentIndex, leg);
                }
                else {
                    // Remove the leg from the first airway segment, then change the name of the airway segment to reflect the
                    // new exit waypoint.
                    plan.removeLeg(segmentIndex, segmentLegIndex);
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                    plan.addLeg(segmentIndex + 1, leg);
                    const firstAirwaySegment = plan.getSegment(segmentIndex);
                    const airway = (_b = firstAirwaySegment.airway) === null || _b === void 0 ? void 0 : _b.split('.');
                    firstAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + firstAirwaySegment.legs[segmentLegIndex - 1].name : firstAirwaySegment.airway;
                    plan.setAirway(segmentIndex, firstAirwaySegment.airway);
                }
                removed = true;
            }
        }
        if (removed) {
            if (needReconcileDto) {
                BoeingFmsUtils.reconcileDirectToData(plan);
            }
            if (removeLegGlobalIndex <= plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        return removed;
    }
    /**
     * Checks if a flight plan segment is empty, and removes the segment if it is eligible to be removed. Only Enroute
     * segments that are followed by another Enroute segment are eligible to be removed if empty.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment to check.
     * @returns Whether the segment was removed.
     */
    checkAndRemoveEmptySegment(plan, segmentIndex) {
        if (this.checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex)) {
            this.planRemoveSegment(segmentIndex);
            const prevSegmentIndex = segmentIndex - 1;
            const nextSegmentIndex = segmentIndex;
            const prevSegment = prevSegmentIndex >= 0 ? plan.getSegment(prevSegmentIndex) : undefined;
            const nextSegment = nextSegmentIndex < plan.segmentCount ? plan.getSegment(nextSegmentIndex) : undefined;
            if ((prevSegment === null || prevSegment === void 0 ? void 0 : prevSegment.segmentType) === FlightPlanSegmentType.Enroute
                && prevSegment.airway === undefined
                && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) === FlightPlanSegmentType.Enroute
                && nextSegment.airway === undefined) {
                // We are left with two consecutive non-airway enroute segments -> merge the two
                this.mergeSegments(plan, prevSegmentIndex);
            }
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Checks if a remove left an empty segment that also needs to be removed.
     * @param plan is the flight plan
     * @param segmentIndex The segment to add the leg to.
     * @returns whether to remove the segment.
     */
    checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        let nextSegment;
        if (segmentIndex < plan.segmentCount - 1) {
            nextSegment = plan.getSegment(segmentIndex + 1);
        }
        if (segment.legs.length < 1) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Enroute:
                    {
                        if (nextSegment && nextSegment.segmentType === FlightPlanSegmentType.Enroute) {
                            return true;
                        }
                        const priorSegment = plan.getSegment(segmentIndex - 1);
                        if (priorSegment.segmentType === FlightPlanSegmentType.Approach || priorSegment.segmentType === FlightPlanSegmentType.Arrival) {
                            return true;
                        }
                    }
                    break;
                //TODO: Add more cases as appropriate
            }
        }
        return false;
    }
    /**
     * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
     * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
     * segment.
     * @param isOrigin Whether to add an origin leg.
     * @param segmentIndex The index of the segment to which to add the leg.
     * @param airport The origin airport.
     * @param runway The origin runway.
     */
    planAddOriginDestinationLeg(isOrigin, segmentIndex, airport, runway) {
        let leg;
        if (runway) {
            leg = BoeingFmsUtils.buildRunwayLeg(airport, runway, isOrigin);
        }
        else {
            leg = FlightPlan.createLeg({
                lat: airport.lat,
                lon: airport.lon,
                type: isOrigin ? LegType.IF : LegType.TF,
                fixIcao: airport.icao,
                altitude1: airport.runways[0].elevation + UnitType.FOOT.convertTo(50, UnitType.METER)
            });
        }
        if (leg) {
            this.planAddLeg(segmentIndex, leg, isOrigin ? 0 : undefined);
            if (!isOrigin) {
                const plan = this.getPlanToModify();
                const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
                for (let i = lastEnrouteSegment.legs.length - 1; i >= 0; i--) {
                    if (lastEnrouteSegment.legs[i].leg.fixIcao === airport.icao) {
                        this.planRemoveLeg(lastEnrouteSegmentIndex, i, true, true);
                    }
                }
            }
        }
    }
    /**
     * Method to add a segment to the flightplan.
     * @param segmentType is the FlightPlanSegmentType.
     * @param index is the optional segment index to insert the segment.
     * @returns the segment index of the inserted segment.
     */
    planInsertSegmentOfType(segmentType, index) {
        const plan = this.getPlanToModify();
        let segmentIndex = -1;
        if (index) {
            segmentIndex = index - 1;
        }
        else {
            const segments = [];
            for (const segment of plan.segments()) {
                segments.push(segment);
            }
            switch (segmentType) {
                case FlightPlanSegmentType.Origin:
                    break;
                case FlightPlanSegmentType.Departure:
                    segmentIndex = 0;
                    break;
                case FlightPlanSegmentType.Arrival:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Approach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival;
                    }, 2);
                    break;
                case FlightPlanSegmentType.MissedApproach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Approach;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Destination:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach;
                    }, 5);
                    break;
                default:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach || v.segmentType === FlightPlanSegmentType.Destination;
                    }, 1);
                    segmentIndex--;
                    break;
            }
        }
        return this.planInsertSegment(segmentIndex + 1, segmentType).segmentIndex;
    }
    /**
     * Method to remove all legs from a segment.
     * @param segmentIndex is the index of the segment to delete all legs from.
     * @param segmentType is the type if segment to delete all legs from, if known.
     */
    planClearSegment(segmentIndex, segmentType) {
        this.planRemoveSegment(segmentIndex);
        this.planInsertSegment(segmentIndex, segmentType);
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    planInsertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const plan = this.getPlanToModify();
        const segment = plan.insertSegment(segmentIndex, segmentType, airway, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        if (plan.directToData.segmentIndex >= 0 && segmentIndex <= plan.directToData.segmentIndex) {
            plan.setDirectToData(plan.directToData.segmentIndex + 1, plan.directToData.segmentLegIndex);
        }
        return segment;
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    planRemoveSegment(segmentIndex, notify = true) {
        const plan = this.getPlanToModify();
        const segment = plan.getSegment(segmentIndex);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (plan.directToData.segmentIndex >= 0) {
            if (segmentIndex < plan.directToData.segmentIndex) {
                plan.setDirectToData(plan.directToData.segmentIndex - 1, plan.directToData.segmentLegIndex);
            }
            else if (segmentIndex === plan.directToData.segmentIndex) {
                plan.setDirectToData(-1);
            }
        }
        // If the segment we are trying to delete is the active one,
        // then we need to do something to preserve the active legs so they aren't deleted.
        // We only need to do this for the Enroute segment, because if other segments are getting deleted,
        // their functions are already handling this.
        if (activeSegmentIndex === segmentIndex && !Simplane.getIsGrounded() && plan.length > 1 && segment.segmentType === FlightPlanSegmentType.Enroute) {
            // I think this block of code is only supposed to run when called from the cleanupLegsAfterApproach() function
            const currentToLeg = plan.getLeg(plan.activeLateralLeg);
            const currentFromLeg = plan.getLeg(plan.activeLateralLeg - 1);
            const newToLeg = Object.assign({}, currentToLeg.leg);
            const newFromLeg = Object.assign({}, currentFromLeg.leg);
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            if (BitFlags.isAll(currentToLeg.flags, WT21LegDefinitionFlags.DirectTo)) {
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                plan.addLeg(lastEnrouteSegmentIndex, discoLeg, undefined, WT21LegDefinitionFlags.DirectTo);
                plan.addLeg(lastEnrouteSegmentIndex, newFromLeg, undefined, WT21LegDefinitionFlags.DirectTo);
                plan.addLeg(lastEnrouteSegmentIndex, newToLeg, undefined, WT21LegDefinitionFlags.DirectTo | WT21LegDefinitionFlags.DirectToTarget);
            }
            else {
                plan.addLeg(lastEnrouteSegmentIndex, newFromLeg, undefined);
                plan.addLeg(lastEnrouteSegmentIndex, newToLeg, undefined);
            }
            const newSegment = plan.getSegment(lastEnrouteSegmentIndex);
            const newActiveLegIndex = newSegment.offset + newSegment.legs.length - 1;
            plan.setCalculatingLeg(newActiveLegIndex - 2);
            plan.setLateralLeg(newActiveLegIndex);
        }
        else {
            const newActiveLegIndex = plan.activeLateralLeg - Utils.Clamp(plan.activeLateralLeg - segment.offset, 0, segment.legs.length);
            plan.setCalculatingLeg(newActiveLegIndex);
            plan.setLateralLeg(newActiveLegIndex);
        }
        plan.removeSegment(segmentIndex, notify);
        plan.calculate(plan.activeLateralLeg - 1);
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
     * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
     * which is also an IF, TF, or DF leg.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is a duplicate of the first.
     */
    isDuplicateLeg(leg1, leg2) {
        if (leg1.type === LegType.Discontinuity && leg2.type === LegType.Discontinuity) {
            return true;
        }
        if (leg2.type !== LegType.IF
            && leg2.type !== LegType.DF
            && leg2.type !== LegType.TF
            && leg2.type !== LegType.CF) {
            return false;
        }
        return (leg1.type === LegType.IF
            || leg1.type === LegType.TF
            || leg1.type === LegType.DF
            || leg1.type === LegType.CF)
            && leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
     * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is an duplicate IF leg of the first.
     */
    isDuplicateIFLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF) {
            return false;
        }
        if (leg1.type !== LegType.TF
            && leg1.type !== LegType.DF
            && leg1.type !== LegType.RF
            && leg1.type !== LegType.CF
            && leg1.type !== LegType.AF
            && leg1.type !== LegType.IF) {
            return false;
        }
        return leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
     * and all other data is derived from the target leg.
     * @param target The target leg.
     * @param source The source leg.
     * @returns the merged leg.
     */
    mergeDuplicateLegData(target, source) {
        const merged = FlightPlan.createLeg(target);
        merged.fixTypeFlags |= source.fixTypeFlags;
        merged.altDesc = source.altDesc;
        merged.altitude1 = source.altitude1;
        merged.altitude2 = source.altitude2;
        merged.speedRestriction = source.speedRestriction;
        return merged;
    }
    /**
     * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
     * not in a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
     * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
     * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
     * @param leg1 The first duplicate leg.
     * @param leg2 The second duplicate leg.
     * @returns the leg that was deleted, or null if neither leg was deleted.
     * @throws Error if direct to legs could not be updated.
     */
    planRemoveDuplicateLeg(leg1, leg2) {
        const plan = this.getPlanToModify();
        const leg1Segment = plan.getSegmentFromLeg(leg1);
        const leg1Index = plan.getLegIndexFromLeg(leg1);
        const leg2Segment = plan.getSegmentFromLeg(leg2);
        const leg2Index = plan.getLegIndexFromLeg(leg2);
        if (!leg1Segment || !leg2Segment) {
            return null;
        }
        const isLeg1DirectToLeg = BitFlags.isAll(leg1.flags, WT21LegDefinitionFlags.DirectTo);
        const isLeg2DirectToLeg = BitFlags.isAll(leg2.flags, WT21LegDefinitionFlags.DirectTo);
        const dupDirectToLeg = isLeg1DirectToLeg ? leg1
            : isLeg2DirectToLeg ? leg2
                : null;
        if (dupDirectToLeg) {
            if (dupDirectToLeg.leg.type === LegType.IF) {
                // Technically this should never happen.
                return null;
            }
            else {
                // If one of the duplicates is the second leg in a direct to sequence, then the true duplicated leg is the
                // target leg of the DTO. In this case, we call this method with the DTO target leg replacing the DTO leg.
                const dtoTargetLeg = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                return isLeg1DirectToLeg ? this.planRemoveDuplicateLeg(dtoTargetLeg, leg2) : this.planRemoveDuplicateLeg(leg1, dtoTargetLeg);
            }
        }
        const isLeg1InProc = leg1Segment.segmentType !== FlightPlanSegmentType.Enroute;
        const isLeg2InProc = leg2Segment.segmentType !== FlightPlanSegmentType.Enroute;
        let toDeleteSegment;
        let toDeleteIndex;
        let toDeleteLeg;
        if ((!isLeg1InProc && isLeg2InProc)
            || (isLeg1InProc && isLeg2InProc && leg1Segment !== leg2Segment)
            || BitFlags.isAny(leg2.leg.fixTypeFlags, FixTypeFlags.FAF | FixTypeFlags.MAP)) {
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1Index - leg1Segment.offset;
            toDeleteLeg = leg1;
        }
        else {
            toDeleteSegment = leg2Segment;
            toDeleteIndex = leg2Index - leg2Segment.offset;
            // TODO Probably shouldn't modify the LegDefinition like this,
            // TODO because events won't fire and things won't know that it changed.
            leg1.leg = this.mergeDuplicateLegData(leg1.leg, leg2.leg);
            toDeleteLeg = leg2;
        }
        if (toDeleteIndex >= 0) {
            const dtoTargetLeg = plan.directToData.segmentIndex < 0 ? null : plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
            const needMoveDtoLegs = toDeleteLeg === dtoTargetLeg;
            if (needMoveDtoLegs) {
                const isDtoExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
                // If the removed leg was the target leg of a DTO existing, we need to shift the DTO legs to target the leg
                // that was not removed.
                const oldDiscoLeg = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg1 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg2 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                if (!oldDtoLeg1 || !oldDtoLeg2 || !oldDiscoLeg) {
                    throw new Error(`Fms: Could not remove direct to legs starting at segment index ${plan.directToData.segmentIndex}, leg index ${plan.directToData.segmentLegIndex} during duplicate leg resolution.`);
                }
                const preservedLeg = toDeleteLeg === leg1 ? leg2 : leg1;
                const preservedLegIndex = plan.getLegIndexFromLeg(preservedLeg);
                const newTargetSegmentIndex = plan.getSegmentIndex(preservedLegIndex);
                const newTargetSegmentLegIndex = preservedLegIndex - plan.getSegment(newTargetSegmentIndex).offset;
                plan.setDirectToData(newTargetSegmentIndex, newTargetSegmentLegIndex);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDiscoLeg.leg), newTargetSegmentLegIndex + 1, WT21LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg1.leg), newTargetSegmentLegIndex + 2, WT21LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg2.leg), newTargetSegmentLegIndex + 3, WT21LegDefinitionFlags.DirectTo | WT21LegDefinitionFlags.DirectToTarget);
                if (isDtoExistingActive) {
                    plan.setLateralLeg(preservedLegIndex + 3);
                }
            }
            const success = this.planRemoveLeg(toDeleteSegment.segmentIndex, toDeleteIndex, true, false, needMoveDtoLegs);
            if (success) {
                return toDeleteLeg;
            }
        }
        return null;
    }
    /**
     * Resets the subject to force a cross-instrument notification.
     */
    forceNotifyApproachFrequency() {
        const approachFrequency = this.approachFrequency.get();
        this.approachFrequency.set(undefined);
        this.approachFrequency.set(approachFrequency);
    }
    /**
     * Sets the approach details for the loaded approach and sends an event across the bus.
     * @param approachLoaded Whether an approach is loaded.
     * @param approachType The approach type.
     * @param approachRnavType The approach RNAV type.
     * @param approachIsActive Whether the approach is active.
     * @param approachIsCircling Whether the approach is a circling approach.
     * @param approachName The name of the approach.
     * @param approachRunway The runway associated with the approach
     * @param referenceFacility The reference navaid for the approach
     * @param finalApproachCourse The final approach course (-1 is invalid)
     */
    setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling, approachName, approachRunway, referenceFacility, finalApproachCourse) {
        const approachDetails = {
            approachLoaded: approachLoaded !== undefined ? approachLoaded : this.approachDetails.approachLoaded,
            approachType: approachType !== undefined ? approachType : this.approachDetails.approachType,
            approachRnavType: approachRnavType !== undefined ? approachRnavType : this.approachDetails.approachRnavType,
            approachIsActive: approachIsActive !== undefined ? approachIsActive : this.approachDetails.approachIsActive,
            approachIsCircling: approachIsCircling !== undefined ? approachIsCircling : this.approachDetails.approachIsCircling,
            approachName: approachName !== undefined ? approachName : this.approachDetails.approachName,
            approachRunway: approachRunway !== undefined ? approachRunway : this.approachDetails.approachRunway,
            referenceFacility: referenceFacility !== undefined ? referenceFacility : this.approachDetails.referenceFacility,
            finalApproachCourse: finalApproachCourse !== undefined ? finalApproachCourse : this.approachDetails.finalApproachCourse,
        };
        if (approachDetails.approachIsActive && !approachDetails.approachLoaded) {
            this.checkApproachState();
            return;
        }
        if (approachDetails !== this.approachDetails) {
            this.approachDetails = approachDetails;
            this.bus.getPublisher().pub('approach_details_set', this.approachDetails, true);
            this.bus.getPublisher().pub('approach_available', approachDetails.approachIsActive && approachDetails.approachLoaded, true);
            // this.bus.getPublisher<WT21VNavDataEvents>().pub('approach_supports_gp', this.doesApproachSupportGp(), true);
        }
    }
    /**
     * Checks whether the approach details indicate that vertical guidance (GP) can be supported.
     * @returns whether or not vertical guidance is supported.
     */
    doesApproachSupportGp() {
        if (this.approachDetails.approachLoaded && this.approachDetails.approachIsActive && !this.approachDetails.approachIsCircling) {
            switch (this.approachDetails.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                case ApproachType.APPROACH_TYPE_RNAV:
                case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                    return true;
            }
        }
        return false;
    }
    /**
     * Checks if an RNAV approach can be activated in the AP.
     * @param cdiScaling The current CDI Scaling Label
     * @returns Whether approach can activate.
     */
    canApproachActivate(cdiScaling = this.cdiScaleLabel.get()) {
        const apprModeAvailable = cdiScaling === CDIScaleLabel.Terminal || cdiScaling === CDIScaleLabel.TerminalArrival || cdiScaling === CDIScaleLabel.Approach;
        return this.approachDetails.approachLoaded && apprModeAvailable;
    }
    /** Check if the tuned ILS frequency and course match the selected approach */
    checkTunedIlsMismatch() {
        var _a, _b;
        this.approachFrequencyMismatch.set(!!(this.approachDetails.referenceFacility)
            && !BoeingFmsUtils.vhfFrequenciesEqual(this.approachDetails.referenceFacility.freqMHz, (_a = this.tunedIlsFrequency) !== null && _a !== void 0 ? _a : -1));
        this.approachCourseMismatch.set(this.approachDetails.finalApproachCourse >= 0
            && Math.round(this.approachDetails.finalApproachCourse) !== Math.round((_b = this.tunedIlsCourse) !== null && _b !== void 0 ? _b : -1));
    }
    /**
     * Get the true course for the final approach
     * @param facility Destination airport facility
     * @param approach The approach
     */
    async getFinalApproachTrueCourse(facility, approach) {
        // the final leg is guaranteed to be CF, TF, or RF
        // the default navdata doesn't code a course on TFs (navigraph does)
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        if (finalLeg.type === LegType.CF && finalLeg.trueDegrees) {
            return finalLeg.course;
        }
        let trueCourse = MagVar.magneticToTrue(finalLeg.course, facility.lat, facility.lon);
        if (finalLeg.type === LegType.TF) {
            const finalFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.fixIcao), finalLeg.fixIcao);
            const penultimateLeg = approach.finalLegs[approach.finalLegs.length - 2];
            if (!finalFacility || !penultimateLeg) {
                return -1;
            }
            // guaranteed to be XF
            const penultimateFacility = await this.facLoader.getFacility(ICAO.getFacilityType(penultimateLeg.fixIcao), penultimateLeg.fixIcao);
            if (!penultimateFacility) {
                return -1;
            }
            const penultimatePoint = BoeingFms.geoPointCache[0].set(penultimateFacility);
            trueCourse = penultimatePoint.bearingTo(finalFacility);
        }
        else if (finalLeg.type === LegType.RF) {
            // for exactly one airport in the world... but it is legal
            const finalFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.fixIcao), finalLeg.fixIcao);
            const centreFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.arcCenterFixIcao), finalLeg.arcCenterFixIcao);
            if (!finalFacility || !centreFacility) {
                return -1;
            }
            const finalPoint = BoeingFms.geoPointCache[0].set(finalFacility);
            trueCourse = NavMath.normalizeHeading(finalPoint.bearingTo(centreFacility) + (finalLeg.turnDirection === LegTurnDirection.Left ? 90 : -90));
        }
        return trueCourse;
    }
    /**
     * Get the magnetic course for the final approach
     * @param facility Destination airport facility
     * @param approach The approach
     * @param trueCourse The true course if already calculated, else it will be calculated
     */
    async getFinalApproachCourse(facility, approach, trueCourse) {
        if (trueCourse === undefined) {
            trueCourse = await this.getFinalApproachTrueCourse(facility, approach);
        }
        // the final leg is guaranteed to be CF, TF, or RF
        // the default navdata doesn't code a course on TFs (navigraph does)
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        // use the published airport magvar for terminal legs, except VHF navaids which use station declination
        let magVar = MagVar.get(facility.lat, facility.lon);
        if (finalLeg.originIcao !== ICAO.emptyIcao && ICAO.getFacilityType(finalLeg.originIcao) === FacilityType.VOR && finalLeg.type !== LegType.TF) {
            const originFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.originIcao), finalLeg.originIcao);
            // ILS approach must use the ILS declination
            if (originFacility && originFacility.type === VorType.ILS) {
                magVar = -originFacility.magneticVariation;
            }
        }
        else if (finalLeg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(finalLeg.fixIcao) === FacilityType.VOR && finalLeg.type !== LegType.TF) {
            const fixFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.originIcao), finalLeg.originIcao);
            if (fixFacility) {
                magVar = -fixFacility.magneticVariation;
            }
        }
        return MagVar.trueToMagnetic(trueCourse, magVar);
    }
}
BoeingFms.ACT_RTE_PLAN_INDEX = 0;
BoeingFms.RTE_1_INACTIVE_PLAN_INDEX = 1;
BoeingFms.RTE_1_MOD_PLAN_INDEX = 2;
BoeingFms.RTE_2_INACTIVE_PLAN_INDEX = 3;
BoeingFms.RTE_2_MOD_PLAN_INDEX = 4;
BoeingFms.USER_DATA_KEY_ALTN = 'wtboeing.altn';
BoeingFms.USER_DATA_KEY_FIX_INFO = 'wtboeing.fix-info';
BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN = 'wtboeing.new-inactive-plan';
BoeingFms.USER_DATA_KEY_ROUTE = 'wtboeing.route';
BoeingFms.USER_DATA_KEY_VISUAL_APPROACH = 'wtboeing.visual-approach';
BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA = 'wtboeing.visual-approach-vfr-vpa';
BoeingFms.geoPointCache = [new GeoPoint(0, 0)];

var AlternateDiversionMode;
(function (AlternateDiversionMode) {
    AlternateDiversionMode[AlternateDiversionMode["Direct"] = 0] = "Direct";
    AlternateDiversionMode[AlternateDiversionMode["Offset"] = 1] = "Offset";
    AlternateDiversionMode[AlternateDiversionMode["Overhead"] = 2] = "Overhead";
})(AlternateDiversionMode || (AlternateDiversionMode = {}));
var AlternateSpeedScheduleMode;
(function (AlternateSpeedScheduleMode) {
    AlternateSpeedScheduleMode["Econ"] = "ECON";
    AlternateSpeedScheduleMode["Lrc"] = "LRC";
    AlternateSpeedScheduleMode["EO"] = "EO";
    AlternateSpeedScheduleMode["EOLrc"] = "EOLRC";
    AlternateSpeedScheduleMode["CO"] = "CO";
})(AlternateSpeedScheduleMode || (AlternateSpeedScheduleMode = {}));
/**
 * Boeing alternates
 */
class BoeingAlternates {
    /**
     * Ctor
     *
     * @param bus the event bus
     * @param fms the fns
     */
    constructor(bus, fms) {
        this.bus = bus;
        this.fms = fms;
        this.ignoreSync = false;
        this._alternateSub = new Map();
        this._alternatePredictionsSub = new Map();
        this.alternatesPredictionsEntries = new Map();
        this.alternatesPredictionsForcedUpdates = new Map();
        this.alternates = ArraySubject.create([null, null, null, null]);
        this.activeLeg = Subject.create(null);
        this.alternates.sub((index, type, item) => {
            var _a, _b;
            if (type === SubscribableArrayEventType.Added) {
                if (Array.isArray(item)) {
                    const arr = item;
                    for (let i = 0; i < arr.length; i++) {
                        if (this._alternateSub.has(index + i)) {
                            (_a = this._alternateSub.get(index + i)) === null || _a === void 0 ? void 0 : _a.set(item[i]);
                        }
                    }
                }
                else {
                    const sub = this._alternateSub.get(index);
                    sub === null || sub === void 0 ? void 0 : sub.set(item);
                }
            }
            else if (type === SubscribableArrayEventType.Removed || type === SubscribableArrayEventType.Cleared) {
                if (Array.isArray(item)) {
                    const arr = item;
                    for (let i = 0; i < arr.length; i++) {
                        if (this._alternateSub.has(index + i)) {
                            (_b = this._alternateSub.get(index + i)) === null || _b === void 0 ? void 0 : _b.set(null);
                        }
                    }
                }
                else {
                    const sub = this._alternateSub.get(index);
                    sub === null || sub === void 0 ? void 0 : sub.set(null);
                }
            }
        });
        const sub = this.bus.getSubscriber();
        sub.on('realTime').whenChangedBy(1000 * 60 * 5).handle(() => this.handleUpdatePredictions());
        sub.on('fplLoaded').handle((event) => this.handleFlightPlanLoaded(event));
        sub.on('fplUserDataSet').handle((event) => this.handleFlightPlanUserDataChanged(event));
        sub.on('fplActiveLegChange').handle(() => this.handleUpdateActiveLeg());
        sub.on('fplCopied').handle(() => this.handleUpdateActiveLeg());
        this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => {
            this.tryForceUpdatePredictions();
        });
    }
    /**
     * Tries to force update predictions.
     */
    tryForceUpdatePredictions() {
        for (const [index, entry] of this.alternatesPredictionsEntries) {
            if (this.alternatesPredictionsForcedUpdates.get(index)) {
                this.alternatesPredictionsForcedUpdates.set(index, false);
                const predictions = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(entry);
                const sub = this._alternatePredictionsSub.get(index);
                if (!sub) {
                    continue;
                }
                sub.set(predictions !== null && predictions !== void 0 ? predictions : null);
                sub.notify();
            }
        }
    }
    /**
     * Handles updating alternate predictions
     */
    handleUpdatePredictions() {
        for (const [index, entry] of this.alternatesPredictionsEntries) {
            const predictions = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(entry);
            const sub = this._alternatePredictionsSub.get(index);
            if (!sub) {
                continue;
            }
            sub.set(predictions !== null && predictions !== void 0 ? predictions : null);
            sub.notify();
        }
    }
    /**
     * Handles `fplLoaded` events
     *
     * @param event the event
     */
    handleFlightPlanLoaded(event) {
        if (event.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX) {
            return;
        }
        this.readPlanAlternates();
    }
    /**
     * Handles `fplUserDataSet` events
     *
     * @param event the event
     */
    handleFlightPlanUserDataChanged(event) {
        if (this.ignoreSync) {
            return;
        }
        if (event.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX) {
            return;
        }
        if (event.key !== BoeingFms.USER_DATA_KEY_ALTN) {
            return;
        }
        this.readPlanAlternates();
    }
    /**
     * Handles updating the active leg
     */
    handleUpdateActiveLeg() {
        const plan = this.fms.getPrimaryFlightPlan();
        const leg = plan.tryGetLeg(plan.activeLateralLeg);
        this.activeLeg.set(leg);
    }
    /**
     * Returns whether an alternate exists for the specified index
     *
     * @param index the index
     *
     * @returns a boolean
     */
    hasAlternate(index) {
        return !!this.alternates.getArray()[index];
    }
    /**
     * Returns the index of an alternate from an ICAO, or -1 if the facility is not entered as an alternate
     *
     * @param fixIcao the airport ICAO
     *
     * @returns a number
     */
    getAlternateIndexByIcao(fixIcao) {
        return this.alternates.getArray().findIndex((it) => (it === null || it === void 0 ? void 0 : it.facilityIcao) === fixIcao);
    }
    /**
     * Returns a {@link Subscribable} for a position in the alternates array
     *
     * @param index the index for which to return a subscribable
     * @param initialNotify whether to initially notify
     *
     * @returns a subscribable
     */
    alternateSub(index, initialNotify = false) {
        let sub = this._alternateSub.get(index);
        if (!sub) {
            const subject = Subject.create(this.alternates.length > index ? this.alternates.get(index) : null);
            this._alternateSub.set(index, subject);
            if (initialNotify) {
                subject.set(this.alternates.length > index ? this.alternates.get(index) : null);
            }
            sub = subject;
        }
        return sub;
    }
    /**
     * Returns a {@link Subscribable} for predictions of a position in the alternates array
     *
     * @param index the index for which to return a subscribable
     *
     * @returns a subscribable
     */
    alternatePredictionsSub(index) {
        var _a;
        let sub = this._alternatePredictionsSub.get(index);
        if (!sub) {
            const trackingEntry = this.getFacilityTrackingEntryForAlternate(index);
            const subject = Subject.create(this.alternates.length > index && trackingEntry ?
                (_a = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(trackingEntry)) !== null && _a !== void 0 ? _a : null
                : null);
            this._alternatePredictionsSub.set(index, subject);
            sub = subject;
        }
        return sub;
    }
    /**
     * Sets the alternate in a position
     *
     * @param index the position
     * @param data the alternate data
     * @param notify whether to sync this change
     */
    setAlternate(index, data, notify = true) {
        const existing = this.alternates.get(index);
        if (existing) {
            this.alternates.removeAt(index);
            const trackingEntry = this.alternatesPredictionsEntries.get(index);
            if (trackingEntry) {
                this.fms.activeRoutePredictor.stopTrackingFacility(trackingEntry);
            }
        }
        else if (data) {
            const entry = {};
            this.setPredictionsTrackingEntryFromAlternateData(entry, data);
            this.alternatesPredictionsEntries.set(index, entry);
            this.alternatesPredictionsForcedUpdates.set(index, true);
            this.fms.activeRoutePredictor.startTrackingFacility(entry);
        }
        this.alternates.insert(data, index);
        if (notify) {
            this.writePlanAlternates();
        }
    }
    /**
     * Modifies the alternate in a position
     *
     * @param index the position
     * @param data the alternate data
     * @param notify whether to sync this change
     */
    modifyAlternate(index, data, notify = true) {
        const existing = this.alternates.get(index);
        Object.assign(existing, data);
        this.alternates.removeAt(index);
        this.alternates.insert(existing, index);
        const predictionsTrackingEntry = this.alternatesPredictionsEntries.get(index);
        if (predictionsTrackingEntry) {
            this.setPredictionsTrackingEntryFromAlternateData(predictionsTrackingEntry, data);
            setTimeout(() => this.handleUpdatePredictions(), 1100);
        }
        if (notify) {
            this.writePlanAlternates();
        }
    }
    /**
     * Returns the facility predictions tracking entry, if applicable, for the given alternate index
     *
     * @param index the position
     *
     * @returns a {@link FacilityPredictionsTrackingEntry} object
     */
    getFacilityTrackingEntryForAlternate(index) {
        return this.alternatesPredictionsEntries.get(index);
    }
    /**
     * Sets a facility predictions tracking entry's values from alternate data
     *
     * @param entry the tracking entry
     * @param data the alternate data
     */
    setPredictionsTrackingEntryFromAlternateData(entry, data) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const alternateSpeedMode = this.fms.activePerformancePlan.alternateSpeedValue.get();
        const alternateSpeedIsMach = this.fms.activePerformancePlan.alternateSpeedIsMach.get();
        const alternateCruiseAltitude = this.fms.activePerformancePlan.alternateCruiseAltitude.get();
        if (data.facilityIcao) {
            entry.facIcao = data.facilityIcao;
        }
        entry.predictionSpeed = alternateSpeedMode;
        entry.predictionSpeedIsMach = alternateSpeedIsMach;
        entry.predictionsAltitude = UnitType.METER.convertFrom(alternateCruiseAltitude !== null && alternateCruiseAltitude !== void 0 ? alternateCruiseAltitude : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        entry.predictionsOatAltitude = UnitType.METER.convertFrom((_a = data.oatAltitude) !== null && _a !== void 0 ? _a : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        entry.predictionsOatTemperature = (_b = data.oatTemperature) !== null && _b !== void 0 ? _b : -50; // TODO investigate proper placeholder value
        entry.predictionsWind = { direction: (_d = (_c = data.wind) === null || _c === void 0 ? void 0 : _c.direction) !== null && _d !== void 0 ? _d : 0, speed: (_f = (_e = data.wind) === null || _e === void 0 ? void 0 : _e.speed) !== null && _f !== void 0 ? _f : 0, trueDegrees: (_h = (_g = data.wind) === null || _g === void 0 ? void 0 : _g.trueDegrees) !== null && _h !== void 0 ? _h : false };
        switch ((_j = data.diversion) === null || _j === void 0 ? void 0 : _j.mode) {
            case AlternateDiversionMode.Overhead: {
                entry.startAfterFlightPlanLeg = data.diversion.legIndex;
                break;
            }
            default:
            case AlternateDiversionMode.Offset:
                entry.startAfterFlightPlanLeg = 'direct';
                break;
        }
    }
    /**
     * Reads the alternates from the RTE 1 primary flight plan
     */
    readPlanAlternates() {
        const alternates = this.fms.getFlightPlanAlternates(BoeingFms.ACT_RTE_PLAN_INDEX);
        if (!alternates) {
            return;
        }
        for (let i = 0; i < alternates.length; i++) {
            const alternate = alternates[i];
            this.setAlternate(i, alternate !== null && alternate !== void 0 ? alternate : null, false);
        }
    }
    /**
     * Writes the alternates to the RTE 1 primary flight plan
     */
    writePlanAlternates() {
        this.ignoreSync = true;
        this.fms.setFlightPlanAlternates(BoeingFms.ACT_RTE_PLAN_INDEX, this.alternates.getArray());
        this.ignoreSync = false;
    }
}

/**
 * A utility class for working with Boeing flight path calculations.
 */
class BoeingFlightPathUtils {
}
/** The flight path calculator plans turns at these bank angles */
BoeingFlightPathUtils.flightPathBankAngleTable = [
    [15, 0],
    [25, 100],
    [25, 375],
    [19, 450],
];

/** Keep this in sync with WTB748_Common.css & WTB78x_Common.css */
class BoeingColors {
}
BoeingColors.black = 'black';
BoeingColors.blackTranslucent = 'rgba(0, 0, 0, 0.2)';
BoeingColors.white = 'white';
BoeingColors.gray = 'hsl(0, 0%, 70%)';
BoeingColors.darkGray = 'hsl(0, 0%, 50%)';
BoeingColors.blue = 'hsl(230, 100%, 51%)';
BoeingColors.red = 'red';
BoeingColors.amber = 'hsl(45, 100%, 50%)';
BoeingColors.green = '#49e700';
BoeingColors.magenta = 'magenta';
BoeingColors.cyan = 'hsl(195, 100%, 50%)';

/**
 * A class for shared temperature utilities
 */
class BoeingTemperatureUtils {
    /**
     * Adjusts a temperature Subject value towards a target.
     * @param target The target temperature.
     * @param temp The temperature Subject to adjust.
     * @param timeConstant The time constant to use when adjusting the temperature.
     * @param deltaTime The current update delta time.
     */
    static adjustTemp(target, temp, timeConstant, deltaTime) {
        const error = target - temp.get();
        const change = Math.sign(error) * (timeConstant / 1000) * deltaTime;
        if (Math.abs(change) >= Math.abs(error)) {
            temp.set(target);
        }
        else {
            temp.set(temp.get() + change);
        }
    }
}

/**
 * Boeing unit utility class.
 */
class BoeingUnitUtils {
    /**
     * Gets the weight unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The weight unit.
     */
    static getWeightUnits(isMetric) {
        return isMetric ? UnitType.KILOGRAM : UnitType.POUND;
    }
    /**
     * Gets the length unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The length unit.
     */
    static getLengthUnits(isMetric) {
        return isMetric ? UnitType.METER : UnitType.FOOT;
    }
    /**
     * Gets the pressure unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The pressure unit.
     */
    static getPressureUnits(isMetric) {
        return isMetric ? UnitType.HPA : UnitType.IN_HG;
    }
    /**
     * Gets the flow unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The flow unit.
     */
    static getFlowUnits(isMetric) {
        return isMetric ? UnitType.KGH : UnitType.PPH;
    }
    /**
     * Gets the string (used for display) for a given unit in the WT21.
     * @param unit The unit to get the string for.
     * @returns The unit string for display.
     */
    static getUnitString(unit) {
        var _a;
        return (_a = BoeingUnitUtils.UNIT_STRINGS.get(unit)) !== null && _a !== void 0 ? _a : '';
    }
    /**
     * Returns a boolean indicating if the sim is in metric mode.
     * @returns true if sim is in metric mode, false otherwise.
     */
    static getIsMetric() {
        return SimVar.GetGameVarValue('GAME UNIT IS METRIC', 'number') === 1;
    }
}
BoeingUnitUtils.UNIT_STRINGS = new Map([
    [UnitType.KILOGRAM, 'KG'],
    [UnitType.POUND, 'LB'],
    [UnitType.METER, 'M'],
    [UnitType.FOOT, 'FT'],
    [UnitType.IN_HG, 'IN'],
    [UnitType.HPA, 'HPA'],
    [UnitType.PPH, 'PPH'],
    [UnitType.KGH, 'KGH'],
]);

/**
 * An implementation of {@link FlightPlanPredictionsProvider} that uses {@link BoeingPathCalculator}
 */
class BoeingFlightPlanPredictionsProvider {
    /**
     * Ctor
     * @param bus the bus
     * @param fmsPosIndex the index of the fms position to use
     * @param planIndex the index of the plan to predict data for
     * @param updateRate the update rate, in Hertz, at which to update plan predictions
     * @param flightPlanner the flight planner
     * @param verticalPathCalculator the path calculator
     * @param performancePlanRepository the perf plan repo
     * @param perfProvider the perf provider
     * @param facLoader the fac loader
     */
    constructor(bus, fmsPosIndex, planIndex, updateRate, flightPlanner, verticalPathCalculator, performancePlanRepository, perfProvider, facLoader) {
        this.bus = bus;
        this.fmsPosIndex = fmsPosIndex;
        this.planIndex = planIndex;
        this.updateRate = updateRate;
        this.flightPlanner = flightPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.perfProvider = perfProvider;
        this.facLoader = facLoader;
        this.onPredictionsUpdated = new SubEvent();
        this.updateDebouncer = new DebounceTimer();
        this.realTimeValue = ConsumerValue.create(null, -1);
        this.simTimeValue = ConsumerValue.create(null, -1);
        this.activeLegDistanceAlongValue = ConsumerValue.create(null, -1);
        this.activeLegDtgValue = ConsumerValue.create(null, -1);
        this.pposValue = ConsumerValue.create(null, new LatLongAlt(NaN, NaN));
        this.fobValue = ConsumerValue.create(null, -1);
        this.fuelWeightValue = ConsumerValue.create(null, -1);
        this.fuelFlowValue = ConsumerValue.create(null, -1);
        this.planPredictions = new Map();
        this.trackedFacilities = new Map();
        this.trackFacilityLastUpdates = new Map();
        this.resolvedFacilities = new Map();
        this.destinationPredictions = {
            ident: '',
            position: new GeoPoint(0, 0),
            valid: true,
            distance: NaN,
            estimatedTimeOfArrival: NaN,
            fob: NaN,
            altitude: NaN,
        };
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        const sub = this.bus.getSubscriber();
        sub.on('realTime').whenChangedBy(this.updateRate).handle(() => {
            this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
        });
        this.realTimeValue.setConsumer(sub.on('realTime'));
        this.simTimeValue.setConsumer(sub.on('simTime'));
        this.activeLegDistanceAlongValue.setConsumer(sub.on('lnav_leg_distance_along'));
        this.activeLegDtgValue.setConsumer(sub.on('lnav_leg_distance_remaining'));
        this.pposValue.setConsumer(sub.on(`fms_pos_gps-position_${this.fmsPosIndex}`));
        this.fobValue.setConsumer(sub.on('fuel_total_weight'));
        this.fuelWeightValue.setConsumer(sub.on('fuel_weight_per_gallon'));
        this.fuelFlowValue.setConsumer(sub.on('fuel_flow_total'));
        sub.on('fplLegChange').handle(({ legIndex, type }) => {
            const legPredictions = this.planPredictions.get(legIndex);
            switch (type) {
                case LegEventType.Removed:
                    legPredictions && (legPredictions.valid = false);
            }
        });
    }
    /**
     * Updates predictions for the flight plan, then notifies subscribers.
     */
    updatePredictions() {
        this.updatePredictionsInternal();
        this.onPredictionsUpdated.notify(this);
    }
    /**
     * Updates predictions for the flight plan
     */
    updatePredictionsInternal() {
        var _a, _b, _c, _d, _e, _f;
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return;
        }
        const zeroFuelWeight = this.performancePlanRepository.getActivePlan().manualZfw.get();
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        const verticalPath = this.verticalPathCalculator.getVerticalFlightPath(this.planIndex);
        const unixTimestamp = this.simTimeValue.get() / 1000;
        let accumulatedDistance = 0;
        let accumulatedTime = 0;
        for (let i = 0; i < plan.length; i++) {
            let legPredictions = this.planPredictions.get(i);
            if (i < plan.activeLateralLeg) {
                if (legPredictions) {
                    legPredictions.valid = false;
                }
                this.invalidateTrackedFacilitiesForPosition(i);
                continue;
            }
            const lateralLeg = plan.getLeg(i);
            const matchingVerticalLeg = verticalPath.legs[i];
            if (legPredictions === undefined) {
                legPredictions = {
                    ident: (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '',
                    position: new GeoPoint(0, 0),
                    valid: true,
                    distance: NaN,
                    estimatedTimeOfArrival: NaN,
                    fob: NaN,
                    altitude: NaN,
                };
                this.planPredictions.set(i, legPredictions);
            }
            legPredictions.ident = (_b = lateralLeg.name) !== null && _b !== void 0 ? _b : '';
            let legDistance = NaN;
            if (i === plan.activeLateralLeg) { // TODO effective leg index
                accumulatedDistance += UnitType.METER.convertFrom(this.activeLegDtgValue.get(), UnitType.NMILE);
                if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                    const totalTime = matchingVerticalLeg.simDuration;
                    const distanceAlong = this.activeLegDistanceAlongValue.get();
                    const distanceToGo = this.activeLegDtgValue.get();
                    if (distanceAlong !== -1 && distanceToGo !== -1) {
                        accumulatedTime += (1 - distanceAlong / (distanceAlong + distanceToGo)) * totalTime;
                    }
                }
            }
            else if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                accumulatedDistance += matchingVerticalLeg.simDistance;
                accumulatedTime += matchingVerticalLeg.simDuration;
            }
            else if (lateralLeg.calculated) {
                accumulatedDistance += lateralLeg.calculated.distanceWithTransitions;
            }
            legDistance = accumulatedDistance;
            if (zeroFuelWeight !== null && matchingVerticalLeg && matchingVerticalLeg.vectors.length !== 0) {
                const lastVector = matchingVerticalLeg.vectors[matchingVerticalLeg.vectors.length - 1];
                legPredictions.valid = true;
                legPredictions.position.set((_d = (_c = lateralLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) !== null && _d !== void 0 ? _d : NaN, (_f = (_e = lateralLeg.calculated) === null || _e === void 0 ? void 0 : _e.endLon) !== null && _f !== void 0 ? _f : NaN);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = unixTimestamp + accumulatedTime;
                legPredictions.fob = lastVector.endWeight - zeroFuelWeight;
                legPredictions.altitude = lastVector.endAltitude;
                for (const entry of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(entry, i);
                }
            }
            else if (lateralLeg.calculated && lateralLeg.calculated.endLat !== undefined && lateralLeg.calculated.endLon !== undefined) {
                legPredictions.valid = true;
                legPredictions.position.set(lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = NaN;
                legPredictions.fob = NaN;
                legPredictions.altitude = NaN;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            else {
                legPredictions.valid = false;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
        }
        // Update tracked facilities with no leg index
        for (const entry of this.getTrackedFacilityEntriesForPosition('direct')) {
            this.updateTrackedFacilityPredictionsFromPpos(entry);
        }
        this.updateDestinationPredictions();
    }
    /**
     * Updates a tracked facility entry's predictions based on the predictions of a given leg index
     *
     * @param entry the entry
     * @param legIndex the leg index
     */
    updateTrackedFacilityPredictionsAfterLeg(entry, legIndex) {
        var _a;
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        const legPredictions = this.planPredictions.get(legIndex);
        if (!legPredictions) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilities.set(entry, facilityPredictions);
        this.trackFacilityLastUpdates.set(entry, this.realTimeValue.get());
        const distance = legPredictions.position.distance(facilityPredictions.position);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        const distanceNm = UnitType.NMILE.convertFrom(distance, UnitType.GA_RADIAN);
        const predictionOatIsaDev = entry.predictionsOatTemperature - AeroMath.isaTemperature(entry.predictionsOatAltitude);
        let predictionGroundSpeed;
        let predictionFuelFlow;
        if (typeof entry.predictionSpeed === 'number') {
            let predictionTrueAirspeed;
            if (entry.predictionSpeedIsMach) {
                predictionTrueAirspeed = AeroMath.machToTasIsa(entry.predictionSpeed, entry.predictionsAltitude, predictionOatIsaDev);
            }
            else {
                const predictionCasMps = UnitType.MPS.convertFrom(entry.predictionSpeed, UnitType.KNOT);
                predictionTrueAirspeed = AeroMath.casToTasIsa(predictionCasMps, entry.predictionsAltitude, predictionOatIsaDev);
            }
            const predictionTrueAirSpeedKnots = UnitType.KNOT.convertFrom(predictionTrueAirspeed, UnitType.MPS);
            const currentWeight = ((_a = this.performancePlanRepository.getActivePlan().manualZfw.get()) !== null && _a !== void 0 ? _a : 0) + this.fobValue.get();
            predictionFuelFlow = this.getInstantaneousFuelFlowIsa(entry.predictionsAltitude, predictionTrueAirspeed, predictionOatIsaDev, currentWeight);
            // Cache great circle between PPOS and facility
            this.geoCircleCache[0].setAsGreatCircle(legPredictions.position, facility);
            let windKnots = FlightPathUtils.projectVelocityToCircle(entry.predictionsWind.speed, facility, entry.predictionsWind.trueDegrees ? entry.predictionsWind.direction : MagVar.magneticToTrue(entry.predictionsWind.direction, facility), this.geoCircleCache[0]);
            if (!Number.isFinite(windKnots)) {
                windKnots = 0;
            }
            predictionGroundSpeed = predictionTrueAirSpeedKnots + windKnots;
        }
        else {
            predictionGroundSpeed = AeroMath.casToTasIsa(250, entry.predictionsAltitude, predictionOatIsaDev);
            // TODO support speed schedules
        }
        const durationSeconds = (distanceNm / predictionGroundSpeed) * 3600;
        if (predictionFuelFlow === undefined) {
            const fuelFlowPph = this.fuelFlowValue.get() * this.fuelWeightValue.get();
            predictionFuelFlow = fuelFlowPph / 3600;
        }
        facilityPredictions.valid = true;
        facilityPredictions.position.set(facility.lat, facility.lon);
        facilityPredictions.distance = distanceMetres;
        facilityPredictions.estimatedTimeOfArrival = legPredictions.estimatedTimeOfArrival + durationSeconds;
        facilityPredictions.fob = legPredictions.fob - (durationSeconds * predictionFuelFlow);
        facilityPredictions.altitude = entry.predictionsAltitude;
    }
    /**
     * Updates a tracked facility entry's predictions based on PPOS
     *
     * @param entry the entry
     */
    updateTrackedFacilityPredictionsFromPpos(entry) {
        var _a;
        const unixTimestamp = this.simTimeValue.get() / 1000;
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilities.set(entry, facilityPredictions);
        const ppos = this.pposValue.get();
        const distance = GeoPoint.distance(facility.lat, facility.lon, ppos.lat, ppos.long);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        const distanceNm = UnitType.NMILE.convertFrom(distance, UnitType.GA_RADIAN);
        let predictionGroundSpeed;
        let predictionFuelFlow;
        if (typeof entry.predictionSpeed === 'number') {
            const predictionOatIsaDev = entry.predictionsOatTemperature - AeroMath.isaTemperature(entry.predictionsOatAltitude);
            let predictionTrueAirspeed;
            if (entry.predictionSpeedIsMach) {
                predictionTrueAirspeed = AeroMath.machToTasIsa(entry.predictionSpeed, entry.predictionsAltitude, predictionOatIsaDev);
            }
            else {
                const predictionCasMps = UnitType.MPS.convertFrom(entry.predictionSpeed, UnitType.KNOT);
                predictionTrueAirspeed = AeroMath.casToTasIsa(predictionCasMps, entry.predictionsAltitude, predictionOatIsaDev);
            }
            const predictionTrueAirSpeedKnots = UnitType.KNOT.convertFrom(predictionTrueAirspeed, UnitType.MPS);
            const currentWeight = ((_a = this.performancePlanRepository.getActivePlan().manualZfw.get()) !== null && _a !== void 0 ? _a : 0) + this.fobValue.get();
            predictionFuelFlow = this.getInstantaneousFuelFlowIsa(entry.predictionsAltitude, predictionTrueAirspeed, predictionOatIsaDev, currentWeight);
            // Cache great circle between PPOS and facility
            this.geoCircleCache[0].setAsGreatCircle(this.geoPointCache[0].set(ppos.lat, ppos.long), facility);
            let windKnots = FlightPathUtils.projectVelocityToCircle(entry.predictionsWind.speed, facility, entry.predictionsWind.trueDegrees ? entry.predictionsWind.direction : MagVar.magneticToTrue(entry.predictionsWind.direction, facility), this.geoCircleCache[0]);
            if (!Number.isFinite(windKnots)) {
                windKnots = 0;
            }
            predictionGroundSpeed = predictionTrueAirSpeedKnots + windKnots;
        }
        else {
            predictionGroundSpeed = 200;
            // TODO support speed schedules
        }
        const durationSeconds = (distanceNm / predictionGroundSpeed) * 3600;
        if (predictionFuelFlow === undefined) {
            const fuelFlowPph = this.fuelFlowValue.get() * this.fuelWeightValue.get();
            predictionFuelFlow = fuelFlowPph / 3600;
        }
        const currentFob = this.fobValue.get();
        facilityPredictions.valid = true;
        facilityPredictions.position.set(facility.lat, facility.lon);
        facilityPredictions.distance = distanceMetres;
        facilityPredictions.estimatedTimeOfArrival = unixTimestamp + durationSeconds;
        facilityPredictions.fob = currentFob - (durationSeconds * predictionFuelFlow);
        facilityPredictions.altitude = entry.predictionsAltitude;
    }
    /**
     * Calculates the instantaneous fuel flow for given parameters at ISA conditions
     *
     * @param altitude the altitude, in metres
     * @param tas the true airspeed, in metres per second
     * @param isaDev the ISA temperature deviation, in degrees Celsius
     * @param weight the weight, in pounds
     *
     * @returns the fuel flow, in pounds per second
     */
    getInstantaneousFuelFlowIsa(altitude, tas, isaDev, weight) {
        const weightForce = UnitType.NEWTON.convertFrom(weight, UnitType.POUND_FORCE);
        const density = AeroMath.isaDensity(altitude, isaDev);
        const cl = AeroMath.liftCoefficient(weightForce, this.perfProvider.getWingArea(), density, tas);
        const thrust = this.perfProvider.getLevelFlightRequiredThrust(weight, cl);
        const mach = AeroMath.tasToMachIsa(tas, altitude, AeroMath.soundSpeedIsa(altitude, isaDev));
        const grossThrust = this.perfProvider.estimateGrossThrustFromNetThrust(thrust, mach, AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + isaDev);
        return this.perfProvider.getEngineFuelFlow(grossThrust) / 3600;
    }
    /**
     * Returns the predictions object for a tracked facility entry, creating a new empty and invalid object if none is present
     *
     * @param entry the tracked facility entry
     *
     * @returns a {@link Predictions} object
     */
    getTrackedFacilityPredictions(entry) {
        var _a;
        const predictions = this.trackedFacilities.get(entry);
        if (!predictions) {
            const emptyPredictions = {
                ident: (_a = ICAO.getIdent(entry.facIcao)) !== null && _a !== void 0 ? _a : '',
                position: new GeoPoint(NaN, NaN),
                valid: false,
                distance: NaN,
                estimatedTimeOfArrival: NaN,
                fob: NaN,
                altitude: NaN,
                groundSpeed: NaN,
            };
            this.trackedFacilities.set(entry, emptyPredictions);
            return emptyPredictions;
        }
        return predictions;
    }
    /**
     * Updates the destination prediction
     */
    updateDestinationPredictions() {
        const unixTimestamp = this.simTimeValue.get() / 1000;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        const mapIndex = VNavUtils.getMissedApproachLegIndex(plan);
        // Use the MAP index if it is available
        if (mapIndex !== -1) {
            const mapLegPredictions = this.planPredictions.get(mapIndex);
            if (mapLegPredictions && mapLegPredictions.valid) {
                this.destinationPredictions.valid = true;
                Object.assign(this.destinationPredictions, mapLegPredictions);
                return;
            }
        }
        // Otherwise, predict using the prediction at the last non-missed-approach plan leg + great circle direct
        // distance to the destination airport reference point
        if (plan.length > 0 && plan.destinationAirport) {
            let lastNonMissedApproachLegIndex = -1;
            for (let i = plan.length - 1; i > 0; i--) {
                const leg = plan.getLeg(i);
                if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
                    lastNonMissedApproachLegIndex = i;
                    break;
                }
            }
            if (lastNonMissedApproachLegIndex !== -1) {
                const backwardsIterator = this.iteratePredictionsReverse(lastNonMissedApproachLegIndex);
                let lastLegPredictions;
                let prevLastLegPredictions;
                for (const predictions of backwardsIterator) {
                    if (!prevLastLegPredictions && lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        prevLastLegPredictions = predictions;
                        break;
                    }
                    if (!lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        lastLegPredictions = predictions;
                    }
                }
                if (prevLastLegPredictions && lastLegPredictions) {
                    this.destinationPredictions.valid = true;
                    Object.assign(this.destinationPredictions, lastLegPredictions);
                    const airportFacility = this.resolvedFacilities.get(plan.destinationAirport);
                    if (!airportFacility) {
                        this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                        this.destinationPredictions.valid = false;
                        return;
                    }
                    const distance = lastLegPredictions.position.distance(airportFacility);
                    const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    BoeingFlightPlanPredictionsProvider.extrapolatePrediction(prevLastLegPredictions, lastLegPredictions, distanceMetres, this.destinationPredictions);
                    return;
                }
            }
        }
        // In the worst case scenario, predict the great circle direct distance from PPOS to the destination airport reference point
        if (plan.destinationAirport) {
            const facility = this.resolvedFacilities.get(plan.destinationAirport);
            if (!facility) {
                this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                this.destinationPredictions.valid = false;
                return;
            }
            const ppos = this.pposValue.get();
            const distance = GeoPoint.distance(facility.lat, facility.lon, ppos.lat, ppos.long);
            const distanceNm = UnitType.NMILE.convertFrom(distance, UnitType.GA_RADIAN);
            const predictionGroundSpeed = 300;
            const durationSeconds = (distanceNm / predictionGroundSpeed) * 3600;
            const currentFob = this.fobValue.get();
            const fuelFlowPph = this.fuelFlowValue.get() * this.fuelWeightValue.get();
            const fuelFlowPps = fuelFlowPph / 3600;
            this.destinationPredictions.valid = true;
            this.destinationPredictions.distance = distanceNm;
            this.destinationPredictions.estimatedTimeOfArrival = unixTimestamp + durationSeconds;
            this.destinationPredictions.fob = currentFob - (durationSeconds * fuelFlowPps);
            this.destinationPredictions.altitude = 37000; // TODO use more reasonable or appropriate value
            return;
        }
        // Otherwise mark the destination predictions as invalid
        this.destinationPredictions.valid = false;
    }
    /**
     * Invalidates all leg predictions
     */
    invalidateLegPredictions() {
        var _a;
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = 0; i < plan.length; i++) {
            const leg = plan.getLeg(i);
            const existing = this.planPredictions.get(i);
            if (existing) {
                existing.valid = false;
            }
            else {
                this.planPredictions.set(i, { valid: false, ident: (_a = leg.name) !== null && _a !== void 0 ? _a : '', fob: NaN, altitude: NaN, estimatedTimeOfArrival: NaN, position: new GeoPoint(NaN, NaN), distance: NaN });
            }
        }
    }
    /**
     * Invalidates all tracked facility predictions
     */
    invalidateAllTrackedFacilities() {
        for (const [, predictions] of this.trackedFacilities.entries()) {
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Invalidates all tracked facility predictions attached to a given position
     *
     * @param position the position
     */
    invalidateTrackedFacilitiesForPosition(position) {
        const entries = this.getTrackedFacilityEntriesForPosition(position);
        for (const entry of entries) {
            const predictions = this.trackedFacilities.get(entry);
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Returns all facility tracking entries for a given position
     *
     * @param position the position
     *
     * @returns an array of {@link FacilityPredictionsTrackingEntry} objects
     */
    getTrackedFacilityEntriesForPosition(position) {
        const indices = [];
        for (const entry of this.trackedFacilities.keys()) {
            if (entry.startAfterFlightPlanLeg === position) {
                indices.push(entry);
            }
        }
        return indices;
    }
    /** @inheritDoc */
    *iteratePredictions(startGlobalLegIndex = 0) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = startGlobalLegIndex; i < plan.length; i++) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    *iteratePredictionsReverse(startGlobalLegIndex = this.flightPlanner.getFlightPlan(this.planIndex).length - 1) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = Math.min(plan.length - 1, startGlobalLegIndex); i > 0; i--) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    getPredictionsForLeg(globalLegIndex) {
        return this.planPredictions.get(globalLegIndex);
    }
    /** @inheritDoc */
    getDestinationPredictions() {
        return this.destinationPredictions;
    }
    /** @inheritDoc */
    getPredictionsForTrackedFacility(entry) {
        var _a;
        return (_a = this.trackedFacilities.get(entry)) !== null && _a !== void 0 ? _a : undefined;
    }
    /** @inheritDoc */
    startTrackingFacility(entry) {
        this.trackedFacilities.set(entry, null);
        this.facLoader.getFacility(ICAO.getFacilityType(entry.facIcao), entry.facIcao).then((facility) => {
            this.resolvedFacilities.set(entry.facIcao, facility);
            this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
        });
    }
    /** @inheritDoc */
    stopTrackingFacility(entry) {
        return this.trackedFacilities.delete(entry);
    }
    /** @inheritDoc */
    getPredictionsForTime(time) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('estimatedTimeOfArrival', time, 1);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const ratio = (time - predictionsBefore.estimatedTimeOfArrival) / (predictionsAfter.estimatedTimeOfArrival - predictionsBefore.estimatedTimeOfArrival);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, ratio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForAltitude(altitude) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let startAltitude;
        let crossingDirection = 1;
        for (let i = 0; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (startAltitude === undefined && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                startAltitude = predictions.altitude;
                crossingDirection = startAltitude > altitude ? -1 : 1;
            }
            if (!predictions) {
                continue;
            }
            if (crossingDirection > 0 && predictions.altitude > altitude) {
                predictionsBefore = this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
            if (crossingDirection < 0 && predictions.altitude < altitude) {
                predictionsBefore = this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return undefined;
        }
        const altitudeRatio = Math.abs(altitude - predictionsBefore.altitude) / Math.abs(predictionsAfter.altitude - predictionsBefore.altitude);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, altitudeRatio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForDistance(distance) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('distance', distance, 1);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const distanceRatio = (distance - predictionsBefore.distance) / (predictionsAfter.distance - predictionsBefore.distance);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, distanceRatio, out);
        return out;
    }
    /**
     * Gets the bounding (previous and next) leg predictions that surround a given value of a property
     *
     * @param discriminant the property to evaluate
     * @param value the value (the value the previous prediction must be below, and the next prediction above)
     * @param progression the progression direction: if -1, inverts the example conditions of the {@link value} param
     *
     * @returns a tuple of {@link Predictions} objects, or null if none found
     */
    getBoundingLegPredictions(discriminant, value, progression) {
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = 0; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (!predictions) {
                continue;
            }
            if (!predictionsBefore && (progression > 0 ? predictions[discriminant] < value : predictions[discriminant] > value)) {
                predictionsBefore = predictions;
                continue;
            }
            if (progression > 0 ? predictions[discriminant] > value : predictions[discriminant] < value) {
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return null;
        }
        return [predictionsBefore, predictionsAfter];
    }
    /**
     * Loads a facility and schedules a predictions update
     *
     * @param facilityIcao the facility ICAO
     */
    loadFacilityAndScheduleUpdate(facilityIcao) {
        this.facLoader.getFacility(ICAO.getFacilityType(facilityIcao), facilityIcao).then((loadedFac) => {
            this.resolvedFacilities.set(facilityIcao, loadedFac);
            this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
        });
    }
    /**
     * Linearly interpolates two prediction objects
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param ratio the ratio to interpolate at
     * @param out the output value object
     */
    static linearlyInterpolatePredictions(predictionsA, predictionsB, ratio, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsA.distance + (ratio * (predictionsB.distance - predictionsA.distance));
            out.estimatedTimeOfArrival = predictionsA.estimatedTimeOfArrival + (ratio * (predictionsB.estimatedTimeOfArrival - predictionsA.estimatedTimeOfArrival));
            out.fob = predictionsA.fob + (ratio * (predictionsB.fob - predictionsA.fob));
            out.altitude = predictionsA.altitude + (ratio * (predictionsB.altitude - predictionsA.altitude));
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
        }
    }
    /**
     * Linearly extrapolates two prediction objects into another prediction given an additional distance flown
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param additionalDistance the additional distance to extrapolate to
     * @param out the output value object
     */
    static extrapolatePrediction(predictionsA, predictionsB, additionalDistance, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsB.distance + additionalDistance;
            out.estimatedTimeOfArrival = MathUtils.lerp(predictionsA.distance, predictionsB.distance, predictionsB.distance + additionalDistance, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival);
            out.fob = MathUtils.lerp(predictionsA.distance, predictionsB.distance, predictionsB.distance + additionalDistance, predictionsA.fob, predictionsB.fob);
            out.altitude = MathUtils.lerp(predictionsA.distance, predictionsB.distance, predictionsB.distance + additionalDistance, predictionsA.altitude, predictionsB.altitude);
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
        }
    }
}

var BoeingInhibitStates;
(function (BoeingInhibitStates) {
    BoeingInhibitStates["EngineStopped"] = "engine-shutdown-inhibit";
    BoeingInhibitStates["EngineStarting"] = "engine-start-inhibit";
    BoeingInhibitStates["TakingOff"] = "takeoff-inhibit";
    BoeingInhibitStates["BeforeCruiseFlightPhases"] = "all-prior-cruise";
    BoeingInhibitStates["DuringAndAfterCruiseFlightPhases"] = "all-past-cruise";
})(BoeingInhibitStates || (BoeingInhibitStates = {}));
var AlertSuffixes;
(function (AlertSuffixes) {
    AlertSuffixes["L"] = "L";
    AlertSuffixes["R"] = "R";
    AlertSuffixes["C"] = "C";
})(AlertSuffixes || (AlertSuffixes = {}));
var AlertSuffixesEngGen;
(function (AlertSuffixesEngGen) {
    AlertSuffixesEngGen["L1"] = "L1";
    AlertSuffixesEngGen["L2"] = "L2";
    AlertSuffixesEngGen["R1"] = "R1";
    AlertSuffixesEngGen["R2"] = "R2";
})(AlertSuffixesEngGen || (AlertSuffixesEngGen = {}));

/**
 * Handles the common inhibit conditions on Boeing aircraft.
 */
class BoeingOpPhaseStateInhibitor {
    /**
     * Creates an instance of the B787OpPhaseStateInhibitor.
     * @param bus The event bus to use with this instance.
     * @param performanceData Used to read the min n1 values
     */
    constructor(bus, performanceData) {
        this.bus = bus;
        this.performanceData = performanceData;
        this.sub = this.bus.getSubscriber();
        this.casPublisher = this.bus.getPublisher();
        // Data sources:
        this.onGround = ConsumerSubject.create(this.sub.on('on_ground'), true);
        this.fuelCutoffEngL = ConsumerSubject.create(this.sub.on('fuel_system_valve_switch_1'), false); // 0 when fuel cut off
        this.fuelCutoffEngR = ConsumerSubject.create(this.sub.on('fuel_system_valve_switch_2'), false); // 0 when fuel cut off
        this.engineStartSelectorL = ConsumerSubject.create(this.sub.on('eng_starter_on_1'), false);
        this.engineStartSelectorR = ConsumerSubject.create(this.sub.on('eng_starter_on_2'), false);
        this.n1LPct = ConsumerSubject.create(this.sub.on('n1_1').whenChangedBy(1.0), 0);
        this.n1RPct = ConsumerSubject.create(this.sub.on('n1_2').whenChangedBy(1.0), 0);
        this.ias = ConsumerSubject.create(this.sub.on('ias').whenChangedBy(2.0), 0);
        this.radioAltitude = ConsumerSubject.create(this.sub.on('radio_alt'), 0);
        this.flightPhase = ConsumerSubject.create(this.sub.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        // Subjects for state that depend on stateful input:
        this.engineStartingL = Subject.create(false);
        this.engineStartingR = Subject.create(false);
        this.takingOff = Subject.create(false);
        // Helper subjects:
        this.iasAboveTakeoffPhaseThreshold = Subject.create(false);
        // State helper variable(s):
        this.takeoffPhaseStartTime = new Date().getTime();
        this.lastfuelCutoffL = false;
        this.lastfuelCutoffR = false;
        // B787InhibitStates.EngineShutdown:
        // On the ground, and both FUEL CONTROL switches in CUTOFF
        MappedSubject.create(([fuelCutoff1, fuelCutoff2, onGround]) => (fuelCutoff1 == false) && (fuelCutoff2 == false) && onGround, this.fuelCutoffEngL, this.fuelCutoffEngR, this.onGround).sub(newInhibitState => {
            this.casPublisher.pub(newInhibitState ? 'cas_activate_inhibit_state' : 'cas_deactivate_inhibit_state', BoeingInhibitStates.EngineStopped, true, false);
        }, true);
        // B787InhibitStates.EngineStarting
        // After -> Engine START selector to START -> Until -> Engine reaches idle RPM
        // We treat both sides differently, before combining the state of both engines into a single inhibit state
        this.engineStartSelectorL.sub(newPos => {
            if (newPos) {
                // Only catch the transition to START = 1
                this.engineStartingL.set(true);
            }
        }, true);
        MappedSubject.create(([fuelCutoffL, n1]) => {
            const fuelFlowCut = this.lastfuelCutoffL && !fuelCutoffL; // Detect only transition from fuel-on to fuel-off
            this.lastfuelCutoffL = fuelCutoffL;
            return fuelFlowCut || (n1 > this.performanceData.aircraftFlightModel.low_idle_n1 - BoeingOpPhaseStateInhibitor.n1ThresholdAcceptanceBuffer);
        }, this.fuelCutoffEngL, this.n1LPct).sub(exitCondition => {
            if (exitCondition) {
                // Reset L engine starting condition
                this.engineStartingL.set(false);
            }
        }, true);
        this.engineStartSelectorR.sub(newPos => {
            if (newPos) {
                // Only catch the transition to START = 1
                this.engineStartingR.set(true);
            }
        }, true);
        MappedSubject.create(([fuelCutoffR, n1]) => {
            const fuelFlowCut = this.lastfuelCutoffR && !fuelCutoffR; // Detect only transition from fuel-on to fuel-off
            this.lastfuelCutoffR = fuelCutoffR;
            return fuelFlowCut || (n1 > this.performanceData.aircraftFlightModel.low_idle_n1 - BoeingOpPhaseStateInhibitor.n1ThresholdAcceptanceBuffer);
        }, this.fuelCutoffEngR, this.n1RPct).sub(exitCondition => {
            if (exitCondition) {
                // Reset R engine starting condition
                this.engineStartingR.set(false);
            }
        }, true);
        MappedSubject.create(([startingL, startingR]) => startingL || startingR, this.engineStartingL, this.engineStartingR).sub(newInhibitState => {
            this.casPublisher.pub(newInhibitState ? 'cas_activate_inhibit_state' : 'cas_deactivate_inhibit_state', BoeingInhibitStates.EngineStarting, true, false);
        }, true);
        // B787InhibitStates.TakingOff
        // After -> 80 kts airspeed -> Until -> 400 RA or 20s, whichever is reached first Or <75 kts airpspeed (takeoff rejected)
        // Handle the takeoff-phase enter condition:
        this.ias.sub(v => this.iasAboveTakeoffPhaseThreshold.set(v > BoeingOpPhaseStateInhibitor.takeOffPhaseSpeedTrigger));
        this.iasAboveTakeoffPhaseThreshold.sub(v => {
            if (v) {
                // During slewing, we can come here without a takeoff being conducted, therefore add a RA condition:
                if (this.radioAltitude.get() < 20.0) {
                    this.takingOff.set(true);
                    this.takeoffPhaseStartTime = new Date().getTime();
                }
            }
        });
        // Handle the takeoff-phase exit conditions, we will come frequently here, so we dont need a subscription for the time expiration:
        MappedSubject.create(([ias, radioALt]) => this.takingOff.get() && (ias > 75) && (radioALt < 400) && (new Date().getTime() - this.takeoffPhaseStartTime < 20000), this.ias, this.radioAltitude).sub(exitWhenFalse => {
            if (exitWhenFalse == false) {
                this.takingOff.set(false);
            }
        }, true);
        this.takingOff.sub(newInhibitState => {
            this.casPublisher.pub(newInhibitState ? 'cas_activate_inhibit_state' : 'cas_deactivate_inhibit_state', BoeingInhibitStates.TakingOff, true, false);
        }, true);
        // B787InhibitStates.AllPriorCruiseFlightPhase
        // Allows to inhibit alerts prior the cruise flight phase.
        this.flightPhase.sub(newFlightPhase => {
            this.casPublisher.pub((newFlightPhase < FmsOperatingPhase.CRUISE) ? 'cas_activate_inhibit_state' : 'cas_deactivate_inhibit_state', BoeingInhibitStates.BeforeCruiseFlightPhases, true, false);
        }, true);
        // B787InhibitStates.CruiseAndDescendFlightPhase
        // Allows to inhibit alerts after cruise alt has been reached.
        this.flightPhase.sub(newFlightPhase => {
            this.casPublisher.pub((newFlightPhase >= FmsOperatingPhase.CRUISE) ? 'cas_activate_inhibit_state' : 'cas_deactivate_inhibit_state', BoeingInhibitStates.DuringAndAfterCruiseFlightPhases, true, false);
        }, true);
    }
}
BoeingOpPhaseStateInhibitor.takeOffPhaseSpeedTrigger = 80.0;
BoeingOpPhaseStateInhibitor.n1ThresholdAcceptanceBuffer = 1.0;

/** The CAS component. */
class CAS extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.recallIndicationRef = FSComponent.createRef();
        this.pageIndicationRef = FSComponent.createRef();
        this.activeAnnunciations = [];
        this.recallVisibilityTimer = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a;
        if (this.props.casPresentationController != undefined) {
            (_a = this.props.casPresentationController.displayedAnnunciations) === null || _a === void 0 ? void 0 : _a.sub((idx, type, item) => {
                if (Array.isArray(item)) {
                    // Insert into the specified index from the end of the array to keep
                    // the provided order.
                    for (let i = item.length - 1; i >= 0; i--) {
                        this.handleArrayEvent(idx, type, item[i]);
                    }
                }
                else {
                    this.handleArrayEvent(idx, type, item);
                }
            }, true);
            this.props.casPresentationController.hasMoreThanOnePage.sub(v => this.pageIndicationRef.instance.style.visibility = v ? 'visible' : 'hidden', true);
            this.props.casPresentationController.recallTriggered.sub(v => {
                if (v) {
                    this.recallIndicationRef.instance.style.visibility = 'visible';
                    this.recallVisibilityTimer.schedule(() => { this.recallIndicationRef.instance.style.visibility = 'hidden'; }, CAS.RECALL_DISPLAY_DURATION);
                }
            }, true);
            // Hide RECALL indication per default:
            this.recallIndicationRef.instance.style.visibility = 'hidden';
        }
        // TODO Remove testing code:
        // const publisher = this.props.bus.getPublisher<CasEvents>();
        // publisher.pub('cas_register_alert', { uuid: 'cd4eadb6-ab9e-11ed-0242ac120002', message: 'RED FLAG SUPER ALERT' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb086-ab9e-11ed-0242ac120002', message: 'BEWARE OF WARNING' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb1d0-ab9e-11ed-0242ac120002', message: 'CAUTION 2ND PRIO' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb36a-ab9e-11ed-0242ac120002', message: 'ADVISORY 3RD PRIO 1' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb64e-ab9e-11ed-0242ac120002', message: 'ADVISORY 3RD PRIO 2' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb784-ab9e-11ed-0242ac120002', message: 'MEMO1' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb8a6-ab9e-11ed-0242ac120002', message: 'MEMO IS SAFEOP ON 787' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb9e6-ab9e-11ed-0242ac120002', message: 'MEMO3' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4ebc20-ab9e-11ed-0242ac120002', message: 'MEMO4' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4ebd60-ab9e-11ed-0242ac120002', message: 'MEMO5' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb123-ab9e-11ed-0242ac120002', message: 'MEMO6' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb456-ab9e-11ed-0242ac120002', message: 'MEMO7' }, true);
        // publisher.pub('cas_register_alert', { uuid: 'cd4eb789-ab9e-11ed-0242ac120002', message: 'MEMO8' }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eadb6-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.Warning }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb086-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.Warning }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb1d0-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.Caution }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb36a-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.Advisory }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb64e-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.Advisory }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb784-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb8a6-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb9e6-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4ebc20-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4ebd60-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb123-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb456-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
        // publisher.pub('cas_activate_alert', { key: { uuid: 'cd4eb789-ab9e-11ed-0242ac120002' }, priority: AnnunciationType.SafeOp }, true);
    }
    /**
     * Handle a SubscribableArrayEventType on a per-item bases.
     * @param idx  The index of the message
     * @param type The type of event we're handling
     * @param item The individual item to manage.
     */
    handleArrayEvent(idx, type, item) {
        if (type == SubscribableArrayEventType.Cleared) {
            this.clearAnnunciations();
        }
        else {
            switch (type) {
                case SubscribableArrayEventType.Added:
                    if (item !== undefined) {
                        this.addAnnunciation(idx, item);
                    }
                    else {
                        console.error('Unable to handle CAS array event with undefined item.');
                    }
                    break;
                case SubscribableArrayEventType.Removed:
                    this.removeAnnunciation(idx);
                    break;
            }
        }
    }
    /**
     * Add an annunciation to the active list.
     * @param idx The index of the annunciations array for the annunciation.
     * @param item The annunciation configuration to add
     */
    addAnnunciation(idx, item) {
        const annunciationNodeRef = FSComponent.createRef();
        FSComponent.render(FSComponent.buildComponent(CASAnnunciation, { ref: annunciationNodeRef, casMessage: item }), this.containerRef.instance);
        this.activeAnnunciations.splice(idx, 0, annunciationNodeRef);
        this.rerenderNodes();
    }
    /**
     * Remove an annunciation from the active list if present.
     * @param idx The index of the annunciations array for the annunciation.
     */
    removeAnnunciation(idx) {
        const nodeRef = this.activeAnnunciations[idx];
        nodeRef === null || nodeRef === void 0 ? void 0 : nodeRef.instance.destroy();
        this.activeAnnunciations.splice(idx, 1);
        this.rerenderNodes();
    }
    /**
     * Clear the annunciation display.
     */
    clearAnnunciations() {
        this.activeAnnunciations.forEach(nodeRef => {
            nodeRef === null || nodeRef === void 0 ? void 0 : nodeRef.instance.destroy();
        });
        this.activeAnnunciations.splice(0);
        this.rerenderNodes();
    }
    /**
     * Rerenders the annunciations in order.
     */
    rerenderNodes() {
        this.containerRef.instance.innerHTML = '';
        const fragment = document.createDocumentFragment();
        this.activeAnnunciations.forEach(nodeRef => {
            fragment.appendChild(nodeRef.instance.getDomNode());
        });
        this.containerRef.instance.appendChild(fragment);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent("div", { class: 'cas-alerts-container', ref: this.containerRef }),
            FSComponent.buildComponent("div", { class: "cas-helper left-aligned", ref: this.recallIndicationRef }, "RECALL"),
            FSComponent.buildComponent("div", { class: "cas-helper right-aligned", ref: this.pageIndicationRef },
                "PG ", (_a = this.props.casPresentationController) === null || _a === void 0 ? void 0 :
                _a.displayedPage)));
    }
}
CAS.RECALL_DISPLAY_DURATION = 1000; // milliseconds
/**
 * The CAS Annunciation component.
 */
class CASAnnunciation extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.containerRef = FSComponent.createRef();
        this.annunciationRef = FSComponent.createRef();
        this.acknowledged = false;
        // remember time when annunciation was created
        this.timeCreated = new Date();
    }
    /**
     * Sets the acknowledged state on the annunciation.
     */
    acknowledge() {
        this.acknowledged = true;
        this.annunciationRef.instance.classList.remove('cas-blink');
    }
    /**
     * Gets the acknowledged state on the annunciation.
     * @returns True if acknowledged, false otherwise.
     */
    isAcknowledged() {
        return this.acknowledged;
    }
    /**
     * Gets the time when the annunciation was created.
     * @returns The time when the annunciation was created.
     */
    getTimeCreated() {
        return this.timeCreated.getTime();
    }
    /**
     * Removes the node from the DOM.
     */
    removeDomNode() {
        this.containerRef.instance.remove();
    }
    /**
     * Gets the DOM node of this annunciation.
     * @returns The DOM node.
     */
    getDomNode() {
        return this.containerRef.instance;
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.removeDomNode();
    }
    /**
     * Gets the CSS class for the annunciation based on the type.
     * @param type The type of annunciation.
     * @returns The CSS class for the annunciation.
     */
    getAnnunciationStyle(type) {
        switch (type) {
            case AnnunciationType.Warning:
                return 'cas-warning';
            case AnnunciationType.Caution:
                return 'cas-caution';
            case AnnunciationType.Advisory:
                return 'cas-advisory';
            case AnnunciationType.SafeOp:
                return 'cas-memo';
            default:
                return 'cas-advisory';
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: "cas-annunciation", ref: this.containerRef },
            FSComponent.buildComponent("div", { ref: this.annunciationRef, class: this.getAnnunciationStyle(this.props.casMessage.priority) }, this.props.casMessage.message + (this.props.casMessage.suffixes !== undefined ? ' ' + ((_a = this.props.casMessage.suffixes) === null || _a === void 0 ? void 0 : _a.join('-')) : ''))));
    }
}

/**
 *
 */
class CasPresentationController {
    /**
     * Creates an instance of CasPresentationController.
     * @param bus The event bus to use with this instance.
     * @param casSystem The instruments CAS system.
     * @param cancRecallEventName Name of the H event, which represents the can/rcl-button.
     */
    constructor(bus, casSystem, cancRecallEventName) {
        var _a;
        this.bus = bus;
        this.casSystem = casSystem;
        this.cancRecallEventName = cancRecallEventName;
        this.hEventSubscriber = this.bus.getSubscriber();
        this.activeAnnunciations = [];
        this.pages = Subject.create(1);
        this.currentPage = 0;
        this.canceledActive = false;
        this.cancRclDebounceTimer = new DebounceTimer();
        this.casPublisher = this.bus.getPublisher();
        // Public subjects:
        this.displayedAnnunciations = ArraySubject.create();
        this.hasMoreThanOnePage = Subject.create(false);
        this.displayedPage = Subject.create(1);
        this.recallTriggered = Subject.create(false);
        this.hEventSubscriber.on('hEvent').handle((e) => this.handleHEvent(e));
        (_a = casSystem.casActiveMessageSubject) === null || _a === void 0 ? void 0 : _a.sub((idx, type, item) => {
            if (Array.isArray(item)) {
                // Insert into the specified index from the end of the array to keep
                // the provided order.
                for (let i = item.length - 1; i >= 0; i--) {
                    this.handleArrayEvent(idx, type, item[i]);
                }
            }
            else {
                this.handleArrayEvent(idx, type, item);
            }
        }, true);
        this.pages.sub(v => this.hasMoreThanOnePage.set(v > 1), true);
    }
    /**
     * Handle a SubscribableArrayEventType on a per-item bases.
     * @param idx  The index of the message
     * @param type The type of event we're handling
     * @param item The individual item to manage.
     */
    handleArrayEvent(idx, type, item) {
        if (type == SubscribableArrayEventType.Cleared) {
            this.clearAnnunciations();
        }
        else if (item === undefined) {
            console.error('Unable to handle CAS array event with undefined item.');
        }
        else {
            switch (type) {
                case SubscribableArrayEventType.Added:
                    this.addAnnunciation(idx, item);
                    break;
                case SubscribableArrayEventType.Removed:
                    this.removeAnnunciation(idx);
                    break;
            }
        }
    }
    /**
     * Add an annunciation to the active list.
     * @param idx The index of the annunciations array for the annunciation.
     * @param item The annunciation configuration to add
     */
    addAnnunciation(idx, item) {
        this.activeAnnunciations.splice(idx, 0, item);
        this.updateDisplayedAnnunciations();
    }
    /**
     * Remove an annunciation from the active list if present.
     * @param idx The index of the annunciations array for the annunciation.
     */
    removeAnnunciation(idx) {
        this.activeAnnunciations.splice(idx, 1);
        this.updateDisplayedAnnunciations();
    }
    /**
     * Clear the annunciation display.
     */
    clearAnnunciations() {
        this.activeAnnunciations.splice(0);
        this.updateDisplayedAnnunciations();
    }
    /**
     * Rerenders the annunciations in order.
     */
    updateDisplayedAnnunciations() {
        const sortFn = (a, b) => {
            if (a.priority < b.priority) {
                return -1;
            }
            else if (a.priority > b.priority) {
                return 1;
            }
            return a.lastActive < b.lastActive ? 1 : -1;
        };
        // This array collects the 11 displayed rows:
        const visibleAnnunciationsList = new Array();
        // Create ordered array with all messages:
        const orderedActiveAnnunciations = [...this.activeAnnunciations.values()].sort(sortFn);
        // Warnings shall be displayed on top on all pages:
        const activeWarnings = this.activeAnnunciations.filter(annunciation => annunciation.priority === AnnunciationType.Warning);
        const numberOfWarnings = activeWarnings.length;
        const numberOfLinesBelowWarnings = 11 - numberOfWarnings;
        if (numberOfWarnings < 11) {
            this.pages.set(Math.ceil((orderedActiveAnnunciations.length - numberOfWarnings) / numberOfLinesBelowWarnings));
        }
        else {
            // If more than 10 warnings exist, scrolling pages shall be inhibited
            // (because displaying all warnings on top of every page is not possible anymore).
            this.pages.set(1);
            this.currentPage = 0;
            this.displayedPage.set(1);
        }
        visibleAnnunciationsList.push(...activeWarnings);
        // Add the CAUTIONS; ADVISORIES, MEMOs below the warnings:
        let annunciationIndex = numberOfWarnings + this.currentPage * numberOfLinesBelowWarnings;
        for (let lineIndex = numberOfWarnings; lineIndex < 11; lineIndex++) {
            // List CAUTIONS and ADVISORIES from top and stack up memos from the bottom:
            if (annunciationIndex < orderedActiveAnnunciations.length && orderedActiveAnnunciations[annunciationIndex].priority < AnnunciationType.SafeOp) {
                // The current message from the orderedActiveAnnunciations array belongs to the top, so add it:
                visibleAnnunciationsList.push(orderedActiveAnnunciations[annunciationIndex]);
                annunciationIndex++;
            }
            else {
                // We found a memo. The number of remaining (memo) messages determines whether we need placeholder lines:
                const remainingMemos = orderedActiveAnnunciations.length - annunciationIndex;
                if (lineIndex < 11 - remainingMemos || annunciationIndex >= orderedActiveAnnunciations.length) {
                    // Memos won't stack up to this line, so add an empty placeholder:
                    visibleAnnunciationsList.push({ uuid: '', message: '', priority: AnnunciationType.SafeOp, acknowledged: false, inhibited: false, suppressed: false, lastActive: 0 });
                }
                else {
                    // we found the line for this memo message, so add it:
                    visibleAnnunciationsList.push(orderedActiveAnnunciations[annunciationIndex]);
                    annunciationIndex++;
                }
            }
        }
        this.displayedAnnunciations.clear();
        this.displayedAnnunciations.insertRange(0, visibleAnnunciationsList);
    }
    /**
     * This handler receives H events and handles the CANC/RCL button:
     * @param event The H event, which was received
     */
    handleHEvent(event) {
        //console.log(event);
        if (event === this.cancRecallEventName) {
            this.cancRclDebounceTimer.schedule(() => {
                //console.log('can rcl detected');
                if (this.canceledActive === false) {
                    if (this.currentPage < this.pages.get() - 1) {
                        // Scroll to the next page, if there are more than one and if the last one is not yet being displayed:
                        this.currentPage++;
                        this.updateDisplayedAnnunciations();
                    }
                    else if (this.currentPage == this.pages.get() - 1) {
                        // Call for suppressing (canceling) once on the last page:
                        this.casPublisher.pub('cas_suppress_priority', AnnunciationType.Caution);
                        this.casPublisher.pub('cas_suppress_priority', AnnunciationType.Advisory);
                        this.canceledActive = true;
                        this.recallTriggered.set(false);
                        // Jump back to the first page already:
                        this.currentPage = 0;
                    }
                }
                else {
                    // Call for unsuppressing (recall):
                    this.casPublisher.pub('cas_unsuppress_priority', AnnunciationType.Caution);
                    this.casPublisher.pub('cas_unsuppress_priority', AnnunciationType.Advisory);
                    this.canceledActive = false;
                    this.recallTriggered.set(true);
                }
                this.displayedPage.set(this.currentPage + 1);
                this.updateDisplayedAnnunciations();
            }, 300);
        }
    }
}

var EngineCrewAlertIDs;
(function (EngineCrewAlertIDs) {
    EngineCrewAlertIDs["ApuCoolDown"] = "apu-cool-down";
    EngineCrewAlertIDs["ApuRunning"] = "apu-running";
    EngineCrewAlertIDs["EngFail"] = "eng-fail";
    EngineCrewAlertIDs["EngRev"] = "eng-rev";
    EngineCrewAlertIDs["EngShutdownAll"] = "eng-shutdown-all";
    EngineCrewAlertIDs["EngShutdownNotAll"] = "eng-shutdown-not-all";
    EngineCrewAlertIDs["EngOilPress"] = "eng-oil-press";
    EngineCrewAlertIDs["EngOilTemp"] = "eng-oil-temp";
})(EngineCrewAlertIDs || (EngineCrewAlertIDs = {}));
/**
 * Updates the CAS for the engine related alerts.
 */
class EngineCrewAlerts {
    /**
     * Creates an instance of EngineCrewAlerts.
     * @param bus The event bus to use with this instance.
     * @param numberOfEngines Engine count
     * @param performanceData Source for flight model data
     */
    constructor(bus, numberOfEngines, performanceData) {
        this.bus = bus;
        this.numberOfEngines = numberOfEngines;
        this.performanceData = performanceData;
        this.failedEngingeN1Threshold = this.performanceData.aircraftFlightModel.low_idle_n1 - 1.5;
        this.sub = this.bus.getSubscriber();
        // Data sources - per engine, based on engine count:
        this.n1PctArray = Array();
        this.fuelControlSwitchArray = Array();
        this.oilPressureArray = Array();
        this.oilTempArray = Array();
        this.isApuCoolingDown = Subject.create(false);
        this.delayedInit = new DebounceTimer();
        this.apuCooldownTimer = new DebounceTimer();
        // Prepare a helper array that matches the number of engines:
        this.engineSuffixes = (numberOfEngines > 2) ? [...Array(numberOfEngines).keys()].map(i => (i + 1).toString()) : [AlertSuffixes.L, AlertSuffixes.R];
        // Define the data sources:
        this.apuPct = ConsumerSubject.create(this.sub.on('apu_pct').whenChangedBy(1), 0);
        this.apuSwitch = ConsumerSubject.create(this.sub.on('apu_switch'), false);
        this.onGround = ConsumerValue.create(this.sub.on('on_ground'), true);
        this.engineSuffixes.forEach((_, index) => {
            this.n1PctArray[index] = ConsumerSubject.create(this.sub.on(`n1_${index + 1}`).whenChangedBy(1), 0);
            this.fuelControlSwitchArray[index] = ConsumerSubject.create(this.sub.on(`eng_fuel_flow_switch_${index + 1}`), false);
            this.oilPressureArray[index] = ConsumerSubject.create(this.sub.on(`oil_press_${index + 1}`).whenChangedBy(2.0), 0);
            this.oilTempArray[index] = ConsumerSubject.create(this.sub.on(`oil_temp_${index + 1}`).whenChangedBy(2), 0);
        });
        // Register the alerts:
        const cas = this.bus.getPublisher();
        const engStoppedAndStarting = [BoeingInhibitStates.EngineStopped, BoeingInhibitStates.EngineStarting]; // For cautions
        const engStartingAndTakingoff = [BoeingInhibitStates.EngineStarting, BoeingInhibitStates.TakingOff]; // For advisories
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.ApuCoolDown, message: 'APU COOLDOWN', inhibitedBy: [''], debounceTime: 1000 }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.ApuRunning, message: 'APU RUNNING', inhibitedBy: [''], debounceTime: 2000 }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.EngFail, message: 'ENG FAIL', inhibitedBy: [...engStoppedAndStarting], suffixes: this.engineSuffixes, debounceTime: 5000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.EngRev, message: 'ENG REV COMMANDED', inhibitedBy: [...engStoppedAndStarting], suffixes: this.engineSuffixes }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.EngShutdownAll, message: 'ENG SHUTDOWN', inhibitedBy: [''] }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.EngShutdownNotAll, message: 'ENG SHUTDOWN', inhibitedBy: [''], suffixes: this.engineSuffixes }, true, false); // Caution -> but not inhibited
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.EngOilPress, message: 'ENG OIL PRESS', inhibitedBy: [...engStoppedAndStarting], suffixes: this.engineSuffixes, debounceTime: 2000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: EngineCrewAlertIDs.EngOilTemp, message: 'ENG OIL TEMP', inhibitedBy: [...engStartingAndTakingoff], suffixes: this.engineSuffixes, debounceTime: 4000 }, true, false); // Advisory
        // Delay the initialization by 10 seconds to prevent alerts while the engine parameter stabilize:
        this.delayedInit.schedule(() => this.initAlerts(), 10000);
    }
    /**
     * Initalizes the basic aircraft alerts.
     */
    initAlerts() {
        // APU COOLDOWN is displayed for two minutes after turning off the APU:
        this.apuSwitch.sub(v => {
            if (v == false) {
                // APU was just switched off:
                this.isApuCoolingDown.set(true);
                this.apuCooldownTimer.schedule(() => {
                    this.isApuCoolingDown.set(false);
                }, 120000);
            }
            else {
                // Clear timer and alert in case the APU was started (again):
                this.isApuCoolingDown.set(false);
                this.apuCooldownTimer.clear();
            }
        }, false); // apuSwitch is false initially and we dont want to trigger the alert right away
        CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.ApuCoolDown, AnnunciationType.SafeOp)
            .bind(this.isApuCoolingDown, v => v);
        // APU RUNNING is shown above 95% rpm:
        CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.ApuRunning, AnnunciationType.SafeOp)
            .bind(this.apuPct, v => v > EngineCrewAlerts.apuRunningThreshold);
        // ENG SHUTDOWN ALL/<suffixed eng idx>:
        // This alert displays the suffix if not all engines are affected and nothing if all engines are affected.
        // Therefore the alert for all engines is made separately, while the suffixed alerts for 
        CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.EngShutdownAll, AnnunciationType.Caution)
            .bind(MappedSubject.create(...this.fuelControlSwitchArray), switchStates => switchStates.every(state => state === false));
        // The remaining alerts are suffixed per engine:
        this.engineSuffixes.forEach((suffix, index) => {
            // ENG SHUTDOWN <suffixed eng idx>
            // This alert is shown if not all engines are shut down:
            CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.EngShutdownNotAll, AnnunciationType.Caution, suffix)
                .bind(MappedSubject.create(...this.fuelControlSwitchArray), switchStates => switchStates.some(state => state === true) && (switchStates[index] === false));
            // ENG FAIL <suffixed eng idx> is shown below idle thrust:
            CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.EngFail, AnnunciationType.Caution, suffix)
                .bind(this.n1PctArray[index], v => v < this.failedEngingeN1Threshold);
            // ENG REV COMMANDED <suffixed eng idx>:
            CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.EngRev, AnnunciationType.Caution, suffix)
                .bindUpdate(() => {
                return (SimVar.GetSimVarValue(`B:ENGINE_Throttle_Reverser_${index + 1}`, SimVarValueType.Number) > EngineCrewAlerts.revThrustPositionThreshold)
                    && (this.onGround.get() == false);
            });
            // ENG OIL PRESS <suffixed eng idx>:
            CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.EngOilPress, AnnunciationType.Caution, suffix)
                .bind(this.oilPressureArray[index], v => v < EngineCrewAlerts.oilPressureCautionlimit);
            // ENG OIL TEMP <suffixed eng idx>:
            CasAlertTransporter.create(this.bus, EngineCrewAlertIDs.EngOilTemp, AnnunciationType.Advisory, suffix)
                .bind(this.oilTempArray[index], v => {
                return UnitType.FAHRENHEIT.convertTo(v, UnitType.CELSIUS) < EngineCrewAlerts.oilTemperatureCautionlimit;
            });
        });
    }
}
EngineCrewAlerts.apuRunningThreshold = 95.0;
EngineCrewAlerts.oilPressureCautionlimit = 22.0;
EngineCrewAlerts.oilTemperatureCautionlimit = 42.0;
EngineCrewAlerts.revThrustPositionThreshold = 0.5;

var FlightControlAlertIDs;
(function (FlightControlAlertIDs) {
    FlightControlAlertIDs["PitchDownAuthority"] = "pitch-down-authority";
    FlightControlAlertIDs["PitchUpAuthority"] = "pitch-up-authority";
    FlightControlAlertIDs["RollLeftAuthority"] = "roll-left-authority";
    FlightControlAlertIDs["RollRightAuthority"] = "roll-right-authority";
    FlightControlAlertIDs["RollYawAsymetry"] = "roll-yaw-asymetry";
    FlightControlAlertIDs["SpeedBrakeExtended"] = "speedbrake-extended";
    FlightControlAlertIDs["SpeedbrakeArmed"] = "speedbrake-armed";
})(FlightControlAlertIDs || (FlightControlAlertIDs = {}));
/**
 * Updates the CAS for the flight control related alerts.
 */
class FlightControlAlerts {
    /**
     * Creates an instance of FlightControlAlerts.
     * @param bus The event bus to use with this instance.
     * @param numberOfEngines Engine count
     * @param speedData the type specific speed data source.
     */
    constructor(bus, numberOfEngines, speedData) {
        this.bus = bus;
        this.numberOfEngines = numberOfEngines;
        this.sub = this.bus.getSubscriber();
        // Data sources:
        this.pitchAttitude = ConsumerSubject.create(this.sub.on('pitch_deg').whenChangedBy(1), 0);
        this.elevatorTrimPerc = ConsumerSubject.create(this.sub.on('elevator_trim_pct').whenChangedBy(3), 0);
        this.ias = ConsumerSubject.create(this.sub.on('ias').whenChangedBy(2), 0);
        this.spoilersPerc = ConsumerSubject.create(this.sub.on('spoilers_without_spoilerons_left_percent').whenChangedBy(2), 0);
        this.flapsHandlePos = ConsumerSubject.create(this.sub.on('flaps_handle_index'), 0);
        this.radioAltitude = ConsumerSubject.create(this.sub.on('radio_alt').whenChangedBy(2), 0);
        // Data sources - per engine, based on engine count:
        this.n1PctArray = Array();
        this.throttleLeverPosArray = Array();
        this.delayedInit = new DebounceTimer();
        // Prepare a helper array that matches the number of engines:
        this.engineSuffixes = (numberOfEngines > 2) ? [...Array(numberOfEngines).keys()].map(i => (i + 1).toString()) : [AlertSuffixes.L, AlertSuffixes.R];
        this.engineSuffixes.forEach((_, index) => {
            this.n1PctArray[index] = ConsumerSubject.create(this.sub.on(`n1_${index + 1}`).whenChangedBy(1), 0);
            this.throttleLeverPosArray[index] = ConsumerSubject.create(this.sub.on(`v_throttle_lever_pos_${index + 1}`), 0);
        });
        // Register the cas alerts:
        const cas = this.bus.getPublisher();
        this.excessiveOverspeed = speedData.getVmo() + FlightControlAlerts.excessiveOverspeed;
        const engStoppedAndStarting = [BoeingInhibitStates.EngineStopped, BoeingInhibitStates.EngineStarting]; // For cautions
        cas.pub('cas_register_alert', { uuid: FlightControlAlertIDs.PitchDownAuthority, message: 'PITCH DOWN AUTHORITY', inhibitedBy: [...engStoppedAndStarting], debounceTime: 1000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: FlightControlAlertIDs.PitchUpAuthority, message: 'PITCH UP AUTHORITY', inhibitedBy: [...engStoppedAndStarting], debounceTime: 5000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: FlightControlAlertIDs.RollLeftAuthority, message: 'ROLL LEFT AUTHORITY', inhibitedBy: [...engStoppedAndStarting], debounceTime: 5000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: FlightControlAlertIDs.RollRightAuthority, message: 'ROLL RIGHT AUTHORITY', inhibitedBy: [...engStoppedAndStarting], debounceTime: 5000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: FlightControlAlertIDs.RollYawAsymetry, message: 'ROLL/YAW ASYMMETRY', inhibitedBy: [...engStoppedAndStarting], debounceTime: 2000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: FlightControlAlertIDs.SpeedBrakeExtended, message: 'SPEEDBRAKE EXTENDED', inhibitedBy: [...engStoppedAndStarting], debounceTime: 2000 }, true, false); // Caution
        cas.pub('cas_register_alert', { uuid: FlightControlAlertIDs.SpeedbrakeArmed, message: 'SPEEDBRAKES ARMED', inhibitedBy: [''], debounceTime: 2000 }, true, false); // Memo
        // Delay the initialization by 8 seconds to prevent alerts while the sim stabilizes:
        this.delayedInit.schedule(() => this.initAlerts(), 8000);
    }
    /**
     * Initalizes the basic aircraft alerts.
     */
    initAlerts() {
        // PITCH DOWN AUTHORITY
        // Pitch down authority is restricted.
        // https://www.boeing.com/commercial/aeromagazine/aero_12/attack_story.html
        CasAlertTransporter.create(this.bus, FlightControlAlertIDs.PitchDownAuthority, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.pitchAttitude, this.elevatorTrimPerc), ([pitch, anuTrimPerc]) => {
            return (pitch * -1 > FlightControlAlerts.pitchUpsetUpperThreshold) && (anuTrimPerc > FlightControlAlerts.anuTrimThreshold);
        });
        // PITCH UP AUTHORITY
        // At airspeeds well above VMO/MMO, the ability to command a nose-up pitch rate with elevator may be reduced because of the
        // extreme aero-dynamic loads on the elevator.
        CasAlertTransporter.create(this.bus, FlightControlAlertIDs.PitchUpAuthority, AnnunciationType.Caution)
            .bind(this.ias, ias => ias > this.excessiveOverspeed);
        // ROLL LEFT AUTHORITY
        // AILERON POSITION deviates from the control bank axis  TODO -> subscribe when control axis available on bus
        // CasAlertTransporter.create(this.bus, FlightControlAlertIDs.RollLeftAuthority, AnnunciationType.Caution)
        //   .bind(
        //     MappedSubject.create(
        //       this.aileronLeftPerc,
        //       this.bankAxisControlInput
        //     ),
        //     rollAuthorityState => {
        //       const [aileronLeft, controlLeft] = rollAuthorityState;
        //       return (aileronLeft < -70.0) && (controlLeft > -20.0);    // Alert if -> aileron (due to fbw) close to the
        //                                                                 // full left endposition and the yoke centered
        //     }
        //   );
        // ROLL RIGHT AUTHORITY
        // AILERON POSITION deviates from the control bank axis  TODO -> subscribe when control axis available on bus
        // CasAlertTransporter.create(this.bus, FlightControlAlertIDs.RollRightAuthority, AnnunciationType.Caution)
        //   .bind(
        //     MappedSubject.create(
        //       this.aileronLeftPerc,
        //       this.bankAxisControlInput
        //     ),
        //     rollAuthorityState => {
        //       const [aileronLeft, controlLeft] = rollAuthorityState;
        //       return (aileronLeft > 70.0) && (controlLeft < 20.0);    // Alert if -> aileron (due to fbw) close to the
        //                                                               // full left endposition and the yoke centered
        //     }
        //   );
        // ROLL/YAW ASYMMETRY
        // An airplane roll or yaw asymmetry occurs.
        CasAlertTransporter.create(this.bus, FlightControlAlertIDs.RollYawAsymetry, AnnunciationType.Caution)
            .bind(MappedSubject.create(...this.n1PctArray), thrustState => {
            let thrustL = 0;
            let thrustR = 0;
            switch (this.numberOfEngines) {
                case 2:
                    thrustL = thrustState[0];
                    thrustR = thrustState[1];
                    break;
                case 3: // There are Boeing trijets!
                    thrustL = thrustState[0];
                    thrustR = thrustState[2];
                    break;
                case 4:
                    thrustL = (thrustState[0] + thrustState[1]) / 2.0;
                    thrustR = (thrustState[2] + thrustState[3]) / 2.0;
                    break;
            }
            return Math.abs(thrustL - thrustR) > FlightControlAlerts.tolerableThrustAsymmetry;
        });
        // SPEEDBRAKE EXTENDED
        // The speedbrakes are extended and one or more of these occur:
        // - The radio altitude is between 15 and 800 feet
        // - The flap lever is in a landing setting
        // - A thrust lever is not at idle
        CasAlertTransporter.create(this.bus, FlightControlAlertIDs.SpeedBrakeExtended, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.spoilersPerc, this.radioAltitude, this.flapsHandlePos, ...this.throttleLeverPosArray), airbrakeState => {
            const [brakesExtended, ra, flapsPos] = airbrakeState;
            const throttleLevers = airbrakeState.slice(3);
            return (brakesExtended > FlightControlAlerts.spoilerExtendedThreshold) &&
                (((15 < ra) && (ra < 800))
                    || (flapsPos >= FlightControlAlerts.lowestFlapsLandingPos)
                    || throttleLevers.some(pos => pos > FlightControlAlerts.throttleIdleThreshold));
        });
        // SPEEDBRAKES ARMED
        // The speedbrakes are armed.
        CasAlertTransporter.create(this.bus, FlightControlAlertIDs.SpeedbrakeArmed, AnnunciationType.SafeOp)
            .bindUpdate(() => SimVar.GetSimVarValue('SPOILERS ARMED', SimVarValueType.Bool));
    }
}
FlightControlAlerts.pitchUpsetUpperThreshold = 25.0;
FlightControlAlerts.anuTrimThreshold = 50.0;
FlightControlAlerts.tolerableThrustAsymmetry = 15.0;
FlightControlAlerts.spoilerExtendedThreshold = 3.0;
FlightControlAlerts.lowestFlapsLandingPos = 7; // -> pos 20
FlightControlAlerts.throttleIdleThreshold = 0.05;
FlightControlAlerts.excessiveOverspeed = 40.0;

var GearAndBrakeCrewAlertIDs;
(function (GearAndBrakeCrewAlertIDs) {
    GearAndBrakeCrewAlertIDs["AutoBrake"] = "autobrake";
    GearAndBrakeCrewAlertIDs["AutoBrake1"] = "autobrake-1";
    GearAndBrakeCrewAlertIDs["AutoBrake2"] = "autobrake-2";
    GearAndBrakeCrewAlertIDs["AutoBrake3"] = "autobrake-3";
    GearAndBrakeCrewAlertIDs["AutoBrake4"] = "autobrake-4";
    GearAndBrakeCrewAlertIDs["AutoBrakeMAX"] = "autobrake-max";
    GearAndBrakeCrewAlertIDs["AutoBrakeRTO"] = "autobrake-rto";
    GearAndBrakeCrewAlertIDs["ParkingBrakeSet"] = "parking-brake-set";
    GearAndBrakeCrewAlertIDs["ConfigParkingBrake"] = "config-parking-brake";
    GearAndBrakeCrewAlertIDs["SteeringLockedOut"] = "steering-locked-out";
})(GearAndBrakeCrewAlertIDs || (GearAndBrakeCrewAlertIDs = {}));
/**
 * Updates the CAS for the gears and brakes related alerts.
 */
class GearAndBrakeCrewAlerts {
    /**
     * Creates an instance of GearAndBrakeCrewAlerts.
     * @param bus The event bus to use with this instance.
     * @param numberOfEngines Engine count
     */
    constructor(bus, numberOfEngines) {
        this.bus = bus;
        this.numberOfEngines = numberOfEngines;
        this.sub = this.bus.getSubscriber();
        // Data sources:
        this.autoBrakeSwitchPos = ConsumerSubject.create(this.sub.on('autobrake_switch_pos'), 0);
        this.autoBrakeActive = ConsumerSubject.create(this.sub.on('autobrake_active'), false);
        this.parkingBrakeSet = ConsumerSubject.create(this.sub.on('parking_brake_set'), false);
        this.spoilersExtendedPerc = ConsumerSubject.create(this.sub.on('spoilers_without_spoilerons_left_percent'), 0);
        this.ias = ConsumerSubject.create(this.sub.on('ias').whenChangedBy(5), 0);
        // Data sources - per engine, based on engine count:
        this.n1PctArray = Array();
        // State variable:
        this.pastEndOfActiveAutobrake = Subject.create(false);
        this.delayedInit = new DebounceTimer();
        // Prepare a helper array that matches the number of engines:
        this.engineSuffixes = (numberOfEngines > 2) ? [...Array(numberOfEngines).keys()].map(i => (i + 1).toString()) : [AlertSuffixes.L, AlertSuffixes.R];
        this.engineSuffixes.forEach((_, index) => {
            this.n1PctArray[index] = ConsumerSubject.create(this.sub.on(`n1_${index + 1}`).whenChangedBy(1), 0);
        });
        // Register the cas alerts:
        const cas = this.bus.getPublisher();
        const engStartingAndTakingoff = [BoeingInhibitStates.EngineStarting, BoeingInhibitStates.TakingOff]; // For advisories
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.AutoBrake, message: 'AUTOBRAKE', inhibitedBy: [...engStartingAndTakingoff], debounceTime: 1500 }, true, false); // Advisory
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.AutoBrake1, message: 'AUTOBRAKE 1', inhibitedBy: [''] }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.AutoBrake2, message: 'AUTOBRAKE 2', inhibitedBy: [''] }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.AutoBrake3, message: 'AUTOBRAKE 3', inhibitedBy: [''] }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.AutoBrake4, message: 'AUTOBRAKE 4', inhibitedBy: [''] }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.AutoBrakeMAX, message: 'AUTOBRAKE MAX', inhibitedBy: [''] }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.AutoBrakeRTO, message: 'AUTOBRAKE RTO', inhibitedBy: [''] }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.ParkingBrakeSet, message: 'PARKING BRAKE SET', inhibitedBy: [''] }, true, false); // Memo
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.ConfigParkingBrake, message: 'CONFIG PARKING BRAKE', inhibitedBy: [''] }, true, false); // Warning
        cas.pub('cas_register_alert', { uuid: GearAndBrakeCrewAlertIDs.SteeringLockedOut, message: 'STEERING LOCKED OUT', inhibitedBy: [''], debounceTime: 3000 }, true, false); // Memo
        // Delay the initialization by 10 seconds to prevent alerts while the engine parameter stabilize:
        this.delayedInit.schedule(() => this.initAlerts(), 6000);
    }
    /**
     * Initalizes the basic aircraft alerts.
     */
    initAlerts() {
        // AUTOBRAKE
        // This first one is tricky.
        // We have to check 2 conditions (spoilers and n1) while AUTOBRAKES ACTIVE = true
        // and whether the switch is set to OFF or DISARM only after autobrake was active.
        this.autoBrakeActive.sub(isActive => {
            this.updateSubscriptionStates();
            if (isActive == false) {
                // Catch the transition from active -> inactive autobrake
                this.pastEndOfActiveAutobrake.set(true);
            }
        }, false);
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.AutoBrake, AnnunciationType.Advisory)
            .bind(MappedSubject.create(this.autoBrakeActive, this.spoilersExtendedPerc, this.pastEndOfActiveAutobrake, this.autoBrakeSwitchPos, this.ias, ...this.n1PctArray), inputValues => {
            const [autobrakeActive, spoilers, pastAutobrake, autobrakeSwitch, ias] = inputValues;
            const n1Array = inputValues.slice(5);
            // While autobrake is active, the pilot should not apply thrust or manually stow the spoilers.
            // Throw an alert if he does:
            const autobrakeInterupted = autobrakeActive
                && (n1Array.some(n1 => n1 > GearAndBrakeCrewAlerts.n1AboveIdleThresholdPerc) ||
                    (spoilers < GearAndBrakeCrewAlerts.spoilerStowedThreshold));
            // Only after an active autobrake phase, setting the switch to OFF or DISARM should also trigger the alert:
            const switchPositionEndCondition = pastAutobrake && (autobrakeSwitch === GearAndBrakeCrewAlerts.autobrakeSwitchPosOffDisarmed);
            return (autobrakeInterupted || switchPositionEndCondition) && (ias > GearAndBrakeCrewAlerts.minSpeedForAutobrakeAlert);
        });
        // Autobrake level 1 is selected.
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.AutoBrake1, AnnunciationType.SafeOp)
            .bind(this.autoBrakeSwitchPos, newSwitchPos => newSwitchPos == GearAndBrakeCrewAlerts.autobrakeSwitchPos1);
        // Autobrake level 2 is selected.
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.AutoBrake2, AnnunciationType.SafeOp)
            .bind(this.autoBrakeSwitchPos, newSwitchPos => newSwitchPos == GearAndBrakeCrewAlerts.autobrakeSwitchPos2);
        // Autobrake level 3 is selected.
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.AutoBrake3, AnnunciationType.SafeOp)
            .bind(this.autoBrakeSwitchPos, newSwitchPos => newSwitchPos == GearAndBrakeCrewAlerts.autobrakeSwitchPos3);
        // Autobrake level 4 is selected.
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.AutoBrake4, AnnunciationType.SafeOp)
            .bind(this.autoBrakeSwitchPos, newSwitchPos => newSwitchPos == GearAndBrakeCrewAlerts.autobrakeSwitchPos4);
        // Autobrake level MAX is selected.
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.AutoBrakeMAX, AnnunciationType.SafeOp)
            .bind(this.autoBrakeSwitchPos, newSwitchPos => newSwitchPos == GearAndBrakeCrewAlerts.autobrakeSwitchPosMax);
        // Autobrake level RTO is selected.
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.AutoBrakeRTO, AnnunciationType.SafeOp)
            .bind(this.autoBrakeSwitchPos, newSwitchPos => newSwitchPos == GearAndBrakeCrewAlerts.autobrakeSwitchPosRTO);
        // PARKING BRAKE SET
        // Parking brake set
        this.parkingBrakeSet.sub(() => {
            this.updateSubscriptionStates();
        }, true);
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.ParkingBrakeSet, AnnunciationType.SafeOp)
            .bind(MappedSubject.create(this.parkingBrakeSet, ...this.n1PctArray), inputValues => {
            const brakeSet = inputValues[0];
            const n1Array = inputValues.slice(1);
            return brakeSet && n1Array.every(n1 => n1 < GearAndBrakeCrewAlerts.parkingBrakeTakeoffWarningThreshold);
        });
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.ConfigParkingBrake, AnnunciationType.Warning)
            .bind(MappedSubject.create(this.parkingBrakeSet, ...this.n1PctArray), inputValues => {
            const brakeSet = inputValues[0];
            const n1Array = inputValues.slice(1);
            return brakeSet && n1Array.some(n1 => n1 >= GearAndBrakeCrewAlerts.parkingBrakeTakeoffWarningThreshold);
        });
        // STEERING LOCKED OUT
        // Pushback tug connected
        CasAlertTransporter.create(this.bus, GearAndBrakeCrewAlertIDs.SteeringLockedOut, AnnunciationType.SafeOp)
            .bindUpdate(() => SimVar.GetSimVarValue('PUSHBACK ATTACHED', SimVarValueType.Bool));
    }
    /**
     * Updates the paused state of the n1L and n1R subjects:
     */
    updateSubscriptionStates() {
        if (this.parkingBrakeSet.get() || this.autoBrakeActive.get()) {
            this.n1PctArray.forEach(n1Consumer => n1Consumer.resume());
        }
        else {
            this.n1PctArray.forEach(n1Consumer => n1Consumer.pause());
        }
        if (this.autoBrakeActive.get()) {
            this.spoilersExtendedPerc.resume();
        }
        else {
            this.spoilersExtendedPerc.pause();
        }
    }
}
GearAndBrakeCrewAlerts.autobrakeSwitchPosRTO = 0;
GearAndBrakeCrewAlerts.autobrakeSwitchPosOffDisarmed = 1;
GearAndBrakeCrewAlerts.autobrakeSwitchPos1 = 2;
GearAndBrakeCrewAlerts.autobrakeSwitchPos2 = 3;
GearAndBrakeCrewAlerts.autobrakeSwitchPos3 = 4;
GearAndBrakeCrewAlerts.autobrakeSwitchPos4 = 5;
GearAndBrakeCrewAlerts.autobrakeSwitchPosMax = 6;
GearAndBrakeCrewAlerts.n1AboveIdleThresholdPerc = 25;
GearAndBrakeCrewAlerts.spoilerStowedThreshold = 0.05;
GearAndBrakeCrewAlerts.minSpeedForAutobrakeAlert = 50;
GearAndBrakeCrewAlerts.parkingBrakeTakeoffWarningThreshold = 80;

/**
 * Boeing aural alert IDs.
 */
var BoeingAuralAlertIds;
(function (BoeingAuralAlertIds) {
    // TODO Modify as needed, these are copied from the g3000
    BoeingAuralAlertIds["TawsRtc"] = "boeing-taws-rtc";
    BoeingAuralAlertIds["TawsIti"] = "boeing-taws-iti";
    BoeingAuralAlertIds["TawsRoc"] = "boeing-taws-roc";
    BoeingAuralAlertIds["TawsIoi"] = "boeing-taws-ioi";
    BoeingAuralAlertIds["TawsEdr"] = "boeing-taws-edr";
    BoeingAuralAlertIds["TawsEcr"] = "boeing-taws-ecr";
    BoeingAuralAlertIds["AutopilotDisconnect"] = "boeing-autopilot-disconnect";
    BoeingAuralAlertIds["AutopilotDisengage"] = "boeing-autopilot-disengage";
    BoeingAuralAlertIds["LandingGear"] = "boeing-landing-gear";
    BoeingAuralAlertIds["Minimums"] = "boeing-minimums";
    BoeingAuralAlertIds["CabinAltitude"] = "boeing-cabin-altitude";
    BoeingAuralAlertIds["CabinDeltaPressure"] = "boeing-cabin-delta-pressure";
    BoeingAuralAlertIds["MasterWarning"] = "boeing-master-warning";
    BoeingAuralAlertIds["TcasRA"] = "boeing-tcas-ra";
    BoeingAuralAlertIds["AutothrottleDisconnect"] = "boeing-autothrottle-disconnect";
    BoeingAuralAlertIds["AutothrottleDisengage"] = "boeing-autothrottle-disengage";
    BoeingAuralAlertIds["PfdAlert"] = "boeing-pfd-alert";
    BoeingAuralAlertIds["MasterCaution"] = "boeing-master-caution";
    BoeingAuralAlertIds["TouchdownCallout"] = "boeing-touchdown-callout";
    BoeingAuralAlertIds["TcasTA"] = "boeing-tcas-ta";
    BoeingAuralAlertIds["AltitudeAlert"] = "boeing-altitude-alert";
    BoeingAuralAlertIds["VerticalTrack"] = "boeing-vertical-track";
})(BoeingAuralAlertIds || (BoeingAuralAlertIds = {}));
/**
 * A utility class for working with Boeing aural alerts.
 */
class BoeingAuralAlertUtils {
}
/** The name of the primary Boeing aural alert queue. */
BoeingAuralAlertUtils.PRIMARY_QUEUE = 'boeing-aural-primary';
/** A map from Boeing aural alert IDs to their default priorities. */
BoeingAuralAlertUtils.PRIORITIES = {
    // TODO Modify as needed, these are copied from the g3000
    [BoeingAuralAlertIds.TawsRtc]: -10,
    [BoeingAuralAlertIds.TawsIti]: -10,
    [BoeingAuralAlertIds.TawsRoc]: -10,
    [BoeingAuralAlertIds.TawsIoi]: -10,
    [BoeingAuralAlertIds.TawsEdr]: -10,
    [BoeingAuralAlertIds.TawsEcr]: -10,
    [BoeingAuralAlertIds.AutopilotDisconnect]: -20,
    [BoeingAuralAlertIds.AutopilotDisengage]: -20,
    [BoeingAuralAlertIds.LandingGear]: -30,
    [BoeingAuralAlertIds.Minimums]: -40,
    [BoeingAuralAlertIds.CabinAltitude]: -50,
    [BoeingAuralAlertIds.CabinDeltaPressure]: -60,
    [BoeingAuralAlertIds.MasterWarning]: -70,
    [BoeingAuralAlertIds.TcasRA]: -80,
    [BoeingAuralAlertIds.AutothrottleDisconnect]: -90,
    [BoeingAuralAlertIds.AutothrottleDisengage]: -90,
    [BoeingAuralAlertIds.PfdAlert]: -100,
    [BoeingAuralAlertIds.MasterCaution]: -110,
    [BoeingAuralAlertIds.TouchdownCallout]: -120,
    [BoeingAuralAlertIds.TcasTA]: -130,
    [BoeingAuralAlertIds.AltitudeAlert]: -140,
    [BoeingAuralAlertIds.VerticalTrack]: -150
};

/* eslint-disable max-len */
var WarningSystemAlertIDs;
(function (WarningSystemAlertIDs) {
    WarningSystemAlertIDs["AirspeedLow"] = "airspeed-low";
    WarningSystemAlertIDs["Overspeed"] = "overspeed";
    WarningSystemAlertIDs["AltitudeAlert"] = "altitude-alert";
    WarningSystemAlertIDs["ConfigFlaps"] = "config-flaps";
    WarningSystemAlertIDs["ConfigGear"] = "config-gear";
    WarningSystemAlertIDs["ConfigRudder"] = "config-rudder";
    WarningSystemAlertIDs["ConfigSpoiler"] = "config-spoiler";
    WarningSystemAlertIDs["ConfigStabilizer"] = "config-stabilizer";
    WarningSystemAlertIDs["TailStrike"] = "tail-strike";
    WarningSystemAlertIDs["SinkRate"] = "sink-rate";
    WarningSystemAlertIDs["Terrain"] = "terrain";
    WarningSystemAlertIDs["DontSink"] = "dont-sink";
    WarningSystemAlertIDs["TooLowGear"] = "too-low-gear";
    WarningSystemAlertIDs["TooLowFlaps"] = "too-low-flaps";
    WarningSystemAlertIDs["TooLowTerrain"] = "too-low-terrain";
    WarningSystemAlertIDs["Glideslope"] = "glideslope";
    //CautionTerrain = 'caution-terrain',       // EGPWS -> terrain lookahead, we can't do!
})(WarningSystemAlertIDs || (WarningSystemAlertIDs = {}));
/**
 * Updates the CAS for the warning system related alerts.
 */
class WarningSystemAlerts {
    /**
     * Creates an instance of WarningSystemAlerts.
     * @param bus The event bus to use with this instance.
     * @param numberOfEngines Engine count
     * @param speedData The type specific speed data source.
     * @param tailStrikeFunction Returning max allowed pitch for a given ra
     * @param landingFlapsHandleIndex The first flaps handle index that is considered to be landing flaps.
     */
    constructor(bus, numberOfEngines, speedData, tailStrikeFunction, landingFlapsHandleIndex) {
        this.bus = bus;
        this.numberOfEngines = numberOfEngines;
        this.speedData = speedData;
        this.tailStrikeFunction = tailStrikeFunction;
        this.landingFlapsHandleIndex = landingFlapsHandleIndex;
        this.auralRegistrationManager = new AuralAlertRegistrationManager(this.bus);
        this.soundController = new SoundServerController(this.bus);
        this.sub = this.bus.getSubscriber();
        // Data sources - single:
        this.currentAirspeed = ConsumerSubject.create(this.sub.on('ias').whenChangedBy(1.0), 0);
        this.currentAltitude = ConsumerSubject.create(this.sub.on('indicated_alt').whenChangedBy(2.0), 0);
        this.currentVerticalSpeed = ConsumerSubject.create(this.sub.on('vertical_speed').whenChangedBy(2.0), 0);
        this.radioAltitude = ConsumerSubject.create(this.sub.on('radio_alt').whenChangedBy(3.0), 0);
        this.hiResRadioAltitude = ConsumerSubject.create(this.sub.on('radio_alt').whenChangedBy(0.2), 0); // Used for tail strike
        this.pitchAngleDeg = ConsumerSubject.create(this.sub.on('actual_pitch_deg').whenChangedBy(0.2), 0);
        this.gearExtended = ConsumerSubject.create(this.sub.on('gear_position_2'), 1); // Up 0 / extended 1
        this.holdingSpeed = ConsumerValue.create(this.sub.on('flap_computer_holding_speed').whenChangedBy(1.0), 200);
        this.flapsHandlePos = ConsumerSubject.create(this.sub.on('flaps_handle_index'), 0);
        this.rudderTrimPct = ConsumerSubject.create(this.sub.on('rudder_trim_pct').whenChangedBy(1), 0);
        this.spoilersPerc = ConsumerSubject.create(this.sub.on('spoilers_without_spoilerons_left_percent').whenChangedBy(1), 0);
        this.elevatorTrimAngle = ConsumerSubject.create(this.sub.on('elevator_trim_angle').whenChangedBy(1), 0);
        this.locDeviation = ConsumerSubject.create(this.sub.on('nav_cdi_3').whenChangedBy(1), 0);
        this.gsDeviation = ConsumerSubject.create(this.sub.on('nav_gs_error_3'), 0);
        this.hasLoc = ConsumerSubject.create(this.sub.on('nav_localizer_3'), false);
        this.hasGs = ConsumerSubject.create(this.sub.on('nav_glideslope_3'), false);
        this.ianFacDeviation = ConsumerSubject.create(this.sub.on('boeing_ian_fac_deviation').whenChangedBy(1), 0);
        this.ianGsDeviation = ConsumerSubject.create(this.sub.on('boeing_ian_gp_deviation'), 0);
        this.hasIanFac = ConsumerSubject.create(this.sub.on('boeing_ian_fac_available'), false);
        this.hasIanGs = ConsumerSubject.create(this.sub.on('boeing_ian_gp_available'), false);
        this.onGround = ConsumerSubject.create(this.sub.on('on_ground'), false);
        this.terrainClosureRate = Subject.create(0);
        this.flightPhase = ConsumerSubject.create(this.sub.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.altitudeAlert = ConsumerSubject.create(this.sub.on('altitude_alert'), AltAlertState.DISABLED);
        // Data sources - per engine, based on engine count:
        this.n1PctArray = Array();
        this.throttleLeverPosArray = Array();
        this.lastRa = 0.0;
        this.lastTimestamp = -1;
        this.lastGpwsMode3PeakAlt = 0;
        this.flapSettingAtTakeoff = 0;
        this.flapRetractionStarted = false;
        this.tailStrikeOccured = Subject.create(false);
        this.ilsEstablished = Subject.create(false);
        this.ianEstablished = Subject.create(false);
        this.isLessThan60sAfterLiftoff = Subject.create(false);
        /** True if landing flaps are selected. */
        this.landingFlapsSelected = Subject.create(false);
        this.mode1RaEnvelope = new LerpLookupTable(1);
        this.mode2bRaEnvelope = new LerpLookupTable(1);
        this.mode3RaEnvelope = new LerpLookupTable(1);
        this.liftoffTimer = new DebounceTimer();
        this.delayedInit = new DebounceTimer();
        // Prepare a helper array that matches the number of engines:
        this.engineSuffixes = (numberOfEngines > 2) ? [...Array(numberOfEngines).keys()].map(i => (i + 1).toString()) : [AlertSuffixes.L, AlertSuffixes.R];
        this.engineSuffixes.forEach((_, index) => {
            this.n1PctArray[index] = ConsumerSubject.create(this.sub.on(`n1_${index + 1}`).whenChangedBy(1), 0);
            this.throttleLeverPosArray[index] = ConsumerSubject.create(this.sub.on(`v_throttle_lever_pos_${index + 1}`), 0);
        });
        // Register alerts:
        const cas = this.bus.getPublisher();
        const engStoppedAndStarting = [BoeingInhibitStates.EngineStopped, BoeingInhibitStates.EngineStarting]; // For cautions
        const beforeCruise = [BoeingInhibitStates.BeforeCruiseFlightPhases];
        const duringAndAfterCruise = [BoeingInhibitStates.DuringAndAfterCruiseFlightPhases, BoeingInhibitStates.EngineStopped, BoeingInhibitStates.EngineStarting];
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.AirspeedLow, message: 'AIRSPEED LOW', inhibitedBy: [...engStoppedAndStarting], debounceTime: 1000 }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.Overspeed, message: 'OVERSPEED', inhibitedBy: [''], debounceTime: 500 }, true, false); // W
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.AltitudeAlert, message: 'ALTITUDE ALERT', inhibitedBy: [...engStoppedAndStarting], debounceTime: 500 }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.ConfigFlaps, message: 'CONFIG FLAPS', inhibitedBy: [''], debounceTime: 1000 }, true, false); // W
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.ConfigGear, message: 'CONFIG GEAR', inhibitedBy: [''], debounceTime: 3000 }, true, false); // W
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.ConfigRudder, message: 'CONFIG RUDDER', inhibitedBy: [''], debounceTime: 1000 }, true, false); // W
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.ConfigSpoiler, message: 'CONFIG SPOILERS', inhibitedBy: [''], debounceTime: 1000 }, true, false); // W
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.ConfigStabilizer, message: 'CONFIG STABILIZER', inhibitedBy: [''], debounceTime: 1000 }, true, false); // W
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.TailStrike, message: 'TAIL STRIKE', inhibitedBy: [...engStoppedAndStarting] }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.SinkRate, message: 'SINK RATE', inhibitedBy: [...engStoppedAndStarting] }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.Terrain, message: 'TERRAIN', inhibitedBy: [...engStoppedAndStarting] }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.DontSink, message: 'DON\'T SINK', inhibitedBy: [...duringAndAfterCruise], debounceTime: 1000 }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.TooLowFlaps, message: 'TOO LOW FLAPS', inhibitedBy: [...beforeCruise], debounceTime: 2000 }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.TooLowGear, message: 'TOO LOW GEAR', inhibitedBy: [...beforeCruise], debounceTime: 2000 }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.TooLowTerrain, message: 'TOO LOW TERRAIN', inhibitedBy: [...beforeCruise], debounceTime: 2000 }, true, false); // C
        cas.pub('cas_register_alert', { uuid: WarningSystemAlertIDs.Glideslope, message: 'GLIDESLOPE', inhibitedBy: [...engStoppedAndStarting], debounceTime: 2000 }, true, false); // C
        // Delay the initialization by 10 seconds to prevent alerts while the engine parameter stabilize:
        this.delayedInit.schedule(() => this.initAlerts(), 10000);
    }
    /**
     * Initalizes the basic aircraft alerts.
     */
    initAlerts() {
        // ---- Aural alerts ----
        this.auralRegistrationManager.register({
            uuid: BoeingAuralAlertIds.LandingGear,
            queue: BoeingAuralAlertUtils.PRIMARY_QUEUE,
            priority: BoeingAuralAlertUtils.PRIORITIES[BoeingAuralAlertIds.LandingGear],
            // TODO This is the incorrect sound according the the FCOM and pilots, it should be the Siren sound,
            // TODO but only the 78 PCK has it right now (OVERSPEED_WARNING_SOUND)
            sequence: 'aural_landing_gear',
            continuous: false,
            repeat: true,
            timeout: 3000,
        });
        this.auralRegistrationManager.register({
            uuid: BoeingAuralAlertIds.AltitudeAlert,
            queue: BoeingAuralAlertUtils.PRIMARY_QUEUE,
            priority: BoeingAuralAlertUtils.PRIORITIES[BoeingAuralAlertIds.AltitudeAlert],
            // TODO This is the incorrect sound according the the FCOM and pilots, it should be the Beeper sound, but we don't have it yet
            sequence: 'tone_altitude_alert_default',
            continuous: false,
            repeat: false,
            timeout: 3000,
        });
        CasAuralAlertTransporter.create(this.bus, BoeingAuralAlertIds.LandingGear, undefined, WarningSystemAlertIDs.ConfigGear, AnnunciationType.Warning, undefined, true);
        CasAuralAlertTransporter.create(this.bus, BoeingAuralAlertIds.AltitudeAlert, undefined, WarningSystemAlertIDs.AltitudeAlert, AnnunciationType.Caution, undefined, false);
        this.altitudeAlert.sub(altitudeAlert => {
            if (altitudeAlert === AltAlertState.WITHIN_900) {
                // The 748 FCOM does not state that this alert plays when approaching sel alt
                // But our research showed that it is an airline option, so we opted to have it
                // 78 FCOM does state that this alert plays
                this.soundController.playSound('tone_altitude_alert_default');
            }
        });
        // ---- CAS alerts ----
        // Maintain some helper variables:
        this.onGround.sub(onGround => {
            if (onGround == false) {
                // Liftoff, store the flap setting!
                this.flapSettingAtTakeoff = this.flapsHandlePos.get();
            }
            else {
                // Reset the state after landing.
                this.flapRetractionStarted = false;
            }
        }, true);
        this.flapsHandlePos.sub(v => {
            if (v < this.flapSettingAtTakeoff) {
                // Set the flap retraction started state:
                this.flapRetractionStarted = true;
            }
            this.landingFlapsSelected.set(v >= this.landingFlapsHandleIndex);
        }, true);
        // AIRSPEED LOW
        // Airspeed is less than minimum maneuvering speed.
        // Disabling for flighting build, uncomment and fix after
        // CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.AirspeedLow, AnnunciationType.Caution)
        //   .bind(
        //     MappedSubject.create(
        //       this.currentAirspeed,
        //       this.onGround
        //     ),
        //     inputValues => {
        //       const [ias, onGround] = inputValues;
        //       return (onGround == false)
        //         && this.flapRetractionStarted    // <- Consider this alert not before flaps retraction starts (when the amber lower speedband appears)
        //         && ((this.currentAltitude.get() < 20000.0) ?
        //           ias < Simplane.getStallProtectionMinSpeed() :
        //           ias < this.holdingSpeed.get());
        //     }
        //   );
        // OVERSPEED
        // Airspeed is more than Vmo/Mmo.
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.Overspeed, AnnunciationType.Warning)
            .bind(this.currentAirspeed, v => {
            const vmo = this.speedData.getVmo();
            const mmo = this.speedData.getMmo();
            const pressure = AeroMath.isaPressure(UnitType.FOOT.convertTo(this.currentAltitude.get(), UnitType.METER));
            const casAtMmo = UnitType.MPS.convertTo(AeroMath.machToCas(mmo, pressure), UnitType.KNOT);
            return v > Math.min(vmo, casAtMmo);
        });
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.AltitudeAlert, AnnunciationType.Caution)
            .bind(this.altitudeAlert, altitudeAlert => 
        // 78 FCOM says 300, but Charles says that videos show that 200 is actually the threshold
        // And the 74 FCOM says 200 ft
        altitudeAlert === AltAlertState.DEVIATION_200);
        // CONFIG FLAPS:
        // The flaps are not in a takeoff position during takeoff.
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.ConfigFlaps, AnnunciationType.Warning)
            .bind(MappedSubject.create(this.onGround, this.flapsHandlePos, ...this.n1PctArray), inputValues => {
            const [onGround, flaps] = inputValues;
            const n1Array = inputValues.slice(2);
            return onGround
                && ((flaps < 2) || (7 < flaps))
                && n1Array.every(n1 => n1 >= WarningSystemAlerts.takeOffConsiderationThrust);
        });
        // CONFIG GEAR
        // A landing gear is not down and locked and one of these occurs:
        // - Below 800 feet radio altitude and a thrust lever is at idle
        // - The flaps are in a landing position
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.ConfigGear, AnnunciationType.Warning)
            .bind(MappedSubject.create(this.gearExtended, this.radioAltitude, this.landingFlapsSelected, ...this.throttleLeverPosArray), inputValues => {
            const [gear, ra, flapsInLandingConfig] = inputValues;
            const throttlePosArray = inputValues.slice(3);
            const gearDownAndLocked = !(gear < WarningSystemAlerts.gearExtendedThreshold);
            const below800RA = ra < WarningSystemAlerts.alertConsiderationAltitude;
            const anyThrottleIsIdle = throttlePosArray.some(pos => pos < WarningSystemAlerts.throttleIdleThreshold);
            if (!gearDownAndLocked) {
                if (below800RA && anyThrottleIsIdle) {
                    return true;
                }
                if (flapsInLandingConfig) {
                    return true;
                }
            }
            return false;
        });
        // CONFIG RUDDER
        // Rudder trim is not centered during takeoff.
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.ConfigRudder, AnnunciationType.Warning)
            .bind(MappedSubject.create(this.onGround, this.rudderTrimPct, ...this.n1PctArray), inputValues => {
            const [onGround, rudderTrim] = inputValues;
            const n1Array = inputValues.slice(2);
            return onGround
                && (Math.abs(rudderTrim) > WarningSystemAlerts.rudderTrimCenterBandPct)
                && n1Array.every(n1 => n1 >= WarningSystemAlerts.takeOffConsiderationThrust);
        });
        // CONFIG SPOILER:
        // The speedbrake lever is not down during takeoff.
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.ConfigSpoiler, AnnunciationType.Warning)
            .bind(MappedSubject.create(this.onGround, this.spoilersPerc, ...this.n1PctArray), inputValues => {
            const [onGround, brakesExtended] = inputValues;
            const n1Array = inputValues.slice(2);
            return onGround
                && (brakesExtended > WarningSystemAlerts.spoilerExtendedThreshold)
                && n1Array.every(n1 => n1 >= WarningSystemAlerts.takeOffConsiderationThrust);
        });
        // CONFIG STABILIZER:
        // The stabilizer is not in the greenband during takeoff. Use the calculation from TrimGauge.tsx
        // DISABLING FOR FLIGHTING BUILD, after integration uncomment this and fix so it works for both planes properly
        // CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.ConfigStabilizer, AnnunciationType.Warning)
        //   .bind(
        //     MappedSubject.create(
        //       this.onGround,
        //       this.elevatorTrimAngle,
        //       ...this.n1PctArray
        //     ),
        //     inputValues => {
        //       const [onGround, trimAngleDeg] = inputValues;
        //       const n1Array = inputValues.slice(2) as number[];
        //       const projectedTrim = MathUtils.round(850.0 + (trimAngleDeg * 1650 / 34.0), 25);
        //       return onGround
        //         && ((projectedTrim < 350) || (700 < projectedTrim))
        //         && n1Array.every(n1 => n1 >= WarningSystemAlerts.takeOffConsiderationThrust);
        //     });
        // TAIL STRIKE
        // The tail hits the runway.
        this.radioAltitude.sub((newRa) => {
            if (newRa > 35) {
                // Use the low res RA to pause both triggers once we are clear from the ground:
                this.hiResRadioAltitude.pause();
                this.pitchAngleDeg.pause();
            }
        });
        MappedSubject.create(([ra, pitchAngle]) => {
            // By measuring pairs of ra and pitch angles (when the tail touches the runway), we get a set of data points,
            // for which we can find a function that describes the geometry of the aircraft.
            // For the 787-10, e.g. the following values resulted: (ra -> max pitch angle)
            // 14->-5.47 / 16->-6.77 / 18->-8.21 / 20->-9.54 / 22->-10.79 / 24->-12.01 / 26->-13.19
            // By polynom interpolation, on this website https://valdivia.staff.jade-hs.de/interpol.html
            // a matching polynomial of degree 2 can be found and provided in the tailStrikeFunction callback.
            // First exclude small pitch angles and large ra's:
            let tailStrikeOccured = this.tailStrikeOccured.get(); // Keep the alert once it was set)
            if ((ra < 30.0) && (pitchAngle < -6.0) && (tailStrikeOccured == false)) {
                const maxAllowablePitchAtCurrentRa = this.tailStrikeFunction(ra); // e.g. for the 781: 0.005536 * ra * ra - 0.8682 * ra + 5.636;
                //console.log('ra=' + ra + '::pitch=' + pitchAngle + '::alert=' + (pitchAngle < maxAllowablePitchAtCurrentRa));
                tailStrikeOccured = (pitchAngle < maxAllowablePitchAtCurrentRa);
            }
            return tailStrikeOccured;
        }, this.hiResRadioAltitude, this.pitchAngleDeg).sub(v => {
            this.tailStrikeOccured.set(v);
        });
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.TailStrike, AnnunciationType.Caution)
            .bind(this.tailStrikeOccured, v => v);
        // Now the GPWS detection: (see Honeywell-EGPWS.pdf on sharepoint)
        // GPWS mode 1: excessive descend rate -> SINKRATE
        // Input is vertical speed and radio altitude.
        // The lookup table has allowableRa/vs-tuples.
        this.mode1RaEnvelope = new LerpLookupTable([[-20, 0], [-20, -1000], [2450, -4500], [2450, -10000]]);
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.SinkRate, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.currentVerticalSpeed, this.radioAltitude), inputValues => {
            const [vs, ra] = inputValues;
            return ra < this.mode1RaEnvelope.get(vs);
        });
        // GPWS mode 2: excessive terrain closure rate -> TERRAIN
        // Excessive terrain closing rate. These are GPWS mode 2a and 2b alerts (see Honeywell-EGPWS.pdf on sharepoint, pg 9 ff).
        // Input for this alert is radio altitude (RA), radio altitude closure rate (dRA), speed, flaps settings, time after takeoff and
        // ILS deviations.
        // First provide an "ILS established"-indication, loc-dev -/+127, gs-dev in degress, 2 dots ~ 0.82° :
        MappedSubject.create(([hasLoc, hasGs, locError, gsError]) => {
            return hasLoc && hasGs && (Math.abs(locError) < 50.0) && (Math.abs(gsError) < 0.4);
        }, this.hasLoc, this.hasGs, this.locDeviation, this.gsDeviation).sub(v => {
            this.ilsEstablished.set(v);
        });
        MappedSubject.create(([hasFac, hasIanGs, facError, gsError]) => {
            if (facError !== null && gsError !== null) {
                return hasFac && hasIanGs && (Math.abs(facError) < 0.5) && (Math.abs(gsError) < 100.0);
            }
            else {
                return false;
            }
        }, this.hasIanFac, this.hasIanGs, this.ianFacDeviation, this.ianGsDeviation).sub(v => {
            this.ianEstablished.set(v);
        });
        // Second provide the 60s time window after lift off:
        this.onGround.sub(v => {
            if (v == false) {
                this.isLessThan60sAfterLiftoff.set(true);
                this.liftoffTimer.schedule(() => {
                    this.isLessThan60sAfterLiftoff.set(false);
                }, 60000);
            }
        }, true);
        // Third calculate the terrain closure rate in ft/min:
        this.radioAltitude.sub(newRa => {
            let closureRate = 0.0;
            if (this.lastTimestamp !== -1) {
                const currentTimestamp = Date.now();
                closureRate = (this.lastRa - newRa) * 60000 / (currentTimestamp - this.lastTimestamp); // In ft/min, positive if terrain comes closer!
                //console.log(closureRate + '/old=' + this.lastRa + '/new=' + newRa + '/dts=' + (currentTimestamp - this.lastTimestamp));
            }
            this.lastRa = newRa;
            this.lastTimestamp = Date.now();
            this.terrainClosureRate.set(closureRate);
        });
        this.mode2bRaEnvelope = new LerpLookupTable([[0, 0], [0, 2200], [800, 2800], [250, 10000]]);
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.Terrain, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.radioAltitude, this.terrainClosureRate, this.currentAirspeed, this.landingFlapsSelected, this.ilsEstablished, this.ianEstablished, this.isLessThan60sAfterLiftoff), inputValues => {
            const [ra, closureRate, ias, flapsInLandingConfig, ilsEstablished, ianEstablished, isLessThan60s] = inputValues;
            let minAllowableRa = -100.0;
            let maxAllowableRaFloor = 0.0;
            //let logString = 'mode2calcs::clrate=' + closureRate.toFixed(1);
            // Check whether GPWS mode 2a or 2b applies:
            if ((flapsInLandingConfig === false)
                && (ilsEstablished === false)
                && (ianEstablished === false)
                && (isLessThan60s === false)) {
                //logString += '::2a';
                // GPWS mode 2a -> a large envelope applies before the final approach
                // We calculate allowableRa as described on pg 10 of the mentioned pdf.
                // Between 1500 and 3200 closureRate, allowableRa forms a slope from 0 to 1200
                if (1500 < closureRate) {
                    //logString += '::>1500';
                    if (closureRate < 3200) {
                        minAllowableRa = (closureRate - 1500) * 0.7059;
                        //logString += '::<3200';
                    }
                    else {
                        // Above 3200 closureRate, allowableRa follows a less steep slope until it is capped inside
                        // the speed expansion area between 1600 (for 220 or less airspeed) and 2000 (for 310 airspeed)
                        const speedExpansion = ias < 220 ? 0 : (ias > 310 ? 400 : (ias - 220) * 4.444);
                        minAllowableRa = Math.min(1200.0 + (closureRate - 3200) * 0.11764, 1600 + speedExpansion);
                        //logString += '::>3200';
                    }
                }
            }
            else {
                // GPWS mode 2b -> a much smaller alerting envelope applies:
                minAllowableRa = this.mode2bRaEnvelope.get(closureRate);
                maxAllowableRaFloor = 200.0;
            }
            //console.log(logString + '::ara=' + minAllowableRa.toFixed(1) + '::alert=' + (ra < minAllowableRa));
            // Alert, if ra drops below allowableRa:
            return (maxAllowableRaFloor < ra) && (ra < minAllowableRa);
        });
        // GPWS mode 3: descend after takeoff -> DON'T SINK
        // Input is gear and flap config, radio altitude and flight phase (via inhibitor). We need to detect altitude loss while climbing, thus
        // we need to store the peak altitude which was reached during the climbout before the unintended descend began.
        this.mode3RaEnvelope = new LerpLookupTable([[0, 0], [0, 10], [1500, 140], [1500, 300]]);
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.DontSink, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.flightPhase, this.currentVerticalSpeed, this.currentAltitude, this.gearExtended, this.landingFlapsSelected, this.radioAltitude), inputValues => {
            const [phase, vs, alt, gear, flapsInLandingConfig, ra] = inputValues;
            let minAllowableRa = -100.0;
            // We only monitor GPWS mode 3 during climb flight phase and with gear and flaps not configured for landing:
            if ((phase === FmsOperatingPhase.CLIMB) && (gear < WarningSystemAlerts.gearExtendedThreshold) && (flapsInLandingConfig == false)) {
                // First we need to detect the peak altitude when the descend began.
                if (vs > 0.0) {
                    this.lastGpwsMode3PeakAlt = alt; // Drag the peak alt with current as long as we climb
                }
                const observedAltLoss = Math.min(this.lastGpwsMode3PeakAlt - alt, 300);
                minAllowableRa = this.mode3RaEnvelope.get(observedAltLoss) - 3.0; // Make a bit smaller to avoid ambiguity when all values are 0
                //console.log('altLoss=' + observedAltLoss.toFixed(1) + '::alloweable=' + minAllowableRa.toFixed(1) + '::ra=' + ra);
                return (ra > 50.0) && (ra < minAllowableRa);
            }
            else {
                return false;
            }
        });
        // GPWS mode 4: invalid config at low alt and speed -> TOO LOW TERRAIN, then (when getting slower/lower) TOO LOW GEAR or TOO LOW FLAPS
        // These appear appear when coming in for a landing and the gear/flaps are not configured correctly.
        // Input is gear and flap config, radio altitude, airspeed and flight phase (via inhibitor).
        // These are GPWS mode 4a and 4b alerts (see Honeywell-EGPWS.pdf on sharepoint, pg 14 ff).
        const mode4aSpeedThreshold = 190.0; // kts
        const mode4aLowerAltThreshold = 500.0; // ft
        const mode4aSlopeGradient = 8.333;
        const mode4bSpeedThreshold = 159.0; // kts
        const mode4bLowerAltThreshold = 245.0; // ft
        const mode4bSlopeGradient = 8.297;
        const mode4UpperAltThreshold = 1000.0; // ft
        const mode4SlopeEndSpeed = 250.0;
        // TOO LOW TERRAIN
        // Coming in high and fast, at first only TOO LOW TERRAIN is thrown if gear or flaps are not yet configured.
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.TooLowTerrain, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.gearExtended, this.landingFlapsSelected, this.radioAltitude, this.currentAirspeed), inputValues => {
            const [gear, flapsInLandingConfig, ra, ias] = inputValues;
            let minAllowableRa = -100.0;
            if (gear < WarningSystemAlerts.gearUpThreshold) {
                // Gear not extended. Higher speed part of mode 4a.
                if (ias > mode4aSpeedThreshold) {
                    if (ias < mode4SlopeEndSpeed) {
                        // Allowable ra follows slope between 500ft/190kts and 1000ft/250kts:
                        minAllowableRa = mode4aLowerAltThreshold + (ias - mode4aSpeedThreshold) * mode4aSlopeGradient;
                    }
                    else {
                        minAllowableRa = mode4UpperAltThreshold;
                    }
                }
            }
            else if (flapsInLandingConfig == false) {
                // Gear extended, but flaps not extended. Higher speed part of mode 4b.
                if (ias > mode4bSpeedThreshold) {
                    if (ias < mode4SlopeEndSpeed) {
                        // Allowable ra follows slope between 245ft/159kts and 1000ft/250kts:
                        minAllowableRa = mode4bLowerAltThreshold + (ias - mode4bSpeedThreshold) * mode4bSlopeGradient;
                    }
                    else {
                        minAllowableRa = mode4UpperAltThreshold;
                    }
                }
            }
            //console.log('mode4::ra=' + ra + '::allowable=' + minAllowableRa);
            return (ra < minAllowableRa);
        });
        // TOO LOW GEAR, GPWS mode 4a.
        // This alert is thrown below 190 kts and 500 ft RA and if the gear is not lowered (regardless
        // whether the flaps are configured as well or not).
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.TooLowGear, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.gearExtended, this.radioAltitude, this.currentAirspeed), inputValues => {
            const [gear, ra, ias] = inputValues;
            return (gear < WarningSystemAlerts.gearUpThreshold) // Gear not extended
                && (ra < mode4aLowerAltThreshold) // and below min config alt
                && (ias < mode4aSpeedThreshold); // and below min config speed
        });
        // TOO LOW FLAPS, GPWS mode 4b.
        // This alert is thrown below 160 kts and 245 ft RA and if the flaps are not configured while the
        // gears have been extended.
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.TooLowFlaps, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.gearExtended, this.landingFlapsSelected, this.radioAltitude, this.currentAirspeed, this.onGround), inputValues => {
            const [gear, flapsInLandingConfig, ra, ias, onGround] = inputValues;
            return (gear >= WarningSystemAlerts.gearUpThreshold) // Gear extended
                && (flapsInLandingConfig === false) // but flaps not in landing config
                && (ra < mode4bLowerAltThreshold) // and below min config alt
                && (ias < mode4bSpeedThreshold) // and below min config speed
                && (onGround === false);
        });
        // GPWS mode 5: glideslope deviation
        // This alert is thrown below 1000ft RA and more than 1.3 dots below GS (-0.55°).
        CasAlertTransporter.create(this.bus, WarningSystemAlertIDs.Glideslope, AnnunciationType.Caution)
            .bind(MappedSubject.create(this.hasGs, this.gsDeviation, this.hasIanGs, this.ianGsDeviation, this.radioAltitude, this.onGround), inputValues => {
            const [hasGs, gsDeviation, hasIanGs, ianGsDeviation, ra, onGround] = inputValues;
            const dotsBelow = gsDeviation / -0.41;
            let throwAlert = false;
            if (((hasGs && (dotsBelow > 1.3))
                || ((ianGsDeviation !== null) && hasIanGs && (ianGsDeviation < -150)))
                && (ra < 1000) && (onGround === false)) {
                // Now ra still needs to be higher than 30 or a slope from 150@1.3 to 30@2.8
                throwAlert = (ra > 30.0) && (ra > 150 - ((dotsBelow - 1.3) * 80.0));
            }
            return throwAlert;
        });
    }
}
WarningSystemAlerts.throttleIdleThreshold = 0.05;
WarningSystemAlerts.spoilerExtendedThreshold = 3.0;
WarningSystemAlerts.gearExtendedThreshold = 0.99;
WarningSystemAlerts.gearUpThreshold = 0.03;
WarningSystemAlerts.alertConsiderationAltitude = 800;
WarningSystemAlerts.takeOffConsiderationThrust = 80.0;
WarningSystemAlerts.rudderTrimCenterBandPct = 3.0;

/**
 * A default implementation of {@link VerticalDeviationDataProvider}.
 */
class DefaultVerticalDeviationDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ilsNavIndicator The ILS nav indicator.
     * @param fmsPosIndex The index of the FMS position system that is the source of this provider's data.
     */
    constructor(bus, ilsNavIndicator, fmsPosIndex) {
        this.bus = bus;
        this.ilsNavIndicator = ilsNavIndicator;
        this.verticalNavSource = ConsumerSubject.create(null, NavigationSource.NONE).pause();
        this.fmaData = ConsumerSubject.create(null, undefined).pause();
        this._fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        /** @inheritdoc */
        this.fmsOperatingPhase = this._fmsOperatingPhase;
        this._rnp = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.rnp = this._rnp;
        this._anp = Subject.create(-1);
        /** @inheritdoc */
        this.anp = this._anp;
        /** @inheritdoc */
        this.isVerticalNavSourceNp = this.verticalNavSource.map(source => source === NavigationSource.NPS);
        this._verticalPathAvailable = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isVerticalPathAvailable = this._verticalPathAvailable;
        this._isApLateralTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.lateralActive === APLateralModes.TO || fmaData.lateralActive === APLateralModes.GA);
        });
        /** @inheritdoc */
        this.isApLateralTogaActive = this._isApLateralTogaActive;
        this._isApVerticalTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.verticalActive === APVerticalModes.TO || fmaData.verticalActive === APVerticalModes.GA);
        });
        /** @inheritdoc */
        this.isApVerticalTogaActive = this._isApVerticalTogaActive;
        this._npDeviation = Subject.create(null);
        /** @inheritdoc */
        this.npDeviation = this._npDeviation;
        this._isUnableRnp = Subject.create(false);
        /** @inheritdoc */
        this.isUnableRnp = this._isUnableRnp;
        this._isNpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isNpDeviationExcessive = this._isNpDeviationExcessive;
        this._gsDeviation = Subject.create(null);
        /** @inheritdoc */
        this.gsDeviation = this._gsDeviation;
        this._isApGsActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.GS);
        /** @inheritdoc */
        this.isApGsActive = this._isApGsActive;
        this._isGsDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isGsDeviationExcessive = this._isGsDeviationExcessive;
        /** @inheritdoc */
        this.isVerticalNavSourceGp = this.verticalNavSource.map(source => source === NavigationSource.IAN);
        this._gpDeviation = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.gpDeviation = this._gpDeviation;
        this._isApGpActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.GP);
        /** @inheritdoc */
        this.isApGpActive = this._isApGpActive;
        this._isGpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isGpDeviationExcessive = this._isGpDeviationExcessive;
        this.anpSource = ConsumerSubject.create(null, 0).pause();
        this.anpPipe = this.anpSource.pipe(this._anp, true);
        this._isApFlareActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.FLARE);
        /** @inheritdoc */
        this.isApFlareActive = this._isApFlareActive;
        this.vDev = ConsumerSubject.create(null, 0).pause();
        this.vDevPipe = this.vDev.pipe(this._npDeviation, error => -error, true);
        this.gpAvailable = ConsumerSubject.create(null, false).pause();
        this.gsDeviationPipe = this.ilsNavIndicator.verticalDeviation.pipe(this._gsDeviation, dev => dev === null ? 0 : -dev * 2.5, true);
        this.apMaster = ConsumerSubject.create(null, false).pause();
        this.fdActive = ConsumerSubject.create(null, false).pause();
        this.radioAltitude = ConsumerSubject.create(null, 0).pause();
        this.fmsPosSystemState = ConsumerSubject.create(null, undefined).pause();
        this.isFmsPosDataValid = this.fmsPosSystemState.map(state => {
            return state !== undefined && (state.current === undefined || state.current === AvionicsSystemState.On);
        });
        this.hasNpDeviation = MappedSubject.create(([verticalPathAvailable, verticalNavSource]) => verticalPathAvailable && verticalNavSource === NavigationSource.NPS, this._verticalPathAvailable, this.verticalNavSource);
        this.isUnableRnpSource = MappedSubject.create(([rnp, anp]) => anp >= 0 && anp >= rnp, this._rnp, this._anp);
        this.isUnableRnpTimer = new DebounceTimer();
        this.isNpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._npDeviation, this.isVerticalNavSourceNp);
        this.isNpDeviationExcessiveTimer = new DebounceTimer();
        this.isGpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._gpDeviation, this.isVerticalNavSourceGp);
        this.isGpDeviationExcessiveTimer = new DebounceTimer();
        this.hasGsDeviation = MappedSubject.create(([signal, isGs, gpAvailable]) => !!isGs && signal !== null && signal > 0 && !gpAvailable, this.ilsNavIndicator.signalStrength, this.ilsNavIndicator.hasGlideSlope, this.gpAvailable);
        this.evalExcessiveGsDeviation = MappedSubject.create(([apMaster, fdActive, radioAltitude]) => (apMaster || fdActive) && radioAltitude < 500, this.apMaster, this.fdActive, this.radioAltitude);
        this.excessiveGsDeviationPipe = this._gsDeviation.pipe(this._isGsDeviationExcessive, deviation => deviation !== null && Math.abs(deviation) > 1, true);
        this.pauseableSubjects = [
            this._fmsOperatingPhase,
            this._rnp,
            this.anpSource,
            this._verticalPathAvailable,
            this.vDev,
            this.verticalNavSource,
            this.fmaData,
            this.gpAvailable,
            this._gpDeviation,
            this.apMaster,
            this.fdActive,
            this.radioAltitude,
            this.fmsPosSystemState,
            this.hasGsDeviation
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.fmsPosIndex = SubscribableUtils.toSubscribable(fmsPosIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this._rnp.setConsumer(sub.on('boeingvnav_rnp'));
        this.vDev.setConsumer(sub.on('vnav_vertical_deviation'));
        this.verticalNavSource.setConsumer(sub.on('vertical_nav_source'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        this.apMaster.setConsumer(sub.on('ap_master_status'));
        this.fdActive.setConsumer(sub.on('flight_director_is_active_1'));
        this.radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this.fmsPosIndexSub = this.fmsPosIndex.sub(index => {
            this.fmsPosSystemState.setConsumer(sub.on(`fms_pos_state_${index}`));
            this.anpSource.setConsumer(sub.on(`fms_pos_vertical_anp_${index}`));
        }, true);
        this.fmsPosDataValidSub = this.isFmsPosDataValid.sub(this.onFmsPosDataValidChanged.bind(this), false, true);
        this.hasNpDeviationSub = this.hasNpDeviation.sub(this.onHasNpDeviationChanged.bind(this), false, true);
        this._verticalPathAvailable.setConsumer(sub.on('vnav_path_available'));
        this.gpAvailable.setConsumer(sub.on('boeing_ian_gp_available'));
        this._gpDeviation.setConsumer(sub.on('boeing_ian_gp_deviation'));
        const activateUnableRnp = this._isUnableRnp.set.bind(this._isUnableRnp, true);
        this.isUnableRnpSub = this.isUnableRnpSource.sub(isUnableRnp => {
            if (isUnableRnp) {
                this.isUnableRnpTimer.schedule(activateUnableRnp, DefaultVerticalDeviationDataProvider.UNABLE_RNP_DELAY);
            }
            else {
                this.isUnableRnpTimer.clear();
                this._isUnableRnp.set(false);
            }
        }, false, true);
        const activateExcessiveNpDeviation = this._isNpDeviationExcessive.set.bind(this._isNpDeviationExcessive, true);
        this.isNpDeviationExcessiveSub = this.isNpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isNpDeviationExcessiveTimer.schedule(activateExcessiveNpDeviation, DefaultVerticalDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY);
            }
            else {
                this.isNpDeviationExcessiveTimer.clear();
                this._isNpDeviationExcessive.set(false);
            }
        }, false, true);
        const activateExcessiveGpDeviation = this._isGpDeviationExcessive.set.bind(this._isGpDeviationExcessive, true);
        this.isGpDeviationExcessiveSub = this.isGpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isGpDeviationExcessiveTimer.schedule(activateExcessiveGpDeviation, DefaultVerticalDeviationDataProvider.EXCESSIVE_GP_DEVIATION_DELAY);
            }
            else {
                this.isGpDeviationExcessiveTimer.clear();
                this._isGpDeviationExcessive.set(false);
            }
        }, false, true);
        this.hasGsDeviationSub = this.hasGsDeviation.sub(this.onHasGsDeviationChanged.bind(this), false, true);
        this.evalExcessiveGsDeviationSub = this.evalExcessiveGsDeviation.sub(this.onEvalExcessiveGsDeviationChanged.bind(this), false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Responds to when FMS position data validity changes.
     * @param isDataValid Whether FMS position data is valid.
     */
    onFmsPosDataValidChanged(isDataValid) {
        if (isDataValid) {
            this.anpPipe.resume(true);
        }
        else {
            this.anpPipe.pause();
            this._anp.set(-1);
        }
    }
    /**
     * Responds to when NP deviation availability changes.
     * @param hasNpDeviation Whether NP deviation is available.
     */
    onHasNpDeviationChanged(hasNpDeviation) {
        if (hasNpDeviation) {
            this.vDevPipe.resume(true);
        }
        else {
            this.vDevPipe.pause();
            this._npDeviation.set(null);
        }
    }
    /**
     * Responds to when glideslope deviation availability changes.
     * @param hasGsDeviation Whether glideslope deviation is available.
     */
    onHasGsDeviationChanged(hasGsDeviation) {
        if (hasGsDeviation) {
            this.gsDeviationPipe.resume(true);
        }
        else {
            this.gsDeviationPipe.pause();
            this._gsDeviation.set(null);
        }
    }
    /**
     * Responds to when whether to evaluate excessive glideslope deviation changes.
     * @param evaluate Whether to evaluate excessive glideslope deviation.
     */
    onEvalExcessiveGsDeviationChanged(evaluate) {
        if (evaluate) {
            this.excessiveGsDeviationPipe.resume(true);
        }
        else {
            this.excessiveGsDeviationPipe.pause();
            this._isGsDeviationExcessive.set(false);
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseableSubjects) {
            subject.resume();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.isGpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.isNpDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.resume(true);
        (_f = this.hasGsDeviationSub) === null || _f === void 0 ? void 0 : _f.resume(true);
        (_g = this.evalExcessiveGsDeviationSub) === null || _g === void 0 ? void 0 : _g.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        for (const subject of this.pauseableSubjects) {
            subject.pause();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.isGpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.isNpDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.pause();
        (_f = this.hasGsDeviationSub) === null || _f === void 0 ? void 0 : _f.pause();
        (_g = this.evalExcessiveGsDeviationSub) === null || _g === void 0 ? void 0 : _g.pause();
        this.gsDeviationPipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        (_a = this.fmsPosIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const subject of this.pauseableSubjects) {
            subject.destroy();
        }
    }
}
DefaultVerticalDeviationDataProvider.UNABLE_RNP_DELAY = 5000; // milliseconds
DefaultVerticalDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY = 5000; // milliseconds
DefaultVerticalDeviationDataProvider.EXCESSIVE_GP_DEVIATION_DELAY = 5000; // milliseconds

/** BoeingChecklistCheckbox */
class BoeingChecklistCheckbox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.checkboxDivRef = FSComponent.createRef();
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
    }
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'chkl-item-checkbox': true,
                'chkl-item-checkbox-selected': this.props.isChecked,
            }, style: {
                width: this.props.sizePx + 'px',
                height: this.props.sizePx + 'px',
            }, ref: this.checkboxDivRef },
            FSComponent.buildComponent("svg", { viewBox: "-35 -35 70 70" },
                FSComponent.buildComponent("path", { d: "M -29 11 L -16 24 L 28 -28", stroke: this.props.isChecked.map(x => x ? 'var(--boeing-colors-green)' : 'none'), fill: "none", "vector-effect": "non-scaling-stroke" }))));
    }
    /** @inheritDoc */
    destroy() {
        this.checkboxDivRef.instance.removeEventListener('click', () => null);
    }
}

/** A MFD generic button */
class BoeingMfdButton extends DisplayComponent {
    /**
     * The constructor of the BoeingMfdButton, used for formatting button text on creation.
     * @param props The props of the BoeingMfdButton.
     */
    constructor(props) {
        super(props);
        this.root = FSComponent.createRef();
        this.buttonText = [];
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable(this.props.isDisabled, true);
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => this.props.onClick && this.props.onClick());
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        return (FSComponent.buildComponent("span", { ref: this.root, style: style, class: Object.assign({ 'boeing-mfd-button': true, 'boeing-mfd-button-selected': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-mfd-button-disabled': this.isDisabled.map(x => x === true), 'boeing-mfd-button-alerted': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                previous[current] = true;
                return previous;
            }, {}))) }, ...this.buttonText));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}

var BoeingChecklistItemState;
(function (BoeingChecklistItemState) {
    BoeingChecklistItemState["Incomplete"] = "Incomplete";
    BoeingChecklistItemState["Complete"] = "Complete";
    BoeingChecklistItemState["Overriden"] = "Overriden";
})(BoeingChecklistItemState || (BoeingChecklistItemState = {}));
/** A BoeingChecklistItem. */
class BoeingChecklistItem {
    /**
     * Creates a new BoeingChecklistItem.
     * @param name The string that will be displayed on the left side of the item.
     * @param task The string that will be displayed on the right side of the item.
     */
    constructor(name, task) {
        this.name = name;
        this.task = task;
        this.state = Subject.create(BoeingChecklistItemState.Incomplete);
    }
}
/** A BoeingChecklist. */
class BoeingChecklist {
    /**
     * Creates a new BoeingChecklistItem.
     * @param name The name of the checklist.
     * @param items The items that make up the checklist, in order.
     */
    constructor(name, items) {
        this.name = name;
        this.items = items;
        this._isComplete = Subject.create(false);
        this.isComplete = this._isComplete;
        this._anyItemChanged = new SubEvent();
        this.anyItemChanged = this._anyItemChanged;
        this.handleItemsStateChange = (itemIndex) => (itemState) => {
            const everyItemIsCompleted = this.items.every((v) => {
                if (v.state.get() === BoeingChecklistItemState.Complete || v.state.get() === BoeingChecklistItemState.Overriden) {
                    return true;
                }
            });
            this._isComplete.set(everyItemIsCompleted);
            this._anyItemChanged.notify(this, {
                checklistName: this.name,
                itemIndex,
                itemState,
            });
        };
        items.forEach((v, i) => {
            v.state.sub(this.handleItemsStateChange(i));
        });
    }
}

var ChecklistMenu;
(function (ChecklistMenu) {
    ChecklistMenu[ChecklistMenu["None"] = 0] = "None";
    ChecklistMenu[ChecklistMenu["Normal"] = 1] = "Normal";
    ChecklistMenu[ChecklistMenu["Resets"] = 2] = "Resets";
    ChecklistMenu[ChecklistMenu["NonNormal"] = 3] = "NonNormal";
})(ChecklistMenu || (ChecklistMenu = {}));
/** The BoeingChecklistPage component. */
class BoeingChecklistPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.items = ArraySubject.create([]);
        this.list = FSComponent.createRef();
        this.checklistMenuTitleRef = FSComponent.createRef();
        this.checklistTitleRef = FSComponent.createRef();
        this.checklistItemsRef = FSComponent.createRef();
        this.activeMenu = Subject.create(ChecklistMenu.None);
        this.isNormalMenuActive = this.activeMenu.map(x => x === ChecklistMenu.Normal);
        this.isResetsMenuActive = this.activeMenu.map(x => x === ChecklistMenu.Resets);
        this.isNonNormalMenuActive = this.activeMenu.map(x => x === ChecklistMenu.NonNormal);
        this.isNormalButtonVisible = MappedSubject.create(SubscribableMapFunctions.nor(), this.isNormalMenuActive);
        this.isChklOvrdButtonVisible = MappedSubject.create(SubscribableMapFunctions.nor(), this.isNormalMenuActive);
        this.isChklResetButtonVisible = MappedSubject.create(SubscribableMapFunctions.nor(), this.isNormalMenuActive);
        this.isOvrdButtonVisible = MappedSubject.create(SubscribableMapFunctions.nor(), this.isNormalMenuActive);
        this.isChecklistCompleteAlertVisible = MappedSubject.create(SubscribableMapFunctions.and(), this.isNormalMenuActive.map(x => !x), this.props.repo.isActiveChecklistComplete);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.repo.activeChecklist.sub(activeChecklist => {
            this.items.set(activeChecklist.items);
        }, true);
        this.isNormalMenuActive.sub(isNormalMenuSelected => {
            this.checklistItemsRef.instance.classList.toggle('hidden', isNormalMenuSelected);
            this.checklistTitleRef.instance.classList.toggle('hidden', isNormalMenuSelected);
            this.checklistMenuTitleRef.instance.classList.toggle('hidden', !isNormalMenuSelected);
        }, true);
    }
    /**
     * Handler when any top menu button is clicked.(NORMAL, RESET, NON-NORMAL)
     * @param menu The menu button that was clicked.
     */
    onMenuButtonClicked(menu) {
        if (menu === this.activeMenu.get()) {
            this.activeMenu.set(ChecklistMenu.None);
        }
        else {
            this.activeMenu.set(menu);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "checklist-page" },
            FSComponent.buildComponent("div", { class: "top-row-buttons" },
                FSComponent.buildComponent(BoeingMfdButton, { class: ['chkl-normal-menu-button'], selected: this.isNormalMenuActive, onClick: () => this.onMenuButtonClicked(ChecklistMenu.Normal) }, "NORMAL MENU"),
                FSComponent.buildComponent(BoeingMfdButton, { class: ['chkl-resets-button'], isDisabled: true, onClick: () => this.onMenuButtonClicked(ChecklistMenu.Resets) }, "RESETS"),
                FSComponent.buildComponent(BoeingMfdButton, { class: ['chkl-non-normal-menu-button'], isDisabled: true, onClick: () => this.onMenuButtonClicked(ChecklistMenu.NonNormal) }, "NON-NORMAL MENU")),
            FSComponent.buildComponent("div", { class: 'checklist-title-menu', ref: this.checklistMenuTitleRef }, "NORMAL MENU"),
            FSComponent.buildComponent("div", { class: {
                    'checklist-list-of-normal-items': true,
                    'hidden': this.isNormalMenuActive.map(x => !x),
                } },
                FSComponent.buildComponent(BoeingUiControlList, { data: ArraySubject.create(this.props.repo.getNormalChecklistNames()), renderItem: checklistName => FSComponent.buildComponent(ChecklistMenuItem, { repo: this.props.repo, checklistName: checklistName, onChecklistSelected: () => this.activeMenu.set(ChecklistMenu.None) }) })),
            FSComponent.buildComponent("div", { class: 'checklist-title-middle hidden', ref: this.checklistTitleRef },
                "\uD83D\uDF82",
                this.props.repo.activeChecklistName.map((nameOfCheckList) => nameOfCheckList),
                "\uD83D\uDF80"),
            FSComponent.buildComponent("div", { class: 'checklist-options hidden', ref: this.checklistItemsRef },
                FSComponent.buildComponent(BoeingUiControlList, { ref: this.list, data: this.items, renderItem: (data, index) => (FSComponent.buildComponent(ChecklistItem, { checklistName: this.props.repo.activeChecklistName.get(), itemIndex: index, checklistItem: data, repo: this.props.repo })) })),
            FSComponent.buildComponent("div", { class: {
                    'chkl-complete-text': true,
                    'hidden': this.isChecklistCompleteAlertVisible.map(x => !x),
                } }, "CHECKLIST COMPLETE"),
            FSComponent.buildComponent("div", { class: 'bottom-row-buttons' },
                FSComponent.buildComponent("div", { class: 'bottom-row-group' },
                    FSComponent.buildComponent(BoeingMfdButton, { isVisible: this.isNormalButtonVisible, class: ['chkl-normal-bottom-button'], onClick: () => {
                            if (!this.props.repo.nextNormalChecklist()) {
                                this.activeMenu.set(ChecklistMenu.Normal);
                            }
                        } }, "NORMAL"),
                    FSComponent.buildComponent(BoeingMfdButton, { class: ['chkl-item-ovrd-button'], isDisabled: true, isVisible: this.isOvrdButtonVisible },
                        FSComponent.buildComponent("span", null, "ITEM"),
                        FSComponent.buildComponent("span", null, "OVRD"))),
                FSComponent.buildComponent("div", { class: 'bottom-row-group' },
                    FSComponent.buildComponent(BoeingMfdButton, { class: ['chkl-chkl-ovrd-button'], isVisible: this.isChklOvrdButtonVisible, isDisabled: true },
                        FSComponent.buildComponent("span", null, "CHKL"),
                        FSComponent.buildComponent("span", null, "OVRD")),
                    FSComponent.buildComponent(BoeingMfdButton, { class: ['chkl-reset-button'], isVisible: this.isChklResetButtonVisible, onClick: () => this.props.repo.resetChecklist(this.props.repo.activeChecklistName.get()) },
                        FSComponent.buildComponent("span", null, "CHKL"),
                        FSComponent.buildComponent("span", null, "RESET"))),
                FSComponent.buildComponent("div", { class: 'bottom-row-group' },
                    FSComponent.buildComponent(BoeingMfdButton, { class: ['exit-menu-button'], isVisible: this.isNormalMenuActive, onClick: () => this.onMenuButtonClicked(ChecklistMenu.None) },
                        FSComponent.buildComponent("span", null, "EXIT"),
                        FSComponent.buildComponent("span", null, "MENU"))))));
    }
}
/** ChecklistItem component */
class ChecklistItem extends B787UiControl {
    constructor() {
        super(...arguments);
        this.isNextIncompleteItem = Subject.create(true);
        this.checkListItemTextDiv = FSComponent.createRef();
        this.inwardTickColorSubject = Subject.create('');
        this.entireCheckListItemDivRef = FSComponent.createRef();
    }
    /** @inheritDoc */
    onAfterRender() {
        this.props.checklistItem.state.sub(state => {
            this.checkListItemTextDiv.instance.classList.toggle('item-complete-state', state === BoeingChecklistItemState.Complete);
        }, true);
        this.entireCheckListItemDivRef.instance.addEventListener('click', () => this.handleCheckboxClicked());
    }
    /**
     * when the user checks off the item, check mark will appear and text turns green
     */
    handleCheckboxClicked() {
        const currentItemState = this.props.checklistItem.state.get();
        if (currentItemState === BoeingChecklistItemState.Complete) {
            this.props.repo.setChecklistItemState(this.props.checklistName, this.props.itemIndex, BoeingChecklistItemState.Incomplete);
        }
        else if (currentItemState === BoeingChecklistItemState.Incomplete) {
            this.props.repo.setChecklistItemState(this.props.checklistName, this.props.itemIndex, BoeingChecklistItemState.Complete);
        }
    }
    /**
     * Helper method that makes the line item text have the right amount of dots and formmated correctly
     * @returns the string
     */
    makeChecklistItemName() {
        const lengthOfName = this.props.checklistItem.name.length;
        const lengthOfTask = this.props.checklistItem.task.length;
        const textLengthWithoutDots = lengthOfName + lengthOfTask;
        const dots = '.'.repeat(40 - textLengthWithoutDots);
        return this.props.checklistItem.name + dots + this.props.checklistItem.task;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'chkl-item-display': true,
                'chkl-item-next-incomplete': this.isNextIncompleteItem,
                'chkl-item-complete': this.props.checklistItem.state.map(x => x === BoeingChecklistItemState.Complete),
            }, ref: this.entireCheckListItemDivRef },
            FSComponent.buildComponent(BoeingChecklistCheckbox, { isChecked: this.props.checklistItem.state.map(x => x === BoeingChecklistItemState.Complete), 
                // TODO Different for 748
                sizePx: 60 }),
            FSComponent.buildComponent("div", { class: "chkl-list-text", ref: this.checkListItemTextDiv }, this.makeChecklistItemName().split('').map(char => FSComponent.buildComponent("span", null, char)))));
    }
}
/**
 * Checklist Menu Item class
 */
class ChecklistMenuItem extends B787UiControl {
    /** @inheritDoc */
    onAfterRender() {
        //
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(BoeingMfdButton, { onClick: () => {
                this.props.repo.setActiveChecklist(this.props.checklistName);
                this.props.onChecklistSelected();
            } }, this.props.checklistName));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * The Repo class for the checklists.
 */
class BoeingChecklistRepository {
    /**
     * Builds the Repo for the checklists.
     * @param bus The bus.
     * @param mfdIndex The MFD Index.
     * @param normalChecklists The normal checklist options.
     * @param nonNormalChecklists The non-normal checklist options.
     */
    constructor(bus, mfdIndex, normalChecklists, nonNormalChecklists) {
        this.bus = bus;
        this.mfdIndex = mfdIndex;
        this.normalChecklists = normalChecklists;
        this.nonNormalChecklists = nonNormalChecklists;
        this._activeChecklistName = Subject.create(this.normalChecklists[0].name);
        this.activeChecklistName = this._activeChecklistName;
        this.activeChecklist = this._activeChecklistName.map(this.getChecklistByName.bind(this));
        this.isActiveChecklistComplete = Subject.create(false);
        this.publisher = this.bus.getPublisher();
        const sub = this.bus.getSubscriber();
        this.activeChecklist.sub(activeChecklist => {
            var _a;
            (_a = this.isActiveChecklistCompletePipe) === null || _a === void 0 ? void 0 : _a.destroy();
            this.isActiveChecklistCompletePipe = activeChecklist.isComplete.pipe(this.isActiveChecklistComplete);
        }, true);
        sub.on('boeing_checklist_event').handle(event => {
            if (event.mfdIndex === this.mfdIndex) {
                return;
            }
            switch (event.type) {
                case 'active_checklist_changed':
                    this.setActiveChecklist(event.newActiveChecklistName, false);
                    break;
                case 'checklist_reset':
                    this.resetChecklist(event.checklistName, false);
                    break;
                case 'item_changed':
                    this.setChecklistItemState(event.checklistName, event.itemIndex, event.itemState, false);
                    break;
            }
        });
    }
    /**
     * Get the Checklist searched by name.
     * @param name The name of the checklist.
     * @returns The Checklist that holds the given name.
     */
    getChecklistByName(name) {
        const normalChecklist = this.normalChecklists.find(x => x.name === name);
        const nonNormalChecklist = this.nonNormalChecklists.find(x => x.name === name);
        return normalChecklist !== null && normalChecklist !== void 0 ? normalChecklist : nonNormalChecklist;
    }
    /**
     * gets the next normal checklist in the given lists.
     * @returns If there is another list returns true otherwise false.
     */
    nextNormalChecklist() {
        const currentIndex = this.normalChecklists.findIndex(x => x.name === this.activeChecklist.get().name);
        const nextIndex = currentIndex + 1;
        const nextChecklist = this.normalChecklists[nextIndex];
        if (nextChecklist) {
            this.setActiveChecklist(nextChecklist.name);
            return true;
        }
        //if no more lists are left this false will tell the main menu to show up
        return false;
    }
    /**
     * Sets the new active checklist and sends the bus event.
     * @param name Name of new active checklist.
     * @param notify Whether to send the bus event. Defaults to true.
     */
    setActiveChecklist(name, notify = true) {
        this._activeChecklistName.set(name);
        if (notify) {
            this.publisher.pub('boeing_checklist_event', {
                type: 'active_checklist_changed',
                mfdIndex: this.mfdIndex,
                newActiveChecklistName: this._activeChecklistName.get(),
            }, true);
        }
    }
    /**
     * Sets the new active checklist and sends the bus event.
     * @param checklistName The name of the checklist containing the item.
     * @param itemIndex The item index.
     * @param itemState The new item state.
     * @param notify Whether to send the bus event. Defaults to true.
     */
    setChecklistItemState(checklistName, itemIndex, itemState, notify = true) {
        this.getChecklistByName(checklistName).items[itemIndex].state.set(itemState);
        if (notify) {
            this.publisher.pub('boeing_checklist_event', {
                type: 'item_changed',
                checklistName,
                itemIndex,
                itemState,
                mfdIndex: this.mfdIndex,
            }, true);
        }
    }
    /**
     * Resets all items in a checklist to incomplete.
     * @param checklistName The checklist name.
     * @param notify Whether to send the bus event. Defaults to true.
     */
    resetChecklist(checklistName, notify = true) {
        this.getChecklistByName(checklistName).items.forEach(x => x.state.set(BoeingChecklistItemState.Incomplete));
        if (notify) {
            this.publisher.pub('boeing_checklist_event', {
                type: 'checklist_reset',
                checklistName,
                mfdIndex: this.mfdIndex,
            }, true);
        }
    }
    /**
     * Gets a list of names for each checklist.
     * @returns List of names.
     */
    getNormalChecklistNames() {
        return this.normalChecklists.map(x => {
            return x.name;
        });
    }
}

/**
 * An active map flightplan waypoint icon that can be set to flash.
 */
class ActiveWaypointIcon extends MapWaypointImageIcon {
    constructor() {
        super(...arguments);
        this.isDisplayed = true;
    }
    /**
     * Sets whether or not the icon is displayed.
     * @param isDisplayed Whether or not the icon is displayed.
     */
    setDisplayed(isDisplayed) {
        this.isDisplayed = isDisplayed;
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, left, top) {
        if (this.isDisplayed) {
            super.drawIconAt(context, mapProjection, left, top);
        }
    }
}

/**
 * A collection of common keys used by the BoeingMap API.
 */
class BoeingMapKeys {
}
BoeingMapKeys.Tod = 'tod';
BoeingMapKeys.CtrWpt = 'ctrwpt';
BoeingMapKeys.CompassArcLowerLayer = 'compass-arc-lower-layer';
BoeingMapKeys.CompassArcUpperLayer = 'compass-arc-upper-layer';
BoeingMapKeys.CompassCenterLowerLayer = 'compass-center-lower-layer';
BoeingMapKeys.CompassCenterUpperLayer = 'compass-center-upper-layer';
BoeingMapKeys.MapFormatController = 'map-format-controller';
BoeingMapKeys.PlanFormatController = 'plan-format-controller';
BoeingMapKeys.RangeController = 'RangeController';
BoeingMapKeys.WaypointDisplayController = 'WaypointDisplayController';
BoeingMapKeys.PlanLowerLayer = 'plan-lower-layer';
BoeingMapKeys.PlanUpperLayer = 'plan-upper-layer';
BoeingMapKeys.OwnShipTriLayer = 'ownship-tri';
BoeingMapKeys.OwnShipOutlineLayer = 'ownship-outline';
BoeingMapKeys.OwnShipXtkErrorLayer = 'ownship-xtk-error';
BoeingMapKeys.PlanAirportsLayer = 'plan-airports';
BoeingMapKeys.PositionTrendVector = 'trackVector';
BoeingMapKeys.NdDataProvider = 'NdDataProvider';
BoeingMapKeys.MapStyles = 'MapStyles';
BoeingMapKeys.VNavData = 'VNavData';
BoeingMapKeys.TcasAdvisoryStatusLayer = 'tcas-advisory-status-layer';

/**
 * Updates the properties in a {@link MapAutopilotPropsModule}.
 */
class BoeingMapAutopilotPropsController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.subs.push(sub.on('ap_altitude_selected_3').atFrequency(4).handle(alt => this.module.selectedAltitude.set(alt, UnitType.FOOT)));
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.subs.forEach(sub => sub.destroy());
    }
}

/** Bitflags that describe which map waypoint types should be displayed. */
var MapWaypointsDisplay;
(function (MapWaypointsDisplay) {
    MapWaypointsDisplay[MapWaypointsDisplay["None"] = 0] = "None";
    MapWaypointsDisplay[MapWaypointsDisplay["NearestAirports"] = 1] = "NearestAirports";
    MapWaypointsDisplay[MapWaypointsDisplay["HiNavaids"] = 2] = "HiNavaids";
    MapWaypointsDisplay[MapWaypointsDisplay["LoNavaids"] = 4] = "LoNavaids";
    MapWaypointsDisplay[MapWaypointsDisplay["Intersections"] = 8] = "Intersections";
    MapWaypointsDisplay[MapWaypointsDisplay["TerminalWaypoints"] = 16] = "TerminalWaypoints";
    MapWaypointsDisplay[MapWaypointsDisplay["ETA"] = 32] = "ETA";
    MapWaypointsDisplay[MapWaypointsDisplay["Speed"] = 64] = "Speed";
    MapWaypointsDisplay[MapWaypointsDisplay["Altitude"] = 128] = "Altitude";
    MapWaypointsDisplay[MapWaypointsDisplay["Airports"] = 256] = "Airports";
    MapWaypointsDisplay[MapWaypointsDisplay["NDBs"] = 512] = "NDBs";
    MapWaypointsDisplay[MapWaypointsDisplay["MissedApproach"] = 1024] = "MissedApproach";
})(MapWaypointsDisplay || (MapWaypointsDisplay = {}));
/** Features that a map format can support. */
var MapFormatFeatures;
(function (MapFormatFeatures) {
    MapFormatFeatures[MapFormatFeatures["None"] = 0] = "None";
    MapFormatFeatures[MapFormatFeatures["Weather"] = 1] = "Weather";
    MapFormatFeatures[MapFormatFeatures["Terrain"] = 2] = "Terrain";
    MapFormatFeatures[MapFormatFeatures["AltitudeArc"] = 4] = "AltitudeArc";
    MapFormatFeatures[MapFormatFeatures["PositionTrendVector"] = 8] = "PositionTrendVector";
})(MapFormatFeatures || (MapFormatFeatures = {}));
/** Info and function common across Boeing maps. */
class BoeingMapCommon {
}
BoeingMapCommon.COMPASS_FORMAT_COMMON_LAYER_KEYS = [
    BoeingMapKeys.OwnShipTriLayer,
    BoeingMapKeys.OwnShipXtkErrorLayer,
];
BoeingMapCommon.PLAN_FORMAT_COMMON_LAYER_KEYS = [
    BoeingMapKeys.OwnShipOutlineLayer,
];
BoeingMapCommon.COMPASS_DEFAULT_CONFIG = {
    rotationType: MapRotation.TrackUp,
    features: MapFormatFeatures.Terrain | MapFormatFeatures.Weather | MapFormatFeatures.AltitudeArc | MapFormatFeatures.PositionTrendVector,
};
BoeingMapCommon.PLAN_DEFAULT_CONFIG = {
    rotationType: MapRotation.NorthUp,
    features: MapFormatFeatures.None,
};
BoeingMapCommon.tunedVorRole = 'tunedVorRole';

/**
 * A map system controller that controls the display settings of the various format
 * and terrain/wxr combinations.
 */
class BoeingMapFormatController extends MapSystemController {
    /**
     * Creates an instance of the BoeingMapFormatController.
     * @param context The map system context to use with this controller.
     * @param canvasScale The canvas scale.
     * @param currentMapFormatConfig A subscribable for the current map format config.
     * @param terrWxState A subscribable for the current terr wx state.
     */
    constructor(context, canvasScale, currentMapFormatConfig, terrWxState) {
        super(context);
        this.canvasScale = canvasScale;
        this.currentMapFormatConfig = currentMapFormatConfig;
        this.terrWxState = terrWxState;
        this.blankTerrainColors = BingComponent.createEarthColorsArray('#000000', [
            { elev: 0, color: '#000000' }
        ], 0, 30000, 1);
        this.terrModeTerrainColors = BingComponent.createEarthColorsArray('#000000', [
            { elev: 0, color: '#FF0000' },
            { elev: 500, color: '#FFFF00' },
            { elev: 1000, color: '#00FF00' },
            { elev: 2000, color: '#000000' }
        ]);
        this.terrain = this.context.model.getModule(MapSystemKeys.TerrainColors);
        this.wxr = this.context.model.getModule(MapSystemKeys.Weather);
        this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
        this.altitudeArcModule = this.context.model.getModule(MapSystemKeys.AltitudeArc);
        this.positionTrendVectorModule = this.context.model.getModule(BoeingMapKeys.PositionTrendVector);
        this.bingLayer = this.context.getLayer(MapSystemKeys.Bing);
        this.sub = this.context.bus.getSubscriber();
        this.isOnGround = ConsumerSubject.create(this.sub.on('on_ground').whenChanged().atFrequency(0.2), true);
        this.currentFormatLayerKeys = [];
        this.wxr.weatherRadarArc.set(180);
        this.wxr.weatherRadarMode.set(EWeatherRadar.HORIZONTAL);
    }
    /** @inheritdoc */
    onAfterMapRender() {
        // Bing layer should always be visible so that you can use the airport map
        this.bingLayer.setVisible(true);
        this.currentMapFormatConfig.sub(this.handleFormatConfigChanged.bind(this), true);
        this.currentMapFormatConfig.sub(this.updateBingLayer.bind(this), true);
        this.isOnGround.sub(this.updateBingLayer.bind(this), true);
        this.terrWxState.sub(this.updateBingLayer.bind(this), true);
    }
    /** Updates the bing layer according to the current terr wx state and format. */
    updateBingLayer() {
        const terrWxState = this.terrWxState.get();
        if (terrWxState === 'TERR') {
            this.handleTerr();
        }
        else if (terrWxState === 'WX') {
            this.handleWxr();
        }
        else {
            this.handleOff();
        }
    }
    /** Handles when the terrain system is on. */
    handleTerr() {
        this.terrain.reference.set(EBingReference.PLANE);
        // Hide terrain when on ground
        if (this.isOnGround.get() || !BitFlags.isAll(this.currentMapFormatConfig.get().features, MapFormatFeatures.Terrain)) {
            this.terrain.colors.set(this.blankTerrainColors);
        }
        else {
            this.terrain.colors.set(this.terrModeTerrainColors);
        }
        this.wxr.isEnabled.set(false);
    }
    /** Handles when the WXR system is on. */
    handleWxr() {
        this.terrain.reference.set(EBingReference.SEA);
        this.terrain.colors.set(this.blankTerrainColors);
        this.wxr.isEnabled.set(BitFlags.isAll(this.currentMapFormatConfig.get().features, MapFormatFeatures.Weather));
    }
    /** Handles when the terrain/wxr system is off. */
    handleOff() {
        this.terrain.reference.set(EBingReference.SEA);
        this.terrain.colors.set(this.blankTerrainColors);
        this.wxr.isEnabled.set(false);
    }
    /** Handles the map format config changing. */
    handleFormatConfigChanged() {
        const mapFormatConfig = this.currentMapFormatConfig.get();
        this.context.projection.setQueued({ targetProjectedOffset: this.getOffset(mapFormatConfig) });
        this.context.projection.setQueued({ rangeEndpoints: this.getRangeEndpoints(mapFormatConfig) });
        this.rotationModule.rotationType.set(mapFormatConfig.rotationType);
        this.altitudeArcModule.show.set(BitFlags.isAll(mapFormatConfig.features, MapFormatFeatures.AltitudeArc));
        this.positionTrendVectorModule.show.set(BitFlags.isAll(mapFormatConfig.features, MapFormatFeatures.PositionTrendVector));
        this.updateLayerVisibility();
    }
    /**
     * Sets the map target offset for the specified format.
     * @param formatConfig The format config to use.
     * @returns The target projected offset.
     */
    getOffset(formatConfig) {
        const offset = Vec2Math.create(0, formatConfig.targetProjectedOffsetUnscaledY);
        return Vec2Math.multScalar(offset, this.canvasScale, offset);
    }
    /**
     * Calculates the range endpoints for a given format config.
     * @param formatConfig The format config to use.
     * @returns The calculated range endpoints.
     */
    getRangeEndpoints(formatConfig) {
        const formatCenterY = (formatConfig.mapHeightUnscaled / 2) + formatConfig.targetProjectedOffsetUnscaledY;
        // With arc style formats, the lower endpoint is just the center
        const lowerEndpoint = formatConfig.compassType === 'arc'
            ? formatCenterY
            : formatCenterY + formatConfig.compassRadiusUnscaled;
        // Upper endpoint is same for both compass types
        const upperEndpoint = formatCenterY - formatConfig.compassRadiusUnscaled;
        // Divide by map height to make it a ratio
        // We put 0.5 for the x value because all the formats are centered horizontally
        const rangeEndpoints = VecNMath.create(4, 0.5, lowerEndpoint / formatConfig.mapHeightUnscaled, 0.5, upperEndpoint / formatConfig.mapHeightUnscaled);
        return rangeEndpoints;
    }
    /** Hides the layers for the previous format, and enbales the ones for the new format. */
    updateLayerVisibility() {
        const mapFormatConfig = this.currentMapFormatConfig.get();
        this.currentFormatLayerKeys.forEach(layerKey => {
            (this.context.getLayer(layerKey)).setVisible(false);
        });
        this.currentFormatLayerKeys = mapFormatConfig.layerKeys;
        this.currentFormatLayerKeys.forEach(layerKey => {
            (this.context.getLayer(layerKey)).setVisible(true);
        });
    }
}

/** A controller which handles map traffic settings. */
class BoeingMapTrafficController extends MapSystemController {
    /**
     * Constructor.
     * @param context The map system context to use with this controller.
     * @param ndDataProvider The ND data provider.
     */
    constructor(context, ndDataProvider) {
        super(context);
        this.ndDataProvider = ndDataProvider;
        this.trafficModule = this.context.model.getModule(MapSystemKeys.Traffic);
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.wireSettings();
    }
    /**
     * Wires the controller to the settings manager.
     */
    wireSettings() {
        this.subs.push(this.ndDataProvider.showTfc.sub(show => {
            this.trafficModule.show.set(show);
        }, true), this.ndDataProvider.mapRange.sub(range => {
            this.trafficModule.offScaleRange.set(range, UnitType.NMILE);
        }, true));
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.subs.forEach(sub => sub.destroy());
    }
}
BoeingMapTrafficController.ALTITUDE_RESTRICTION_NORMAL = UnitType.FOOT.createNumber(2700);
BoeingMapTrafficController.ALTITUDE_RESTRICTION_FULL = UnitType.FOOT.createNumber(9900);

/** Util functions for boeing maps. */
class BoeingMapUtils {
    /**
     * Determines whether an altitude for a leg should be displayed on the map.
     * @param leg the leg def
     * @returns whther to show the altitude
     */
    static showAltitudeForLeg(leg) {
        if (leg.leg.fixIcao[0] === 'R') {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.CA:
            case LegType.VA:
                return false;
            default:
                return true;
        }
    }
}

/** Updates the VNavData module. */
class BoeingVNavDataController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
        this.vnavDataModule = this.context.model.getModule(BoeingMapKeys.VNavData);
        this.activeRoutePlanSubject = this.flightPlanModule.getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.activeRoutePlanSubject.activeLeg.sub(this.updateNextConstraint.bind(this));
        this.activeRoutePlanSubject.flightPlan.sub(this.updateNextConstraint.bind(this));
        this.activeRoutePlanSubject.planChanged.on(this.updateNextConstraint.bind(this));
        this.updateNextConstraint();
    }
    /** Updates the next constraint. */
    updateNextConstraint() {
        this.vnavDataModule.nextConstraintLegDefForMap.set(this.getNextConstraint());
    }
    /**
     * Gets the next constraint.
     * @returns the next constraint leg def.
     */
    getNextConstraint() {
        const planSubject = this.flightPlanModule.getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX);
        const activeLeg = planSubject.activeLeg.get();
        const plan = planSubject.flightPlan.get();
        if (!plan) {
            return undefined;
        }
        for (const leg of plan.legs(false, activeLeg)) {
            if (BoeingMapUtils.showAltitudeForLeg(leg) === false) {
                continue;
            }
            if (leg.verticalData.altDesc !== AltitudeRestrictionType.Unused) {
                return leg;
            }
        }
        return undefined;
    }
}

/**
 * A controller that handles map range settings.
 */
class MapRangeController extends MapSystemController {
    /**
     * Creates an instance of the MapRangeController.
     * @param context The map system context to use with this controller.
     * @param mapRange The map range.
     */
    constructor(context, mapRange) {
        super(context);
        this.mapRange = mapRange;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.wireSettings();
    }
    /**
     * Wires the controller to the settings manager.
     */
    wireSettings() {
        this.mapRange.sub(this.handleRangeChanged.bind(this), true);
    }
    /**
     * Handles when the range changes.
     * @param range The range of the map, in nautical miles.
     */
    handleRangeChanged(range) {
        this.context.projection.setQueued({ range: UnitType.NMILE.convertTo(range, UnitType.GA_RADIAN) });
    }
}

/** A map system controller that controls the display settings of the nearest waypoints. */
class MapWaypointDisplayController extends MapSystemController {
    /**
     * Creates an instance of the WaypointDisplayController.
     * @param context The map system context to use with this controller.
     * @param mapWaypointsDisplay A subscribable MapWaypointsDisplay.
     */
    constructor(context, mapWaypointsDisplay) {
        var _a;
        super(context);
        this.mapWaypointsDisplay = mapWaypointsDisplay;
        this.waypoints = this.context.model.getModule(MapSystemKeys.NearestWaypoints);
        // selectWaypointModule is only on the ND, not on the minimap
        this.selectWaypointModule = this.context.model.getModule(BoeingMapKeys.CtrWpt);
        this.navComSub = this.context.bus.getSubscriber();
        this.tunedVorIdents = ['', ''];
        this.waypointRenderer = this.context[MapSystemKeys.WaypointRenderer];
        this.systemWaypointRole = (_a = this.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.Normal)) !== null && _a !== void 0 ? _a : 0;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.wireSettings();
    }
    /**
     * Wires the settings system to the waypoint display controller.
     */
    wireSettings() {
        var _a;
        this.mapWaypointsDisplay.sub((v) => this.handleSettingsChanged(v), true);
        this.waypoints.waypointRoleSelector.set(w => {
            const facility = w.facility.get();
            const isVor = ICAO.isFacility(facility.icao, FacilityType.VOR);
            const identMatch = this.tunedVorIdents.includes(ICAO.getIdent(facility.icao));
            if (isVor && identMatch) {
                return BoeingMapCommon.tunedVorRole;
            }
            else {
                return MapSystemWaypointRoles.Normal;
            }
        });
        this.navComSub.on('nav_ident_1').whenChanged().handle(ident => {
            this.tunedVorIdents[0] = ident;
            this.waypoints.refreshWaypoints.notify();
        });
        this.navComSub.on('nav_ident_2').whenChanged().handle(ident => {
            this.tunedVorIdents[1] = ident;
            this.waypoints.refreshWaypoints.notify();
        });
        // selectWaypointModule is only on the ND, not on the minimap
        (_a = this.selectWaypointModule) === null || _a === void 0 ? void 0 : _a.facility.sub(this.updateDisplayWaypoint.bind(this));
    }
    /**
     * Determines if a map waypoint should be displayed because it is the selected facility.
     * @param shouldShow The current setting value for that facility type.
     * @returns A function that is checking if the waypoint is the selected waypoint.
     */
    shouldShowWaypoint(shouldShow) {
        return (w) => {
            // selectWaypointModule is only on the ND, not on the minimap
            if (this.selectWaypointModule && FacilityWaypointUtils.isFacilityWaypoint(w) && w.facility.get().icao === this.selectWaypointModule.facilityIcao.get()) {
                return true;
            }
            return shouldShow;
        };
    }
    /**
     * Handles when the waypoint display settings mask has changed.
     * @param mask The waypoint display settings mask to apply.
     */
    handleSettingsChanged(mask) {
        this.waypoints.showAirports.set(this.shouldShowWaypoint(BitFlags.isAll(mask, MapWaypointsDisplay.Airports)));
        this.waypoints.showIntersections.set(this.shouldShowWaypoint(BitFlags.isAll(mask, MapWaypointsDisplay.Intersections)));
        // NDB's are not shown on the 787 with STA enabled, but we will show them when centered on with CTR ON
        this.waypoints.showNdbs.set(this.shouldShowWaypoint(false));
        this.waypoints.showVors.set(w => {
            if (this.tunedVorIdents.includes(ICAO.getIdent(w.facility.get().icao))) {
                return true;
            }
            return this.shouldShowWaypoint(BitFlags.isAny(mask, MapWaypointsDisplay.HiNavaids | MapWaypointsDisplay.LoNavaids))(w);
        });
    }
    /**
     * Updates the displayed facility.
     * @param facility The facility to display.
     */
    updateDisplayWaypoint(facility) {
        this.displayWaypoint && this.waypointRenderer.deregister(this.displayWaypoint, this.systemWaypointRole, 'waypoints-layer');
        if (facility !== null) {
            this.displayWaypoint = new BasicFacilityWaypoint(facility, this.context.bus);
            if (!this.waypointRenderer.isRegistered(this.displayWaypoint)) {
                this.waypointRenderer.register(this.displayWaypoint, this.systemWaypointRole, 'waypoints-layer');
            }
        }
    }
}
MapWaypointDisplayController.CtrWaypointRole = 'CtrWptRole';

/** Display modes for PlanAirportsLayer. */
var PlanAirportsLayerDisplayMode;
(function (PlanAirportsLayerDisplayMode) {
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["None"] = 1] = "None";
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["AirportMap"] = 2] = "AirportMap";
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["Near"] = 4] = "Near";
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["Far"] = 8] = "Far";
})(PlanAirportsLayerDisplayMode || (PlanAirportsLayerDisplayMode = {}));
/** A module that controls display of airport runways. */
class AirportRunwayDisplayModule {
    constructor() {
        /** The current display mode of the plan airports layer */
        this.displayMode = Subject.create(PlanAirportsLayerDisplayMode.None);
        /** Whether or not runway labels should be displayed */
        this.displayLabels = Subject.create(true);
        /** Whether or not the runways themselves should be displayed. */
        this.displayRunways = Subject.create(true);
        /**
         * Highlights an airport which may not already be contained in the set of
         * nearest airports to already be displayed.
         */
        this.focusAirports = ArraySubject.create([]);
    }
}

/** A module that contains the map styles. */
class BoeingMapStylesModule {
    /**
     * Creates a new BoeingMapStylesModule.
     * @param styles The styles.
     */
    constructor(styles) {
        this.styles = styles;
    }
}

/** Provides vnav data. */
class BoeingVNavDataModule {
    constructor() {
        /** Holds the leg def for the next or current altitude constraint,
         * for the purposes of displaying the altitude constraitn on the map when DATA is off. */
        this.nextConstraintLegDefForMap = Subject.create(undefined);
    }
}

/**
 * A module which defines an icao to select.
 */
class MapFacilitySelectModule {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        /** The ICAO of the facility to select. */
        this.facilityIcao = Subject.create(null);
        this.facility = Subject.create(null);
        this.userFacility = Subject.create(null);
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(bus));
        this.facilityIcao.sub(this.updateFacility.bind(this), false);
        this.userFacility.sub(this.updateFacility.bind(this), false);
    }
    /** Updates the facility. */
    async updateFacility() {
        const facilityIcao = this.facilityIcao.get();
        const userFacility = this.userFacility.get();
        if (facilityIcao) {
            if (facilityIcao === (userFacility === null || userFacility === void 0 ? void 0 : userFacility.icao)) {
                this.facility.set(userFacility);
            }
            else {
                const facility = await this.facLoader.getFacility(ICAO.getFacilityType(facilityIcao), facilityIcao);
                this.facility.set(facility);
            }
        }
        else {
            this.facility.set(null);
        }
    }
}

/** A module describing the display of the position trend vector. */
class MapPositionTrendVectorModule {
    /**
     * MapPositionTrendVectorModule constructor.
     * @param show When passed, the `show` field will be initialized to this value.
     */
    constructor(show) {
        /** Whether to show the position trend vector. */
        this.show = Subject.create(false);
        if (show !== undefined) {
            this.show.set(show);
        }
    }
}

/** A map system controller that controls the display of airports and runways. */
class PlanAirportsRunwaysController extends MapSystemController {
    /**
     * Creates an instance of the PlanAirportsRunwaysController.
     * @param context The map system context to use with this controller.
     * @param facLoader The fac loader.
     * @param flightPlanner The flight planner.
     * @param ndDataProvider The ND Data Provider.
     * @param pfdOrMfd pfd or mfd.
     */
    constructor(context, facLoader, flightPlanner, ndDataProvider, pfdOrMfd) {
        super(context);
        this.context = context;
        this.facLoader = facLoader;
        this.flightPlanner = flightPlanner;
        this.ndDataProvider = ndDataProvider;
        this.pfdOrMfd = pfdOrMfd;
        this.module = this.context.model.getModule(BoeingMapKeys.PlanAirportsLayer);
        this.subs = [];
        // 2d array, outer array is by plan index, inner array is the active airport icaos that we want to render
        this.icaos = [];
        this.onRangeChanged = (range) => {
            if (range >= 80) {
                this.module.displayMode.set(PlanAirportsLayerDisplayMode.Far);
                // Manual says 10 NM and above but I have a photo showing it at 2 NM in PLAN
                // But maybe it's always visible in PLAN, who knows
            }
            else if (range >= 2) {
                this.module.displayMode.set(PlanAirportsLayerDisplayMode.Near);
            }
            else {
                this.module.displayMode.set(PlanAirportsLayerDisplayMode.AirportMap);
            }
        };
        this.handlePlanLoad = (event) => {
            this.syncPlanAirportsToMap(event.planIndex).then();
        };
        this.handlePlanCopied = (event) => {
            this.syncPlanAirportsToMap(event.targetPlanIndex).then();
        };
        this.loadExistingFlightPlans();
        const planSub = this.context.bus.getSubscriber();
        this.subs = [
            planSub.on('fplOriginDestChanged').handle(this.handlePlanLoad),
            planSub.on('fplCreated').handle(this.handlePlanLoad),
            planSub.on('fplLoaded').handle(this.handlePlanLoad),
            planSub.on('fplProcDetailsChanged').handle(this.handlePlanLoad),
            planSub.on('fplCopied').handle(this.handlePlanCopied),
        ];
        if (this.pfdOrMfd === 'MFD') {
            this.subs.push(this.ndDataProvider.mapRange.sub(this.onRangeChanged, true));
        }
        else {
            this.module.displayMode.set(PlanAirportsLayerDisplayMode.Near);
        }
    }
    /** Loads existing flight plans. */
    loadExistingFlightPlans() {
        [BoeingFms.ACT_RTE_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, BoeingFms.RTE_1_MOD_PLAN_INDEX].forEach(planIndex => {
            if (this.flightPlanner.hasFlightPlan(planIndex)) {
                this.syncPlanAirportsToMap(planIndex);
            }
        });
    }
    /**
     * Syncs flight plan airports to the plan airports module
     * @param planIndex The flight plan index to sync from.
     */
    async syncPlanAirportsToMap(planIndex) {
        this.icaos[planIndex] = [];
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        if (plan.originAirport && plan.destinationAirport && plan.originAirport === plan.destinationAirport) {
            this.icaos[planIndex].push(plan.originAirport);
        }
        else {
            if (plan.originAirport) {
                this.icaos[planIndex].push(plan.originAirport);
            }
            if (plan.destinationAirport) {
                this.icaos[planIndex].push(plan.destinationAirport);
            }
        }
        // Clear airports that should not be there
        this.module.focusAirports.getArray().forEach((focusAirport, i) => {
            if (focusAirport.planIndex === planIndex && !this.icaos[planIndex].includes(focusAirport.airport.facility.get().icao)) {
                this.module.focusAirports.removeAt(i);
            }
        });
        if (plan.originAirport && plan.destinationAirport && plan.originAirport === plan.destinationAirport) {
            await this.ensureAirportAndRunwayOnMap(planIndex, plan.originAirport, plan.procedureDetails.originRunway, plan.procedureDetails.destinationRunway);
        }
        else {
            if (plan.originAirport) {
                await this.ensureAirportAndRunwayOnMap(planIndex, plan.originAirport, plan.procedureDetails.originRunway, undefined);
            }
            if (plan.destinationAirport) {
                await this.ensureAirportAndRunwayOnMap(planIndex, plan.destinationAirport, undefined, plan.procedureDetails.destinationRunway);
            }
        }
    }
    /**
     * Ensures an airport is present in the plan airports module. Removes any existing instances before inserting
     * @param planIndex the flight plan index
     * @param airportIcao the airport icao
     * @param departureRunway the departure one way runway if applicable
     * @param arrivalRunway the arrival one way runway if applicable
     */
    async ensureAirportAndRunwayOnMap(planIndex, airportIcao, departureRunway, arrivalRunway) {
        const facility = await this.facLoader.getFacility(FacilityType.Airport, airportIcao);
        const wp = new BasicFacilityWaypoint(facility, this.context.bus);
        const array = this.module.focusAirports.getArray();
        const existingEntry = array.findIndex((item) => item.planIndex === planIndex && item.airport.facility.get().icao === airportIcao);
        if (existingEntry !== -1) {
            this.module.focusAirports.removeAt(existingEntry);
        }
        if (!this.icaos[planIndex].includes(airportIcao)) {
            // Because this is async, the airport could have been removed by now
            // so don't add it if it's not still in the icaos list
            return;
        }
        this.module.focusAirports.insert({ planIndex, airport: wp, departureRunway, arrivalRunway });
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.subs.forEach(sub => sub.destroy());
    }
}

/**
 * A controller for the PLAN map format.
 */
class PlanFormatController extends MapSystemController {
    /**
     * Creates an instance of the PlanFormatController.
     * @param context The map system context to use with this controller.
     * @param displayIndex The index of the display, 1 or 2.
     * @param flightPlanner The flight planner to use with this controller.
     * @param ndDataProvider The nd data provider.
     */
    constructor(context, displayIndex, flightPlanner, ndDataProvider) {
        super(context);
        this.displayIndex = displayIndex;
        this.flightPlanner = flightPlanner;
        this.ndDataProvider = ndDataProvider;
        this.targetControlModerator = this.context[MapSystemKeys.TargetControl];
        this.facilitySelectModule = this.context.model.getModule(BoeingMapKeys.CtrWpt);
        // private readonly fmsPosSetting;
        this.currentFmsPos = new LatLongAlt(0, 0);
        this.currentFocusIndex = 0;
        this.gnssEventSub = this.context.bus.getSubscriber();
        this.aircraftLatLongPos = ConsumerSubject.create(this.gnssEventSub.on('gps-position').whenChanged(), new LatLongAlt(0, 0));
        this.isDisconnected = true;
        this.location = new GeoPoint(0, 0);
        this.hasPlanChanged = true;
        this.prevFocusIndex = -1;
        this.prevMaxIndex = -1;
        this.trackingActiveLeg = true;
        this.targetParam = {
            target: new GeoPoint(0, 0)
        };
        this.planHasTargetControl = false;
        this.targetControlConsumer = {
            priority: 10,
            onAcquired: () => {
                this.planHasTargetControl = true;
                // force location reset
                this.hasPlanChanged = true;
                if (this.location.lat === 0 && this.location.lon === 0) {
                    this.location.set(this.aircraftLatLongPos.get().lat, this.aircraftLatLongPos.get().long);
                }
                this.updateMapPosition();
            },
            onCeded: () => {
                this.planHasTargetControl = false;
            }
        };
        // this.fmsPosSetting = FmcUserSettings.getManager(this.context.bus).getSetting('lastFmsPos');
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.wireSettings();
    }
    /**
     * Update map position after changes in Lat Long data.
     * @param location A Facility or LatLonInferface.
     */
    updateMapPositionByLocation(location) {
        this.location.set(location.lat, location.lon);
        this.updateMapPosition();
    }
    /**
     * Wires the controller.
     */
    wireSettings() {
        this.facilitySelectModule.facility.sub((v) => {
            const destAirport = v;
            if (destAirport) {
                this.updateMapPositionByLocation(destAirport);
            }
        });
        this.ndDataProvider.isPlanFormat.sub(isPlanFormat => {
            if (isPlanFormat) {
                this.targetControlModerator.claim(this.targetControlConsumer);
            }
            else {
                this.targetControlModerator.forfeit(this.targetControlConsumer);
            }
        }, true);
        this.ndDataProvider.mapWaypointsDisplay.sub(this.updateMapPosition.bind(this), true);
        const subscriber = this.context.bus.getSubscriber();
        subscriber.on('fplCopied').handle((e) => { if (e.targetPlanIndex == 0) {
            this.hasPlanChanged = true;
        } });
        subscriber.on('fplCalculated').handle((e) => {
            if (e.planIndex == 0) {
                if (this.trackingActiveLeg && this.hasValidFlightPlan()) {
                    this.isDisconnected = false;
                    this.currentFocusIndex = this.flightPlanner.getFlightPlan(0).activeLateralLeg;
                }
                this.updateMapPosition();
            }
        });
        subscriber.on('plan_map_next').handle(i => {
            if (i === this.displayIndex && this.hasValidFlightPlan()) {
                this.isDisconnected = false;
                this.trackingActiveLeg = false;
                this.facilitySelectModule.facilityIcao.set(null);
                this.currentFocusIndex++;
                this.updateMapPosition();
            }
        });
        subscriber.on('plan_map_prev').handle(i => {
            if (i === this.displayIndex && this.hasValidFlightPlan()) {
                this.isDisconnected = false;
                this.trackingActiveLeg = false;
                this.facilitySelectModule.facilityIcao.set(null);
                this.currentFocusIndex--;
                this.updateMapPosition();
            }
        });
        subscriber.on('plan_map_to').handle(i => {
            if (i === this.displayIndex && this.hasValidFlightPlan()) {
                this.isDisconnected = false;
                this.trackingActiveLeg = true;
                this.facilitySelectModule.facilityIcao.set(null);
                this.currentFocusIndex = this.flightPlanner.getFlightPlan(0).activeLateralLeg;
                this.updateMapPosition();
            }
            // else {
            //   this.enableTrackFmsPos();
            // }
        });
        subscriber.on('plan_map_ctr_wpt').handle(({ index, icao, position, userFacility }) => {
            if (index === this.displayIndex) {
                this.isDisconnected = true;
                this.trackingActiveLeg = false;
                this.facilitySelectModule.userFacility.set(userFacility !== null && userFacility !== void 0 ? userFacility : null);
                this.facilitySelectModule.facilityIcao.set(icao);
                if (position !== null) {
                    this.updateMapPositionByLocation(position);
                }
                else if (icao === null) {
                    this.isDisconnected = false;
                    this.trackingActiveLeg = true;
                }
            }
        });
        // this.fmsPosSetting.sub((v: string) => {
        //   if (this.trackingActiveLeg && !this.hasValidFlightPlan()) {
        //     this.currentFmsPos = LatLong.fromStringFloat(v) as LatLongAlt;
        //     this.enableTrackFmsPos();
        //     this.updateMapPosition();
        //   }
        // }, true);
    }
    // /**
    //  * Enables tracking the FMS position.
    //  */
    // private enableTrackFmsPos(): void {
    //   this.isDisconnected = true;
    //   // HINT: keep this on, so it will switch when a flightplan shows up
    //   this.trackingActiveLeg = true;
    //   this.location.set(new GeoPoint(this.currentFmsPos.lat, this.currentFmsPos.long));
    // }
    /**
     * Checks if there is a valid flightplan to display.
     * @returns True if there is a valid flightplan, false otherwise.
     */
    hasValidFlightPlan() {
        return (this.flightPlanner.hasActiveFlightPlan() && this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX).length > 0);
    }
    /**
     * Updates the current plan map position.
     */
    updateMapPosition() {
        if (this.planHasTargetControl) {
            if (this.isDisconnected) {
                this.targetParam.target.set(this.location);
                this.context.projection.setQueued(this.targetParam);
                this.prevFocusIndex = -1;
            }
            else if (this.flightPlanner.hasFlightPlan(0)
                && this.flightPlanner.getFlightPlan(0).length > 0
                && (this.hasPlanChanged || this.currentFocusIndex !== this.prevFocusIndex)) {
                this.hasPlanChanged = false;
                const plan = this.flightPlanner.getFlightPlan(0);
                const showMissedAppr = BitFlags.isAll(this.ndDataProvider.mapWaypointsDisplay.get(), MapWaypointsDisplay.MissedApproach);
                const mapIndex = VNavUtils.getMissedApproachLegIndex(plan);
                // If missed approach is hidden, you shouldn't be able to sequence to it in the PLAN map
                const maxIndex = showMissedAppr ? (plan.length - 1) : mapIndex;
                if (this.currentFocusIndex === this.prevFocusIndex && maxIndex !== this.prevMaxIndex && this.focusedLeg) {
                    // Try to find our previously focused leg in the modified plan
                    const newLegIndex = this.getLegIndexByIcao(this.focusedLeg.leg.fixIcao, plan, plan.activeLateralLeg);
                    this.currentFocusIndex = newLegIndex > -1 ? newLegIndex : plan.activeLateralLeg;
                }
                this.focusedLeg = this.findFocusableLeg(plan, maxIndex, MathUtils.clamp(this.currentFocusIndex - this.prevFocusIndex, -1, 1));
                this.prevFocusIndex = this.currentFocusIndex;
                this.prevMaxIndex = maxIndex;
                if (this.focusedLeg.calculated !== undefined && this.focusedLeg.calculated.endLat !== undefined && this.focusedLeg.calculated.endLon !== undefined) {
                    this.targetParam.target.set(this.focusedLeg.calculated.endLat, this.focusedLeg.calculated.endLon);
                    this.context.projection.setQueued(this.targetParam);
                }
            }
        }
    }
    /**
     * Tries to find a valid leg to focus based on the given search direction and proposed focus index.
     * @param plan The plan to search.
     * @param maxIndex The maximum index to search.
     * @param direction The search direction.
     * @returns The leg to focus.
     */
    findFocusableLeg(plan, maxIndex, direction) {
        this.currentFocusIndex = MathUtils.clamp(this.currentFocusIndex, plan.activeLateralLeg, maxIndex);
        const leg = plan.getLeg(this.currentFocusIndex);
        if (leg.leg.type === LegType.Discontinuity && this.currentFocusIndex > plan.activeLateralLeg && this.currentFocusIndex < maxIndex) {
            this.currentFocusIndex += direction;
            return this.findFocusableLeg(plan, maxIndex, direction);
        }
        return leg;
    }
    /**
     * Tries to find the index of a leg in the plan by ICAO
     * HINT: We can't use `getLegIndexFromLeg` because of the fpl copying on modification.
     * @param icao The ICAO of the leg to find.
     * @param plan The plan to search in.
     * @param startIndex The index of the leg to start the search from.
     * @returns The index of the leg, or -1 if not found.
     */
    getLegIndexByIcao(icao, plan, startIndex) {
        for (let i = startIndex; i < plan.length; i++) {
            const leg = plan.getLeg(i);
            if (leg.leg.fixIcao === icao) {
                return i;
            }
        }
        return -1;
    }
}

/** Creates a div with voerflow hidden, and an inner container to recenter things on. */
class MapCompassArcMask extends DisplayComponent {
    /** @inheritdoc */
    render() {
        if (this.props.isEnabled) {
            return (FSComponent.buildComponent("div", { class: "map-compass-offset-clipped", style: `position: absolute; top: 0px; width: 100%; height: ${this.props.maskHeightPx}px; overflow: hidden;` },
                FSComponent.buildComponent("div", { class: "map-compass-offset-clipped-inner", style: `position: absolute; top: 0px; width: 100%; height: ${this.props.innerHeightPx}px;
            display: flex; justify-content: center; align-items: center;` }, this.props.children)));
        }
        else {
            return FSComponent.buildComponent(FSComponent.Fragment, null, this.props.children);
        }
    }
}

/** Creates a div with the given compass svg size, and translates it to match the map projection offset. */
class MapCompassOffset extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.mapOffsetContainerStyles = ObjectSubject.create({
            'position': 'absolute',
            'display': 'flex',
            'justify-content': 'center',
            'align-items': 'center',
            'width': this.props.compassSvgSize ? (this.props.compassSvgSize + 'px') : '100%',
            'height': this.props.compassSvgSize ? (this.props.compassSvgSize + 'px') : '100%',
            'transform': `translate(0, ${this.props.targetProjectedOffsetY.get()}px)`,
        });
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.targetProjectedOffsetY.sub(offsetY => {
            this.mapOffsetContainerStyles.set('transform', `translate(0, ${offsetY}px)`);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-compass-offset", style: this.mapOffsetContainerStyles }, this.props.children));
    }
}

/**
 * A layer which shows the cross track error number of the airplane.
 * It is positioned below the projected location of the airplane.
 */
class MapCrossTrackErrorLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.xtkString = Subject.create('0.0');
        this.sub = this.props.bus.getSubscriber();
        this.rootStyle = ObjectSubject.create({
            'display': 'flex',
            'position': 'absolute',
            'left': -50 * this.props.canvasScale + 'px',
            'top': this.props.top * this.props.canvasScale + 'px',
            'min-width': 100 * this.props.canvasScale + 'px',
            'height': 100 * this.props.canvasScale + 'px',
            'color': 'white',
            'font-size': this.props.fontSize * this.props.canvasScale + 'px',
            'transform': 'translate3d(0, 0, 0)',
            'align-items': 'center',
            'justify-content': 'center',
            'margin': '0px',
            'padding': '0px 2px',
        });
        this.spanStyle = ObjectSubject.create({
            background: 'black',
            height: this.props.height * this.props.canvasScale + 'px',
            padding: this.props.padding * this.props.canvasScale + 'px',
        });
        this.ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        this.ownAirplaneIconModule = this.props.model.getModule('ownAirplaneIcon');
        this.visibilityBounds = VecNMath.create(4);
        this.iconTransform = CssTransformBuilder.translate3d('px');
        this.showIcon = true;
        this.needUpdateVisibility = false;
        this.needUpdatePosition = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.xtkSub = this.sub.on('lnav_xtk').whenChangedBy(0.1).atFrequency(1).handle((v) => {
            const suffix = v <= -0.1 ? 'L' : v >= 0.1 ? 'R' : '';
            let xtkFixed = Math.abs(MathUtils.clamp(v, -99.99, 99.99)).toFixed(1);
            if (MathUtils.round(Math.abs(v * 10), 0.1) < 1) {
                xtkFixed = '0.0';
            }
            this.xtkString.set(`${xtkFixed}  ${suffix}`.trim());
        });
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.needUpdateVisibility = true;
        this.needUpdatePosition = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    /** @inheritdoc */
    onAttached() {
        this.showSub = this.ownAirplaneIconModule.show.sub((show) => {
            this.needUpdateVisibility = true;
            this.needUpdatePosition = this.showIcon = show && this.isVisible();
        }, true);
        this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
            this.needUpdatePosition = this.showIcon;
        }, true);
        this.needUpdateVisibility = true;
    }
    /** @inheritdoc */
    onMapProjectionChanged() {
        this.needUpdatePosition = this.showIcon;
    }
    /** @inheritdoc */
    onUpdated() {
        if (this.needUpdatePosition) {
            this.updateIconPosition();
            this.needUpdatePosition = false;
            this.needUpdateVisibility = false;
        }
        else if (this.needUpdateVisibility) {
            this.updateIconVisibility();
            this.needUpdateVisibility = false;
        }
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
        this.rootStyle.set('display', this.showIcon ? 'flex' : 'none');
    }
    /**
     * Updates the airplane icon's projected position.
     */
    updateIconPosition() {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapCrossTrackErrorLayer.vec2Cache[0]);
        this.iconTransform.set(projected[0], projected[1], 0, 0.1);
        this.rootStyle.set('transform', this.iconTransform.resolve());
        this.updateIconVisibility();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-cross-track-error-container", style: this.rootStyle },
            FSComponent.buildComponent("span", { style: this.spanStyle }, this.xtkString)));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e;
        (_a = this.xtkSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.showSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.positionSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.iconSizeSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.iconAnchorSub) === null || _e === void 0 ? void 0 : _e.destroy();
        super.destroy();
    }
}
MapCrossTrackErrorLayer.vec2Cache = [Vec2Math.create()];

/**
 * A map layer which displays a track vector.
 */
class MapPositionTrendVectorLayer extends MapLayer {
    constructor() {
        var _a, _b, _c, _d;
        super(...arguments);
        this.lookaheadTime = NumberUnitSubject.create(UnitType.SECOND.createNumber(90));
        this.canvasLayerRef = FSComponent.createRef();
        this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapPositionTrendVectorLayer.DEFAULT_STROKE_WIDTH;
        this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapPositionTrendVectorLayer.DEFAULT_STROKE_STYLE;
        this.outlineWidth = (_c = this.props.outlineWidth) !== null && _c !== void 0 ? _c : MapPositionTrendVectorLayer.DEFAULT_OUTLINE_WIDTH;
        this.outlineStyle = (_d = this.props.outlineStyle) !== null && _d !== void 0 ? _d : MapPositionTrendVectorLayer.DEFAULT_OUTLINE_STYLE;
        this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.module = this.props.model.getModule(BoeingMapKeys.PositionTrendVector);
        this.arcTurnRateThreshold = !this.props.arcTurnRateThreshold
            ? undefined
            : (typeof this.props.arcTurnRateThreshold === 'object')
                ? this.props.arcTurnRateThreshold
                : Subject.create(this.props.arcTurnRateThreshold);
        this.arcMaxLookaheadTime = ('isSubscribable' in this.props.arcMaxLookaheadTime)
            ? this.props.arcMaxLookaheadTime
            : Subject.create(this.props.arcMaxLookaheadTime);
        this.projectedPlanePosition = Vec2Subject.createFromVector(new Float64Array(2));
        this.projectPlanePositionHandler = () => {
            const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapPositionTrendVectorLayer.vec2Cache[0]);
            this.projectedPlanePosition.set(projected);
        };
        this.turnRateSmoother = new ExpSmoother(500 / Math.LN2, undefined, 1000);
        this.needUpdate = false;
        this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a, _b;
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    /** @inheritdoc */
    onAttached() {
        var _a, _b, _c, _d;
        this.canvasLayerRef.instance.onAttached();
        this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
        const scheduleUpdate = () => { this.needUpdate = true; };
        const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
        this.isVectorVisible = MappedSubject.create(([show, isOnGround, isGpsValid, isHeadingValid, isAttitudeValid, isAdcValid, mapRange]) => {
            return show && !isOnGround && isGpsValid && isAdcValid && (isHeadingValid || isAttitudeValid) && mapRange >= this.props.minRangeVisible;
        }, this.module.show, this.ownAirplanePropsModule.isOnGround, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.headingSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true), (_c = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.attitudeSignalValid) !== null && _c !== void 0 ? _c : Subject.create(true), (_d = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _d !== void 0 ? _d : Subject.create(true), this.props.ndDataProvider.mapRange);
        this.isVectorVisible.sub(isVisible => { this.setVisible(isVisible); }, true);
        this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.turnRate.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.lookaheadTime.sub(scheduleUpdate), this.props.ndDataProvider.mapRange.sub(range => {
            if (range > 20 || this.props.alwaysShow3Segments) {
                this.lookaheadTime.set(90);
            }
            else if (range === 20) {
                this.lookaheadTime.set(60);
            }
            else {
                this.lookaheadTime.set(30);
            }
        }, true));
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.projectPlanePositionHandler();
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const display = this.canvasLayerRef.instance.display;
        display.clear();
        const lookaheadTime = this.lookaheadTime.get();
        const track = this.ownAirplanePropsModule.trackTrue.get();
        const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
        const turnRate = this.turnRateSmoother.next(this.ownAirplanePropsModule.turnRate.get(), elapsed);
        const distanceNM = groundSpeed.asUnit(UnitType.KNOT) * lookaheadTime.asUnit(UnitType.HOUR);
        const distancePx = UnitType.NMILE.convertTo(distanceNM, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - Math.PI / 2;
        const projectedPlanePos = this.projectedPlanePosition.get();
        display.context.beginPath();
        display.context.moveTo(projectedPlanePos[0], projectedPlanePos[1]);
        let length = 0;
        if (this.arcTurnRateThreshold && Math.abs(turnRate) < this.arcTurnRateThreshold.get() || lookaheadTime.compare(this.arcMaxLookaheadTime.get()) > 0) {
            // draw a line
            const delta = Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapPositionTrendVectorLayer.vec2Cache[0]);
            display.context.lineTo(projectedPlanePos[0] + delta[0], projectedPlanePos[1] + delta[1]);
            length = distancePx;
        }
        else {
            // draw an arc
            const groundSpeedPxPerSec = UnitType.NMILE.convertTo(groundSpeed.asUnit(UnitType.KNOT) / 3600, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            const turnRadius = groundSpeedPxPerSec / (turnRate * Avionics.Utils.DEG2RAD);
            const angularWidthDrawn = Utils.Clamp(distancePx / turnRadius, -Math.PI / 2, Math.PI / 2);
            const circleOffsetAngle = projectedTrackAngle + Math.PI / 2;
            const circleCenter = Vec2Math.add(Vec2Math.setFromPolar(turnRadius, circleOffsetAngle, MapPositionTrendVectorLayer.vec2Cache[0]), projectedPlanePos, MapPositionTrendVectorLayer.vec2Cache[0]);
            const startAngle = circleOffsetAngle + (turnRadius < 0 ? 0 : Math.PI);
            const endAngle = startAngle + angularWidthDrawn;
            display.context.arc(circleCenter[0], circleCenter[1], Math.abs(turnRadius), startAngle, endAngle, turnRadius < 0);
            length = turnRadius * angularWidthDrawn;
        }
        const gapSize = 8;
        const segmentCount = lookaheadTime.asUnit(UnitType.SECOND) / this.props.segmentLengthSeconds;
        const gapCount = Math.max(0, segmentCount - 1);
        display.context.setLineDash([((length - (gapSize * gapCount) - ((this.strokeWidth / 2) + this.outlineWidth)) / segmentCount), gapSize]);
        display.context.lineCap = 'round';
        display.context.lineWidth = this.strokeWidth + this.outlineWidth * 2;
        display.context.strokeStyle = this.outlineStyle;
        display.context.stroke();
        display.context.lineWidth = this.strokeWidth;
        display.context.strokeStyle = this.strokeStyle;
        display.context.stroke();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.isVectorVisible) === null || _a === void 0 ? void 0 : _a.destroy();
        this.subscriptions.forEach(sub => sub.destroy());
    }
}
MapPositionTrendVectorLayer.DEFAULT_STROKE_WIDTH = 2; // px
MapPositionTrendVectorLayer.DEFAULT_STROKE_STYLE = 'cyan';
MapPositionTrendVectorLayer.DEFAULT_OUTLINE_WIDTH = 1; // px
MapPositionTrendVectorLayer.DEFAULT_OUTLINE_STYLE = '#505050';
MapPositionTrendVectorLayer.vec2Cache = [new Float64Array(2)];

/** A waypoint icon factory for VNAV waypoints. */
class MapTodIconFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
        this.ICON_SIZE = Vec2Math.create(50 * this.mapStyles.canvasScale, 50 * this.mapStyles.canvasScale);
    }
    /** @inheritdoc */
    getIcon(role, waypoint) {
        return new MapTodIcon(waypoint, 9999, this.ICON_SIZE, { offset: new Float64Array([0, 0.5]) });
    }
}
/** A waypoint label factory for VNAV waypoints. */
class MapTocLabelFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        return new MapCullableLocationTextLabel('T/C', 9999, waypoint.location, true, {
            fontSize: this.mapStyles.labelFontSize,
            fontColor: BoeingColors.green,
            font: 'B787',
            anchor: new Float64Array([-0.35, 0.4]),
            offset: new Float64Array([5 * this.mapStyles.canvasScale, 2 * this.mapStyles.canvasScale])
        });
    }
}
/** A waypoint label factory for VNAV waypoints. */
class MapTodLabelFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        return new MapCullableLocationTextLabel('T/D', 9999, waypoint.location, true, {
            fontSize: this.mapStyles.labelFontSize,
            fontColor: BoeingColors.green,
            font: 'B787',
            anchor: new Float64Array([-0.35, 0.4]),
            offset: new Float64Array([5 * this.mapStyles.canvasScale, 2 * this.mapStyles.canvasScale])
        });
    }
}
/** A waypoint label factory for VNAV waypoints. */
class MapBodLabelFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        return new MapCullableLocationTextLabel('E/D', 9999, waypoint.location, true, {
            fontSize: this.mapStyles.labelFontSize,
            fontColor: BoeingColors.green,
            font: 'B787',
            anchor: new Float64Array([-0.35, 0.4]),
            offset: new Float64Array([5 * this.mapStyles.canvasScale, 2 * this.mapStyles.canvasScale])
        });
    }
}
/** A VNAV waypoint icon. */
class MapTodIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param size The size of this icon, as `[width, height]` in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, size, options) {
        super(waypoint, priority, ImageCache.get('TOD'), size, options);
    }
}

/** The map layer for displaying the Tod. */
class MapTodLayer extends MapSyncedCanvasLayer {
    constructor() {
        super(...arguments);
        this.TocWaypointRole = 'TocRole';
        this.TodWaypointRole = 'TodRole';
        this.BodWaypointRole = 'BodRole';
        this.vnavPathMode = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_path_mode').whenChanged(), VNavPathMode.None);
        this.vnavTocLegIndex = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_toc_global_leg_index').whenChanged(), -1);
        this.vnavTocLegDistance = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_toc_leg_distance').whenChanged(), -1);
        this.vnavDistanceToToc = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_toc_distance').whenChanged(), -1);
        this.vnavTodLegIndex = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_tod_global_leg_index').whenChanged(), -1);
        this.vnavTodLegDistance = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_tod_leg_distance').whenChanged(), -1);
        this.vnavDistanceToTod = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_tod_distance').whenChanged(), -1);
        this.vnavBodLegIndex = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_bod_global_leg_index').whenChanged(), -1);
        this.vnavDistanceToBod = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_bod_distance').whenChanged(), -1);
        this.mapStyles = this.props.model.getModule(BoeingMapKeys.MapStyles).styles;
    }
    /** @inheritdoc */
    onAttached() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        super.onAttached();
        this.props.waypointRenderer.addRenderRole(this.TocWaypointRole);
        this.props.waypointRenderer.addRenderRole(this.TodWaypointRole);
        this.props.waypointRenderer.addRenderRole(this.BodWaypointRole);
        // ToC
        this.props.waypointRenderer.setCanvasContext((_a = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _a !== void 0 ? _a : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_b = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _b !== void 0 ? _b : 0, new MapTodIconFactory(this.mapStyles));
        this.props.waypointRenderer.setLabelFactory((_c = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _c !== void 0 ? _c : 0, new MapTocLabelFactory(this.mapStyles));
        // ToD
        this.props.waypointRenderer.setCanvasContext((_d = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _d !== void 0 ? _d : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_e = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _e !== void 0 ? _e : 0, new MapTodIconFactory(this.mapStyles));
        this.props.waypointRenderer.setLabelFactory((_f = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _f !== void 0 ? _f : 0, new MapTodLabelFactory(this.mapStyles));
        // BoD
        this.props.waypointRenderer.setCanvasContext((_g = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _g !== void 0 ? _g : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_h = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _h !== void 0 ? _h : 0, new MapTodIconFactory(this.mapStyles));
        this.props.waypointRenderer.setLabelFactory((_j = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _j !== void 0 ? _j : 0, new MapBodLabelFactory(this.mapStyles));
        this.vnavPathMode.sub(() => { this.updateTodWaypoint(); });
        this.vnavTocLegIndex.sub(() => { this.updateTocWaypoint(); });
        this.vnavTocLegDistance.sub(() => { this.updateTocWaypoint(); });
        this.vnavDistanceToToc.sub(() => { this.updateTocWaypoint(); });
        this.vnavTodLegIndex.sub(() => { this.updateTodWaypoint(); });
        this.vnavTodLegDistance.sub(() => { this.updateTodWaypoint(); });
        this.vnavDistanceToTod.sub(() => { this.updateTodWaypoint(); });
        this.vnavBodLegIndex.sub(() => { this.updateBodWaypoint(); });
        this.vnavDistanceToBod.sub(() => { this.updateBodWaypoint(); });
        // We also update every `fplCalculated` so that we refresh with valid leg calculations
        this.props.bus.getSubscriber().on('fplCalculated').handle(() => {
            this.updateTocWaypoint();
            this.updateTodWaypoint();
            this.updateBodWaypoint();
        });
    }
    /** Updates the T/C waypoint. */
    updateTocWaypoint() {
        var _a, _b;
        this.tocWaypoint && this.props.waypointRenderer.deregister(this.tocWaypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _a !== void 0 ? _a : 0, 'toc-layer-toc');
        this.tocWaypoint = undefined;
        if (this.props.planner.hasActiveFlightPlan()) {
            const plan = this.props.planner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
            if (plan.segmentCount > 1 && this.vnavTocLegIndex.get() >= 0) {
                try {
                    const leg = plan.getLeg(this.vnavTocLegIndex.get());
                    this.tocWaypoint = new VNavWaypoint(leg, this.vnavTocLegDistance.get(), 'vnav-toc', 'T/C');
                    this.props.waypointRenderer.register(this.tocWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _b !== void 0 ? _b : 0, 'toc-layer-toc');
                }
                catch (error) {
                    console.warn(`Invalid ToC leg at: ${this.vnavTocLegIndex.get()}`);
                }
            }
        }
    }
    /** Updates the T/D waypoint. */
    updateTodWaypoint() {
        var _a, _b;
        this.todWaypoint && this.props.waypointRenderer.deregister(this.todWaypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _a !== void 0 ? _a : 0, 'tod-layer-tod');
        this.todWaypoint = undefined;
        if (this.props.planner.hasActiveFlightPlan()) {
            const plan = this.props.planner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
            if (plan.segmentCount > 1 && this.vnavTodLegIndex.get() >= 0) {
                try {
                    const leg = plan.getLeg(this.vnavTodLegIndex.get());
                    this.todWaypoint = new VNavWaypoint(leg, this.vnavTodLegDistance.get(), 'vnav-tod', 'T/D');
                    this.props.waypointRenderer.register(this.todWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _b !== void 0 ? _b : 0, 'tod-layer-tod');
                }
                catch (error) {
                    console.warn(`Invalid ToD leg at: ${this.vnavTodLegIndex.get()}`);
                }
            }
        }
    }
    /** Updates the E/D waypoint. */
    updateBodWaypoint() {
        var _a, _b;
        this.bodWaypoint && this.props.waypointRenderer.deregister(this.bodWaypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _a !== void 0 ? _a : 0, 'bod-layer-bod');
        this.bodWaypoint = undefined;
        if (this.props.planner.hasActiveFlightPlan()) {
            const plan = this.props.planner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
            if (plan.segmentCount > 1 && this.vnavBodLegIndex.get() >= 0) {
                try {
                    const leg = plan.getLeg(this.vnavBodLegIndex.get());
                    this.bodWaypoint = new VNavWaypoint(leg, 0, 'vnav-bod', 'E/D');
                    this.props.waypointRenderer.register(this.bodWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _b !== void 0 ? _b : 0, 'bod-layer-bod');
                }
                catch (error) {
                    console.warn(`Invalid BoD leg at: ${this.vnavBodLegIndex.get()}`);
                }
            }
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/** Plan airports runways layer */
class PlanAirportsRunwaysLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.updateRequired = false;
        /** Map<planIndex, Map<wptUid, labels>> */
        this.runwayLabelsMap = new Map([
            [BoeingFms.ACT_RTE_PLAN_INDEX, new Map()],
            [BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, new Map()],
            [BoeingFms.RTE_1_MOD_PLAN_INDEX, new Map()],
        ]);
        this.vec2Cache = new Array(11).fill(0).map(() => new Float64Array(2));
        this.geoPointCache = new Array(6).fill(0).map(() => new GeoPoint(0, 0));
        this.stylesModule = this.props.model.getModule(BoeingMapKeys.MapStyles);
        this.displayModule = this.props.model.getModule(BoeingMapKeys.PlanAirportsLayer);
        this.displayModeSub = this.displayModule.displayMode.sub(() => this.updateRequired = true);
        this.runwaysDisplayedSub = this.displayModule.displayRunways.sub(() => this.updateRequired = true);
        this.labelsDisplayedSub = this.displayModule.displayLabels.sub(() => this.updateRequired = true);
        this.focusChangedSub = this.displayModule.focusAirports.sub((index, type, item) => {
            switch (type) {
                case SubscribableArrayEventType.Added:
                    if (item && 'airport' in item) {
                        const { planIndex, airport, departureRunway, arrivalRunway } = item;
                        this.onFocusAirportAdded(planIndex, airport, departureRunway, arrivalRunway);
                    }
                    break;
                case SubscribableArrayEventType.Removed:
                    if (item && 'airport' in item) {
                        const { planIndex, airport } = item;
                        this.onFocusAirportRemoved(planIndex, airport);
                    }
                    break;
                case SubscribableArrayEventType.Cleared:
                    this.onFocusAirportsCleared();
                    break;
            }
        });
        this.noLineDash = [];
        this.centerlineDash = [15, 10];
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
        const displayMode = this.displayModule.displayMode.get();
        const performUpdate = this.isVisible() && (this.updateRequired || this.canvasLayerRef.instance.display.isInvalid);
        if (performUpdate) {
            this.canvasLayerRef.instance.display.syncWithMapProjection(this.props.mapProjection);
            this.canvasLayerRef.instance.display.clear();
            const context = this.canvasLayerRef.instance.display.context;
            const geoProjection = this.canvasLayerRef.instance.display.geoProjection;
            const runwaysVisible = displayMode !== PlanAirportsLayerDisplayMode.None;
            if (runwaysVisible) {
                if (this.displayModule.displayRunways.get()) {
                    for (const { airport, departureRunway, arrivalRunway } of this.displayModule.focusAirports.getArray()) {
                        const hasRunway = !!(departureRunway || arrivalRunway);
                        const drawRunway = hasRunway && (displayMode === PlanAirportsLayerDisplayMode.AirportMap || displayMode === PlanAirportsLayerDisplayMode.Near);
                        const drawAirportCircle = displayMode === PlanAirportsLayerDisplayMode.Far || !hasRunway;
                        if (drawRunway) {
                            if (departureRunway) {
                                this.drawRunway(departureRunway, geoProjection, context);
                            }
                            if (arrivalRunway) {
                                this.drawRunway(arrivalRunway, geoProjection, context);
                            }
                        }
                        else if (drawAirportCircle) {
                            this.drawAirportCircle(context, geoProjection, airport);
                        }
                    }
                }
            }
            else {
                context.clearRect(0, 0, this.canvasLayerRef.instance.getWidth(), this.canvasLayerRef.instance.getHeight());
            }
            this.updateRequired = false;
        }
    }
    /**
     * Draws a runway.
     * @param runway The runway to draw.
     * @param geoProjection The geoprojection from the canvas to draw against.
     * @param context The canvas rendering context to use.
     */
    drawRunway(runway, geoProjection, context) {
        context.lineCap = 'round';
        const runwayPos = this.geoPointCache[0].set(runway.latitude, runway.longitude);
        const forwardLength = UnitType.METER.convertTo(runway.length - runway.startThresholdLength, UnitType.GA_RADIAN);
        const backwardLength = UnitType.METER.convertTo(runway.startThresholdLength, UnitType.GA_RADIAN);
        const forwardBound = runwayPos.offset(runway.course, forwardLength, this.geoPointCache[2]);
        const backwardBound = runwayPos.offset(runway.course, -backwardLength, this.geoPointCache[3]);
        const pBack = geoProjection.project(backwardBound, this.vec2Cache[0]);
        const pForward = geoProjection.project(forwardBound, this.vec2Cache[1]);
        this.drawRunwayShape(context, pForward, pBack);
        this.drawExtendedDashedCenterline(context, pForward, pBack, forwardBound, backwardBound, geoProjection, runway);
    }
    /**
     * Draws the runway shape.
     * @param context The context.
     * @param pForward The forward projection.
     * @param pBack The backward projection.
     */
    drawRunwayShape(context, pForward, pBack) {
        const width = 7 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
        const theta = Vec2Math.theta(Vec2Math.sub(pForward, pBack, this.vec2Cache[2]));
        const pBackL = Vec2Math.add(Vec2Math.setFromPolar(width, theta - (Math.PI / 2), this.vec2Cache[2]), pBack, this.vec2Cache[3]);
        const pBackR = Vec2Math.add(Vec2Math.setFromPolar(width, theta + (Math.PI / 2), this.vec2Cache[2]), pBack, this.vec2Cache[4]);
        const pForwardL = Vec2Math.add(Vec2Math.setFromPolar(width, theta - (Math.PI / 2), this.vec2Cache[2]), pForward, this.vec2Cache[5]);
        const pForwardR = Vec2Math.add(Vec2Math.setFromPolar(width, theta + (Math.PI / 2), this.vec2Cache[2]), pForward, this.vec2Cache[6]);
        context.beginPath();
        context.moveTo(pBackL[0], pBackL[1]);
        context.lineTo(pForwardL[0], pForwardL[1]);
        context.moveTo(pBackR[0], pBackR[1]);
        context.lineTo(pForwardR[0], pForwardR[1]);
        context.setLineDash(this.noLineDash);
        context.strokeStyle = BoeingColors.black;
        context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.stroke();
        context.strokeStyle = BoeingColors.white;
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * Draws the dashed extended runway centerline.
     * @param context The context.
     * @param pForward The forward projection.
     * @param pBack The backward projection.
     * @param forwardBound The forward bound.
     * @param backwardBound The backward bound.
     * @param geoProjection The geo projection.
     * @param runway The runway.
     */
    drawExtendedDashedCenterline(context, pForward, pBack, forwardBound, backwardBound, geoProjection, runway) {
        const centrelineExtensionLength = UnitType.NMILE.convertTo(14.2, UnitType.GA_RADIAN);
        const cForwardBound = forwardBound.offset(runway.course, centrelineExtensionLength, this.geoPointCache[2]);
        const pCForward = geoProjection.project(cForwardBound, this.vec2Cache[7]);
        const cBackwardBound = backwardBound.offset(NavMath.normalizeHeading(runway.course + 180), centrelineExtensionLength, this.geoPointCache[3]);
        const pCBack = geoProjection.project(cBackwardBound, this.vec2Cache[8]);
        context.beginPath();
        context.moveTo(pForward[0], pForward[1]);
        context.lineTo(pCForward[0], pCForward[1]);
        context.moveTo(pBack[0], pBack[1]);
        context.lineTo(pCBack[0], pCBack[1]);
        context.setLineDash(this.centerlineDash);
        context.strokeStyle = BoeingColors.black;
        context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.stroke();
        context.strokeStyle = BoeingColors.white;
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * Draws the airport circle.
     * @param context The context.
     * @param geoProjection The geo projection.
     * @param airport The airport.
     */
    drawAirportCircle(context, geoProjection, airport) {
        const airportRef = airport.facility.get();
        const pAirport = geoProjection.project(airportRef, this.vec2Cache[10]);
        // This number is for MAX displays, the `maxToOldBoeingScale` var will scale it properly for older boeing displays
        const circleRadius = 15 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
        context.beginPath();
        context.ellipse(pAirport[0], pAirport[1], circleRadius, circleRadius, 0, 0, Math.PI * 2);
        context.setLineDash(this.noLineDash);
        context.strokeStyle = BoeingColors.black;
        context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.stroke();
        context.strokeStyle = BoeingColors.white;
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * A callback fired when the focused airport is added.
     * @param planIndex The flight plan index.
     * @param waypoint The waypoint representing the focused airport.
     * @param departureRunway The departure runway if applicable.
     * @param arrivalRunway The arrival runway if applicable.
     */
    onFocusAirportAdded(planIndex, waypoint, departureRunway, arrivalRunway) {
        this.addLabels(planIndex, waypoint, departureRunway, arrivalRunway);
        this.updateRequired = true;
    }
    /**
     * A callback fired when a focused airport is removed.
     * @param planIndex The flight plan index.
     * @param waypoint The waypoint representing the focused airport.
     */
    onFocusAirportRemoved(planIndex, waypoint) {
        const labels = this.runwayLabelsMap.get(planIndex).get(waypoint.uid);
        if (labels) {
            for (const l of labels) {
                this.props.textManager.deregister(l);
            }
        }
        this.runwayLabelsMap.get(planIndex).delete(waypoint.uid);
        this.updateRequired = true;
    }
    /** A callback fired when focused airports are cleared. */
    onFocusAirportsCleared() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [planIndex, map2] of this.runwayLabelsMap.entries()) {
            for (const [uid, labels] of map2.entries()) {
                if (labels) {
                    for (const l of labels) {
                        this.props.textManager.deregister(l);
                    }
                }
                this.runwayLabelsMap.get(planIndex).delete(uid);
            }
        }
        this.updateRequired = true;
    }
    /**
     * Processes an airport waypoint to generate airport and runway labels.
     * @param planIndex The flight plan index.
     * @param waypoint The airport waypoint the runway belongs to.
     * @param departureRunway The departure runway if applicable.
     * @param arrivalRunway The arrival runway if applicable.
     */
    addLabels(planIndex, waypoint, departureRunway, arrivalRunway) {
        const refPointAirport = new GeoPoint(waypoint.facility.get().lat, waypoint.facility.get().lon);
        const labels = [];
        const modesVisible = departureRunway || arrivalRunway
            ? PlanAirportsLayerDisplayMode.Far
            : PlanAirportsLayerDisplayMode.Far | PlanAirportsLayerDisplayMode.Near;
        const airportLabel = new PlanAirportsRunwaysTextLabel(ICAO.getIdent(waypoint.facility.get().icao), refPointAirport, modesVisible, this.displayModule.displayMode, {
            fontSize: this.stylesModule.styles.labelFontSize,
            font: 'B787',
            fontColor: BoeingColors.white,
            offset: this.stylesModule.styles.bigLabelOffset,
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: this.stylesModule.styles.fontOutlineWidth,
        });
        this.props.textManager.register(airportLabel);
        labels.push(airportLabel);
        if (departureRunway) {
            // Only show departure runway label under airport label if the arrival runway isn't at the same airport
            // Otherwise, if origin and destination are same airport, we'll just only show the arrival runway label under the airport label
            this.addRunwayLabel(planIndex, departureRunway, refPointAirport, !arrivalRunway, labels);
        }
        if (arrivalRunway) {
            this.addRunwayLabel(planIndex, arrivalRunway, refPointAirport, true, labels);
        }
        this.runwayLabelsMap.get(planIndex).set(waypoint.uid, labels);
    }
    /**
     * Adds labels for a runway.
     * @param planIndex The plan index.
     * @param runway The runway.
     * @param refPointAirport The airport ref point.
     * @param showRunwayLabelUnderAirport Whether to make a label for the runway to show under the airport label when zoomed out.
     * @param labels The labels array to add to.
     */
    addRunwayLabel(planIndex, runway, refPointAirport, showRunwayLabelUnderAirport, labels) {
        // When near, draw runway label next to runway
        const refPointRunway = runway && new GeoPoint(runway.latitude, runway.longitude);
        const runwayLabelNear = new RunwayTextLabel(runway.designation, refPointRunway, runway.course, PlanAirportsLayerDisplayMode.Near, this.displayModule.displayMode, this.stylesModule.styles);
        this.props.textManager.register(runwayLabelNear);
        labels.push(runwayLabelNear);
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && showRunwayLabelUnderAirport) {
            // When far, and active plan, draw runway label under the airport label
            // We only draw this for active plan to avoid clashing runway labels from other plans
            const offsetY = 26 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
            const runwayLabelFar = new PlanAirportsRunwaysTextLabel(runway.designation, refPointAirport, PlanAirportsLayerDisplayMode.Far, this.displayModule.displayMode, {
                fontSize: this.stylesModule.styles.labelFontSize,
                font: 'B787',
                fontColor: BoeingColors.white,
                offset: new Float64Array([this.stylesModule.styles.bigLabelOffsetPx, this.stylesModule.styles.bigLabelOffsetPx + offsetY]),
                fontOutlineColor: BoeingColors.black,
                fontOutlineWidth: this.stylesModule.styles.fontOutlineWidth,
            });
            this.props.textManager.register(runwayLabelFar);
            labels.push(runwayLabelFar);
        }
    }
    /** @inheritdoc */
    onDetached() {
        this.displayModeSub.destroy();
        this.runwaysDisplayedSub.destroy();
        this.labelsDisplayedSub.destroy();
        this.focusChangedSub.destroy();
        this.canvasLayerRef.instance.onDetached();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2, class: "plan-airports-runways-canvas-layer" })));
    }
}
/** A map text label used for airports and runways. */
class PlanAirportsRunwaysTextLabel extends MapCullableLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param modesVisible Which modes this label should be displayed in.
     * @param displayMode The display mode subscribable.
     * @param options Options with which to initialize this label.
     */
    constructor(text, location, modesVisible, displayMode, options) {
        // Priority 10 to render above the waypoint icons layer (ARPT, STA, WPT)
        // but below the flight plan labels
        super(text, 10, location, true, options);
        this.modesVisible = modesVisible;
        this.displayMode = displayMode;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        if (BitFlags.isAny(this.modesVisible, this.displayMode.get())) {
            super.setTextStyle(context);
            super.draw(context, mapProjection);
        }
    }
}
/**
 * A map text label used for runway designations.
 */
class RunwayTextLabel extends PlanAirportsRunwaysTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param runwayDirection The direction of the runway, used to offset the label.
     * @param modesVisible Which modes this label should be displayed in.
     * @param displayMode The display mode subscribable.
     * @param mapStyles The map styles.
     */
    constructor(text, location, runwayDirection, modesVisible, displayMode, mapStyles) {
        const runwayLabelOffset = Vec2Subject.create(new Float64Array(2));
        super(text, location, modesVisible, displayMode, {
            fontSize: mapStyles.labelFontSize,
            font: 'B787',
            fontColor: BoeingColors.white,
            offset: runwayLabelOffset,
            anchor: new Float64Array([0.5, 0.5]),
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: mapStyles.fontOutlineWidth,
        });
        this.runwayDirection = runwayDirection;
        this.runwayLabelOffset = runwayLabelOffset;
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const runwayDirectionRad = this.runwayDirection * Avionics.Utils.DEG2RAD;
        const mapRotationRad = mapProjection.getRotation();
        const relativeBearing = runwayDirectionRad + mapRotationRad;
        // Rotate 180 deg (pi) to put on other side of runway
        const theta = relativeBearing + Math.PI;
        // This is how far the label is from the runway
        const offsetMagnitude = 50 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale;
        const offsetVec = Vec2Math.setFromPolar(offsetMagnitude, theta, MapLocationTextLabel.tempVec2);
        // The label is much wider than it is tall, so we minimize the vertical offset, so when the runway is running left to right,
        // the label is on top or on bottom, and we don't want it to look too far away.
        const verticalOffsetFactor = 0.75;
        this.runwayLabelOffset.set(offsetVec[0], offsetVec[1] * verticalOffsetFactor);
        super.draw(context, mapProjection);
    }
}

/**
 * Displays TRAFFIC and OFFSCALE messages on the top right of the ND map.
 * OFFSCALE in red when RA is beyond selected map range.
 * OFFSCALE in amber when TA is beyond selected map range.
 * TRAFFIC in red when RA is occuring.
 * TRAFFIC in amber when TA is occuring and RA is not occuring.
 * TRAFFIC alert messages display regardless ND modes / ranges / TFC on or not.
 */
class TcasAdvisoryStatus extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.trafficRef = FSComponent.createRef();
        this.offScaleRef = FSComponent.createRef();
        /**
         * Beside TA/RA conditions, only display OFFSCALE status when:
         * Plane is not on ground, and ND in MAP / MAP CTR, and TFC is not selected.
         */
        this.isOffScaleStatusHidden = MappedSubject.create(([tcasOffScaleStatus, isOnGround, isPlanFormat, isTfcEnabled,]) => {
            if (isOnGround
                || isPlanFormat
                || !isTfcEnabled
                || tcasOffScaleStatus === TcasAlertLevel.None
                || tcasOffScaleStatus === TcasAlertLevel.ProximityAdvisory) {
                return true;
            }
            return false;
        }, this.props.tcasOffScaleStatus, this.props.ndDataProvider.isOnGround, this.props.ndDataProvider.isPlanFormat, this.props.ndDataProvider.isTfcEnabled);
        this.isTrafficStatusHidden = MappedSubject.create(([tcasTrafficStatus, isOnGround]) => {
            if (isOnGround
                || tcasTrafficStatus === TcasAlertLevel.None
                || tcasTrafficStatus === TcasAlertLevel.ProximityAdvisory) {
                return true;
            }
            return false;
        }, this.props.ndDataProvider.tcasTrafficStatus, this.props.ndDataProvider.isOnGround);
        this.flagTextStyle = {
            background: 'black',
            'text-align': 'right',
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.offScaleStatusSub = this.props.tcasOffScaleStatus.sub((v) => {
            if (v === TcasAlertLevel.ResolutionAdvisory) {
                this.offScaleRef.instance.style.color = 'var(--boeing-colors-red)';
            }
            else if (v === TcasAlertLevel.TrafficAdvisory) {
                this.offScaleRef.instance.style.color = 'var(--boeing-colors-amber)';
            }
            else {
                this.offScaleRef.instance.style.color = 'var(--boeing-colors-white)';
            }
        }, true);
        this.trafficStatusSub = this.props.ndDataProvider.tcasTrafficStatus.sub((v) => {
            if (v === TcasAlertLevel.ResolutionAdvisory) {
                this.trafficRef.instance.style.color = 'var(--boeing-colors-red)';
            }
            else if (v === TcasAlertLevel.TrafficAdvisory) {
                this.trafficRef.instance.style.color = 'var(--boeing-colors-amber)';
            }
            else {
                this.trafficRef.instance.style.color = 'var(--boeing-colors-white)';
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "tcas-advisory-status-container" },
            FSComponent.buildComponent("div", { class: {
                    'tcas-off-scale-status': true,
                    'tcas-status-no-background-container': this.isOffScaleStatusHidden,
                }, style: this.flagTextStyle },
                FSComponent.buildComponent("span", { class: { 'hidden': this.isOffScaleStatusHidden }, ref: this.offScaleRef }, "OFFSCALE")),
            FSComponent.buildComponent("div", { class: {
                    'tcas-traffic-status': true,
                    'tcas-status-no-background-container': this.isTrafficStatusHidden,
                }, style: this.flagTextStyle },
                FSComponent.buildComponent("span", { class: { 'hidden': this.isTrafficStatusHidden }, ref: this.trafficRef }, "TRAFFIC"))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        (_a = this.offScaleStatusSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.trafficStatusSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/** Colection of function to help build boeing map systems. */
class BoeingMapBuilder {
    /**
     * Creates a new BoeingMapBuilder.
     * @param bus the event bus.
     * @param ndDataProvider The nd data provider.
     * @param pfdOrMfd pfd or mfd.
     * @param facLoader the fac loader.
     * @param flightPlanner the flight planner.
     * @param activeRoutePredictor The active route predictor.
     * @param perfPlanRepository The perfPlanRepository.
     * @param tcas The Tcas instance.
     */
    constructor(bus, ndDataProvider, pfdOrMfd, facLoader, flightPlanner, activeRoutePredictor, perfPlanRepository, tcas) {
        this.bus = bus;
        this.ndDataProvider = ndDataProvider;
        this.pfdOrMfd = pfdOrMfd;
        this.facLoader = facLoader;
        this.flightPlanner = flightPlanner;
        this.activeRoutePredictor = activeRoutePredictor;
        this.perfPlanRepository = perfPlanRepository;
        this.tcas = tcas;
        /**
         * Add the plan airports and runways
         * @param builder The map system builder.
         * @param mapSystemConfig The map system config.
         * @returns The map system builder, after it has been configured.
         */
        this.withFlightPlans = (builder, mapSystemConfig) => {
            const vnavDataModule = new BoeingVNavDataModule();
            return builder
                .withInit('init-flight-plans', context => {
                if (this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX)) {
                    // Init the flight plans in case the plans already exist
                    context.model.getModule(MapSystemKeys.FlightPlan)
                        .getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX)
                        .flightPlan.set(this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX));
                    context.model.getModule(MapSystemKeys.FlightPlan)
                        .getPlanSubjects(BoeingFms.RTE_1_MOD_PLAN_INDEX)
                        .flightPlan.set(this.flightPlanner.getFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX));
                    context.model.getModule(MapSystemKeys.FlightPlan)
                        .getPlanSubjects(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX)
                        .flightPlan.set(this.flightPlanner.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX));
                }
            })
                .withFlightPlan(mapSystemConfig.configureInactiveFlightPlan(), this.flightPlanner, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, false, undefined, 'inactive-flight-plan-map-layer')
                .withFlightPlan(mapSystemConfig.configureModFlightPlan(this.bus), this.flightPlanner, BoeingFms.RTE_1_MOD_PLAN_INDEX, false, undefined, 'mod-flight-plan-map-layer')
                .withFlightPlan(mapSystemConfig.configureFlightPlan(this.bus, this.ndDataProvider, vnavDataModule, this.activeRoutePredictor, this.perfPlanRepository), this.flightPlanner, BoeingFms.ACT_RTE_PLAN_INDEX, false, undefined, 'active-flight-plan-map-layer')
                .withModule(BoeingMapKeys.VNavData, () => vnavDataModule)
                .withController(BoeingMapKeys.VNavData, context => new BoeingVNavDataController(context));
        };
        /**
         * The map builder for the airplane icon.
         * @param builder The map system builder.
         * @param crossTrackLayerProps The required props for the cross track layer.
         * @param ownshipTriPath File path to the triangle ownship icon.
         * @param ownshipOutlinePath File path to the outline ownship icon.
         * @param svgScale The svgScale to apply.
         * @returns The map system builder, after it has been configured.
         */
        this.withAirplaneIcon = (builder, crossTrackLayerProps, ownshipTriPath, ownshipOutlinePath, svgScale = 1) => {
            builder = builder
                .withOwnAirplanePropBindings([
                'position',
                'hdgTrue',
                'trackTrue',
                'altitude',
                'verticalSpeed',
                'groundSpeed',
                'isOnGround',
                'turnRate',
            ], 30)
                .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
                .withModule(MapSystemKeys.OwnAirplaneIcon, () => {
                const module = new MapOwnAirplaneIconModule();
                module.orientation.set(MapOwnAirplaneIconOrientation.TrackUp);
                return module;
            })
                .withLayer(BoeingMapKeys.OwnShipXtkErrorLayer, (context) => {
                return (FSComponent.buildComponent(MapCrossTrackErrorLayer, Object.assign({ bus: context.bus, model: context.model, mapProjection: context.projection, canvasScale: this.ndDataProvider.canvasScale }, crossTrackLayerProps)));
            })
                .withLayer(BoeingMapKeys.OwnShipTriLayer, (context) => {
                return (FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: ownshipTriPath, iconSize: 92 * svgScale * this.ndDataProvider.canvasScale, iconAnchor: new Float64Array([0.5, 0.108]), class: 'airplane-symbol-tri' }));
            });
            if (this.pfdOrMfd === 'MFD') {
                // The PLAN format airplane icon
                builder = builder.withLayer(BoeingMapKeys.OwnShipOutlineLayer, (context) => {
                    return (FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: ownshipOutlinePath, iconSize: 84 * svgScale * this.ndDataProvider.canvasScale, iconAnchor: new Float64Array([0.5, 0.0]), class: 'airplane-symbol-outline' }));
                });
            }
            return builder;
        };
        /**
         * Configures a map builder to generate a map with a track vector.
         * @param mapBuilder The map builder to configure.
         * @param options The options.
         * @returns The map builder, after it has been configured.
         */
        this.positionTrendVector = (mapBuilder, options) => {
            return mapBuilder
                .withModule(BoeingMapKeys.PositionTrendVector, () => new MapPositionTrendVectorModule())
                .withLayer(BoeingMapKeys.PositionTrendVector, context => {
                return (FSComponent.buildComponent(MapPositionTrendVectorLayer, { model: context.model, mapProjection: context.projection, class: "position-trend-vector", arcMaxLookaheadTime: UnitType.SECOND.createNumber(90), segmentLengthSeconds: 30, strokeStyle: "white", outlineStyle: "black", minRangeVisible: options.minRangeVisible, strokeWidth: options.strokeWidth, outlineWidth: options.outlineWidth, ndDataProvider: this.ndDataProvider, alwaysShow3Segments: this.pfdOrMfd === 'PFD' }));
            });
        };
        /**
         * Add the altitude arc.
         * @param builder The map system builder.
         * @param options Altitude arc options.
         * @returns The map system builder, after it has been configured.
         */
        this.withAltitudeArc = (builder, options) => {
            return builder
                .withModule(MapSystemKeys.AltitudeArc, () => new MapAltitudeArcModule(true))
                .withLayer(MapSystemKeys.AltitudeArc, context => FSComponent.buildComponent(MapAltitudeArcLayer, { model: context.model, mapProjection: context.projection, renderMethod: "svg", verticalSpeedPrecision: UnitType.FPM.createNumber(10), verticalSpeedThreshold: UnitType.FPM.createNumber(150), altitudeDeviationThreshold: UnitType.FOOT.createNumber(750), arcRadius: options.arcRadius, arcAngularWidth: options.arcAngularWidth, strokeStyle: options.strokeStyle, strokeWidth: options.strokeWidth, strokeLineCap: "round", outlineWidth: options.outlineWidth, outlineStyle: "black", outlineLineCap: "round", class: "altitude-arc" }));
        };
        /**
         * Adds the terrain colors module.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withTerrainColors = (builder) => {
            return builder
                .withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule())
                .withInit(MapSystemKeys.TerrainColors, (context) => {
                context.model.getModule(MapSystemKeys.TerrainColors).colors.set(BingComponent.createEarthColorsArray('#000000', [
                    {
                        elev: 0,
                        color: '#000000'
                    }
                ], 0, 30000, 1));
            });
        };
        /**
         * Add the plan airports and runways.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withPlanAirportsRunways = (builder) => {
            return builder
                .withModule(BoeingMapKeys.PlanAirportsLayer, () => new AirportRunwayDisplayModule())
                .withController(BoeingMapKeys.PlanAirportsLayer, context => new PlanAirportsRunwaysController(context, this.facLoader, this.flightPlanner, this.ndDataProvider, this.pfdOrMfd))
                .withLayer(BoeingMapKeys.PlanAirportsLayer, context => FSComponent.buildComponent(PlanAirportsRunwaysLayer, { model: context.model, mapProjection: context.projection, textManager: context.textManager }));
        };
        /**
         * Add the T/D, E/D, etc. to the map.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withTopOfDescent = (builder) => {
            return builder
                .withLayer(BoeingMapKeys.Tod, context => FSComponent.buildComponent(MapTodLayer, { bus: context.bus, model: context.model, mapProjection: context.projection, waypointRenderer: context[MapSystemKeys.WaypointRenderer], planner: this.flightPlanner }));
        };
        /**
         * Add the map select waypoint module.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withMapSelectWpt = (builder) => {
            return builder
                .withModule(BoeingMapKeys.CtrWpt, () => new MapFacilitySelectModule(this.bus));
        };
        /**
         * Add the nearest waypoints layer.
         * @param builder The map system builder.
         * @param mapSystemConfig The map system config.
         * @returns The map system builder, after it has been configured.
         */
        this.withNearestWaypoints = (builder, mapSystemConfig) => {
            return builder
                .withNearestWaypoints(mapSystemConfig.configureMapWaypoints(), false, undefined, 'nearest-waypoints');
        };
        /**
         * Add the waypoint display controller.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withWaypointDisplayController = (builder) => {
            return builder
                .withController(BoeingMapKeys.WaypointDisplayController, context => new MapWaypointDisplayController(context, this.ndDataProvider.mapWaypointsDisplay));
        };
        /**
         * Add the map select waypoint layer.
         * @param builder The map system builder.
         * @param mapSystemConfig The map system config.
         * @param supportAdsbIn Whether to support the display of ADS-B In triangle icons.
         * @param mapSystemFactory A callback to pass MapSystemContext to the boeing plane's specific MapTrafficController.
         * @param offScaleTcasAlertLevel The offScaleTcasAlertLevel subject.
         * @returns The map system builder, after it has been configured.
         */
        this.withTraffic = (builder, mapSystemConfig, supportAdsbIn, mapSystemFactory, offScaleTcasAlertLevel) => {
            return builder
                .withTraffic(this.tcas, mapSystemConfig.createTrafficIntruderIcon({ supportAdsbIn }), mapSystemConfig.initTrafficLayerCanvasStyles, this.getOffScaleOobOptions(offScaleTcasAlertLevel), undefined, 'traffic')
                .withController(MapSystemKeys.Traffic, mapSystemFactory);
        };
        /**
         * Generates options for handling off-scale and out-of-bounds intruders.
         * @param offScaleTcasAlertLevel Mutable subscribale that receives updates when there is an off-scale TA/RA event.
         * @returns a TrafficOffScaleOobOptions object.
         */
        this.getOffScaleOobOptions = (offScaleTcasAlertLevel) => () => {
            const offScaleIntruders = SetSubject.create();
            const offScaleTAs = SetSubject.create();
            const offScaleRAs = SetSubject.create();
            const offScaleHandler = (_set, type, intruder) => {
                if (type === SubscribableSetEventType.Added) {
                    intruder.alertLevel.sub(alertLevel => {
                        if (alertLevel === TcasAlertLevel.ResolutionAdvisory) {
                            offScaleRAs.add(intruder);
                            offScaleTAs.delete(intruder);
                        }
                        else if (alertLevel === TcasAlertLevel.TrafficAdvisory) {
                            offScaleTAs.add(intruder);
                            offScaleRAs.delete(intruder);
                        }
                        else {
                            offScaleRAs.add(intruder);
                            offScaleTAs.delete(intruder);
                            offScaleRAs.delete(intruder);
                        }
                    }, true);
                }
                else {
                    offScaleTAs.delete(intruder);
                    offScaleRAs.delete(intruder);
                }
            };
            offScaleIntruders.sub(offScaleHandler);
            const raTAHandler = () => {
                if (offScaleRAs.get().size > 0) {
                    offScaleTcasAlertLevel.set(TcasAlertLevel.ResolutionAdvisory);
                }
                else if (offScaleTAs.get().size > 0) {
                    offScaleTcasAlertLevel.set(TcasAlertLevel.TrafficAdvisory);
                }
                else {
                    offScaleTcasAlertLevel.set(TcasAlertLevel.None);
                }
            };
            offScaleTAs.sub(raTAHandler);
            offScaleRAs.sub(raTAHandler);
            raTAHandler();
            return {
                offScaleIntruders,
            };
        };
    }
}

/** An animator driven by requestAnimationFrame designed for ND elements. */
class MapCompassAnimator {
    /** Creates a new NdAnimator.
     * @param speed Higher is faster, but it gets faster fast, try incerements of 0.5.
     * @param isRunning A subscribable boolean to control whether the animator is running.
     * @param inputValue A subscribable number to control the target value with.
     */
    constructor(speed = 4, isRunning = undefined, inputValue = undefined) {
        this.speed = speed;
        /** The animated value. */
        this._output = Subject.create(0);
        this.output = this._output;
        this.previousTimestamp = window.performance.now();
        this.animationFrameId = 0;
        this.targetValue = 0;
        this.started = false;
        this.subs = [];
        /** Sets the value that the output will be gradually animated towards.
         * @param value The value to animate towards. If null or undefined, the target value will not change.
         */
        this.setTargetValue = (value) => {
            if (value === undefined || value === null) {
                return;
            }
            this.targetValue = value;
        };
        /** Starts the requestAnimationFrame loop. */
        this.start = () => {
            if (!this.started) {
                this.started = true;
                this.previousTimestamp = window.performance.now();
                this.animationFrameId = window.requestAnimationFrame(this.update);
            }
        };
        /** Stops the requestAnimationFrame loop. */
        this.stop = () => {
            if (this.started) {
                this.started = false;
                window.cancelAnimationFrame(this.animationFrameId);
            }
        };
        /**
         * Starts or stops the animaton based on a boolean.
         * @param force If true, will start animation if not already running, else will stop animation.
         */
        this.toggle = (force) => {
            if (force) {
                this.start();
            }
            else {
                this.stop();
            }
        };
        this.update = (timestamp) => {
            const deltaTime = timestamp - this.previousTimestamp;
            this.previousTimestamp = timestamp;
            const currentValue = this.output.get();
            const delta = ((this.targetValue - currentValue + 540) % 360) - 180;
            // This makes it so it's not updating every frame after the value has settled
            if (Math.abs(delta) > 0.01) {
                const deltaToApply = Math.min(delta / 10, delta * (this.speed * (deltaTime / 1000)));
                const newValue = currentValue + deltaToApply;
                this._output.set(newValue);
            }
            else {
                this._output.set(this.targetValue);
            }
            this.animationFrameId = window.requestAnimationFrame(this.update);
        };
        this.subs = [
            isRunning === null || isRunning === void 0 ? void 0 : isRunning.sub(this.toggle.bind(this), true),
            inputValue === null || inputValue === void 0 ? void 0 : inputValue.sub(this.setTargetValue.bind(this), true),
        ];
    }
    /** Cleans up the component. */
    destroy() {
        this.stop();
        this.subs.forEach(sub => sub === null || sub === void 0 ? void 0 : sub.destroy());
    }
}

const RANGE_FORMATTER = NumberFormatter.create({ precision: .01, forceDecimalZeroes: false });
/** Provides data for the ND. */
class BoeingNdDataProvider {
    /**
     * Creates a new data provider.
     * @param bus The event bus.
     * @param navIndicators The nav indicators.
     * @param settings Boeing map settings.
     */
    constructor(bus, navIndicators, settings) {
        this.bus = bus;
        this.navIndicators = navIndicators;
        this.settings = settings;
        this.boeingType = 'change-me';
        this.white = BoeingColors.white;
        this.black = BoeingColors.black;
        this.green = BoeingColors.green;
        this.cyan = BoeingColors.cyan;
        this.magenta = BoeingColors.magenta;
        this.canvasScale = 1;
        this._targetProjectedOffsetY = Subject.create(0);
        this.targetProjectedOffsetY = this._targetProjectedOffsetY;
        this.isOnGround = ConsumerSubject.create(this.bus.getSubscriber().on('on_ground'), true);
        // TODO
        // Whether the IRS is aligned, when not aligned, the compass numbers and other items will not be visible
        this.isAligned = Subject.create(true);
        this.lnavEvents = this.bus.getSubscriber();
        this.currentTrackDegMag = ConsumerSubject.create(this.bus.getSubscriber().on('track_deg_magnetic').withPrecision(2), 0);
        // TODO Use AhrsSystemEvents for heading once it works
        // private readonly currentHeadingMag = ConsumerSubject.create(
        //   this.bus.getSubscriber<AhrsSystemEvents>().on('ahrs_hdg_deg_1').withPrecision(2), 0);
        this.currentHeadingMag = ConsumerSubject.create(this.bus.getSubscriber().on('hdg_deg').withPrecision(2), 0);
        this.currentGroundSpeed = ConsumerSubject.create(this.bus.getSubscriber().on('ground_speed').atFrequency(1), 0);
        this.selectedHeadingAndTrack = ConsumerSubject.create(this.bus.getSubscriber().on('ap_heading_selected'), 0);
        this.fmaData = ConsumerSubject.create(this.bus.getSubscriber().on('fma_data'), BoeingFmaDataUtils.createBoeingFmaData());
        this.isMissedApproachActive = ConsumerSubject.create(this.lnavEvents.on('lnavdata_cdi_scale_label'), 0)
            .map(x => x === CDIScaleLabel.MissedApproach);
        this.compassTrackRotation = MappedSubject.create(([track, heading, groundSpeed, isAligned]) => {
            return isAligned
                ? groundSpeed < 10
                    ? heading
                    : track
                : 0;
        }, this.currentTrackDegMag, this.currentHeadingMag, this.currentGroundSpeed, this.isAligned);
        this.compassRotationAnimator = new MapCompassAnimator(undefined, undefined, this.compassTrackRotation);
        this.compassTrackRotationAnimated = this.compassRotationAnimator.output;
        this.vorLeftRotation = MappedSubject.create(([trk, vorLeftBearing]) => {
            return vorLeftBearing === null ? 0 : trk - vorLeftBearing;
        }, this.compassRotationAnimator.output, this.navIndicators.get('vorLeft').bearing);
        this.vorRightRotation = MappedSubject.create(([trk, vorRightBearing]) => {
            return vorRightBearing === null ? 0 : trk - vorRightBearing;
        }, this.compassRotationAnimator.output, this.navIndicators.get('vorRight').bearing);
        this.adfLeftRotation = MappedSubject.create(([trk, adfLeftBearing]) => {
            return adfLeftBearing === null ? 0 : trk - adfLeftBearing;
        }, this.compassRotationAnimator.output, this.navIndicators.get('adfLeft').bearing);
        this.adfRightRotation = MappedSubject.create(([trk, adfRightBearing]) => {
            return adfRightBearing === null ? 0 : trk - adfRightBearing;
        }, this.compassRotationAnimator.output, this.navIndicators.get('adfRight').bearing);
        this._navAidLeftState = Subject.create('OFF');
        this.navAidLeftState = this._navAidLeftState;
        this._navAidRightState = Subject.create('OFF');
        this.navAidRightState = this._navAidRightState;
        this.vorPointerLeftIsVisible = MappedSubject.create(([hasNav, isLoc, state]) => {
            return !!hasNav && !isLoc && state === 'VOR';
        }, this.navIndicators.get('vorLeft').hasNav, this.navIndicators.get('vorLeft').isLocalizer, this.navAidLeftState);
        this.vorPointerRightIsVisible = MappedSubject.create(([hasNav, isLoc, state]) => {
            return !!hasNav && !isLoc && state === 'VOR';
        }, this.navIndicators.get('vorRight').hasNav, this.navIndicators.get('vorRight').isLocalizer, this.navAidRightState);
        this.adfPointerLeftIsVisible = MappedSubject.create(([bearing, state]) => {
            return bearing !== null && state === 'ADF';
        }, this.navIndicators.get('adfLeft').bearing, this.navAidLeftState);
        this.adfPointerRightIsVisible = MappedSubject.create(([bearing, state]) => {
            return bearing !== null && state === 'ADF';
        }, this.navIndicators.get('adfRight').bearing, this.navAidRightState);
        this.vorLeftAnimator = new MapCompassAnimator(undefined, this.vorPointerLeftIsVisible, this.vorLeftRotation);
        this.vorRightAnimator = new MapCompassAnimator(undefined, this.vorPointerRightIsVisible, this.vorRightRotation);
        this.adfLeftAnimator = new MapCompassAnimator(undefined, this.adfPointerLeftIsVisible, this.adfLeftRotation);
        this.adfRightAnimator = new MapCompassAnimator(undefined, this.adfPointerRightIsVisible, this.adfRightRotation);
        this.vorLeftRotationAnimated = this.vorLeftAnimator.output;
        this.vorRightRotationAnimated = this.vorRightAnimator.output;
        this.adfLeftRotationAnimated = this.adfLeftAnimator.output;
        this.adfRightRotationAnimated = this.adfRightAnimator.output;
        this.currentHeadingRotation = MappedSubject.create(([trk, hdg]) => {
            return trk - hdg;
        }, this.compassRotationAnimator.output, this.currentHeadingMag);
        this.selectedHeadingAndTrackRotation = MappedSubject.create(([trk, selHdg]) => {
            return trk - selHdg;
        }, this.compassRotationAnimator.output, this.selectedHeadingAndTrack);
        this.mapFormat = this.settings.getSetting('mapFormat');
        this.isPlanFormat = this.mapFormat.map(f => f === 'PLAN');
        this.hideWindVector = this.isPlanFormat;
        this.hideTrack = this.isPlanFormat;
        this.isWxrEnabled = this.settings.getSetting('terrWxState').map(x => x === 'WX');
        this.isTerrEnabled = this.settings.getSetting('terrWxState').map(x => x === 'TERR');
        this.isTfcEnabled = this.settings.getSetting('tfcEnabled');
        this.tcasTrafficStatus = MappedSubject.create(([taIntruderCount, raIntruderCount]) => {
            if (raIntruderCount > 0) {
                return TcasAlertLevel.ResolutionAdvisory;
            }
            else if (taIntruderCount > 0) {
                return TcasAlertLevel.TrafficAdvisory;
            }
            return TcasAlertLevel.None;
        }, ConsumerSubject.create(this.bus.getSubscriber().on('tcas_ta_intruder_count'), 0), ConsumerSubject.create(this.bus.getSubscriber().on('tcas_ra_intruder_count'), 0));
        this.isWxrSupported = this.mapFormat.map(x => x !== 'PLAN');
        this.isTerrSupported = this.isWxrSupported;
        this.isTfcSupported = this.isWxrSupported;
        this.isVorSupported = this.isWxrSupported;
        this.isAdfSupported = this.isWxrSupported;
        this.isNavPerfSupported = this.isWxrSupported;
        this.isClockSupported = this.mapFormat.map(x => x !== 'PLAN');
        this.showWxr = MappedSubject.create(([isWxrEnabled, isWxrSupported]) => isWxrEnabled && isWxrSupported, this.isWxrEnabled, this.isWxrSupported);
        this.showTerr = MappedSubject.create(([isTerrEnabled, isTerrSupported]) => isTerrEnabled && isTerrSupported, this.isTerrEnabled, this.isTerrSupported);
        this.showTfc = MappedSubject.create(([isTfcEnabled, isTfcSupported]) => isTfcEnabled && isTfcSupported, this.isTfcEnabled, this.isTfcSupported);
        this.mapRange = this.settings.getSetting('mapRange');
        this.mapWaypointsDisplay = this.settings.getSetting('mapWaypointsDisplay');
        this.halfRangeNumber = this.mapRange.map(x => RANGE_FORMATTER(x / 2));
        this.quarterRangeNumber = this.mapRange.map(x => RANGE_FORMATTER(x / 4));
        this._selHdgOrTrk = Subject.create('heading');
        this.selHdgOrTrk = this._selHdgOrTrk;
        this.isHeadingSelectActive = this.fmaData.map(x => x.lateralActive === APLateralModes.HEADING);
        this.isTrackSelectActive = this.fmaData.map(x => x.lateralActive === APLateralModes.TRACK);
        this.hdgTrkWasSelectedInLast10Seconds = Subject.create(false);
        this.showSelHdgTrkLine = MappedSubject.create(([hdgSelectActive, trkSelectActive, selectionRecentlyChanged]) => {
            return hdgSelectActive || trkSelectActive || selectionRecentlyChanged;
        }, this.isHeadingSelectActive, this.isTrackSelectActive, this.hdgTrkWasSelectedInLast10Seconds);
        this.hasWindData = ConsumerSubject.create(this.bus.getSubscriber().on('tas').withPrecision(0), 0)
            .map(tas => tas >= 100);
        /** Called n seconds after selected hdg/trk was last changed. */
        this.handleSelectedHdgTrkTimeoutCompleted = () => {
            this.hdgTrkWasSelectedInLast10Seconds.set(false);
            this.selectedHdgTrkTimeout = undefined;
        };
        // Selected hdg/trk timeout
        this.selectedHeadingAndTrack.sub(() => this.startSelectedHdgTrkTimeout(), false);
        this.compassRotationAnimator.start();
    }
    /** Keeps track of how long ago the selected hdg/trk was last changed. */
    startSelectedHdgTrkTimeout() {
        this.hdgTrkWasSelectedInLast10Seconds.set(true);
        if (this.selectedHdgTrkTimeout) {
            clearTimeout(this.selectedHdgTrkTimeout);
        }
        this.selectedHdgTrkTimeout = window.setTimeout(this.handleSelectedHdgTrkTimeoutCompleted, 10 * 1000);
    }
    /**
     * Set the map projection once map system is created.
     * @param mapProjection The map projection.
     */
    initMapProjection(mapProjection) {
        this._targetProjectedOffsetY.set(mapProjection.getTargetProjectedOffset()[1]);
        mapProjection.addChangeListener((projection, changeFlags) => {
            if (BitFlags.isAny(changeFlags, MapProjectionChangeType.TargetProjected)) {
                this._targetProjectedOffsetY.set(projection.getTargetProjectedOffset()[1]);
            }
        });
    }
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Renders 2 elements, both with the passed class, and the first element with the outlineClass.
 * Saves you from having to write out 2 elements everytime you want an outline in svg.
 */
class OutlinedElement extends DisplayComponent {
    /** @inheritdoc*/
    render() {
        const _a = this.props, { tag, className, outlineClass } = _a, other = __rest(_a, ["tag", "className", "outlineClass"]);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const OutlinedTag = tag;
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(OutlinedTag, Object.assign({ class: (className !== null && className !== void 0 ? className : '') + ' ' + (outlineClass !== null && outlineClass !== void 0 ? outlineClass : '') }, other)),
            FSComponent.buildComponent(OutlinedTag, Object.assign({ class: className !== null && className !== void 0 ? className : '' }, other))));
    }
}

const pathMap = {
    VOR: {
        left: {
            head: 'l 0 66 l 0 -4 l -16 0 l 32 0 l -16 0 l 0 -86 l 0 0 l -8 8 l 8 -8 l 8 8',
            tail: 'l 0 18 l 0 -12 l -16 4.57 l 16 -4.57 l 16 4.57 l -16 -4.57 l 0 -85',
        },
        right: {
            head: 'l 0 -24 l -7 8 l 0 72 l -14 0 l 0 12 l 43 0 l 0 -12 l -15 0 l 0 -72 l -7 -8 z',
            tail: 'm 0 -78 l -7 8 l 0 72 l -14 4 l 0 12 l 21 -6 l 21 6 l 0 -12 l -21 -6 l -7 2 l 7 -2 l 0 12 l 0 -12 l 7 2 l 0 -72 l -7 -8 z',
        },
    },
    ADF: {
        left: {
            head: 'l 0 66 l 0 -4 l -16 0 l 32 0 l -16 0 l 0 -86 l 0 0 l -8 8 l 8 -8 l 8 8',
            tail: 'l 0 18 l 0 -12 l -16 4.57 l 16 -4.57 l 16 4.57 l -16 -4.57 l 0 -85',
        },
        right: {
            head: 'l 0 -24 l -7 8 l 0 72 l -14 0 l 0 12 l 43 0 l 0 -12 l -15 0 l 0 -72 l -7 -8 z',
            tail: 'm 0 -78 l -7 8 l 0 72 l -14 4 l 0 12 l 21 -6 l 21 6 l 0 -12 l -21 -6 l -7 2 l 7 -2 l 0 12 l 0 -12 l 7 2 l 0 -72 l -7 -8 z',
        },
    },
};
/** The BearingPointer component. */
class BearingPointer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.isVisible.sub(isVisible => {
            this.svgRef.instance.classList.toggle('hidden', !isVisible);
        }, true);
        this.props.rotation.sub(rotation => {
            this.svgRef.instance.style.transform = `rotate3d(0, 0, 1, ${rotation * -1}deg)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        const width = 60;
        const halfHeight = this.props.heightUnscaled / 2;
        const headY = halfHeight - this.props.compassRadiusUnscaled;
        const tailY = halfHeight + this.props.compassRadiusUnscaled;
        const { svgScale } = this.props;
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: `bearing-pointer bearing-pointer-${this.props.type} bearing-pointer-${this.props.leftOrRight}`, viewBox: `0 0 ${width} ${this.props.heightUnscaled}`, width: width * this.props.canvasScale, height: this.props.heightUnscaled * this.props.canvasScale, style: "position: absolute;" },
            FSComponent.buildComponent("g", { transform: `translate(${width / 2} ${headY}) scale(${svgScale !== null && svgScale !== void 0 ? svgScale : 1})` },
                FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", "vector-effect": "non-scaling-stroke", stroke: this.props.color, d: `M 0 0 ${pathMap[this.props.type][this.props.leftOrRight]['head']}` })),
            FSComponent.buildComponent("g", { transform: `translate(${width / 2} ${tailY}) scale(${svgScale !== null && svgScale !== void 0 ? svgScale : 1})` },
                FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", "vector-effect": "non-scaling-stroke", stroke: this.props.color, d: `M 0 0 ${pathMap[this.props.type][this.props.leftOrRight]['tail']}` }))));
    }
}

/** A compass rose display component. */
class CompassRoseTicks extends DisplayComponent {
    /** Builds the compass rose tick marks.
     * @returns A collection of rose tick line elements. */
    buildRoseTicks() {
        const { svgViewBoxSize, ticksRadius, shortTickLength, longTickLength, tickDirection, degreesPerTick, degreesPerBigTick = 10, } = this.props;
        const half = svgViewBoxSize / 2;
        const direction = tickDirection === 'Inwards' ? 1 : -1;
        const radialOffset = tickDirection === 'Inwards' ? 0 : 1;
        let path = '';
        for (let deg = 0; deg < 360; deg += degreesPerTick) {
            const length = (deg % degreesPerBigTick == 0 ? longTickLength : shortTickLength) * direction;
            const startX = half + (ticksRadius - length + radialOffset) * Math.sin(deg * Avionics.Utils.DEG2RAD);
            const startY = half + (ticksRadius - length + radialOffset) * -Math.cos(deg * Avionics.Utils.DEG2RAD);
            const endX = startX + (length * Math.sin(deg * Avionics.Utils.DEG2RAD));
            const endY = startY + (length * -Math.cos(deg * Avionics.Utils.DEG2RAD));
            path += `M ${startX} ${startY} L ${endX} ${endY} `;
        }
        return path;
    }
    /** @inheritdoc */
    render() {
        const ticksPath = this.buildRoseTicks();
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            this.props.withCircle && FSComponent.buildComponent("circle", { class: "compass-circle nd-path-shadow", cx: "50%", cy: "50%", r: this.props.ticksRadius + 1 }),
            FSComponent.buildComponent("path", { class: "nd-path-shadow", d: ticksPath }),
            this.props.withCircle && FSComponent.buildComponent("circle", { class: "compass-circle", cx: "50%", cy: "50%", r: this.props.ticksRadius + 1 }),
            FSComponent.buildComponent("path", { d: ticksPath })));
    }
}
/** A compass rose display component. */
class CompassRoseNumbers extends DisplayComponent {
    /** Builds the compass rose letter markings.
     * @returns A collection of letter marking text elements. */
    buildRoseNumbers() {
        const { svgViewBoxSize, numbersRadius, numbersRadiusBigNumber = numbersRadius, degreesPerNumber = 30, degreesPerBigNumber = degreesPerNumber, fontSize, fontSizeBig = fontSize, } = this.props;
        const half = svgViewBoxSize / 2;
        const texts = [];
        for (let deg = degreesPerNumber; deg <= 360; deg += degreesPerNumber) {
            const isBigNumber = deg % degreesPerBigNumber === 0;
            const finalFontSize = isBigNumber
                ? fontSizeBig
                : fontSize;
            const finalRadius = isBigNumber
                ? numbersRadiusBigNumber
                : numbersRadius;
            texts.push(this.buildNumber(half, finalRadius, deg, Math.round(deg / 10).toFixed(0), finalFontSize));
        }
        return texts;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    buildNumber(half, radius, angle, text, fontSize) {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("text", { x: half, y: half - radius, transform: `rotate(${angle}, ${half}, ${half})`, fill: "var(--boeing-colors-black)", "text-anchor": "middle", "font-size": fontSize, stroke: "var(--boeing-colors-black)", "stroke-width": this.props.strokeWidth }, text),
            FSComponent.buildComponent("text", { x: half, y: half - radius, transform: `rotate(${angle}, ${half}, ${half})`, fill: "var(--boeing-colors-white)", "text-anchor": "middle", "font-size": fontSize, stroke: "none" }, text)));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("g", { class: "compass-numbers" }, this.buildRoseNumbers()));
    }
}

/** The CurrentHeadingTriangle component. */
class CurrentHeadingTriangle extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.currentHeadingRotation.sub(hdg => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${hdg * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /**
     * Builds a current heading triangle element.
     * @param compassRadius The compass radius.
     * @param ref The ref to use.
     * @param canvasScale The canvas scale to use, defaults to 1.
     * @param svgScale the svg scale to use, defaults to 1.
     * @returns the heading triangle svg element.
     */
    static build(compassRadius, ref, canvasScale = 1, svgScale = 1) {
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: ref, class: "current-heading-triangle", viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * canvasScale, height: sizeUnscaled * canvasScale, style: `position: absolute; transform: translateY(${compassRadius * -1}px)` },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M -13 -26 l 13 26 l 13 -26 z", "vector-effect": "non-scaling-stroke", transform: `scale(${svgScale})` })));
    }
    /** @inheritdoc */
    render() {
        return CurrentHeadingTriangle.build(this.props.compassRadius, this.svgRef, this.props.ndDataProvider.canvasScale, this.props.svgScale);
    }
}

/** The SelectedHeadingBug component. */
class SelectedHeadingBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isAligned, selHdgOrTrk]) => {
            const isVisible = isAligned && selHdgOrTrk === 'heading';
            return !isVisible;
        }, this.props.ndDataProvider.isAligned, this.props.ndDataProvider.selHdgOrTrk);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /**
     * Builds a selected heading bug element.
     * @param ref The ref to use.
     * @param canvasScale The canvas scale to use, defaults to 1.
     * @param svgScale the svg scale to use, defaults to 1.
     * @param isHidden Whether bug should be hidden or not. Defaults to false.
     * @returns the selected heading bug svg element.
     */
    static build(ref, canvasScale = 1, svgScale = 1, isHidden) {
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: ref, class: {
                'selected-heading-bug': true,
                'hidden': isHidden !== null && isHidden !== void 0 ? isHidden : false,
            }, viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * canvasScale, height: sizeUnscaled * canvasScale, style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M 0 0 l -23 0 l 0 -18 l 10 0 l 10 18 l 6 0 l 10 -18 l 10 0 l 0 18 z", stroke: BoeingColors.magenta, "vector-effect": "non-scaling-stroke", transform: `scale(${svgScale})` })));
    }
    /** @inheritdoc */
    render() {
        return SelectedHeadingBug.build(this.svgRef, this.props.ndDataProvider.canvasScale, this.props.svgScale, this.isHidden);
    }
}

/** The SelectedHeadingLine component. */
class SelectedHeadingLine extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isAligned, selHdgOrTrk, showSelHdgTrkLine]) => {
            const isVisible = isAligned && selHdgOrTrk === 'heading' && showSelHdgTrkLine;
            return !isVisible;
        }, this.props.ndDataProvider.isAligned, this.props.ndDataProvider.selHdgOrTrk, this.props.ndDataProvider.showSelHdgTrkLine);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${(this.props.compassRadius * -0.5) + (1 * this.props.ndDataProvider.canvasScale)}px)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: {
                'selected-heading-line': true,
                'hidden': this.isHidden,
            }, viewBox: `-5 0 10 ${(this.props.compassRadius / this.props.ndDataProvider.canvasScale) + 10}`, width: 10 * this.props.ndDataProvider.canvasScale, height: this.props.compassRadius + (10 * this.props.ndDataProvider.canvasScale), style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "line", outlineClass: "nd-path-shadow", x1: 0, y1: this.props.compassRadius / this.props.ndDataProvider.canvasScale, x2: 0, y2: 4, stroke: this.props.ndDataProvider.magenta, "stroke-dasharray": `${19 * this.props.ndDataProvider.canvasScale} ${44 * this.props.ndDataProvider.canvasScale}`, "vector-effect": "non-scaling-stroke" })));
    }
}

/** The SelectedTrackBug component. */
class SelectedTrackBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isAligned, selHdgOrTrk]) => {
            const isVisible = isAligned && selHdgOrTrk === 'track';
            return !isVisible;
        }, this.props.ndDataProvider.isAligned, this.props.ndDataProvider.selHdgOrTrk);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        var _a;
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: {
                'selected-track-bug': true,
                'hidden': this.isHidden,
            }, viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * this.props.ndDataProvider.canvasScale, height: sizeUnscaled * this.props.ndDataProvider.canvasScale, style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M 0 0 l -23 0 l 0 8 l 23 12 l 23 -12 l 0 -8 l -23 0 l 0 20", stroke: this.props.ndDataProvider.magenta, "vector-effect": "non-scaling-stroke", transform: `scale(${(_a = this.props.svgScale) !== null && _a !== void 0 ? _a : 1})` })));
    }
}

/** The SelectedTrackLine component. */
class SelectedTrackLine extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isAligned, selHdgOrTrk, showSelHdgTrkLine]) => {
            const isVisible = isAligned && selHdgOrTrk === 'track' && showSelHdgTrkLine;
            return !isVisible;
        }, this.props.ndDataProvider.isAligned, this.props.ndDataProvider.selHdgOrTrk, this.props.ndDataProvider.showSelHdgTrkLine);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${(this.props.compassRadius * -0.5) + (1 * this.props.ndDataProvider.canvasScale)}px)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: {
                'selected-heading-line': true,
                'hidden': this.isHidden,
            }, viewBox: `-5 0 10 ${(this.props.compassRadius / this.props.ndDataProvider.canvasScale) + 10}`, width: 10 * this.props.ndDataProvider.canvasScale, height: this.props.compassRadius + (10 * this.props.ndDataProvider.canvasScale), style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "line", outlineClass: "nd-path-shadow", x1: 0, y1: this.props.compassRadius / this.props.ndDataProvider.canvasScale, x2: 0, y2: 4, stroke: this.props.ndDataProvider.magenta, "stroke-dasharray": `${18 * this.props.ndDataProvider.canvasScale} ${44 * this.props.ndDataProvider.canvasScale}`, "vector-effect": "non-scaling-stroke" })));
    }
}

const whiteSpaceRegex = /\s/g;
const FL = 'FL';
const EMPTY = '';
/**
 * An map flightplan waypoint label for the B787.
 * Capable of showing speed and altitude restrictions.
 */
class FlightPathWaypointLabel extends MapCullableLocationTextLabel {
    /**
     * Ctor
     * @param waypoint The map waypoint object to display.
     * @param displaySetting The map display settings object.
     * @param options The label options.
     * @param canvasScale The canvas scale.
     * @param lineHeight The amount of pixels to offset each line by vertically.
     * @param vnavDataModule The vnav data module.
     * @param activeRoutePredictor The active route predictor.
     * @param activeRoutePlan The active route plan subject.
     * @param perfPlanRepository The perfPlanRepository.
     */
    constructor(waypoint, displaySetting, options, canvasScale, lineHeight, vnavDataModule, activeRoutePredictor, activeRoutePlan, perfPlanRepository) {
        super(waypoint.ident.replace(whiteSpaceRegex, ''), 999, waypoint.location, true, options);
        this.waypoint = waypoint;
        this.canvasScale = canvasScale;
        this.lineHeight = lineHeight;
        this.vnavDataModule = vnavDataModule;
        this.activeRoutePredictor = activeRoutePredictor;
        this.activeRoutePlan = activeRoutePlan;
        this.perfPlanRepository = perfPlanRepository;
        this.timeFormatter = DateTimeFormatter.create('{HH}{mm}Z');
        this.altDesc = AltitudeRestrictionType.Unused;
        this.altitude1 = -1;
        this.altitude2 = -1;
        this.phase = VerticalFlightPhase.Climb;
        this.transitionAltitude = -1;
        this.transitionLevel = -1;
        this.altitudeText = '';
        this.eta = undefined;
        this.etaText = '';
        this.isDisplayed = true;
        this.showAltRestrictions = false;
        this.showEta = false;
        if (displaySetting) {
            this.displaySettingSub = displaySetting.sub(v => {
                this.showAltRestrictions = BitFlags.isAll(v, MapWaypointsDisplay.Altitude);
                this.showEta = BitFlags.isAll(v, MapWaypointsDisplay.ETA);
            }, true);
        }
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.displaySettingSub) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
    /**
     * Sets whether or not the label is displayed.
     * @param isDisplayed Whether or not the label is displayed.
     */
    setDisplayed(isDisplayed) {
        this.isDisplayed = isDisplayed;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        if (this.isDisplayed) {
            this.setTextStyle(context);
            context.textBaseline = 'top';
            context.textAlign = 'left';
            const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
            const centerX = pos[0];
            const centerY = pos[1];
            this.drawText(context, centerX, centerY);
        }
    }
    /** @inheritdoc */
    drawText(context, centerX, centerY) {
        // IDENT
        // Ident is always line 1
        this.renderText(context, centerX, centerY, this.text.get());
        // ALTITUDE
        const isNextConstraint = this.vnavDataModule
            ? this.waypoint.leg === this.vnavDataModule.nextConstraintLegDefForMap.get()
            : false;
        const renderAltitudeLabel = (isNextConstraint || this.showAltRestrictions === true) && BoeingMapUtils.showAltitudeForLeg(this.waypoint.leg);
        if (renderAltitudeLabel) {
            this.updateAltitudeText();
        }
        if (renderAltitudeLabel && this.altitudeText) {
            // Altitude is always line 2
            const offsetY = this.lineHeight * this.canvasScale;
            this.renderText(context, centerX, centerY + offsetY, this.altitudeText);
        }
        // ETA
        if (this.showEta) {
            this.updateEtaText();
        }
        if (this.showEta && this.etaText) {
            // ETA could be line 2 or 3
            const offsetY = (this.altitudeText ? this.lineHeight * 2 : this.lineHeight) * this.canvasScale;
            this.renderText(context, centerX, centerY + offsetY, this.etaText);
        }
    }
    /**
     * Renders text for the label
     * @param context the context
     * @param centerX the cneter x position
     * @param centerY the center y position
     * @param text the text to render
     */
    renderText(context, centerX, centerY, text) {
        const fontOutlineWidth = this.fontOutlineWidth.get();
        if (fontOutlineWidth > 0) {
            context.lineWidth = fontOutlineWidth * 2;
            context.strokeStyle = this.fontOutlineColor.get();
            context.strokeText(text, centerX, centerY);
        }
        context.fillStyle = this.fontColor.get();
        context.fillText(text, centerX, centerY);
    }
    /** Updates the ETA text if anything changed. */
    updateEtaText() {
        var _a, _b, _c;
        const globalLegIndex = (_b = (_a = this.activeRoutePlan) === null || _a === void 0 ? void 0 : _a.get()) === null || _b === void 0 ? void 0 : _b.getLegIndexFromLeg(this.waypoint.leg);
        let predictions;
        if (globalLegIndex !== undefined) {
            predictions = (_c = this.activeRoutePredictor) === null || _c === void 0 ? void 0 : _c.getPredictionsForLeg(globalLegIndex);
        }
        let needsUpdate = false;
        if ((predictions === null || predictions === void 0 ? void 0 : predictions.estimatedTimeOfArrival) !== this.eta) {
            this.eta = predictions === null || predictions === void 0 ? void 0 : predictions.estimatedTimeOfArrival;
            needsUpdate = true;
        }
        if (needsUpdate) {
            this.etaText = this.eta !== undefined
                ? this.timeFormatter(this.eta * 1000)
                : EMPTY;
        }
    }
    /** Updates the altitude text if anything changed. */
    updateAltitudeText() {
        var _a;
        const legVerticalData = this.waypoint.leg.verticalData;
        const activePerfPlan = (_a = this.perfPlanRepository) === null || _a === void 0 ? void 0 : _a.getActivePlan();
        if (!activePerfPlan) {
            return;
        }
        let needsUpdate = false;
        if (legVerticalData.altDesc !== this.altDesc) {
            this.altDesc = legVerticalData.altDesc;
            needsUpdate = true;
        }
        if (legVerticalData.altitude1 !== this.altitude1) {
            this.altitude1 = legVerticalData.altitude1;
            needsUpdate = true;
        }
        if (legVerticalData.altitude2 !== this.altitude2) {
            this.altitude2 = legVerticalData.altitude2;
            needsUpdate = true;
        }
        if (legVerticalData.phase !== this.phase) {
            this.phase = legVerticalData.phase;
            needsUpdate = true;
        }
        if (activePerfPlan.transitionAltitude.get() !== this.transitionAltitude) {
            this.transitionAltitude = activePerfPlan.transitionAltitude.get();
            needsUpdate = true;
        }
        if (activePerfPlan.transitionLevel.get() !== this.transitionLevel) {
            this.transitionLevel = activePerfPlan.transitionLevel.get();
            needsUpdate = true;
        }
        if (needsUpdate) {
            this.altitudeText = this.formatAltitudeConstraint();
        }
    }
    /**
     * Formats an altitude constraint for display on a waypoint label.
     * @returns A formatted altitude constraint text.
     */
    formatAltitudeConstraint() {
        const alt1Feet = UnitType.FOOT.convertFrom(this.altitude1, UnitType.METER);
        const alt2Feet = UnitType.FOOT.convertFrom(this.altitude2, UnitType.METER);
        const isAlt1FL = alt1Feet > (this.phase === VerticalFlightPhase.Climb ? this.transitionAltitude : this.transitionLevel);
        const isAlt2FL = alt2Feet > (this.phase === VerticalFlightPhase.Climb ? this.transitionAltitude : this.transitionLevel);
        const alt1FlString = isAlt1FL ? FL : EMPTY;
        const alt2FlString = isAlt2FL ? FL : EMPTY;
        const alt1String = (alt1Feet / (isAlt1FL ? 100 : 1)).toFixed(0);
        const alt2String = (alt2Feet / (isAlt2FL ? 100 : 1)).toFixed(0);
        switch (this.altDesc) {
            case AltitudeRestrictionType.At:
                return `${alt1FlString}${alt1String}`;
            case AltitudeRestrictionType.AtOrAbove:
                return `${alt1FlString}${alt1String}A`;
            case AltitudeRestrictionType.AtOrBelow:
                return `${alt1FlString}${alt1String}B`;
            case AltitudeRestrictionType.Between:
                return this.phase === VerticalFlightPhase.Climb
                    ? `${alt2FlString}${alt2String}A${alt1FlString}${alt1String}B`
                    : `${alt1FlString}${alt1String}B${alt2FlString}${alt2String}A`;
            case AltitudeRestrictionType.Unused: {
                return EMPTY;
            }
        }
    }
}

const ETA_FORMATTER = DurationFormatter.create('{hh}{mm.m}', UnitType.MILLISECOND, 6000, '------');
const DISTANCE_FORMATTER = NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: true, nanString: '----' });
const MSEC_PER_DAY = 1000 * 60 * 60 * 24;
/** The ActiveWaypointDataBlock component. */
class ActiveWaypointDataBlock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.date = new Date(0);
        this.lNavDataSub = this.props.bus.getSubscriber();
        this.clockSub = this.props.bus.getSubscriber();
        this.activeLegPrediction = Subject.create(null);
        this.currentSimTime = ConsumerSubject.create(this.clockSub.on('simTime').atFrequency(1), 0);
        this.activeLegIndex = ConsumerSubject.create(this.lNavDataSub.on('lnavdata_nominal_leg_index'), -1);
        this.activeLegIdent = ConsumerSubject.create(this.lNavDataSub.on('lnavdata_waypoint_ident'), '');
        this.activeLegDistance = ConsumerSubject.create(this.lNavDataSub.on('lnavdata_waypoint_distance').withPrecision(1), 0);
        this.waypointIdent = MappedSubject.create(([activeLegIdent]) => {
            if (activeLegIdent.trim().length === 0) {
                return '(-----)';
            }
            else {
                // Don't remove whitespace here, the real thing will display alt legs like (3500 ), so that's expected
                return activeLegIdent;
            }
        }, this.activeLegIdent);
        this.eta = MappedSubject.create(([activeLegPrediction, simTime]) => {
            if (!activeLegPrediction) {
                return ETA_FORMATTER(NaN);
            }
            const unixDayStartMs = simTime - (simTime % (MSEC_PER_DAY));
            const eta = unixDayStartMs + activeLegPrediction.estimatedTimeOfArrival * 1000;
            this.date.setTime(eta);
            const etaTimeMs = eta - this.date.setUTCHours(0, 0, 0, 0);
            return ETA_FORMATTER(etaTimeMs);
        }, this.activeLegPrediction, this.currentSimTime);
        this.distance = MappedSubject.create(([distance, activeLegIdent]) => {
            return (activeLegIdent.trim().length > 0
                ? DISTANCE_FORMATTER(distance)
                : '----').padStart(this.props.distancePad, ' ');
        }, this.activeLegDistance, this.activeLegIdent);
        this.subs = [];
    }
    /** @inheritDoc */
    onAfterRender() {
        this.subs = [
            this.props.activeRoutePredictor.onPredictionsUpdated.on(this.updatePrediction.bind(this)),
            this.activeLegIndex.sub(this.updatePrediction.bind(this)),
        ];
    }
    /** Update predictions after updating flight plan predictor. */
    updatePrediction() {
        const activeLegIndex = this.activeLegIndex.get();
        const hasActiveLeg = activeLegIndex !== -1;
        const hasActiveRoutePlan = this.props.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        if (hasActiveRoutePlan && hasActiveLeg) {
            const predictions = this.props.activeRoutePredictor.iteratePredictions(activeLegIndex);
            const activeLegPredictions = predictions.next();
            if (activeLegPredictions.value) {
                this.activeLegPrediction.set(activeLegPredictions.value);
                this.activeLegPrediction.notify();
            }
            else {
                this.activeLegPrediction.set(null);
            }
        }
        else {
            this.activeLegPrediction.set(null);
        }
    }
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "active-waypoint-data-block-container" },
            FSComponent.buildComponent("div", { class: "waypoint-ident" }, this.waypointIdent),
            FSComponent.buildComponent("div", { class: "waypoint-estimated-arrival-time" },
                FSComponent.buildComponent("span", null, this.eta),
                FSComponent.buildComponent("span", { class: "s-text" }, "Z")),
            FSComponent.buildComponent("div", { class: "waypoint-distance" },
                this.distance,
                FSComponent.buildComponent("span", { class: "s-text" }, "NM"))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.map((sub) => sub.destroy());
    }
}

/** The AdfDisplay component. */
class AdfDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.adfSectionRef = FSComponent.createRef();
        this.adfLeftRef = FSComponent.createRef();
        this.adfRightRef = FSComponent.createRef();
        this.navComSub = this.props.bus.getSubscriber();
        this.adfFreq1 = ConsumerSubject.create(this.navComSub.on('adf_active_frequency_1').withPrecision(1), 0);
        this.adfFreq2 = ConsumerSubject.create(this.navComSub.on('adf_active_frequency_2').withPrecision(1), 0);
        this.adfIdent1 = ConsumerSubject.create(this.navComSub.on('adf_ident_1').whenChanged(), '');
        this.adfIdent2 = ConsumerSubject.create(this.navComSub.on('adf_ident_2').whenChanged(), '');
        this.adfSignal1 = ConsumerSubject.create(this.navComSub.on('adf_signal_1').atFrequency(1), 0);
        this.adfSignal2 = ConsumerSubject.create(this.navComSub.on('adf_signal_2').atFrequency(1), 0);
        this.formatAdfData = ([freq, ident, signal]) => {
            if (signal > 0 && ident !== '') {
                return ident;
            }
            else if (freq) {
                return freq.toFixed(1);
            }
            else {
                return '---.-';
            }
        };
        this.adfLeftData = MappedSubject.create(this.adfFreq1, this.adfIdent1, this.adfSignal1).map(this.formatAdfData);
        this.adfRightData = MappedSubject.create(this.adfFreq2, this.adfIdent2, this.adfSignal2).map(this.formatAdfData);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.navAidLeftState.sub(state => {
            this.adfLeftRef.instance.classList.toggle('hidden', state !== 'ADF');
        }, true);
        this.props.ndDataProvider.navAidRightState.sub(state => {
            this.adfRightRef.instance.classList.toggle('hidden', state !== 'ADF');
        }, true);
        this.props.ndDataProvider.isAdfSupported.sub(isAdfSupported => {
            this.adfSectionRef.instance.classList.toggle('hidden', !isAdfSupported);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "adf-display", ref: this.adfSectionRef },
            FSComponent.buildComponent("div", { class: "data-block-left", ref: this.adfLeftRef },
                FSComponent.buildComponent("div", null, "ADF L"),
                FSComponent.buildComponent("div", null, this.adfLeftData)),
            FSComponent.buildComponent("div", { class: "data-block-right", ref: this.adfRightRef },
                FSComponent.buildComponent("div", null, "ADF R"),
                FSComponent.buildComponent("div", null, this.adfRightData))));
    }
}

/** The AircraftTrack component. */
class AircraftTrack extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.currentTrackDegMag = ConsumerSubject.create(this.props.bus.getSubscriber().on('track_deg_magnetic').withPrecision(0), 0);
        this.currentHeadingMag = ConsumerSubject.create(this.props.bus.getSubscriber().on('hdg_deg').withPrecision(0), 0);
        this.currentGroundSpeed = ConsumerSubject.create(this.props.bus.getSubscriber().on('ground_speed').atFrequency(1), 0);
        this.aircraftTrack = MappedSubject.create(([track, heading, groundSpeed, isAligned]) => {
            if (!isAligned) {
                return '---';
            }
            const value = groundSpeed < 5 ? heading : track;
            return value === 0 ? 360 : value;
        }, this.currentTrackDegMag, this.currentHeadingMag, this.currentGroundSpeed, this.props.ndDataProvider.isAligned);
    }
    /** @inheritDoc */
    onAfterRender() {
        this.props.ndDataProvider.hideTrack.sub(isHidden => this.setVisibility(!isHidden), true);
    }
    /**
     * Sets the visibility of the aircraft track.
     * @param isVisible the isVisible flag
     */
    setVisibility(isVisible) {
        this.containerRef.instance.classList.toggle('hidden', !isVisible);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "aircraft-track-container", ref: this.containerRef },
            FSComponent.buildComponent("div", { class: "track-orientation-text" }, "TRK"),
            FSComponent.buildComponent("div", { class: "aircraft-track-number" }, this.aircraftTrack),
            FSComponent.buildComponent("div", { class: "track-reference-text" }, "MAG")));
    }
}

/** The GroundAirSpeed component. */
class GroundAirSpeed extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.speedSub = this.props.bus.getSubscriber();
        this.tasRef = FSComponent.createRef();
        this.isTasInvalid = Subject.create(false);
        this.trueAirSpeed = Subject.create(0);
        this.groundSpeed = Subject.create(0);
    }
    /** @inheritDoc */
    onAfterRender() {
        this.speedSub.on('tas').withPrecision(0).atFrequency(5).handle((value) => {
            this.isTasInvalid.set(value < 100);
            this.trueAirSpeed.set(value);
        });
        this.isTasInvalid.sub((value) => {
            this.tasRef.instance.classList.toggle('hidden', value);
        }, true);
        this.speedSub.on('ground_speed').withPrecision(0).atFrequency(5).handle((value) => this.groundSpeed.set(value));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "ground-air-speed-container" },
            FSComponent.buildComponent("span", { class: "ground-speed" },
                FSComponent.buildComponent("span", { class: "s-text" }, "GS"),
                FSComponent.buildComponent("span", null, this.groundSpeed)),
            FSComponent.buildComponent("span", { class: "true-air-speed", ref: this.tasRef },
                FSComponent.buildComponent("span", { class: "s-text" }, "TAS"),
                FSComponent.buildComponent("span", null, this.trueAirSpeed))));
    }
}

/** The MapRange component. */
class MapRange extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-range-container" },
            FSComponent.buildComponent("div", { class: "s-text" }, "RANGE"),
            FSComponent.buildComponent("div", { class: "text" }, this.props.ndDataProvider.mapRange)));
    }
}

/** Display lateral RNP / ANP at the bottom of the ND map. */
class LateralRnpAnp extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.rnp = ConsumerSubject.create(this.props.sub.on('lnavdata_rnp').whenChanged(), 0);
        this.anp = ConsumerSubject.create(this.props.sub.on('fms_pos_anp_1').whenChangedBy(0.01).atFrequency(3), 0);
        this.isWarning = MappedSubject.create(this.rnp, this.anp).map(([rnp, anp]) => anp >= rnp);
        this.rootContainerStyle = ObjectSubject.create({
            position: 'absolute',
            display: 'flex',
            bottom: '0',
            right: 'auto',
            left: 'auto',
            width: '100%',
            'font-size': `${this.props.fontSize}px`,
            'margin-left': '-20px',
            'justify-content': 'center',
            'align-content': 'center',
            'color': 'var(--boeing-colors-green)',
        });
        this.rnpContainerStyle = {
            display: 'flex',
            background: 'var(--boeing-colors-black)',
            padding: '2px 2px 0 2px',
            'flex-direction': 'column',
            'text-align': 'center',
            'padding-right': '16px',
        };
        this.anpContainerStyle = {
            display: 'flex',
            background: 'var(--boeing-colors-black)',
            padding: '2px 2px 0 2px',
            'flex-direction': 'column',
            'text-align': 'center',
            'padding-left': '16px',
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.warningSub = this.isWarning.sub((v) => {
            this.rootContainerStyle.set('color', v ? 'var(--boeing-colors-amber)' : 'var(--boeing-colors-green)');
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "nd-lateral-rnp-anp-container", style: this.rootContainerStyle, ref: this.containerRef },
            FSComponent.buildComponent("div", { style: this.rnpContainerStyle },
                FSComponent.buildComponent("div", null, "RNP"),
                FSComponent.buildComponent("div", null, this.rnp.map(v => v.toFixed(2)))),
            FSComponent.buildComponent("div", { style: this.anpContainerStyle },
                FSComponent.buildComponent("div", null, "ANP"),
                FSComponent.buildComponent("div", null, this.anp.map(v => v < 0 ? '----' : v.toFixed(2))))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.warningSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/** The VerticalNavigationPerformance component. Displays only during FMC descent phase of flight. */
class VerticalRnpAnp extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootContainerRef = FSComponent.createRef();
        this.isWarning = MappedSubject.create(this.props.rnp, this.props.anp).map(([rnp, anp]) => anp >= rnp);
        this.rootContainerStyle = ObjectSubject.create({
            position: 'absolute',
            display: 'flex',
            'flex-direction': 'column',
            right: '46px',
            height: '100%',
            color: 'var(--boeing-colors-green)',
            'font-size': `${this.props.fontSize}px`,
            'align-content': 'space-between',
        });
        this.sharedRnpAnpContainerStyle = {
            display: 'flex',
            background: 'var(--boeing-colors-black)',
            'flex-direction': 'column',
            'text-align': 'right',
            'align-content': 'center',
            height: '50%',
            'min-width': '40px',
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.warningSub = this.isWarning.sub((v) => {
            this.rootContainerStyle.set('color', v ? 'var(--boeing-colors-amber)' : 'var(--boeing-colors-green)');
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "nd-vertical-rnp-anp-container", style: this.rootContainerStyle, ref: this.rootContainerRef },
            FSComponent.buildComponent("div", { class: "rnp-text-container", style: Object.assign(Object.assign({}, this.sharedRnpAnpContainerStyle), { 'justify-content': 'flex-end' }) },
                FSComponent.buildComponent("span", null, "RNP"),
                FSComponent.buildComponent("span", null, this.props.rnp.map((v) => v.toFixed(0)))),
            FSComponent.buildComponent("div", { class: "anp-text-container", style: Object.assign(Object.assign({}, this.sharedRnpAnpContainerStyle), { 'justify-content': 'flex-start', 'padding-top': '8px' }) },
                FSComponent.buildComponent("span", null, "ANP"),
                FSComponent.buildComponent("span", null, this.props.anp.map((v) => v < 0 ? '---' : v.toFixed(0))))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.warningSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/** The VerticalDeviationIndicator component. Displays only during FMC descent phase of flight. */
class VerticalDeviationIndicator extends DisplayComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.scaleRatio = (_a = this.props.scaleRatio) !== null && _a !== void 0 ? _a : 1;
        this.containerHeightString = '213.75px';
        this.rootContainerStyle = {
            position: 'absolute',
            bottom: `${this.props.marginBottom}px`,
            right: '0',
            'padding-right': '10px',
            color: 'var(--boeing-colors-white)',
            background: 'var(--boeing-colors-black)',
            transform: `scale(${this.scaleRatio})`,
        };
        this.digitalDeviationDisplayUpperRef = FSComponent.createRef();
        this.digitalDeviationDisplayLowerRef = FSComponent.createRef();
        this.verticalDeviationRaw = Subject.create(0);
        this.verticalDeviationRawAbsolute = Subject.create(0);
        this.subscriptions = [];
        this.isVnavPathDevIndicatorVisible = MappedSubject.create(([pathAvailable, gsActive, flareActive, onGround]) => {
            return pathAvailable && !gsActive && !flareActive && !onGround;
        }, this.props.verticalDeviationDataProvider.isVerticalPathAvailable, this.props.verticalDeviationDataProvider.isApGsActive, this.props.verticalDeviationDataProvider.isApFlareActive, this.props.ndDataProvider.isOnGround);
        this.pointerTransform = MappedSubject.create(([deviation]) => {
            const nominalDeviation = deviation === null
                ? 0
                // The clamp values are -404/404 instead of -400/400 for realistic visualization of the pointer position
                // (it goes off the scale a bit at both extremes in real life)
                : MathUtils.clamp(deviation, -404, 404) / VerticalDeviationIndicator.SCALE_ABS_FULL_VOLUME;
            return `translate3d(0, ${nominalDeviation * 100}%, 0)`;
        }, this.props.verticalDeviationDataProvider.npDeviation);
        this.extensionBandTransform = this.props.verticalDeviationDataProvider.npDeviation.map((deviation) => {
            const nominalDeviation = deviation === null
                ? 0
                : deviation / VerticalDeviationIndicator.SCALE_ABS_FULL_VOLUME;
            return `translate3d(0, ${nominalDeviation * 100}%, 0)`;
        });
        /** This re-paints the SVG, but this does not get called often, about 3 times per flight. */
        this.extensionBandPath = this.props.verticalDeviationDataProvider.rnp.map((rnp) => {
            const halfBandHeight = Math.abs(MathUtils.clamp(rnp, -394, 394) * 0.095);
            return `M 5.4273 -3.0365 V -${halfBandHeight} M 5.4273 3.0365 V ${halfBandHeight} M 5.4273 ${halfBandHeight} H 1 M 5.4273 -${halfBandHeight} H 1`;
        });
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subscriptions = [
            this.props.verticalDeviationDataProvider.npDeviation.sub((v) => {
                this.verticalDeviationRaw.set(MathUtils.round(v ? -v : 0));
            }, true),
            this.verticalDeviationRaw.sub(v => {
                this.digitalDeviationDisplayUpperRef.instance.classList.toggle('hidden', !(v >= 20 && v <= 20000) || v < 0);
                this.digitalDeviationDisplayLowerRef.instance.classList.toggle('hidden', !(v <= -20 && v >= -20000) || v > 0);
                this.verticalDeviationRawAbsolute.set(Math.abs(v));
            }, true),
        ];
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'vertical-deviation-indicator': true,
                'hidden': this.isVnavPathDevIndicatorVisible.map(x => !x),
            }, style: this.rootContainerStyle },
            FSComponent.buildComponent(VerticalRnpAnp, { rnp: this.props.verticalDeviationDataProvider.rnp, anp: this.props.verticalDeviationDataProvider.anp, fontSize: this.props.fontSize / this.scaleRatio }),
            FSComponent.buildComponent("div", { class: "digital-deviation-display-upper", style: { 'font-size': `${this.props.fontSize / this.scaleRatio}px` }, ref: this.digitalDeviationDisplayUpperRef }, this.verticalDeviationRawAbsolute),
            FSComponent.buildComponent("div", { class: "digital-deviation-display-lower", style: { 'font-size': `${this.props.fontSize / this.scaleRatio}px` }, ref: this.digitalDeviationDisplayLowerRef }, this.verticalDeviationRawAbsolute),
            FSComponent.buildComponent("svg", { class: "deviation-scale", style: { position: 'absolute', bottom: '0' }, viewBox: VerticalDeviationIndicator.SCALE_VIEW_BOX_STRING, width: 60 },
                FSComponent.buildComponent("path", { d: "M -5 -38 H 0 V 38 H -5 M 0 0 H -10", "vector-effect": "non-scaling-stroke", stroke: "var(--boeing-colors-white)", "stroke-linecap": "butt", "stroke-width": `${this.props.lineThickness}px`, fill: "none" })),
            FSComponent.buildComponent("div", { class: "pointer-extension-band-overflow-container", style: { position: 'absolute', bottom: '0', height: this.containerHeightString, overflow: 'hidden' } },
                FSComponent.buildComponent("div", { class: "pointer-extension-band-transform-container", style: { transform: this.extensionBandTransform, height: this.containerHeightString } },
                    FSComponent.buildComponent("svg", { class: "pointer-extension-band", viewBox: VerticalDeviationIndicator.SCALE_VIEW_BOX_STRING, width: 60 },
                        FSComponent.buildComponent("path", { d: this.extensionBandPath, "vector-effect": "non-scaling-stroke", stroke: "var(--boeing-colors-magenta)", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": `${this.props.lineThickness}px`, fill: "none" })))),
            FSComponent.buildComponent("div", { class: "deviation-pointer-transform-container", style: { transform: this.pointerTransform, height: this.containerHeightString } },
                FSComponent.buildComponent("svg", { class: "deviation-pointer", viewBox: VerticalDeviationIndicator.SCALE_VIEW_BOX_STRING, width: 60 },
                    FSComponent.buildComponent("path", { class: "deviation-pointer-outline", d: "M 1.5 0 L 5.4273 -2.7329 L 9.3746 0 L 5.4273 2.7329 Z", "vector-effect": "non-scaling-stroke", stroke: "var(--boeing-colors-magenta)", fill: "var(--boeing-colors-black)", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": `${this.props.lineThickness * 2}` })))));
    }
    /** @inheritdoc */
    destroy() {
        this.subscriptions.map((sub) => sub.destroy());
    }
}
/** The full scale can represent an absolute 800 units (+/-400). */
VerticalDeviationIndicator.SCALE_ABS_FULL_VOLUME = 800;
VerticalDeviationIndicator.SCALE_VIEW_BOX_STRING = '-10 -39 22 78';

/** The MapNavigationPerfomance component. Displays lateral/vertical RNP/ANP for MFD ND and PFD minimap. */
class MapNavigationPerformance extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.sub = this.props.bus.getSubscriber();
        this.rootContainerRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.settingSub = this.props.ndDataProvider.isNavPerfSupported.sub(isNavPerfSupported => {
            this.rootContainerRef.instance.classList.toggle('hidden', !isNavPerfSupported);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-navigation-performance-container", ref: this.rootContainerRef },
            FSComponent.buildComponent(LateralRnpAnp, { sub: this.sub, fontSize: this.props.fontSize }),
            FSComponent.buildComponent(VerticalDeviationIndicator, { verticalDeviationDataProvider: this.props.verticalDeviationDataProvider, ndDataProvider: this.props.ndDataProvider, fontSize: this.props.fontSize, lineThickness: this.props.lineThickness, marginBottom: this.props.marginBottom, scaleRatio: this.props.scaleRatio })));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.settingSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/** The WindVector component. Indicates wind bearing, speed, and direction with respect to heading / track reference.
 * Arrow not displayed in PLAN mode. */
class WindVector extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.windArrowRef = FSComponent.createRef();
        /** Plane track in degrees true. */
        this.magVar = ConsumerSubject.create(null, 0);
        this.sub = this.props.bus.getSubscriber();
        this.trackDegTrue = ConsumerSubject.create(this.sub.on('track_deg_true').withPrecision(1), 0);
        this.windDirectionDegTrue = ConsumerSubject.create(this.sub.on('ambient_wind_direction').withPrecision(0).atFrequency(5), 0);
        this.windSpeedKnots = ConsumerSubject.create(this.sub.on('ambient_wind_velocity').withPrecision(0).atFrequency(5), 0);
        this.groundSpeed = ConsumerSubject.create(this.sub.on('ground_speed').withPrecision(0).atFrequency(5), 0);
        // FIXME wind vector can reference to heading/track, not only heading.
        this.windArrowRotation = MappedSubject.create(([windDirTrue, track]) => {
            return windDirTrue - track - 180;
        }, this.windDirectionDegTrue, this.trackDegTrue);
        this.windArrowAnimator = new MapCompassAnimator(undefined, undefined, this.windArrowRotation);
        // FIXME should take into consideration TRUE/MAG reference if implemented
        this.windDirectionString = MappedSubject.create(([windDirTrue, magVar]) => MagVar.trueToMagnetic(windDirTrue, magVar).toFixed(0).padStart(3, '0'), this.windDirectionDegTrue, this.magVar);
        this.speedValid = this.windSpeedKnots.map((windSpeed, prevValue) => {
            const speedThresh = prevValue ? 5 : 7;
            return windSpeed >= speedThresh;
        });
        this.groundSpeedValid = this.groundSpeed.map((groundSpeed, prevValue) => {
            const groundSpeedThresh = prevValue ? 36 : 40;
            return groundSpeed >= groundSpeedThresh;
        });
        this.isArrowVisible = MappedSubject.create(([hideWindVector, speedValid, groundSpeedValid]) => {
            if (hideWindVector) {
                return false;
            }
            return Boolean(speedValid && groundSpeedValid);
        }, this.props.ndDataProvider.hideWindVector, this.speedValid, this.groundSpeedValid);
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.magVar.setConsumer(sub.on('magvar').withPrecision(1));
        this.windArrowAnimator.output.sub(rotation => {
            this.windArrowRef.instance.style.transform = `rotate3d(0,0,1, ${rotation}deg)`;
        }, true);
        this.windArrowAnimator.start();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'hsi-wind-container': true,
                'hidden': this.props.ndDataProvider.hasWindData.map(x => !x),
            } },
            FSComponent.buildComponent("div", { class: "hsi-wind-direction-speed" },
                this.windDirectionString,
                "\u00B0/",
                FSComponent.buildComponent("span", { class: "hsi-wind-speed" }, this.windSpeedKnots)),
            FSComponent.buildComponent("svg", { class: {
                    'hsi-wind-arrow': true,
                    'hidden': this.isArrowVisible.map(x => !x),
                }, ref: this.windArrowRef, viewBox: "-15 -90 30 90", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" },
                FSComponent.buildComponent("path", { class: "wind-arrow-outline", d: "M 0 -10 l 0 -70 m -8 9 l 8 -9 l 8 9", "vector-effect": "non-scaling-stroke" }),
                FSComponent.buildComponent("path", { d: "M 0 -10 l 0 -70 m -8 9 l 8 -9 l 8 9", "vector-effect": "non-scaling-stroke" }))));
    }
    /** @inheritdoc */
    destroy() {
        this.trackDegTrue.destroy();
        this.windDirectionDegTrue.destroy();
        this.windSpeedKnots.destroy();
        this.groundSpeed.destroy();
    }
}

/**
 * The SpeedWindRangeInfoBlock component.
 * When using this component, make sure to copy the `SpeedWindRangeInfoBlock.css` file from another project
 * and import it where you import this component.
 */
class SpeedWindRangeInfoBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "speed-wind-range-info-block" },
            FSComponent.buildComponent("div", { class: "ground-air-wind-container" },
                FSComponent.buildComponent(GroundAirSpeed, { bus: this.props.bus }),
                FSComponent.buildComponent(WindVector, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider })),
            this.props.showRange && FSComponent.buildComponent(MapRange, { ndDataProvider: this.props.ndDataProvider })));
    }
}

const DME_FORMATTER = NumberFormatter.create({ maxDigits: 3, forceDecimalZeroes: true, precision: 0.1 });
/** The VorDisplay component. */
class VorDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.vorSectionRef = FSComponent.createRef();
        this.vorLeftRef = FSComponent.createRef();
        this.vorRightRef = FSComponent.createRef();
        this.navComSub = this.props.bus.getSubscriber();
        this.navProcSub = this.props.bus.getSubscriber();
        this.dmeDistanceLeft = Subject.create('---');
        this.dmeDistanceRight = Subject.create('---');
        this.navFreq1 = ConsumerSubject.create(this.navComSub.on('nav_active_frequency_1').withPrecision(2), 0);
        this.navFreq2 = ConsumerSubject.create(this.navComSub.on('nav_active_frequency_2').withPrecision(2), 0);
        this.navIdent1 = ConsumerSubject.create(this.navComSub.on('nav_ident_1').whenChanged(), '');
        this.navIdent2 = ConsumerSubject.create(this.navComSub.on('nav_ident_2').whenChanged(), '');
        this.navSignalStrength1 = ConsumerSubject.create(this.navComSub.on('nav_signal_1').whenChanged(), 0);
        this.navSignalStrength2 = ConsumerSubject.create(this.navComSub.on('nav_signal_2').whenChanged(), 0);
        this.formatVorData = ([freq, ident, strength]) => {
            if (ident !== '') {
                if (strength === 0) {
                    return freq ? freq.toFixed(2) : '---.--';
                }
                return ident;
            }
            else if (freq) {
                return freq.toFixed(2);
            }
            else {
                return '---.--';
            }
        };
        this.vorLeftData = MappedSubject.create(this.navFreq1, this.navIdent1, this.navSignalStrength1).map(this.formatVorData);
        this.vorRightData = MappedSubject.create(this.navFreq2, this.navIdent2, this.navSignalStrength2).map(this.formatVorData);
        // TODO Wire up with something
        this.fmcPositionUpdateStatus = Subject.create('GPS');
        this.fmcIrsUpdateStatus = Subject.create('IRS(3)');
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.navAidLeftState.sub(state => {
            this.vorLeftRef.instance.classList.toggle('hidden', state !== 'VOR');
        }, true);
        this.props.ndDataProvider.navAidRightState.sub(state => {
            this.vorRightRef.instance.classList.toggle('hidden', state !== 'VOR');
        }, true);
        this.props.ndDataProvider.isVorSupported.sub(isVorSupported => {
            this.vorSectionRef.instance.classList.toggle('hidden', !isVorSupported);
        }, true);
        this.navProcSub.on('nav_dme_1').withPrecision(1).handle((v) => {
            this.dmeDistanceLeft.set(v > 0 ? DME_FORMATTER(v).padStart(4, ' ') : ' ---');
        });
        this.navProcSub.on('nav_dme_2').withPrecision(1).handle((v) => {
            this.dmeDistanceRight.set(v > 0 ? DME_FORMATTER(v).padStart(4, ' ') : ' ---');
        });
    }
    // TODO: Subscribe VOR selection to MAP CTR selected positions.
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "vor-display", ref: this.vorSectionRef },
            FSComponent.buildComponent("div", { class: "data-block-left", ref: this.vorLeftRef },
                FSComponent.buildComponent("div", { class: "vor-main-label" }, "VOR L"),
                FSComponent.buildComponent("div", { class: "vor-data" }, this.vorLeftData),
                FSComponent.buildComponent("div", { class: "dme-distance" },
                    FSComponent.buildComponent("span", { class: "s-text dme-label" }, "DME"),
                    this.dmeDistanceLeft)),
            FSComponent.buildComponent("div", { class: "s-text fmc-pos-update-status" }, this.fmcPositionUpdateStatus),
            this.props.ndDataProvider.boeingType === '748' &&
                FSComponent.buildComponent("div", { class: "s-text fmc-irs-update-status" }, this.fmcIrsUpdateStatus),
            FSComponent.buildComponent("div", { class: "data-block-right", ref: this.vorRightRef },
                FSComponent.buildComponent("div", { class: "vor-main-label" }, "VOR R"),
                FSComponent.buildComponent("div", { class: "vor-data" }, this.vorRightData),
                FSComponent.buildComponent("div", { class: "dme-distance" },
                    FSComponent.buildComponent("span", { class: "s-text dme-label" }, "DME"),
                    this.dmeDistanceRight))));
    }
}

/** AirportWaypointStationBlockBlock component.
 * Displays ARPT / WPT / STA flag when the respective setting is set in the ND Menu.
 */
class MapSymbolsSettingBlock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.airportTextRef = FSComponent.createRef();
        this.waypointTextRef = FSComponent.createRef();
        this.stationTextRef = FSComponent.createRef();
        this.mapSymbolsSetting = this.props.ndDataProvider.mapWaypointsDisplay;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.mapSymbolsSettingSub = this.mapSymbolsSetting.sub(currentValue => {
            this.airportTextRef.instance.classList.toggle('visibility-hidden', !(BitFlags.isAny(currentValue, MapWaypointsDisplay.Airports)));
            this.waypointTextRef.instance.classList.toggle('visibility-hidden', !(BitFlags.isAny(currentValue, MapWaypointsDisplay.Intersections)));
            this.stationTextRef.instance.classList.toggle('visibility-hidden', !(BitFlags.isAny(currentValue, MapWaypointsDisplay.HiNavaids)) || !(BitFlags.isAny(currentValue, MapWaypointsDisplay.LoNavaids)) || !(BitFlags.isAny(currentValue, MapWaypointsDisplay.NDBs)));
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-symbols-setting-block-container" },
            FSComponent.buildComponent("div", { class: "map-symbols-setting", ref: this.airportTextRef }, "ARPT"),
            FSComponent.buildComponent("div", { class: "map-symbols-setting", ref: this.waypointTextRef }, "WPT"),
            FSComponent.buildComponent("div", { class: "map-symbols-setting", ref: this.stationTextRef }, "STA")));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.mapSymbolsSettingSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/** The TcasBlock component. Displays TCAS / TFC modes in cyan and amber colors at the bottom left side of the ND display. */
class TcasBlock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.tcasModeOffOrFailedContainerRef = FSComponent.createRef();
        this.tcasModeOffOrFailedTextRef = FSComponent.createRef();
        this.tcasModeRef = FSComponent.createRef();
        this.tfcModeRef = FSComponent.createRef();
        this.subscriptions = [];
        this.tcasConditions = MappedSubject.create(([isTfcSupported, tcasOperatingMode]) => {
            return [isTfcSupported, tcasOperatingMode];
        }, this.props.ndDataProvider.isTfcSupported, ConsumerSubject.create(this.props.bus.getSubscriber().on('tcas_operating_mode'), TcasOperatingMode.Off));
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subscriptions = [
            this.props.ndDataProvider.showTfc.sub(isTfcOn => {
                this.tfcModeRef.instance.classList.toggle('visibility-hidden', !isTfcOn);
            }, true),
            this.tcasConditions.sub(([isTfcSupported, tcasOperatingMode]) => {
                const isTcasOff = tcasOperatingMode < TcasOperatingMode.TAOnly || tcasOperatingMode === TcasOperatingMode.Failed;
                this.tcasModeOffOrFailedTextRef.instance.classList.toggle('hidden', !(isTcasOff && isTfcSupported));
                this.tcasModeRef.instance.classList.toggle('hidden', isTcasOff);
                switch (tcasOperatingMode) {
                    case TcasOperatingMode.Off:
                    case TcasOperatingMode.Standby:
                        this.tcasModeOffOrFailedTextRef.instance.textContent = 'TCAS OFF';
                        this.tcasModeOffOrFailedContainerRef.instance.classList.remove('hidden');
                        return;
                    case TcasOperatingMode.Failed:
                        this.tcasModeOffOrFailedTextRef.instance.textContent = 'TCAS FAIL';
                        this.tcasModeOffOrFailedContainerRef.instance.classList.remove('hidden');
                        return;
                    case TcasOperatingMode.Test:
                        this.tcasModeOffOrFailedContainerRef.instance.classList.add('hidden');
                        this.tcasModeRef.instance.textContent = 'TCAS TEST';
                        return;
                    case TcasOperatingMode.TAOnly:
                        this.tcasModeOffOrFailedContainerRef.instance.classList.add('hidden');
                        this.tcasModeRef.instance.textContent = 'TA ONLY';
                        return;
                    case TcasOperatingMode.TA_RA:
                        this.tcasModeOffOrFailedContainerRef.instance.classList.add('hidden');
                        this.tcasModeRef.instance.textContent = '';
                        return;
                    default:
                        console.warn('Undefined TCAS operating mode', tcasOperatingMode);
                        return;
                }
            }, true),
        ];
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "tcas-block-container" },
            FSComponent.buildComponent("div", { class: "tcas-mode-off hidden", ref: this.tcasModeOffOrFailedContainerRef },
                FSComponent.buildComponent("span", { ref: this.tcasModeOffOrFailedTextRef }, "TCAS OFF")),
            FSComponent.buildComponent("div", { class: "tfc-mode", ref: this.tfcModeRef }, "TFC"),
            FSComponent.buildComponent("div", { class: "tcas-mode", ref: this.tcasModeRef })));
    }
    /** @inheritdoc */
    destroy() {
        this.subscriptions.map((sub) => sub === null || sub === void 0 ? void 0 : sub.destroy());
    }
}

/**
 * The TerrainBlock component.
 * TERR has normal (turned on) mode and TEST mode (not implemented);
 * Has FAIL/OVRD/POS status as alerts in amber.
 */
class TerrainBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'terr-block-container': true,
                'hidden': this.props.ndDataProvider.showTerr.map(x => !x),
            } },
            FSComponent.buildComponent("div", { class: "terr-status fixed-double-line hidden" },
                FSComponent.buildComponent("span", { class: "hidden" },
                    "TERR",
                    FSComponent.buildComponent("br", null),
                    "OVRD")),
            FSComponent.buildComponent("div", { class: "terr-status fixed-double-line hidden" },
                FSComponent.buildComponent("span", { class: "hidden" },
                    "TERR",
                    FSComponent.buildComponent("br", null),
                    "FAIL")),
            FSComponent.buildComponent("div", { class: "terr-status fixed-double-line hidden" },
                FSComponent.buildComponent("span", { class: "hidden" },
                    "TERR",
                    FSComponent.buildComponent("br", null),
                    "POS")),
            FSComponent.buildComponent("div", { class: "terr-mode" },
                FSComponent.buildComponent("span", null, "TERR")),
            FSComponent.buildComponent("div", { class: "terr-mode no-width" },
                FSComponent.buildComponent("span", null, "\u00A0")),
            FSComponent.buildComponent("div", { class: "terr-mode no-width" },
                FSComponent.buildComponent("span", null, "\u00A0"))));
    }
}

/**
 * The TcasBlock component.
 * Displays TCAS / TFC modes in cyan and amber colors at the bottom left side of the ND display.
 */
class WeatherRadarBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'wxr-block-container': true,
                'hidden': this.props.ndDataProvider.showWxr.map(x => !x),
            } },
            FSComponent.buildComponent("div", { class: "wxr-mode" }, "WX"),
            FSComponent.buildComponent("div", { class: "wxr-mode radar-tilt" }, "- 2.50A"),
            FSComponent.buildComponent("div", { class: "wxr-mode radar-gain" }, "\u00A00")));
    }
}

/**
 * The WxTerrTfcDataBlock component.
 * Displays mode/status annunciations of the weather radar,
 * terrain display, and TFC/TCAS at the bottom left side of the ND display.
 */
class WxTerrTfcDataBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "wx-terr-tfc-data-block-container" },
            this.props.showMapSymbolsBlock && FSComponent.buildComponent(MapSymbolsSettingBlock, { ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(WeatherRadarBlock, { ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(TerrainBlock, { ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(TcasBlock, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider })));
    }
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * A view representation of a TCAS intruder for MapTrafficIntruderLayer.
 */
class MapTrafficIntruderIcon extends AbstractMapTrafficIntruderIcon {
    /**
     * Constructor.
     * @param intruder This view's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The own airplane properties module for this icon's parent map.
     * @param stylesModule The map styles module.
     * @param options Configuration options for this icon.
     */
    constructor(intruder, trafficModule, ownshipModule, stylesModule, options) {
        super(intruder, trafficModule, ownshipModule);
        this.stylesModule = stylesModule;
        this.options = options;
        this.iconSize = 28 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
        this.altitudeText = '';
    }
    /** @inheritdoc */
    drawIcon(projection, context, projectedPos, isOffScale) {
        if (!projection.isInProjectedBounds(projectedPos)) {
            return;
        }
        const alertLevel = this.intruder.alertLevel.get();
        const isTARA = alertLevel === TcasAlertLevel.TrafficAdvisory || alertLevel === TcasAlertLevel.ResolutionAdvisory;
        if (isOffScale) {
            return;
        }
        if (!isTARA) {
            const altitudeMeters = this.intruder.relativePositionVec[2];
            if (altitudeMeters > this.trafficModule.altitudeRestrictionAbove.get().asUnit(UnitType.METER)
                || altitudeMeters < -this.trafficModule.altitudeRestrictionBelow.get().asUnit(UnitType.METER)) {
                return;
            }
        }
        context.translate(projectedPos[0], projectedPos[1]);
        this.drawIconVSArrow(context, alertLevel);
        this.drawIconAltitudeLabel(context, alertLevel);
        if (this.options.supportAdsbIn) {
            this.drawArrowIcon(context, projection, alertLevel);
        }
        else {
            this.drawNoArrowIcon(context, alertLevel);
        }
        context.resetTransform();
    }
    /**
     * Draws the icon without a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawNoArrowIcon(context, alertLevel) {
        context.setLineDash(MapTrafficIntruderIcon.EMPTY_LINE_DASH);
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                this.drawDiamondIcon(context, alertLevel === TcasAlertLevel.ProximityAdvisory);
                break;
            case TcasAlertLevel.TrafficAdvisory:
                this.drawCircleIcon(context);
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                this.drawSquareIcon(context);
                break;
        }
    }
    /**
     * Draws a diamond icon.
     * @param context The canvas rendering context to which to draw the icon.
     * @param isFilled Whether the diamond should be filled.
     */
    drawDiamondIcon(context, isFilled) {
        const size = 0.35 * this.iconSize;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.beginPath();
        context.moveTo(0, -size);
        context.lineTo(size, 0);
        context.lineTo(0, size);
        context.lineTo(-size, 0);
        context.closePath();
        context.strokeStyle = 'black';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = 'white';
        context.fill();
        context.stroke();
        if (!isFilled) {
            context.beginPath();
            context.moveTo(0, -size * 0.6);
            context.lineTo(size * 0.6, 0);
            context.lineTo(0, size * 0.6);
            context.lineTo(-size * 0.6, 0);
            context.closePath();
            context.fillStyle = 'black';
            context.fill();
        }
    }
    /**
     * Draws a circle icon for TAs.
     * @param context The canvas rendering context to which to draw the icon.
     */
    drawCircleIcon(context) {
        context.beginPath();
        context.arc(0, 0, 0.35 * this.iconSize, 0, MathUtils.TWO_PI);
        context.strokeStyle = 'black';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
        context.fill();
        context.stroke();
    }
    /**
     * Draws a square icon for RAs.
     * @param context The canvas rendering context to which to draw the icon.
     */
    drawSquareIcon(context) {
        const size = 0.35 * this.iconSize;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.beginPath();
        context.moveTo(-size, -size);
        context.lineTo(size, -size);
        context.lineTo(size, size);
        context.lineTo(-size, size);
        context.closePath();
        context.strokeStyle = 'black';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
        context.fill();
        context.stroke();
    }
    /**
     * Draws the icon with a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawArrowIcon(context, projection, alertLevel) {
        this.drawArrowIconBackground(context, alertLevel);
        this.drawIconArrow(context, projection, alertLevel);
    }
    /**
     * Draws the icon's background when it has a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawArrowIconBackground(context, alertLevel) {
        if (alertLevel === TcasAlertLevel.None || alertLevel === TcasAlertLevel.ProximityAdvisory) {
            return;
        }
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.strokeStyle = '#1a1d21';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = alertLevel === TcasAlertLevel.ResolutionAdvisory ? MapTrafficIntruderIcon.RA_COLOR : MapTrafficIntruderIcon.TA_COLOR;
        context.beginPath();
        const size = 0.65 * this.iconSize;
        if (alertLevel === TcasAlertLevel.ResolutionAdvisory) {
            // RA
            context.rect(-size, -size, size * 2, size * 2);
        }
        else {
            // TA
            context.arc(0, 0, size, 0, MathUtils.TWO_PI);
        }
        context.fill();
    }
    /**
     * Draws the icon's directional arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrow(context, projection, alertLevel) {
        context.save();
        context.rotate(this.intruder.groundTrack * Avionics.Utils.DEG2RAD + projection.getRotation());
        this.drawIconArrowOutline(context, alertLevel);
        context.restore();
    }
    /**
     * Draws the icon's directional arrow outline.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrowOutline(context, alertLevel) {
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.beginPath();
        context.moveTo(0, -0.65 * this.iconSize);
        context.lineTo(0.37 * this.iconSize, 0.55 * this.iconSize);
        context.lineTo(0, 0.25 * this.iconSize);
        context.lineTo(-0.37 * this.iconSize, 0.55 * this.iconSize);
        context.closePath();
        if (alertLevel === TcasAlertLevel.None || alertLevel === TcasAlertLevel.ProximityAdvisory) {
            // Outline
            context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
            context.strokeStyle = 'black';
            context.stroke();
        }
        switch (alertLevel) {
            case TcasAlertLevel.None:
                context.strokeStyle = 'white';
                context.fillStyle = 'transparent';
                break;
            case TcasAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'white';
                context.fillStyle = 'white';
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.strokeStyle = 'transparent';
                context.fillStyle = 'black';
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.strokeStyle = 'transparent';
                context.fillStyle = 'black';
                break;
        }
        if (alertLevel !== TcasAlertLevel.None) {
            context.fill();
        }
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * Draws the icon's vertical speed indicator arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconVSArrow(context, alertLevel) {
        const showArrow = MapTrafficIntruderIcon.VERTICAL_SPEED_THRESHOLD.compare(Math.abs(this.intruder.velocityVec[2]), UnitType.MPS) <= 0;
        if (!showArrow) {
            return;
        }
        const vsSign = Math.sign(this.intruder.velocityVec[2]);
        context.lineCap = 'round';
        context.lineJoin = 'round';
        const offsetX = 0.4;
        context.beginPath();
        context.moveTo((0.75 + offsetX) * this.iconSize, -0.35 * this.iconSize * vsSign);
        context.lineTo((0.75 + offsetX) * this.iconSize, 0.40 * this.iconSize * vsSign);
        context.moveTo((0.55 + offsetX) * this.iconSize, -0.15 * this.iconSize * vsSign);
        context.lineTo((0.75 + offsetX) * this.iconSize, -0.40 * this.iconSize * vsSign);
        context.lineTo((0.95 + offsetX) * this.iconSize, -0.15 * this.iconSize * vsSign);
        // black outline
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.strokeStyle = 'black';
        context.stroke();
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth;
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'white';
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.strokeStyle = MapTrafficIntruderIcon.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.strokeStyle = MapTrafficIntruderIcon.RA_COLOR;
                break;
        }
        context.stroke();
    }
    /**
     * Draws the icon's altitude label.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconAltitudeLabel(context, alertLevel) {
        const isRelative = this.trafficModule.isAltitudeRelative.get();
        const isAltitudeAbove = this.intruder.relativePositionVec[2] >= 0;
        const altitudeFeet = this.trafficModule.isAltitudeRelative.get()
            ? UnitType.METER.convertTo(this.intruder.relativePositionVec[2], UnitType.FOOT)
            : this.intruder.altitude.asUnit(UnitType.FOOT);
        const altitudeRounded = Math.round(altitudeFeet / 100);
        const altitudeAbs = Math.abs(altitudeRounded);
        const prefix = altitudeRounded < 0
            ? '-'
            : isRelative
                ? '+'
                : '';
        if (altitudeAbs !== this.lastDrawnAltitudeValue || prefix !== this.lastDrawnAltitudePrefix) {
            this.lastDrawnAltitudeValue = altitudeAbs;
            this.lastDrawnAltitudePrefix = prefix;
            this.altitudeText = `${prefix}${altitudeAbs}`;
        }
        // black outline
        context.lineWidth = this.stylesModule.styles.fontOutlineWidth * 2;
        context.strokeStyle = 'black';
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.strokeText(this.altitudeText, 0, -0.7 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.strokeText(this.altitudeText, 0, 0.9 * this.iconSize);
        }
        // draw text
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.fillStyle = 'white';
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
                break;
        }
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.fillText(this.altitudeText, 0, -0.7 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.fillText(this.altitudeText, 0, 0.9 * this.iconSize);
        }
    }
}
MapTrafficIntruderIcon.VERTICAL_SPEED_THRESHOLD = UnitType.FPM.createNumber(500);
MapTrafficIntruderIcon.TA_COLOR = BoeingColors.amber;
MapTrafficIntruderIcon.RA_COLOR = BoeingColors.red;
MapTrafficIntruderIcon.EMPTY_LINE_DASH = [];

/**
 * A traffic intruder icon for Boeings. No support for ADS-B In. The icon includes a symbol that is chosen based on the intruder's alert
 * level, an altitude label displaying either the intruder's relative or absolute altitude to the nearest hundreds of
 * feet, and a vertical speed direction arrow which is only visible when the magnitude of the intruder's vertical speed
 * is greater than 500 FPM.
 */
class MapTrafficIntruderIconOld extends AbstractMapTrafficIntruderIcon {
    /**
     * Constructor.
     * @param intruder This icon's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The ownship module for this icon's parent map.
     * @param stylesModule The map styles module.
     */
    constructor(intruder, trafficModule, ownshipModule, stylesModule) {
        super(intruder, trafficModule, ownshipModule);
        this.stylesModule = stylesModule;
        this.iconSize = 28 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
    }
    /** @inheritdoc */
    drawIcon(projection, context, projectedPos, isOffScale) {
        const alertLevel = this.intruder.alertLevel.get();
        if (!projection.isInProjectedBounds(projectedPos)) {
            return;
        }
        if (alertLevel !== TcasAlertLevel.ResolutionAdvisory && alertLevel !== TcasAlertLevel.TrafficAdvisory) {
            if (isOffScale) {
                return;
            }
            const altitudeMeters = this.intruder.relativePositionVec[2];
            if (altitudeMeters > this.trafficModule.altitudeRestrictionAbove.get().asUnit(UnitType.METER)
                || altitudeMeters < -this.trafficModule.altitudeRestrictionBelow.get().asUnit(UnitType.METER)) {
                return;
            }
        }
        context.translate(projectedPos[0], projectedPos[1]);
        this.drawIconVSArrow(context, alertLevel);
        this.drawIconAltitudeLabel(context, alertLevel);
        this.drawIconSymbol(context, projection, projectedPos, alertLevel, isOffScale);
        context.resetTransform();
    }
    /**
     * Draws this icon's symbol.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param projectedPos The projected position of this icon's intruder.
     * @param alertLevel The alert level assigned to this icon's intruder.
     * @param isOffScale Whether this icon's intruder is off-scale.
     */
    drawIconSymbol(context, projection, projectedPos, alertLevel, isOffScale) {
        let needRestoreContextState = false;
        if (isOffScale) {
            context.save();
            needRestoreContextState = true;
            const projectedAngle = Vec2Math.theta(Vec2Math.sub(projectedPos, projection.getTargetProjected(), MapTrafficIntruderIconOld.vec2Cache[0]));
            context.beginPath();
            context.arc(0, 0, 0.5 * this.iconSize, projectedAngle - MathUtils.HALF_PI, projectedAngle + MathUtils.HALF_PI);
            context.closePath();
            context.clip();
        }
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.beginPath();
                context.moveTo(0, -0.4 * this.iconSize);
                context.lineTo(0.3 * this.iconSize, 0);
                context.lineTo(0, 0.4 * this.iconSize);
                context.lineTo(-0.3 * this.iconSize, 0);
                context.closePath();
                // black outline
                context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
                context.lineJoin = 'round';
                context.strokeStyle = 'black';
                context.stroke();
                context.lineWidth = this.stylesModule.styles.strokeWidth;
                context.lineJoin = 'round';
                context.strokeStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                context.stroke();
                if (alertLevel === TcasAlertLevel.ProximityAdvisory) {
                    context.fillStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                    context.fill();
                }
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.beginPath();
                context.moveTo(0.5 * this.iconSize, 0);
                context.arc(0, 0, 0.5 * this.iconSize, 0, MathUtils.TWO_PI);
                context.lineWidth = this.stylesModule.styles.outlineWidth * 2;
                context.strokeStyle = 'black';
                context.stroke();
                context.fillStyle = MapTrafficIntruderIconOld.TA_COLOR;
                context.fill();
                break;
            case TcasAlertLevel.ResolutionAdvisory: {
                const size = this.iconSize * Math.SQRT1_2;
                context.lineWidth = this.stylesModule.styles.outlineWidth * 2;
                context.strokeStyle = 'black';
                context.strokeRect(-0.5 * size, -0.5 * size, size, size);
                context.fillStyle = MapTrafficIntruderIconOld.RA_COLOR;
                context.fillRect(-0.5 * size, -0.5 * size, size, size);
                break;
            }
        }
        if (needRestoreContextState) {
            context.restore();
        }
    }
    /**
     * Draws the icon's vertical speed indicator arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconVSArrow(context, alertLevel) {
        const showArrow = MapTrafficIntruderIconOld.VERTICAL_SPEED_THRESHOLD.compare(Math.abs(this.intruder.velocityVec[2]), UnitType.MPS) <= 0;
        if (!showArrow) {
            return;
        }
        const vsSign = Math.sign(this.intruder.velocityVec[2]);
        context.lineCap = 'round';
        context.beginPath();
        context.moveTo(0.75 * this.iconSize, -0.35 * this.iconSize * vsSign);
        context.lineTo(0.75 * this.iconSize, 0.40 * this.iconSize * vsSign);
        context.moveTo(0.55 * this.iconSize, -0.05 * this.iconSize * vsSign);
        context.lineTo(0.75 * this.iconSize, -0.40 * this.iconSize * vsSign);
        context.lineTo(0.95 * this.iconSize, -0.05 * this.iconSize * vsSign);
        // black outline
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.strokeStyle = 'black';
        context.stroke();
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth;
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.strokeStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.strokeStyle = MapTrafficIntruderIconOld.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.strokeStyle = MapTrafficIntruderIconOld.RA_COLOR;
                break;
        }
        context.stroke();
    }
    /**
     * Draws the icon's altitude label.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconAltitudeLabel(context, alertLevel) {
        const isRelative = this.trafficModule.isAltitudeRelative.get();
        const isAltitudeAbove = this.intruder.relativePositionVec[2] >= 0;
        const altitudeFeet = this.trafficModule.isAltitudeRelative.get()
            ? UnitType.METER.convertTo(this.intruder.relativePositionVec[2], UnitType.FOOT)
            : this.intruder.altitude.asUnit(UnitType.FOOT);
        const altitudeRounded = Utils.Clamp(Math.round(altitudeFeet / 100), isRelative ? -99 : -Infinity, isRelative ? 99 : 999);
        const altitudeAbs = Math.abs(altitudeRounded);
        const prefix = isRelative
            ? altitudeRounded < 0
                ? '-'
                : '+'
            : '';
        const altitudeText = !isRelative && altitudeRounded < 0 ? 'XXX' : `${prefix}${altitudeAbs.toFixed(0).padStart(isRelative ? 2 : 3, '0')}`;
        // black outline
        context.lineWidth = this.stylesModule.styles.fontOutlineWidth * 2;
        context.strokeStyle = 'black';
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.strokeText(altitudeText, 0, -0.5 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.strokeText(altitudeText, 0, 0.7 * this.iconSize);
        }
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.fillStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderIconOld.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderIconOld.RA_COLOR;
                break;
        }
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.fillText(altitudeText, 0, -0.5 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.fillText(altitudeText, 0, 0.7 * this.iconSize);
        }
    }
}
MapTrafficIntruderIconOld.VERTICAL_SPEED_THRESHOLD = UnitType.FPM.createNumber(500);
MapTrafficIntruderIconOld.PA_OTHER_COLOR = BoeingColors.white;
MapTrafficIntruderIconOld.TA_COLOR = BoeingColors.amber;
MapTrafficIntruderIconOld.RA_COLOR = BoeingColors.red;
MapTrafficIntruderIconOld.vec2Cache = [new Float64Array(2)];

/* eslint-disable jsdoc/require-jsdoc */
const nonFixLegTypes = [LegType.CA, LegType.CI, LegType.CR, LegType.FA, LegType.FM, LegType.VA, LegType.VI, LegType.VM, LegType.VR];
/**
 * A map system config for Boeing maps.
 */
class MapSystemConfig {
    /**
     * Creates a new map system config.
     * @param mapStyles the boeing map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
        this.ICON_SIZE = Vec2Math.create(this.mapStyles.mapIconSize, this.mapStyles.mapIconSize);
        this.MagentaPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.magenta,
            outlineWidth: this.mapStyles.outlineWidth,
        };
        this.WhitePath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.white,
            outlineWidth: this.mapStyles.outlineWidth,
        };
        this.WhiteDashedPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.white,
            dash: [14, 10],
            outlineWidth: this.mapStyles.outlineWidth,
            lineCap: 'round',
        };
        this.CyanDashedPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.cyan,
            dash: [24, 10],
            outlineWidth: this.mapStyles.outlineWidth,
            lineCap: 'round',
        };
        this.CyanPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.cyan,
            outlineWidth: this.mapStyles.outlineWidth,
        };
        this.HoldLegWhitePath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildWhiteHoldStyle.bind(this)
        };
        this.HoldLegMagentaPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildMagentaHoldStyle.bind(this)
        };
        this.HoldLegCyanPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildCyanHoldStyle.bind(this)
        };
        this.HoldLegWhiteDashedPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildWhiteDashedHoldStyle.bind(this)
        };
        this.HoldLegCyanDashedPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildCyanDashedHoldStyle.bind(this)
        };
        this.FlightPathWaypointLabelOptions = {
            fontSize: this.mapStyles.labelFontSize,
            font: 'B787',
            fontOutlineWidth: this.mapStyles.fontOutlineWidth,
            fontOutlineColor: BoeingColors.black,
            offset: this.mapStyles.bigLabelOffset,
        };
        /**
         * Configures the map waypoint display layer.
         * @returns A builder function to configure the waypoint display system.
         */
        this.configureMapWaypoints = () => {
            return (builder) => {
                builder.registerRole(BoeingMapCommon.tunedVorRole);
                builder.withSearchCenter('target');
                this.configWptRoles(MapSystemWaypointRoles.Normal, builder);
            };
        };
        /**
         * Configures the map flight plan display layer.
         * @param bus The event bus to use.
         * @param ndDataProvider The ND data provider.
         * @param vnavDataModule The vnav data module.
         * @param activeRoutePredictor The active route predictor.
         * @param perfPlanRepository The perfPlanRepository.
         * @returns A builder function to configure the flight plan display system.
         */
        this.configureFlightPlan = (bus, ndDataProvider, vnavDataModule, activeRoutePredictor, perfPlanRepository) => {
            return (builder, context) => {
                const activeRoutePlanSubject = context.model.getModule(MapSystemKeys.FlightPlan).getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX);
                const flightPlanLabelArgs = [ndDataProvider.mapWaypointsDisplay, vnavDataModule, activeRoutePredictor, activeRoutePlanSubject.flightPlan, perfPlanRepository];
                const effectiveLegIndex = Subject.create(-1);
                const sub = bus.getSubscriber();
                sub.on('lnavdata_nominal_leg_index').handle(effectiveLegIndex.set.bind(effectiveLegIndex));
                builder.registerRole(PlanWaypointRoles.Active_Star)
                    .registerRole(PlanWaypointRoles.Active_Circle)
                    .registerRole(PlanWaypointRoles.Inactive_Star)
                    .registerRole(PlanWaypointRoles.Inactive_Circle)
                    .addDefaultIcon(PlanWaypointRoles.Active_Star, this.buildActiveWaypointIcon('FLIGHTPLAN_M', 999))
                    .addDefaultIcon(PlanWaypointRoles.Active_Circle, this.buildActiveWaypointIcon('FLIGHTPLAN_CIRCLE_MAGENTA', 999))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Star, this.buildIcon('FLIGHTPLAN', 999))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Circle, this.buildIcon('FLIGHTPLAN_CIRCLE_WHITE', 999))
                    // 787 does show DATA for all legs in active route
                    .addLabel(PlanWaypointRoles.Active_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.magenta, ...flightPlanLabelArgs))
                    .addLabel(PlanWaypointRoles.Active_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.magenta, ...flightPlanLabelArgs))
                    .addLabel(PlanWaypointRoles.Inactive_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white, ...flightPlanLabelArgs))
                    .addLabel(PlanWaypointRoles.Inactive_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white, ...flightPlanLabelArgs))
                    .withAnticipationTurns(true)
                    .withLegPathStyles((plan, leg, activeLeg, legIndex) => {
                    const isMissedApproachLeg = BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach);
                    const isHoldLeg = (leg.leg.type === LegType.HF || leg.leg.type === LegType.HA);
                    if (isMissedApproachLeg) {
                        // We only want the MAP legs to be in cyan if we are not already in the missed approach
                        if (!ndDataProvider.isMissedApproachActive.get()) {
                            return isHoldLeg ? this.HoldLegCyanPath : this.CyanPath;
                        }
                    }
                    if (legIndex > effectiveLegIndex.get()) {
                        return isHoldLeg ? this.HoldLegMagentaPath : this.MagentaPath;
                    }
                    else if (legIndex === effectiveLegIndex.get()) {
                        return isHoldLeg ? this.HoldLegMagentaPath : this.MagentaPath;
                    }
                    else if (legIndex === effectiveLegIndex.get() - 1) {
                        return isHoldLeg ? this.HoldLegMagentaPath : this.MagentaPath;
                    }
                    return FlightPathRenderStyle.Hidden;
                })
                    .withLegWaypointRoles((plan, leg, activeLeg, legIndex) => {
                    if (this.isOriginDestOrRunwayLeg(plan, leg)) {
                        return 0;
                    }
                    // Legs with no fix are shown as a circle
                    const useCircleIcon = nonFixLegTypes.includes(leg.leg.type);
                    if (legIndex > effectiveLegIndex.get()) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                    }
                    else if (legIndex === effectiveLegIndex.get()) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Active_Circle : PlanWaypointRoles.Active_Star);
                    }
                    else if (legIndex === effectiveLegIndex.get() - 1) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                    }
                    return 0;
                });
            };
        };
        /**
         * Configures the map flight plan display layer for the mod flight plan.
         * @param bus The event bus to use.
         * @returns A builder function to configure the mod flight plan display system.
         */
        this.configureModFlightPlan = (bus) => {
            return (builder) => {
                const isMissedApproachActive = Subject.create(false);
                bus.getSubscriber().on('lnavdata_cdi_scale_label')
                    .handle(x => isMissedApproachActive.set(x === CDIScaleLabel.MissedApproach));
                const currentlyInMod = Subject.create(false);
                bus.getSubscriber().on('fmcExecActive').handle(active => currentlyInMod.set(active === 1));
                builder
                    .registerRole(PlanWaypointRoles.Inactive_Star)
                    .registerRole(PlanWaypointRoles.Inactive_Circle)
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Star, this.buildIcon('FLIGHTPLAN'))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Circle, this.buildIcon('FLIGHTPLAN_CIRCLE_WHITE'))
                    // 787 does not show DATA for mod or inactive routes
                    .addLabel(PlanWaypointRoles.Inactive_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white))
                    .addLabel(PlanWaypointRoles.Inactive_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white));
                builder.withAnticipationTurns(true);
                builder.withLegPathStyles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    if (legIndex >= activeLegIndex && currentlyInMod.get()) {
                        const isHoldLeg = (leg.leg.type === LegType.HF || leg.leg.type === LegType.HA);
                        const isHoldToManualTerminationLeg = (leg.leg.type === LegType.HM);
                        return isHoldLeg
                            ? this.HoldLegWhiteDashedPath
                            : isHoldToManualTerminationLeg
                                ? this.WhitePath
                                : this.WhiteDashedPath;
                    }
                    return FlightPathRenderStyle.Hidden;
                });
                builder.withLegWaypointRoles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    if (this.isOriginDestOrRunwayLeg(plan, leg)) {
                        return 0;
                    }
                    // Legs with no fix are shown as a circle
                    const useCircleIcon = nonFixLegTypes.includes(leg.leg.type);
                    if (legIndex >= activeLegIndex && currentlyInMod.get()) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                    }
                    return 0;
                });
            };
        };
        /**
         * Configures the map flight plan display layer for the inactive route flight plan.
         * @returns A builder function to configure the inactive route flight plan display system.
         */
        this.configureInactiveFlightPlan = () => {
            return (builder) => {
                builder
                    .registerRole(PlanWaypointRoles.Inactive_Star)
                    .registerRole(PlanWaypointRoles.Inactive_Circle)
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Star, this.buildIcon('FLIGHTPLAN'))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Circle, this.buildIcon('FLIGHTPLAN_CIRCLE_WHITE'))
                    // 787 does not show DATA for mod or inactive routes
                    .addLabel(PlanWaypointRoles.Inactive_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white))
                    .addLabel(PlanWaypointRoles.Inactive_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white));
                builder.withAnticipationTurns(true);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                builder.withLegPathStyles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    const isHoldLeg = (leg.leg.type === LegType.HF || leg.leg.type === LegType.HA);
                    const isHoldToManualTerminationLeg = (leg.leg.type === LegType.HM);
                    return isHoldLeg
                        ? this.HoldLegCyanDashedPath
                        : isHoldToManualTerminationLeg
                            ? this.CyanPath
                            : this.CyanDashedPath;
                });
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                builder.withLegWaypointRoles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    if (this.isOriginDestOrRunwayLeg(plan, leg)) {
                        return 0;
                    }
                    // Legs with no fix are shown as a circle
                    const useCircleIcon = nonFixLegTypes.includes(leg.leg.type);
                    return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                });
            };
        };
        this.createTrafficIntruderIcon = (options) => (intruder, context) => {
            if (options.supportAdsbIn) {
                return new MapTrafficIntruderIcon(intruder, context.model.getModule(MapSystemKeys.Traffic), context.model.getModule(MapSystemKeys.OwnAirplaneProps), context.model.getModule(BoeingMapKeys.MapStyles), options);
            }
            else {
                // Kind of temporary until someone updates the diamond icons in the new icon class
                return new MapTrafficIntruderIconOld(intruder, context.model.getModule(MapSystemKeys.Traffic), context.model.getModule(MapSystemKeys.OwnAirplaneProps), context.model.getModule(BoeingMapKeys.MapStyles));
            }
        };
        /**
         * Initializes global canvas styles for the traffic layer.
         * @param context The canvas rendering context for which to initialize styles.
         */
        this.initTrafficLayerCanvasStyles = (context) => {
            context.textAlign = 'center';
            context.font = this.mapStyles.labelFontSize + 'px B787';
        };
    }
    /**
     * Builds non-active leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildWhiteHoldStyle() {
        return this.WhitePath;
    }
    /**
     * Builds active leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildMagentaHoldStyle() {
        return this.MagentaPath;
    }
    /**
     * Builds leg style for hold legs on the missed approach.
     * @returns The appropriate hold leg display style.
     */
    buildCyanHoldStyle() {
        return this.CyanPath;
    }
    /**
     * Builds mod leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildWhiteDashedHoldStyle() {
        return this.WhiteDashedPath;
    }
    /**
     * Builds inactive plan leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildCyanDashedHoldStyle() {
        return this.CyanDashedPath;
    }
    /**
     * Builds a label for facility waypoints.
     * @param color The color of the label.
     * @param bigIcon Whether this is for a big icon.
     * @returns A new factory that will create the label.
     */
    buildFacilityLabel(color, bigIcon) {
        return (w) => {
            // Default offset
            let offset = this.mapStyles.smallLabelOffset;
            if (bigIcon) {
                offset = this.mapStyles.bigLabelOffset;
            }
            return new MapCullableLocationTextLabel(ICAO.getIdent(w.facility.get().icao), 0, w.location, false, {
                fontSize: this.mapStyles.labelFontSize,
                fontColor: color,
                font: 'B787',
                fontOutlineWidth: this.mapStyles.fontOutlineWidth,
                fontOutlineColor: BoeingColors.black,
                offset,
            });
        };
    }
    /**
     * Builds a label for flight plan waypoints.
     * @param fontColor The color of the label.
     * @param displaySetting The 'mapWaypointsDisplay' setting.
     * @param vnavDataModule The vnav data module.
     * @param activeRoutePredictor The active route predictor.
     * @param activeRoutePlan The active route plan subject.
     * @param perfPlanRepository The perfPlanRepository.
     * @returns A new factory that will create the label.
     */
    buildFlightPlanLabel(fontColor, displaySetting, vnavDataModule, activeRoutePredictor, activeRoutePlan, perfPlanRepository) {
        return w => new FlightPathWaypointLabel(w, displaySetting, Object.assign({ fontColor }, this.FlightPathWaypointLabelOptions), this.mapStyles.canvasScale, this.mapStyles.labelLineHeight, vnavDataModule, activeRoutePredictor, activeRoutePlan, perfPlanRepository);
    }
    /**
     * Builds an icon for a waypoint.
     * @param id The ID of the icon.
     * @param priority he render priority of this icon.
     * @returns A factory that builds the image icon.
     */
    buildIcon(id, priority = 0) {
        return (w) => new MapWaypointImageIcon(w, priority, ImageCache.get(id), this.ICON_SIZE);
    }
    /**
     * Builds an icon for a waypoint.
     * @param id The ID of the icon.
     * @param priority he render priority of this icon.
     * @returns A factory that builds the image icon.
     */
    buildActiveWaypointIcon(id, priority = 0) {
        return (w) => new ActiveWaypointIcon(w, priority, ImageCache.get(id), this.ICON_SIZE);
    }
    /**
     * Configures the map waypoint role styles.
     * @param role The role to configure.
     * @param builder The waypoint display builder
     */
    configWptRoles(role, builder) {
        builder.addDefaultIcon(role, this.buildIcon('INTERSECTION'))
            .addDefaultLabel(role, this.buildFacilityLabel(BoeingColors.cyan, false))
            .addIcon(role, WaypointTypes.Airport, this.buildIcon('AIRPORT'))
            // NDB's are not displayed on the ND, but we will show them when centered on with CTR ON
            .addIcon(role, WaypointTypes.NDB, this.buildIcon('STA_NDB'))
            .addIcon(role, WaypointTypes.VOR, (w) => {
            switch (w.facility.get().type) {
                case VorType.VOR:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('STA_VOR'), this.ICON_SIZE);
                case VorType.VORDME:
                case VorType.DME:
                case VorType.TACAN:
                    // DME's are displayed with TACAN icon
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('STA_TACAN'), this.ICON_SIZE);
                default:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('STA_VORTAC'), this.ICON_SIZE);
            }
        })
            .addLabel(BoeingMapCommon.tunedVorRole, WaypointTypes.VOR, this.buildFacilityLabel(BoeingColors.green, true))
            .addIcon(BoeingMapCommon.tunedVorRole, WaypointTypes.VOR, (w) => {
            switch (w.facility.get().type) {
                case VorType.VOR:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('VOR'), this.ICON_SIZE);
                case VorType.VORDME:
                case VorType.DME:
                case VorType.TACAN:
                    // DME's are displayed with TACAN icon
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('TACAN'), this.ICON_SIZE);
                default:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('VORTAC'), this.ICON_SIZE);
            }
        });
    }
    /**
     * Checks if leg is the origin or destination airport leg or runway leg.
     * @param plan the plan.
     * @param leg the leg.
     * @returns Whether leg is the origin or destination airport leg or runway leg.
     */
    isOriginDestOrRunwayLeg(plan, leg) {
        const isOriginOrDestinationAirportLeg = leg.leg.fixIcao === plan.originAirport || leg.leg.fixIcao === plan.destinationAirport;
        const isRunwayLeg = ICAO.isFacility(leg.leg.fixIcao, FacilityType.RWY);
        return isOriginOrDestinationAirportLeg || isRunwayLeg;
    }
}
var PlanWaypointRoles;
(function (PlanWaypointRoles) {
    PlanWaypointRoles["Inactive_Star"] = "FlightPlan_Inactive_Star";
    PlanWaypointRoles["Active_Star"] = "FlightPlan_Active_Star";
    PlanWaypointRoles["Inactive_Circle"] = "FlightPlan_Inactive_Circle";
    PlanWaypointRoles["Active_Circle"] = "FlightPlan_Active_Circle";
})(PlanWaypointRoles || (PlanWaypointRoles = {}));

/**
 * EIS FADEC mode color classifications.
 */
var EisFadecModeColor;
(function (EisFadecModeColor) {
    EisFadecModeColor["White"] = "White";
    EisFadecModeColor["Cyan"] = "Cyan";
    EisFadecModeColor["Green"] = "Green";
    EisFadecModeColor["Magenta"] = "Magenta";
    EisFadecModeColor["Amber"] = "Amber";
})(EisFadecModeColor || (EisFadecModeColor = {}));
/**
 * A provider of data for Boeing EIS.
 */
class BoeingEisDataProvider {
    /**
     * Create an EisInstrument
     * @param bus The event bus to publish to.
     * @param backplane The backplane.
     * @param facLoader The fac loader.
     * @param engineCount The number of engines.
     * @param flightPlanner The flight planner.
     * @param engineFuelFlowSwitchIndexOffset The offset to apply to the fuel flow switch simvar index.
     */
    constructor(bus, backplane, facLoader, engineCount, flightPlanner, engineFuelFlowSwitchIndexOffset = 0) {
        this.facLoader = facLoader;
        this.engineCount = engineCount;
        this.flightPlanner = flightPlanner;
        this.engineFuelFlowSwitchIndexOffset = engineFuelFlowSwitchIndexOffset;
        //private readonly trSub: EventSubscriber<LongitudeTurbineEvents>;
        this.engineData = this.setupEngineData();
        // public readonly autothrottleData = ObjectSubject.create<EisAutothrottleData>({
        //   g3000_at_mode_active: LongitudeAutothrottleModes.NONE
        // });
        this.surfacesData = ObjectSubject.create({
            flaps_handle_index: 0,
            spoilers_without_spoilerons_left_percent: 0,
            elevator_trim_angle: 0,
            aileron_trim_pct: 0,
            rudder_trim_pct: 0,
            gear_position_0: 0,
            gear_position_1: 0,
            gear_position_2: 0,
        });
        this.flapsData = ObjectSubject.create({
            flap_computer_interpolated_position: 0,
        });
        this.environmentData = ObjectSubject.create({
            isa_temp_c: 0,
            ram_air_temp_c: 0,
            ambient_temp_c: 0,
            pressure_alt: 0
        });
        this.pressurizationData = ObjectSubject.create({
            cabin_altitude: 0,
            cabin_altitude_rate: 0,
            pressure_diff: 0,
        });
        this.weightBalanceData = ObjectSubject.create({
            total_weight: 0
        });
        this.fuelSystemData = ObjectSubject.create({
            fuel_system_valve_open_1: 0,
            fuel_system_valve_open_2: 0,
            fuel_system_valve_open_8: 0,
            fuel_system_valve_open_9: 0,
        });
        this.fadec_ref_n1_1 = ConsumerSubject.create(null, 0);
        this.fadec_ref_n1_2 = ConsumerSubject.create(null, 0);
        this.fadec_ref_n1_3 = ConsumerSubject.create(null, 0);
        this.fadec_ref_n1_4 = ConsumerSubject.create(null, 0);
        this.fadec_target_n1_1 = ConsumerSubject.create(null, 0);
        this.fadec_target_n1_2 = ConsumerSubject.create(null, 0);
        this.fadec_target_n1_3 = ConsumerSubject.create(null, 0);
        this.fadec_target_n1_4 = ConsumerSubject.create(null, 0);
        this.fadec_ref_tpr_1 = ConsumerSubject.create(null, 0);
        this.fadec_ref_tpr_2 = ConsumerSubject.create(null, 0);
        this.fadec_ref_tpr_3 = ConsumerSubject.create(null, 0);
        this.fadec_ref_tpr_4 = ConsumerSubject.create(null, 0);
        this.fadec_target_tpr_1 = ConsumerSubject.create(null, 0);
        this.fadec_target_tpr_2 = ConsumerSubject.create(null, 0);
        this.fadec_target_tpr_3 = ConsumerSubject.create(null, 0);
        this.fadec_target_tpr_4 = ConsumerSubject.create(null, 0);
        this.fadec_eng_start_state_1 = ConsumerSubject.create(null, BoeingEngineStartState.STOPPED);
        this.fadec_eng_start_state_2 = ConsumerSubject.create(null, BoeingEngineStartState.STOPPED);
        this.fadec_eng_start_state_3 = ConsumerSubject.create(null, BoeingEngineStartState.STOPPED);
        this.fadec_eng_start_state_4 = ConsumerSubject.create(null, BoeingEngineStartState.STOPPED);
        this.v_throttle_lever_pos_1 = ConsumerSubject.create(null, 0);
        this.trData = this.setupTrData();
        this._fadecMode1Color = Subject.create(EisFadecModeColor.White);
        this.fadecMode1Color = this._fadecMode1Color;
        this._fadecMode2Color = Subject.create(EisFadecModeColor.White);
        this.fadecMode2Color = this._fadecMode2Color;
        this._isOnGround = ConsumerSubject.create(null, false);
        this.isOnGround = this._isOnGround;
        this.destinationFacility = Subject.create(undefined);
        // Add publishers we need.
        backplane.addPublisher(InstrumentBackplaneNames.Eis, new EISPublisher(bus), true);
        backplane.addPublisher(InstrumentBackplaneNames.Fadec, new BoeingFadecPublisher(bus, engineCount));
        backplane.addPublisher(InstrumentBackplaneNames.ControlSurfaces, new ControlSurfacesPublisher(bus, 3), true);
        backplane.addPublisher(InstrumentBackplaneNames.Electrical, new ElectricalPublisher(bus), true);
        backplane.addPublisher(InstrumentBackplaneNames.Pressurization, new PressurizationPublisher(bus), true);
        backplane.addPublisher(InstrumentBackplaneNames.FuelSystem, new FuelSystemSimVarPublisher(bus), true);
        backplane.addPublisher('AntiIce', new AntiIcePublisher(bus), true);
        this.eisSub = bus.getSubscriber();
        this.fadecSub = bus.getSubscriber();
        // this.autothrottleSub = bus.getSubscriber<G3000AutothrottleEvents>();
        this.surfacesSub = bus.getSubscriber();
        this.flapsSub = bus.getSubscriber();
        this.elecSub = bus.getSubscriber();
        this.adcSub = bus.getSubscriber();
        this.pressurizationSub = bus.getSubscriber();
        this.weightBalanceDataSub = bus.getSubscriber();
        this.fuelSystemDataSub = bus.getSubscriber();
        this.fmcSimVarSub = bus.getSubscriber();
        this._isOnGround.setConsumer(bus.getSubscriber().on('on_ground').whenChanged());
    }
    /**
     * Sets up the engine data object subject based on engine count.
     * @returns the engine data object subject.
     */
    setupEngineData() {
        let engineObject = {
            fuel_usable_total: 0,
            fuel_left: 0,
            fuel_right: 0,
            apu_pct: 0,
            fuel_weight_per_gallon: 0,
            fuel_right_main: 0,
            fuel_left_main: 0,
            fuel_center: 0,
        };
        for (let i = 1; i <= this.engineCount; i++) {
            engineObject = Object.assign(Object.assign({}, engineObject), { [`n1_${i}`]: 0, [`n3_${i}`]: 0, [`n2_${i}`]: 0, [`itt_${i}`]: 0, [`oil_press_${i}`]: 0, [`oil_temp_${i}`]: 0, [`fuel_flow_${i}`]: 0, [`fuel_flow_pph_${i}`]: 0, [`fuel_temp_${i}`]: 0, [`eng_starter_on_${i}`]: false, [`eng_combustion_${i}`]: false, [`eng_igniting_${i}`]: false, [`egt_${i}`]: 0, [`eng_vibration_${i}`]: 0, [`eng_fuel_flow_switch_${i}`]: false });
        }
        return ObjectSubject.create(engineObject);
    }
    /**
     * Sets up the thrust reverser data object subject based on engine count.
     * @returns the thrust reverser data object subject.
     */
    setupTrData() {
        let trDataObject = {};
        for (let i = 1; i <= this.engineCount; i++) {
            trDataObject = Object.assign(Object.assign({}, trDataObject), { [`tr_pos_${i}`]: 0 });
        }
        return ObjectSubject.create(trDataObject);
    }
    /**
     * Sets up the event subscriptions on the event bus.
     */
    init() {
        for (const event in this.engineData.get()) {
            if (event.startsWith('eng_fuel_flow_switch_') && this.engineFuelFlowSwitchIndexOffset > 0) {
                // Some planes, such as the 747-8, have the eng fuel flow switches starting on a different index than 1
                // This maps from the proper fuel system valve event to the eng_fuel_flow_switch_i event starting at 1
                const index = Number.parseInt(event[event.length - 1]) + this.engineFuelFlowSwitchIndexOffset;
                this.fuelSystemDataSub.on(`fuel_system_valve_open_${index}`).withPrecision(0).handle((value) => {
                    this.engineData.set(event, value === 1);
                });
            }
            else {
                this.eisSub.on(event).withPrecision(1).handle((value) => {
                    this.engineData.set(event, value);
                });
            }
        }
        // this.trSub.on('thrust_reverser_pos_1').handle((v: number) => this.trData.set('tr_pos_1', v));
        // this.trSub.on('thrust_reverser_pos_2').handle((v: number) => this.trData.set('tr_pos_2', v));
        // SynopticNumber.create(this.fuel.leftTankTemp, 1).sub((v: number) => this.engineData.set('fuel_temp_1', v), true);
        // SynopticNumber.create(this.fuel.rightTankTemp, 1).sub((v: number) => this.engineData.set('fuel_temp_2', v), true);
        //TODO FADEC EVENT
        this.fadec_ref_tpr_1.setConsumer(this.fadecSub.on('fadec_ref_tpr_1').whenChangedBy(0.1));
        this.fadec_ref_tpr_2.setConsumer(this.fadecSub.on('fadec_ref_tpr_2').whenChangedBy(0.1));
        this.fadec_ref_tpr_3.setConsumer(this.fadecSub.on('fadec_ref_tpr_3').whenChangedBy(0.1));
        this.fadec_ref_tpr_4.setConsumer(this.fadecSub.on('fadec_ref_tpr_4').whenChangedBy(0.1));
        this.fadec_target_tpr_1.setConsumer(this.fadecSub.on('fadec_target_tpr_1').whenChangedBy(0.1));
        this.fadec_target_tpr_2.setConsumer(this.fadecSub.on('fadec_target_tpr_2').whenChangedBy(0.1));
        this.fadec_target_tpr_3.setConsumer(this.fadecSub.on('fadec_target_tpr_3').whenChangedBy(0.1));
        this.fadec_target_tpr_4.setConsumer(this.fadecSub.on('fadec_target_tpr_4').whenChangedBy(0.1));
        this.fadec_ref_n1_1.setConsumer(this.fadecSub.on('fadec_ref_n1_1').whenChangedBy(0.1));
        this.fadec_ref_n1_2.setConsumer(this.fadecSub.on('fadec_ref_n1_2').whenChangedBy(0.1));
        this.fadec_ref_n1_3.setConsumer(this.fadecSub.on('fadec_ref_n1_3').whenChangedBy(0.1));
        this.fadec_ref_n1_4.setConsumer(this.fadecSub.on('fadec_ref_n1_4').whenChangedBy(0.1));
        this.fadec_target_n1_1.setConsumer(this.fadecSub.on('fadec_target_n1_1').whenChangedBy(0.1));
        this.fadec_target_n1_2.setConsumer(this.fadecSub.on('fadec_target_n1_2').whenChangedBy(0.1));
        this.fadec_target_n1_3.setConsumer(this.fadecSub.on('fadec_target_n1_3').whenChangedBy(0.1));
        this.fadec_target_n1_4.setConsumer(this.fadecSub.on('fadec_target_n1_4').whenChangedBy(0.1));
        this.fadec_eng_start_state_1.setConsumer(this.fadecSub.on('fadec_eng_start_state_1'));
        this.fadec_eng_start_state_2.setConsumer(this.fadecSub.on('fadec_eng_start_state_2'));
        this.fadec_eng_start_state_3.setConsumer(this.fadecSub.on('fadec_eng_start_state_3'));
        this.fadec_eng_start_state_4.setConsumer(this.fadecSub.on('fadec_eng_start_state_4'));
        //TODO AUTO THROTTLE EVENT
        // for (const event in this.autothrottleData.get()) {
        //   this.autothrottleSub.on(event as keyof G3000AutothrottleEvents).handle((value: any): void => {
        //     this.autothrottleData.set(event as keyof EisAutothrottleData, value);
        //   });
        // }
        for (const event in this.surfacesData.get()) {
            this.surfacesSub.on(event).withPrecision(1).handle((value) => {
                this.surfacesData.set(event, value);
            });
        }
        for (const event in this.flapsData.get()) {
            this.flapsSub.on(event).withPrecision(1).handle((value) => {
                this.flapsData.set(event, value);
            });
        }
        // SynopticNumber.create(this.electrical.leftBattery.voltage, 1).sub((v: number) => this.elecData.set('elec_bat_v_1', v), true);
        // SynopticNumber.create(this.electrical.leftBattery.amps, 1).sub((v: number) => this.elecData.set('elec_bat_a_1', v), true);
        // SynopticNumber.create(this.electrical.rightBattery.voltage, 1).sub((v: number) => this.elecData.set('elec_bat_v_2', v), true);
        // SynopticNumber.create(this.electrical.rightBattery.amps, 1).sub((v: number) => this.elecData.set('elec_bat_a_2', v), true);
        for (const event in this.environmentData.get()) {
            this.adcSub.on(event).withPrecision(1).handle((value) => {
                this.environmentData.set(event, value);
            });
        }
        for (const event in this.pressurizationData.get()) {
            const precision = event === 'cabin_altitude_rate' ? -1 : 1;
            this.pressurizationSub.on(event).withPrecision(precision).handle((value) => {
                this.pressurizationData.set(event, value);
            });
        }
        for (const event in this.weightBalanceData.get()) {
            this.weightBalanceDataSub.on(event).withPrecision(1).handle((value) => {
                this.weightBalanceData.set(event, value);
            });
        }
        for (const event in this.fuelSystemData.get()) {
            this.fuelSystemDataSub.on(event).withPrecision(1).handle((value) => {
                this.fuelSystemData.set(event, value);
            });
        }
        this.fmcSimVarSub.on('fmcExecActive').handle(async (fmcExecActive) => {
            if (!fmcExecActive && this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX)) {
                const plan = this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
                if (plan.destinationAirport) {
                    const fac = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                    this.destinationFacility.set(fac);
                }
                else {
                    this.destinationFacility.set(undefined);
                }
            }
        });
        // this.fadecData.sub((data, key) => {
        //   switch (key) {
        //     case 'fadec_mode_1':
        //     case 'fadec_ref_n1_1':
        //     case 'fadec_target_n1_1':
        //       this._fadecMode1Color.set(this.getFadecModeColor(1, data, this.autothrottleData.get()));
        //       break;
        //     case 'fadec_mode_2':
        //     case 'fadec_ref_n1_2':
        //     case 'fadec_target_n1_2':
        //       this._fadecMode2Color.set(this.getFadecModeColor(2, data, this.autothrottleData.get()));
        //       break;
        //   }
        // }, true);
        // this.autothrottleData.sub((data: Readonly<EisAutothrottleData>, key: any) => {
        //   switch (key) {
        //     case 'g3000_at_mode_active':
        //       this._fadecMode1Color.set(this.getFadecModeColor(1, this.fadecData.get(), data));
        //       this._fadecMode2Color.set(this.getFadecModeColor(2, this.fadecData.get(), data));
        //       break;
        //   }
        // }, true);
    }
}

/**
 * A publisher that publishes turbine events for the Boeing.
 */
class BoeingTurbinePublisher extends BasePublisher {
    constructor() {
        super(...arguments);
        this.tr1Servo = new LinearServo(0.5);
        this.tr1Value = 0;
        this.tr2Servo = new LinearServo(0.5);
        this.tr2Value = 0;
        this.tr3Servo = new LinearServo(0.5);
        this.tr3Value = 0;
        this.tr4Servo = new LinearServo(0.5);
        this.tr4Value = 0;
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.isPublishing()) {
            // const leftEngineIgnition = SimVar.GetSimVarValue('TURB ENG IGNITION SWITCH EX1:1', SimVarValueType.Enum) > 0;
            // const leftEngineFuel = SimVar.GetSimVarValue('GENERAL ENG MIXTURE LEVER POSITION:1', SimVarValueType.Number) === 1;
            // const leftEngineRunStopState = leftEngineIgnition && leftEngineFuel;
            // const righttEngineIgnition = SimVar.GetSimVarValue('TURB ENG IGNITION SWITCH EX1:2', SimVarValueType.Enum) > 0;
            // const rightEngineFuel = SimVar.GetSimVarValue('GENERAL ENG MIXTURE LEVER POSITION:2', SimVarValueType.Number) === 1;
            // const rightEngineRunStopState = righttEngineIgnition && rightEngineFuel;
            // if (this.runStopState1 !== leftEngineRunStopState) {
            //   this.runStopState1 = leftEngineRunStopState;
            //   this.publish('turb_eng_runstop_1', this.runStopState1, false, true);
            // }
            // if (this.runStopState2 !== rightEngineRunStopState) {
            //   this.runStopState2 = rightEngineRunStopState;
            //   this.publish('turb_eng_runstop_2', this.runStopState2, false, true);
            // }
            this.tr1Value = this.tr1Servo.drive(this.tr1Value, SimVar.GetSimVarValue('GENERAL ENG THROTTLE LEVER POSITION:1', SimVarValueType.Percent) < 0 ? 1 : 0);
            this.tr2Value = this.tr2Servo.drive(this.tr2Value, SimVar.GetSimVarValue('GENERAL ENG THROTTLE LEVER POSITION:2', SimVarValueType.Percent) < 0 ? 1 : 0);
            this.tr3Value = this.tr3Servo.drive(this.tr3Value, SimVar.GetSimVarValue('GENERAL ENG THROTTLE LEVER POSITION:3', SimVarValueType.Percent) < 0 ? 1 : 0);
            this.tr4Value = this.tr4Servo.drive(this.tr4Value, SimVar.GetSimVarValue('GENERAL ENG THROTTLE LEVER POSITION:4', SimVarValueType.Percent) < 0 ? 1 : 0);
            this.publish('thrust_reverser_pos_1', this.tr1Value);
            this.publish('thrust_reverser_pos_2', this.tr2Value);
            this.publish('thrust_reverser_pos_3', this.tr3Value);
            this.publish('thrust_reverser_pos_4', this.tr4Value);
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A handler for altimeter barometric setting key events.
 *
 * The handler manages a set of indexed altimeters by intercepting key events manipulating the barometric settings of
 * those altimeters and applying custom logic in response to those key events. Key events that manipulate non-managed
 * altimeters will be passed through to the sim unchanged.
 *
 * In response to key events that change a managed altimeter's barometric setting, the handler will apply the change
 * as-is if the altimeter is not in STD mode. If the altimeter is in STD mode, then the handler will either change
 * the preselected barometric setting instead if the altimeter supports it, or deactivate STD mode and apply the change
 * if the altimeter does not support preselected barometric settings.
 *
 * In response to the `BAROMETRIC_STD_PRESSURE` key event, the handler will either toggle STD mode if the altimeter
 * supports it, or set standard pressure (29.92 inHg/1013 hPa) if the altimeter does not support STD mode.
 *
 * In response to the `BAROMETRIC` key event, the handler will determine whether standard pressure or QNH should be
 * set based on whether the airplane is above or below the relevant transition altitude/flight level as defined in the
 * active performance plan. If standard pressure should be set, then the handler will activate STD mode if supported,
 * or simply set standard pressure if not. If QNH should be set, then the handler will deactivate STD mode if it is
 * active and set QNH.
 */
class AltimeterBaroKeyEventHandler {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param perfPlan The active performance plan.
     * @param managedAltimeterInfos Information describing the altimeters to be managed by the handler.
     */
    constructor(bus, perfPlan, managedAltimeterInfos) {
        this.bus = bus;
        this.perfPlan = perfPlan;
        this.fmsOperatingPhase = ConsumerValue.create(null, FmsOperatingPhase.PREFLIGHT);
        this.isAlive = true;
        this.isInit = false;
        this.managedAltimeterInfos = Array.from(managedAltimeterInfos, info => {
            return Object.assign(Object.assign({}, info), { settingSimVar: `KOHLSMAN SETTING HG:${info.index}`, stdSimVar: `L:XMLVAR_Baro${info.index}_ForcedToSTD`, 
                // Note: by convention, preselect simvar uses the same units as the KOHLSMAN key events - one unit = 1 / 16 hPa.
                preselectSimVar: `L:XMLVAR_Baro${info.index}_SavedPressure`, indicatedAltSimVar: `INDICATED ALTITUDE:${info.index}` });
        }).filter((info, index, array) => array.findIndex(query => query.index === info.index) === index); // Filter out duplicate altimeters of the same index
        this.keyEventManagerReadyPromise = new Promise((resolve, reject) => {
            this.keyEventManagerReadyPromiseReject = reject;
            KeyEventManager.getManager(this.bus).then(manager => {
                this.keyEventManager = manager;
                resolve();
            });
        });
    }
    /**
     * Waits for this handler's key event manager to be ready.
     * @returns A Promise which will be fulfilled when this handler's key event manager is ready, or rejected if this
     * handler is destroyed before then.
     */
    awaitKeyEventManagerReady() {
        return this.keyEventManagerReadyPromise;
    }
    /**
     * Initializes this handler. Once this handler is initialized, it will change the baro setting for this handler's
     * PFD's altimeter in response to baro knob input events.
     * @returns A Promise which will be fulfilled when this handler is fully initialized, or rejected if this handler is
     * destroyed before then.
     */
    async init() {
        if (!this.isAlive) {
            throw new Error('AltimeterBaroKeyEventHandler: cannot initialize a dead handler');
        }
        await this.awaitKeyEventManagerReady();
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.fmsOperatingPhase.setConsumer(this.bus.getSubscriber().on('fms_operating_phase'));
        this.keyEventManager.interceptKey('KOHLSMAN_SET', false);
        this.keyEventManager.interceptKey('KOHLSMAN_INC', false);
        this.keyEventManager.interceptKey('KOHLSMAN_DEC', false);
        this.keyEventManager.interceptKey('BAROMETRIC_STD_PRESSURE', false);
        this.keyEventManager.interceptKey('BAROMETRIC', false);
        this.keyEventSub = this.bus.getSubscriber().on('key_intercept').handle(this.onKeyIntercepted.bind(this));
    }
    /**
     * Gets information on a managed altimeter.
     * @param index The index of the altimeter.
     * @returns Information on the specified managed altimeter, or `undefined` if the altimeter is not managed by this
     * handler.
     */
    getInfo(index) {
        return this.managedAltimeterInfos.find(info => info.index === index);
    }
    /**
     * Handles a key event intercept.
     * @param data Data describing the intercepted key event.
     */
    onKeyIntercepted(data) {
        var _a, _b, _c, _d;
        switch (data.key) {
            case 'KOHLSMAN_SET': {
                if (data.value0 !== undefined) {
                    const info = this.getInfo((_a = data.value1) !== null && _a !== void 0 ? _a : 0);
                    if (info && info.supportStd) {
                        this.setBaroSetting(info, data.value0);
                        return;
                    }
                }
                this.keyEventManager.triggerKey(data.key, true, data.value0, data.value1);
                break;
            }
            case 'KOHLSMAN_INC': {
                const info = this.getInfo((_b = data.value0) !== null && _b !== void 0 ? _b : 0);
                if (info && info.supportStd) {
                    this.changeBaroSetting(info, 1);
                    return;
                }
                this.keyEventManager.triggerKey(data.key, true, data.value0);
                break;
            }
            case 'KOHLSMAN_DEC': {
                const info = this.getInfo((_c = data.value0) !== null && _c !== void 0 ? _c : 0);
                if (info && info.supportStd) {
                    this.changeBaroSetting(info, -1);
                    return;
                }
                this.keyEventManager.triggerKey(data.key, true, data.value0);
                break;
            }
            case 'BAROMETRIC_STD_PRESSURE': {
                const info = this.getInfo((_d = data.value0) !== null && _d !== void 0 ? _d : 0);
                if (info && info.supportStd) {
                    this.toggleBaroStd(info);
                    return;
                }
                this.keyEventManager.triggerKey(data.key, true, data.value0);
                break;
            }
            case 'BAROMETRIC': {
                this.handleBarometric();
                break;
            }
        }
    }
    /**
     * Sets the baro setting for an altimeter. If STD mode is currently on and baro preselect is supported, the
     * preselected baro setting will be changed instead of the active baro setting. If STD mode is currently on and baro
     * preselect is not supported, STD mode will be deactivated and the active baro setting will be changed.
     * @param info Information on the altimeter to modify.
     * @param value The value to set, in units of raw baro setting pressure (equal to 1/16 hPa).
     */
    setBaroSetting(info, value) {
        value = MathUtils.clamp(value, AltimeterBaroKeyEventHandler.MIN_RAW, AltimeterBaroKeyEventHandler.MAX_RAW);
        const isStd = SimVar.GetSimVarValue(info.stdSimVar, SimVarValueType.Bool) !== 0;
        if (isStd) {
            if (info.supportBaroPreselect) {
                SimVar.SetSimVarValue(info.preselectSimVar, SimVarValueType.Number, value);
                return;
            }
            else {
                SimVar.SetSimVarValue(info.stdSimVar, SimVarValueType.Bool, 0);
            }
        }
        this.keyEventManager.triggerKey('KOHLSMAN_SET', true, value, info.index);
    }
    /**
     * Increments or decrements the baro setting for an altimeter. If STD mode is currently on and baro preselect is
     * supported, the preselected baro setting will be changed instead of the active baro setting. If STD mode is
     * currently on and baro preselect is not supported, STD mode will be deactivated and the active baro setting will
     * be changed.
     * @param info Information on the altimeter to modify.
     * @param direction The direction to change the baro setting.
     */
    changeBaroSetting(info, direction) {
        const isStd = SimVar.GetSimVarValue(info.stdSimVar, SimVarValueType.Bool) !== 0;
        if (isStd) {
            if (info.supportBaroPreselect) {
                const currentVal = SimVar.GetSimVarValue(info.preselectSimVar, SimVarValueType.Number);
                const newVal = MathUtils.clamp(currentVal + AltimeterBaroKeyEventHandler.INCREMENT_RAW * direction, AltimeterBaroKeyEventHandler.MIN_RAW, AltimeterBaroKeyEventHandler.MAX_RAW);
                SimVar.SetSimVarValue(info.preselectSimVar, SimVarValueType.Number, newVal);
                return;
            }
            else {
                SimVar.SetSimVarValue(info.stdSimVar, SimVarValueType.Bool, 0);
            }
        }
        this.keyEventManager.triggerKey(`KOHLSMAN_${direction === 1 ? 'INC' : 'DEC'}`, true, info.index);
    }
    /**
     * Toggles STD BARO mode for an altimeter. If STD mode is currently off, this will turn on STD mode, set the
     * preselected baro setting to the current active baro setting, and set the active baro setting to 29.92 inches
     * (1013 hPa). If STD mode is currently on, this will turn off STD mode and set the active baro setting to the
     * current preselected baro setting.
     * @param info Information on the altimeter to modify.
     */
    toggleBaroStd(info) {
        const isStd = SimVar.GetSimVarValue(info.stdSimVar, SimVarValueType.Bool) !== 0;
        if (isStd) {
            const preselect = SimVar.GetSimVarValue(info.preselectSimVar, SimVarValueType.Number);
            SimVar.SetSimVarValue(info.stdSimVar, SimVarValueType.Bool, 0);
            this.keyEventManager.triggerKey('KOHLSMAN_SET', true, Math.round(preselect), info.index);
        }
        else {
            const currentPressure = SimVar.GetSimVarValue(info.settingSimVar, SimVarValueType.InHG);
            SimVar.SetSimVarValue(info.preselectSimVar, SimVarValueType.Number, currentPressure * AltimeterBaroKeyEventHandler.IN_HG_TO_RAW_KOHLSMAN);
            SimVar.SetSimVarValue(info.stdSimVar, SimVarValueType.Bool, 1);
            this.keyEventManager.triggerKey('KOHLSMAN_SET', true, Math.round(29.92 * AltimeterBaroKeyEventHandler.IN_HG_TO_RAW_KOHLSMAN), info.index);
        }
    }
    /**
     * Handles the `BAROMETRIC` key event. For each managed altimeter, STD mode will be activated if the airplane is
     * currently above the relevant transition altitude or flight level. If the managed altimeter does not support STD
     * mode, it will still be set to 29.92 inches/1013 hPa. If the airplane is below the transition altitude/flight
     * level, STD mode will be deactivated and QNH will be set.
     */
    handleBarometric() {
        // Pass through the key event into the sim so that any altimeters that aren't managed by us are correctly modified.
        // The reason we do it here instead of having the intercept set up to pass through automatically is so that we
        // don't get a frame where the baro setting changes for our managed altimeters.
        this.keyEventManager.triggerKey('BAROMETRIC', true);
        const pressureAltitude = SimVar.GetSimVarValue('PRESSURE ALTITUDE', SimVarValueType.Feet);
        const isClimbing = this.fmsOperatingPhase.get() < FmsOperatingPhase.DESCENT;
        const transitionAltitude = isClimbing
            ? this.perfPlan.transitionAltitude.get()
            : this.perfPlan.transitionLevel.get();
        for (const info of this.managedAltimeterInfos) {
            const indicatedAltitude = SimVar.GetSimVarValue(info.indicatedAltSimVar, SimVarValueType.Feet);
            const isStd = SimVar.GetSimVarValue(info.stdSimVar, SimVarValueType.Bool) !== 0;
            const shouldBeStd = isClimbing
                ? indicatedAltitude > (transitionAltitude !== null && transitionAltitude !== void 0 ? transitionAltitude : 18000)
                : pressureAltitude > (transitionAltitude !== null && transitionAltitude !== void 0 ? transitionAltitude : 18000);
            if (shouldBeStd) {
                if (info.supportStd) {
                    if (!isStd) {
                        this.toggleBaroStd(info);
                    }
                }
                else {
                    this.keyEventManager.triggerKey('KOHLSMAN_SET', true, Math.round(29.92 * AltimeterBaroKeyEventHandler.IN_HG_TO_RAW_KOHLSMAN), info.index);
                }
            }
            else {
                if (info.supportStd && isStd) {
                    SimVar.SetSimVarValue(info.stdSimVar, SimVarValueType.Bool, 0);
                }
                const baroToSetInHg = SimVar.GetSimVarValue('SEA LEVEL PRESSURE', SimVarValueType.InHG);
                this.keyEventManager.triggerKey('KOHLSMAN_SET', true, Math.round(baroToSetInHg * AltimeterBaroKeyEventHandler.IN_HG_TO_RAW_KOHLSMAN), info.index);
            }
        }
    }
    /**
     * Destroys this handler.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        (_a = this.keyEventManagerReadyPromiseReject) === null || _a === void 0 ? void 0 : _a.call(this, 'AltimeterBaroKeyEventHandler: handler was destroyed');
        this.fmsOperatingPhase.destroy();
        (_b = this.keyEventSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}
AltimeterBaroKeyEventHandler.IN_HG_TO_RAW_KOHLSMAN = UnitType.IN_HG.convertTo(1, UnitType.HPA) * 16;
AltimeterBaroKeyEventHandler.INCREMENT_RAW = 5;
AltimeterBaroKeyEventHandler.MIN_RAW = 15169;
AltimeterBaroKeyEventHandler.MAX_RAW = 17344;

/**
 * A Boeing ADC system.
 */
class AdcSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an ADC system.
     * @param index The index of the ADC.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this ADC derives its data.
     * @param altimeterIndex The index of the sim altimeter from which this ADC derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, airspeedIndicatorIndex, altimeterIndex, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.airspeedIndicatorIndex = airspeedIndicatorIndex;
        this.altimeterIndex = altimeterIndex;
        this.initializationTime = 15000;
        this.dataSourceTopicMap = {
            [`adc_ias_${this.index}`]: `ias_${this.airspeedIndicatorIndex}`,
            [`adc_tas_${this.index}`]: `tas_${this.airspeedIndicatorIndex}`,
            [`adc_mach_to_kias_factor_${this.index}`]: `mach_to_kias_factor_${this.airspeedIndicatorIndex}`,
            [`adc_indicated_alt_${this.index}`]: `indicated_alt_${this.altimeterIndex}`,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: `altimeter_baro_setting_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: `altimeter_baro_preselect_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: `altimeter_baro_preselect_mb_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: `altimeter_baro_preselect_raw_${this.altimeterIndex}`,
            [`adc_altimeter_baro_is_std_${this.index}`]: `altimeter_baro_is_std_${this.altimeterIndex}`,
            [`adc_mach_number_${this.index}`]: 'mach_number',
            [`adc_pressure_alt_${this.index}`]: 'pressure_alt',
            [`adc_vertical_speed_${this.index}`]: 'vertical_speed',
            [`adc_ambient_density_${this.index}`]: 'ambient_density',
            [`adc_ambient_temp_c_${this.index}`]: 'ambient_temp_c',
            [`adc_ambient_pressure_inhg_${this.index}`]: 'ambient_pressure_inhg',
            [`adc_isa_temp_c_${this.index}`]: 'isa_temp_c',
            [`adc_ram_air_temp_c_${this.index}`]: 'ram_air_temp_c'
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing ADC data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.dataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
}

/**
 * A Garmin AHRS system.
 */
class AhrsSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an AHRS system.
     * @param index The index of the AHRS.
     * @param bus An instance of the event bus.
     * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this AHRS derives its data.
     * @param directionIndicatorIndex The index of the sim direction indicator from which this AHRS derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, attitudeIndicatorIndex, directionIndicatorIndex, powerSource) {
        super(index, bus, `ahrs_state_${index}`);
        this.attitudeIndicatorIndex = attitudeIndicatorIndex;
        this.directionIndicatorIndex = directionIndicatorIndex;
        this.powerSource = powerSource;
        this.initializationTime = 45000;
        this.magnetometerState = undefined;
        this.adcState = undefined;
        // TODO: add GPS data state
        this.isHeadingDataValid = true;
        this.isAttitudeDataValid = true;
        this.rollSub = this.bus.getSubscriber().on('roll_deg').whenChanged().handle(this.onRollChanged.bind(this), true);
        this.headingDataSourceTopicMap = {
            [`ahrs_hdg_deg_${this.index}`]: `hdg_deg_${this.directionIndicatorIndex}`,
            [`ahrs_hdg_deg_true_${this.index}`]: `hdg_deg_true_${this.directionIndicatorIndex}`
        };
        this.attitudeDataSourceTopicMap = {
            [`ahrs_delta_heading_rate_${this.index}`]: `delta_heading_rate_${this.attitudeIndicatorIndex}`,
            [`ahrs_pitch_deg_${this.index}`]: `pitch_deg_${this.attitudeIndicatorIndex}`,
            [`ahrs_roll_deg_${this.index}`]: `roll_deg_${this.attitudeIndicatorIndex}`,
            [`ahrs_turn_coordinator_ball_${this.index}`]: 'turn_coordinator_ball'
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.headingDataSubs = [];
        this.attitudeDataSubs = [];
        if (this.powerSource !== undefined) {
            this.connectToPower(this.powerSource);
        }
        this.publisher.pub(`ahrs_heading_data_valid_${index}`, this.isHeadingDataValid);
        this.publisher.pub(`ahrs_attitude_data_valid_${index}`, this.isAttitudeDataValid);
        this.bus.getSubscriber()
            .on(`magnetometer_state_${index}`)
            .handle(evt => {
            this.magnetometerState = evt.current;
            this.updateHeadingDataState();
        });
        this.bus.getSubscriber()
            .on(`adc_state_${index}`)
            .handle(evt => {
            this.adcState = evt.current;
            this.updateAttitudeDataState();
        });
        this.startDataPublish();
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.setState(isPowered ? AvionicsSystemState.On : AvionicsSystemState.Off);
        }
        else {
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.rollSub.resume(true);
                this.initializationTimer.schedule(() => {
                    this.rollSub.pause();
                    this.setState(AvionicsSystemState.On);
                }, 45000);
            }
            else {
                this.rollSub.pause();
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /**
     * Starts publishing AHRS data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.headingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.attitudeDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onAttitudeTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.headingDataSourceTopicMap) {
                this.onHeadingTopicSubscribed(topic);
            }
            else if (topic in this.attitudeDataSourceTopicMap) {
                this.onAttitudeTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onHeadingTopicSubscribed(topic) {
        this.headingDataSubs.push(this.dataSourceSubscriber.on(this.headingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's attitude data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onAttitudeTopicSubscribed(topic) {
        this.attitudeDataSubs.push(this.dataSourceSubscriber.on(this.attitudeDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isAttitudeDataValid));
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        this.updateHeadingDataState();
        this.updateAttitudeDataState();
    }
    /**
     * Updates the validity state of this system's heading data. If heading data is valid, this system will start
     * publishing heading data. If heading data is invalid, this system will stop publishing heading data.
     */
    updateHeadingDataState() {
        const isHeadingDataValid = (this._state === undefined || this._state === AvionicsSystemState.On)
            && (this.magnetometerState === undefined || this.magnetometerState === AvionicsSystemState.On);
        if (isHeadingDataValid !== this.isHeadingDataValid) {
            this.isHeadingDataValid = isHeadingDataValid;
            if (isHeadingDataValid) {
                for (const sub of this.headingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.headingDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(`ahrs_heading_data_valid_${this.index}`, this.isHeadingDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's attitude data. If attitude data is valid, this system will start
     * publishing attitude data. If attitude data is invalid, this system will stop publishing attitude data.
     */
    updateAttitudeDataState() {
        const isAttitudeDataValid = (this._state === undefined || this._state === AvionicsSystemState.On);
        // TODO: add logic for no-ADC and no-GPS reversionary modes
        if (isAttitudeDataValid !== this.isAttitudeDataValid) {
            this.isAttitudeDataValid = isAttitudeDataValid;
            if (isAttitudeDataValid) {
                for (const sub of this.attitudeDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.attitudeDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(`ahrs_attitude_data_valid_${this.index}`, this.isAttitudeDataValid, false, true);
        }
    }
    /**
     * Handles when the bank angle changes while AHRS is initializing.
     * @param bankAngle The bank angle of the aircraft.
     */
    onRollChanged(bankAngle) {
        if (Math.abs(bankAngle) >= 20) {
            this.initializationTimer.schedule(() => {
                this.rollSub.pause();
                this.setState(AvionicsSystemState.On);
            }, 45000);
        }
    }
}

/**
 * A Boeing angle of attack computer system.
 */
class AoaSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an angle of attack computer system.
     * @param index The index of the AoA computer.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `aoa_state_${index}`);
        this.initializationTime = 15000;
        this.simVarPublisher = new SimVarPublisher(new Map([
            [`aoa_load_factor_${this.index}`, { name: 'SEMIBODY LOADFACTOR Y', type: SimVarValueType.Number }]
        ]), this.bus);
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.isAoaSubbed = false;
        this.isStallAoaSubbed = false;
        this.isZeroLiftAoaSubbed = false;
        this.normAoaTopic = `aoa_norm_aoa_${this.index}`;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing angle of attack data on the event bus.
     */
    startDataPublish() {
        const topics = [
            `aoa_aoa_${this.index}`,
            `aoa_stall_aoa_${this.index}`,
            `aoa_zero_lift_aoa_${this.index}`,
            `aoa_norm_aoa_${this.index}`
        ];
        for (const topic of topics) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topics.includes(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
        this.simVarPublisher.startPublish();
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        let shouldSubAoa = false;
        let shouldSubStallAoa = false;
        let shouldSubZeroLiftAoa = false;
        switch (topic) {
            case `aoa_aoa_${this.index}`:
                shouldSubAoa = true;
                break;
            case `aoa_stall_aoa_${this.index}`:
                shouldSubStallAoa = true;
                break;
            case `aoa_zero_lift_aoa_${this.index}`:
                shouldSubZeroLiftAoa = true;
                break;
            case `aoa_norm_aoa_${this.index}`:
                shouldSubAoa = true;
                shouldSubStallAoa = true;
                shouldSubZeroLiftAoa = true;
                break;
        }
        if (shouldSubAoa && !this.isAoaSubbed) {
            this.isAoaSubbed = true;
            const pubTopic = `aoa_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('aoa').handle(val => {
                this.aoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubStallAoa && !this.isStallAoaSubbed) {
            this.isStallAoaSubbed = true;
            const pubTopic = `aoa_stall_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('stall_aoa').handle(val => {
                this.stallAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubZeroLiftAoa && !this.isZeroLiftAoaSubbed) {
            this.isZeroLiftAoaSubbed = true;
            const pubTopic = `aoa_zero_lift_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('zero_lift_aoa').handle(val => {
                this.zeroLiftAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.Failed
            || this._state === AvionicsSystemState.Off
            || this.aoa === undefined
            || this.stallAoa === undefined
            || this.zeroLiftAoa === undefined) {
            return;
        }
        this.publisher.pub(this.normAoaTopic, (this.aoa - this.zeroLiftAoa) / (this.stallAoa - this.zeroLiftAoa), false, true);
        this.simVarPublisher.onUpdate();
    }
}

/**
 * A publisher that publishes Boeing Game Units events.
 */
class BoeingGameUnitsPublisher extends GameVarPublisher {
    /**
     * Creates an instance of the BoeingGameUnitsPublisher.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        super(BoeingGameUnitsPublisher.gamevars, bus);
    }
}
BoeingGameUnitsPublisher.gamevars = new Map([
    ['game_units_metric', { name: 'GAME UNIT IS METRIC', type: SimVarValueType.Bool }],
]);

/**
 * A basic instrument to emulate Boeing specific hydraulics data
 */
class BoeingHydraulicDataInstrument {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.sub = this.bus.getSubscriber();
        // inop
    }
    /** @inheritdoc */
    init() {
        // inop
    }
    /**
     * Subscribes and maps the pressure of two hydraulic pumps to one circuit topic and publishes that.
     * @param publish A function that publishes the value to the proper topic.
     * @param circuitIndex1 The index of the first pump.
     * @param circuitIndex2 The index of the second pump.
     */
    mapCircuitToTopic(publish, circuitIndex1, circuitIndex2) {
        // get random full number between 80 and 110
        const rngPress = Math.floor(Math.random() * 30) + 80;
        const circuit = circuitIndex2 ? MappedSubject.create(([press1, press2]) => {
            return Math.max(press1, press2);
        }, ConsumerSubject.create(this.sub.on(`hyd_pressure_${circuitIndex1}`).withPrecision(0), 0), ConsumerSubject.create(this.sub.on(`hyd_pressure_${circuitIndex2}`).withPrecision(0), 0)) : ConsumerSubject.create(this.sub.on(`hyd_pressure_${circuitIndex1}`).withPrecision(0), 0);
        circuit.sub((v) => {
            publish(v + rngPress);
        }, true);
    }
    /**
     * Subscribes and maps the pressure of two reservoir quantity values one topic and publishes that.
     * @param publish A function that publishes the value to the proper topic.
     * @param reservoirIndex1 The index of the first reservoir.
     * @param reservoirIndex2 The index of the second reservoir.
     */
    mapReservoirToTopic(publish, reservoirIndex1, reservoirIndex2) {
        const res = reservoirIndex2 ? MappedSubject.create(([res1, res2]) => {
            return Math.max(res1, res2);
        }, ConsumerSubject.create(this.sub.on(`hyd_reservoir_perc_${reservoirIndex1}`).withPrecision(1), 0), ConsumerSubject.create(this.sub.on(`hyd_reservoir_perc_${reservoirIndex2}`).withPrecision(1), 0)) : ConsumerSubject.create(this.sub.on(`hyd_reservoir_perc_${reservoirIndex1}`).withPrecision(1), 0);
        res.sub((v) => {
            publish(v / 100);
        }, true);
    }
    /** @inheritdoc */
    onUpdate() {
        // inop
    }
}

/**
 * FMS positioning system data modes.
 */
var FmsPositionMode;
(function (FmsPositionMode) {
    /** No position data is available. */
    FmsPositionMode["None"] = "None";
    /** Position data is sourced from GPS. */
    FmsPositionMode["Gps"] = "Gps";
    /** Position data is sourced from DME/DME. */
    FmsPositionMode["Dme"] = "Dme";
    /** Position data is sourced from HNS (hybrid inertial navigation). */
    FmsPositionMode["Hns"] = "Hns";
    /** Position data is sourced from dead reckoning. */
    FmsPositionMode["DeadReckoning"] = "DeadReckoning";
    /** Position data is sourced from dead reckoning and more than 20 minutes have elapsed since the last accurate position fix. */
    FmsPositionMode["DeadReckoningExpired"] = "DeadReckoningExpired";
})(FmsPositionMode || (FmsPositionMode = {}));
/**
 * A Boeing FMS geo-positioning system.
 */
class FmsPositionSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an FMS geo-positioning system.
     * @param index The index of the FMS geo-positioning system.
     * @param bus An instance of the event bus.
     * @param gpsReceiverIndex The index of the GPS receiver used by this system. No GPS data will be used if the index
     * is negative.
     * @param adcIndex The index of the ADC used by this system in dead reckoning mode to obtain airspeed data.
     * @param ahrsIndex The index of the AHRS used by this system in dead reckoning mode to obtain heading data.
     * @param hnsIndex The index of the HNS used by this system. No HNS data will be used if the index is negative.
     * Defaults to `-1`.
     * @param dmeIndex The index of the DME/DME navigation system used by this system. No DME/DME data will be used if
     * the index is negative. Defaults to `-1`.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsReceiverIndex, adcIndex, ahrsIndex, hnsIndex, dmeIndex, powerSource) {
        super(index, bus, `fms_pos_state_${index}`);
        this.initializationTime = 0;
        this.gnssDataSourceTopicMap = {
            [`fms_pos_gps-position_${this.index}`]: 'gps-position',
            [`fms_pos_ground_speed_${this.index}`]: 'ground_speed',
            [`fms_pos_track_deg_true_${this.index}`]: 'track_deg_true',
            [`fms_pos_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.modeTopic = `fms_pos_mode_${this.index}`;
        this.gpsIndexTopic = `fms_pos_gps_index_${this.index}`;
        this.hnsIndexTopic = `fms_pos_hns_index_${this.index}`;
        this.iruAnpTopic = `fms_pos_iru_anp_${this.index}`;
        this.gpsAnpTopic = `fms_pos_gps_anp_${this.index}`;
        this.radioAnpTopic = `fms_pos_radio_anp_${this.index}`;
        this.anpTopic = `fms_pos_anp_${this.index}`;
        this.verticalAnpTopic = `fms_pos_vertical_anp_${this.index}`;
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), 0);
        this.gpsStateSource = ConsumerSubject.create(null, GPSSystemState.Searching);
        this.gpsState = Subject.create(GPSSystemState.Searching);
        this.gpsPdop = ConsumerSubject.create(null, -1);
        this.gpsGroundSpeed = ConsumerSubject.create(null, -1);
        this.adcSystemState = ConsumerSubject.create(null, null);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.pitch = 0;
        /** filtered pitch rate in degrees per second */
        this.pitchRate = Subject.create(0);
        this.verticalAnp = MappedSubject.create(([zp, pitchRate]) => MathUtils.round(MathUtils.clamp(2.6 * zp ** 3 * Math.pow(10, -12) + 49, 49, 169) + 6 * Math.abs(pitchRate)), this.pressureAlt, this.pitchRate);
        this.mode = FmsPositionMode.None;
        this.lastFixTime = undefined;
        this.gpsIndex = SubscribableUtils.toSubscribable(gpsReceiverIndex, true);
        this.hnsIndex = SubscribableUtils.toSubscribable(-1, true);
        this.dmeIndex = SubscribableUtils.toSubscribable(-1, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        this.ahrsIndex = SubscribableUtils.toSubscribable(ahrsIndex, true);
        this.publisher.pub(this.modeTopic, this.mode, false, true);
        this.publisher.pub(this.iruAnpTopic, -1, false, true);
        this.publisher.pub(this.gpsAnpTopic, -1, false, true);
        this.publisher.pub(this.radioAnpTopic, -1, false, true);
        this.publisher.pub(this.anpTopic, -1, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.gnssDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onGnssTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.gnssDataSourceTopicMap) {
                this.onGnssTopicSubscribed(topic);
            }
        });
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.gpsIndex.sub(index => this.publisher.pub(this.gpsIndexTopic, index, false, true), !paused, paused));
        this.dataSubs.push(this.hnsIndex.sub(index => this.publisher.pub(this.hnsIndexTopic, index, false, true), !paused, paused));
        const gpsStatePipe = this.gpsStateSource.pipe(this.gpsState, true);
        this.gpsIndex.sub(index => {
            if (index < 0) {
                this.gpsStateSource.setConsumer(null);
                gpsStatePipe.pause();
                this.gpsState.set(GPSSystemState.Searching);
            }
            else {
                this.gpsStateSource.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_state_changed_${index}`));
                gpsStatePipe.resume(true);
            }
        }, true);
        this.dataSubs.push(this.gpsPdop.sub(this.updateAnp.bind(this), !paused, paused));
        this.verticalAnpSub = this.verticalAnp.sub((verAnp) => this.publisher.pub(this.verticalAnpTopic, verAnp, false, true));
        this.dataSubs.push(this.dataSourceSubscriber.on('actual_pitch_deg').atFrequency(5).handle((pitch) => {
            this.pitchRate.set(0.8 * this.pitchRate.get() + 0.2 * 5 * (pitch - this.pitch));
            this.pitch = pitch;
        }));
        this.adcSystemState.sub(this.updateAdcSystemState.bind(this));
        this.dataSubs.push(this.gpsIndex.sub((index) => this.gpsPdop.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_pdop_${index}`)), !paused, paused));
        this.gpsGroundSpeed.setConsumer(this.dataSourceSubscriber.on('ground_speed').withPrecision(0));
        this.dataSubs.push(this.adcIndex.sub((index) => this.pressureAlt.setConsumer(this.dataSourceSubscriber.on(`adc_pressure_alt_${index}`).withPrecision(-2)), !paused, paused));
        this.dataSubs.push(this.adcIndex.sub((index) => this.adcSystemState.setConsumer(this.dataSourceSubscriber.on(`adc_state_${index}`)), !paused, paused));
    }
    /**
     * Responds to when someone first subscribes to one of this system's GNSS-sourced data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onGnssTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.gnssDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.setMode(FmsPositionMode.None);
            this.lastFixTime = undefined;
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.updateMode();
        }
    }
    /**
     * Updates this system's data mode.
     */
    updateMode() {
        const gpsState = this.gpsState.get();
        if (gpsState === GPSSystemState.SolutionAcquired || gpsState === GPSSystemState.DiffSolutionAcquired) {
            this.setMode(FmsPositionMode.Gps);
            this.lastFixTime = this.simTime.get();
        }
        else if (this.lastFixTime !== undefined) {
            if (this.simTime.get() - this.lastFixTime > FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME) {
                this.setMode(FmsPositionMode.DeadReckoningExpired);
            }
            else {
                this.setMode(FmsPositionMode.DeadReckoning);
            }
        }
        else {
            this.setMode(FmsPositionMode.None);
        }
    }
    /**
     * Sets this system's data mode, and publishes the new value to the event bus if it differs from the current value.
     * @param mode The new data mode.
     */
    setMode(mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this.publisher.pub(this.modeTopic, this.mode, false, true);
    }
    /** Update the ANP from data sources */
    updateAnp() {
        // The Boeing ANP includes navigation system error (aka position uncertainty),
        // but excludes Flight Technical Error (this is shown on the EFIS as a function of ANP and RNP),
        // and excludes path computation error as this is assumed negligable
        // https://www.boeing.com/commercial/aeromagazine/aero_16/navigation_story.html
        const pdop = this.gpsPdop.get();
        if (pdop >= 0) {
            const anp = FmsPositionSystem.ANP(pdop);
            this.publisher.pub(this.gpsAnpTopic, anp, false, true);
            this.publisher.pub(this.anpTopic, anp, false, true);
        }
        else {
            this.publisher.pub(this.gpsAnpTopic, pdop, false, true);
            this.publisher.pub(this.anpTopic, pdop, false, true);
        }
        // TODO IRU and radio position
    }
    /**
     * Updates the ADC derived values when the ADC system state changes
     * @param state ADC system state event
     */
    updateAdcSystemState(state) {
        var _a, _b;
        if ((state === null || state === void 0 ? void 0 : state.current) === AvionicsSystemState.On) {
            (_a = this.verticalAnpSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        }
        else {
            (_b = this.verticalAnpSub) === null || _b === void 0 ? void 0 : _b.pause();
            this.publisher.pub(this.verticalAnpTopic, -1, false, true);
        }
    }
}
FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME = UnitType.MINUTE.convertTo(20, UnitType.MILLISECOND);
/** Calculates the ANP as the circle radius where the airplane position is estimated to be within 95% of the time.
 * Uses the statistic formula of estimating a 95% confidence interval with a (hypothetical) sample size of 1.
 * @param pdop The geometric dilution of precision computation (GDOP).
 * @returns The estimated ANP.
 */
FmsPositionSystem.ANP = (pdop) => {
    /** In meters. Used for calculating the ANP. Sets at 222 under the assumption that airplane cruises at 800 km/h,
     * hence if gps position is updated every second, the deviation would be 222 m/s.
     * Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR = 222;
    /** In meters. Used for calculating the ANP. Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const ESTIMATED_NUMERICAL_ERROR = 200;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL = 1.96;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const HYPOTHETICAL_SAMPLE_SIZE = 1;
    const STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS = () => {
        return Math.sqrt((pdop * STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR) ^ 2 + ESTIMATED_NUMERICAL_ERROR ^ 2);
    };
    const anpMeter = Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL * STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS() / Math.sqrt(HYPOTHETICAL_SAMPLE_SIZE);
    return MathUtils.round(UnitType.NMILE.convertFrom(anpMeter, UnitType.METER), 0.01);
};

/**
 * Automatically selects the best GPS receiver from a set of candidates based on the current states of all receivers.
 * Receivers that have computed a 3D position solution with differential corrections are favored over those that have
 * computed a 3D solution without corrections, and either of these are favored over those that have not computed any
 * position solution.
 */
class GpsReceiverSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param enabledReceiverIndexes The indexes of the GPS receivers from which to select.
     * @param preferredReceiverIndex The index of this selector's preferred GPS receiver, or `-1` if there is no such
     * receiver. This selector is guaranteed to select the preferred GPS receiver if its state is at least as desirable
     * as the state of all other receivers from which to select. Defaults to `-1`.
     */
    constructor(bus, enabledReceiverIndexes, preferredReceiverIndex) {
        this.bus = bus;
        this._selectedIndex = Subject.create(-1);
        this.selectedIndex = this._selectedIndex;
        this.gpsStates = new Map();
        this.isAlive = true;
        this.isInit = false;
        this.enabledReceiverIndexes = 'isSubscribableSet' in enabledReceiverIndexes ? enabledReceiverIndexes : SetSubject.create(enabledReceiverIndexes);
        this.preferredReceiverIndex = SubscribableUtils.toSubscribable(preferredReceiverIndex !== null && preferredReceiverIndex !== void 0 ? preferredReceiverIndex : -1, true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best GPS receiver among
     * its candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('GpsReceiverSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const selectIndex = this.selectIndex.bind(this);
        this.enabledReceiverIndexesSub = this.enabledReceiverIndexes.sub((set, type, key) => {
            var _a;
            (_a = this.gpsStates.get(key)) === null || _a === void 0 ? void 0 : _a.destroy();
            if (type === SubscribableSetEventType.Added) {
                const gpsState = ConsumerSubject.create(sub.on(`gps_rec_gps_system_state_changed_${key}`), GPSSystemState.Acquiring);
                this.gpsStates.set(key, gpsState);
                gpsState.sub(selectIndex);
            }
            else {
                this.gpsStates.delete(key);
            }
            selectIndex();
        }, true);
        this.preferredReceiverIndexSub = this.preferredReceiverIndex.sub(selectIndex);
    }
    /**
     * Selects the index of the GPS receiver with the most desirable state.
     */
    selectIndex() {
        var _a, _b;
        if (this.gpsStates.size === 0) {
            this._selectedIndex.set(-1);
            return;
        }
        if (this.gpsStates.size === 1) {
            this._selectedIndex.set(this.gpsStates.keys().next().value);
            return;
        }
        let bestIndex = this._selectedIndex.get();
        let bestState = (_a = this.gpsStates.get(bestIndex)) === null || _a === void 0 ? void 0 : _a.get();
        for (const index of this.gpsStates.keys()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const state = this.gpsStates.get(index).get();
            if (bestIndex < 0 || !bestState || GpsReceiverSelector.compareGpsState(state, bestState) < 0) {
                bestIndex = index;
                bestState = state;
            }
        }
        const preferredIndex = this.preferredReceiverIndex.get();
        if (preferredIndex >= 0) {
            const preferredIndexState = (_b = this.gpsStates.get(preferredIndex)) === null || _b === void 0 ? void 0 : _b.get();
            if (preferredIndexState !== undefined && GpsReceiverSelector.compareGpsState(preferredIndexState, bestState) <= 0) {
                bestIndex = preferredIndex;
            }
        }
        this._selectedIndex.set(bestIndex);
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        for (const state of this.gpsStates.values()) {
            state.destroy();
        }
        (_a = this.enabledReceiverIndexesSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.preferredReceiverIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
    /**
     * Compares two GPS system states and returns a number whose sign indicates which one is more desirable.
     * @param a The first GPS system state to compare.
     * @param b The second GPS system state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareGpsState(a, b) {
        return GpsReceiverSelector.GPS_STATE_PRIORITIES[a] - GpsReceiverSelector.GPS_STATE_PRIORITIES[b];
    }
}
GpsReceiverSelector.GPS_STATE_PRIORITIES = {
    [GPSSystemState.DiffSolutionAcquired]: 0,
    [GPSSystemState.SolutionAcquired]: 1,
    [GPSSystemState.Acquiring]: 2,
    [GPSSystemState.Searching]: 2
};

/**
 * A Garmin GPS receiver system.
 */
class GpsReceiverSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a GPS receiver system.
     * @param index The index of the GPS receiver.
     * @param bus An instance of the event bus.
     * @param gpsSatComputer This system's GPS computer system.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsSatComputer, powerSource) {
        super(index, bus, `gps_rec_state_${index}`);
        this.gpsSatComputer = gpsSatComputer;
        this.initializationTime = 0;
        this.cachedDataSourceTopicMap = {
            [`gps_rec_gps_system_state_changed_${this.index}`]: `gps_system_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_sbas_state_changed_${this.index}`]: `gps_system_sbas_state_changed_${this.gpsSatComputer.index}`
        };
        this.uncachedDataSourceTopicMap = {
            [`gps_rec_gps_sat_state_changed_${this.index}`]: `gps_sat_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_sat_pos_calculated_${this.index}`]: `gps_sat_pos_calculated_${this.gpsSatComputer.index}`
        };
        this.dopDataSourceTopicMap = {
            [`gps_rec_gps_system_pdop_${this.index}`]: `gps_system_pdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_hdop_${this.index}`]: `gps_system_hdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_vdop_${this.index}`]: `gps_system_vdop_${this.gpsSatComputer.index}`
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.dopSources = [];
        this.sbasState = ConsumerSubject.create(null, GPSSystemSBASState.Disabled);
        gpsSatComputer.init();
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        else if (gpsSatComputer.syncRole !== 'replica') {
            // If our power source is undefined, then the system is always considered to be in the on state. Therefore we
            // will force the GPS to immediately acquire and use all the satellites it can since a system that is always on
            // never needs to initialize.
            gpsSatComputer.acquireAndUseSatellites();
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.cachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.cachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, true);
            }));
        }
        for (const topic of Object.keys(this.uncachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.uncachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, false);
            }));
        }
        // Garmin seems to halve DOP values when SBAS is active. It could be a trainer-specific behavior, but in the
        // absence of any other information, we will implement it here.
        this.sbasState.setConsumer(this.dataSourceSubscriber.on(`gps_system_sbas_state_changed_${this.gpsSatComputer.index}`));
        for (const topic of Object.keys(this.dopDataSourceTopicMap)) {
            const dopSource = ConsumerSubject.create(this.dataSourceSubscriber.on(this.dopDataSourceTopicMap[topic]), -1);
            this.dopSources.push(dopSource);
            const processedDop = MappedSubject.create(([dop, sbasState]) => dop <= 0 ? dop : dop * (sbasState === GPSSystemSBASState.Active ? 0.5 : 1), dopSource, this.sbasState);
            this.dataSubs.push(processedDop.sub(dop => {
                this.publisher.pub(topic, dop, false, false);
            }, true));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        // If this is the first time we are setting our state and the state is on, then we assume that the system was on at
        // flight load, in which case we will force the GPS to immediately acquire and use all the satellites it can so
        // that we don't force people to wait for satellite acquisition when loading onto the runway/in the air.
        if (previousState === undefined && currentState === AvionicsSystemState.On && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.acquireAndUseSatellites();
        }
        // Reset the GPS sat computer if the system is not operating and its receiver is not a replica (a replica receiver
        // will get the reset command from its primary).
        if ((currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.reset();
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.gpsSatComputer.onUpdate();
        }
    }
}

/**
 * IRS operating modes.
 */
var IrsSystemOperatingMode;
(function (IrsSystemOperatingMode) {
    /** The IRS is not operating. */
    IrsSystemOperatingMode["Off"] = "Off";
    /** The IRS is in Standby mode. No data are available. */
    IrsSystemOperatingMode["Standby"] = "Standby";
    /** The IRS is performing a full alignment. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlign"] = "FullAlign";
    /** The IRS has completed a full alignment but is awaiting a position input. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlignPositionPending"] = "FullAlignPositionPending";
    /** The IRS is in Navigation mode. All data are available. */
    IrsSystemOperatingMode["Navigation"] = "Navigation";
    /** The IRS is performing a realignment. All data are available. */
    IrsSystemOperatingMode["Realign"] = "Realign";
    /** The IRS is performing an attitude alignment. No data are available. */
    IrsSystemOperatingMode["AttitudeAlign"] = "AttitudeAlign";
    /** The IRS is in Attitude mode. Attitude and heading data are available. */
    IrsSystemOperatingMode["Attitude"] = "Attitude";
})(IrsSystemOperatingMode || (IrsSystemOperatingMode = {}));
/**
 * IRS system operating mode setting commands.
 */
var IrsSystemOperatingModeSetting;
(function (IrsSystemOperatingModeSetting) {
    /** Forces the IRS into Off mode. */
    IrsSystemOperatingModeSetting["Off"] = "Off";
    /** Commands Navigation mode. The IRS will perform a full alignment (if required), then enter Navigation mode. */
    IrsSystemOperatingModeSetting["Navigation"] = "Navigation";
    /**
     * Arms IRS realignment. If the IRS is in Navigation mode, then the next time Navigation mode is selected and the
     * airplane is on the ground and not moving, it will attempt an realignment.
     */
    IrsSystemOperatingModeSetting["Align"] = "Align";
    /** Commands Attitude mode. The IRS will perform an attitude alignment (if required), then enter Attitude mode. */
    IrsSystemOperatingModeSetting["Attitude"] = "Attitude";
})(IrsSystemOperatingModeSetting || (IrsSystemOperatingModeSetting = {}));
/**
 * A Boeing inertial reference system (IRS). Provides attitude, heading, and inertial (position, velocity,
 * acceleration) data.
 */
class IrsSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an IRS system.
     * @param index The index of the IRS.
     * @param bus An instance of the event bus.
     * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this IRS derives its data.
     * @param directionIndicatorIndex The index of the sim direction indicator from which this IRS derives its data.
     * @param supportInFlightAlign Whether this IRS supports full alignment while in flight. In-flight full alignment
     * requires position input from GPS receivers.
     * @param operatingModeSetting The operating mode setting commanded for this IRS.
     * @param fullAlignDuration The duration, in milliseconds, required for this IRS to complete a full alignment.
     * @param gpsReceiverIndexes The indexes of the GPS receiver systems from which the IRS receives position input data.
     * If no indexes are supplied, then the IRS will not automatically initialize its position from GPS and will require
     * manual position input during alignment.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, attitudeIndicatorIndex, directionIndicatorIndex, supportInFlightAlign, operatingModeSetting, fullAlignDuration, gpsReceiverIndexes, powerSource) {
        var _a;
        super(index, bus, `irs_state_${index}`);
        this.attitudeIndicatorIndex = attitudeIndicatorIndex;
        this.directionIndicatorIndex = directionIndicatorIndex;
        this.supportInFlightAlign = supportInFlightAlign;
        this.operatingModeSetting = operatingModeSetting;
        this.powerSource = powerSource;
        this.initializationTime = 0;
        this.operatingModeTopic = `irs_operating_mode_${this.index}`;
        this.headingDataValidTopic = `irs_heading_data_valid_${this.index}`;
        this.attitudeDataValidTopic = `irs_attitude_data_valid_${this.index}`;
        this.inertialDataValidTopic = `irs_inertial_data_valid_${this.index}`;
        this.positionDataValidTopic = `irs_position_data_valid_${this.index}`;
        this.acceptingPositionTopic = `irs_is_accepting_position_${this.index}`;
        this.requestingPositionTopic = `irs_is_requesting_position_${this.index}`;
        this.operatingMode = IrsSystemOperatingMode.Navigation;
        this.isHeadingDataValid = true;
        this.isAttitudeDataValid = true;
        this.isInertialDataValid = true;
        this.isInertialHeadingDataValid = true;
        this.isPositionDataValid = true;
        this.isPositionInit = Subject.create(true);
        this.isAcceptingPosition = Subject.create(false);
        this.isRealignArmed = false;
        this.attitudeAlignTime = 0;
        this.fullAlignTime = 0;
        this.realignTime = 0;
        this.lastUpdateSimTime = undefined;
        this.simTime = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.speed = ConsumerValue.create(null, 0);
        this.headingDataSourceTopicMap = {
            [`irs_hdg_deg_${this.index}`]: `hdg_deg_${this.directionIndicatorIndex}`,
            [`irs_hdg_deg_true_${this.index}`]: `hdg_deg_true_${this.directionIndicatorIndex}`
        };
        this.attitudeDataSourceTopicMap = {
            [`irs_delta_heading_rate_${this.index}`]: `delta_heading_rate_${this.attitudeIndicatorIndex}`,
            [`irs_pitch_deg_${this.index}`]: `pitch_deg_${this.attitudeIndicatorIndex}`,
            [`irs_roll_deg_${this.index}`]: `roll_deg_${this.attitudeIndicatorIndex}`,
            [`irs_turn_coordinator_ball_${this.index}`]: 'turn_coordinator_ball'
        };
        this.inertialDataSourceTopicMap = {
            [`irs_inertial_speed_${this.index}`]: 'inertial_speed',
            [`irs_inertial_vertical_speed_${this.index}`]: 'inertial_vertical_speed',
            [`irs_inertial_acceleration_${this.index}`]: 'inertial_acceleration',
            [`irs_inertial_track_acceleration_${this.index}`]: 'inertial_track_acceleration',
            [`irs_ground_speed_${this.index}`]: 'ground_speed'
        };
        this.inertialHeadingDataSourceTopicMap = {
            [`irs_track_deg_true_${this.index}`]: 'track_deg_true',
            [`irs_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.positionDataSourceTopicMap = {
            [`irs_gps-position_${this.index}`]: 'gps-position',
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.headingDataSubs = [];
        this.attitudeDataSubs = [];
        this.inertialDataSubs = [];
        this.inertialHeadingDataSubs = [];
        this.positionDataSubs = [];
        this.fullAlignDuration = SubscribableUtils.toSubscribable(fullAlignDuration, true);
        if (this.powerSource !== undefined) {
            this.connectToPower(this.powerSource);
        }
        // Initialize some cached topics.
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid);
        this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid);
        this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid);
        this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid);
        // Set up automatic position initialization from GPS.
        const gpsReceiverIndexArray = Array.from(new Set(gpsReceiverIndexes)); // Ensure no duplicates
        if (gpsReceiverIndexArray.length > 0) {
            const gpsSub = bus.getSubscriber();
            this.isGpsAvailable = MappedSubject.create(states => states.includes(GPSSystemState.SolutionAcquired) || states.includes(GPSSystemState.DiffSolutionAcquired), ...gpsReceiverIndexArray.map(gpsReceiverIndex => ConsumerSubject.create(gpsSub.on(`gps_rec_gps_system_state_changed_${gpsReceiverIndex}`), GPSSystemState.Searching)));
            this.gpsPositionSub = this.isGpsAvailable.sub(isAvail => {
                if (isAvail) {
                    this.isPositionInit.set(true);
                }
            }, false, true);
        }
        const sub = bus.getSubscriber();
        this.simTime.setConsumer(sub.on('simTime'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.speed.setConsumer(sub.on('inertial_speed'));
        this.setPositionSub = sub.on(`irs_set_position_${index}`).handle(() => {
            this.isPositionInit.set(true);
        }, true);
        this.isAcceptingPosition.sub(val => {
            var _a, _b;
            if (val) {
                this.setPositionSub.resume();
                (_a = this.gpsPositionSub) === null || _a === void 0 ? void 0 : _a.resume(true);
            }
            else {
                this.setPositionSub.pause();
                (_b = this.gpsPositionSub) === null || _b === void 0 ? void 0 : _b.pause();
            }
            this.publisher.pub(this.acceptingPositionTopic, val);
        }, true);
        // Request manual position input when the system is accepting position inputs, has not received a position input
        // yet, and GPS position is not available.
        this.isRequestingPosition = MappedSubject.create(([isAccepting, isInit, isGpsAvail]) => isAccepting && !isInit && !isGpsAvail, this.isAcceptingPosition, this.isPositionInit, (_a = this.isGpsAvailable) !== null && _a !== void 0 ? _a : Subject.create(false));
        this.isRequestingPosition.sub(val => { this.publisher.pub(this.requestingPositionTopic, val); }, true);
        this.startDataPublish();
    }
    /**
     * Starts publishing IRS data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.headingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.attitudeDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onAttitudeTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialHeadingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.positionDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onPositionTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.headingDataSourceTopicMap) {
                this.onHeadingTopicSubscribed(topic);
            }
            else if (topic in this.attitudeDataSourceTopicMap) {
                this.onAttitudeTopicSubscribed(topic);
            }
            else if (topic in this.inertialDataSourceTopicMap) {
                this.onInertialTopicSubscribed(topic);
            }
            else if (topic in this.inertialHeadingDataSourceTopicMap) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
            else if (topic in this.positionDataSourceTopicMap) {
                this.onPositionTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onHeadingTopicSubscribed(topic) {
        this.headingDataSubs.push(this.dataSourceSubscriber.on(this.headingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's attitude data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onAttitudeTopicSubscribed(topic) {
        this.attitudeDataSubs.push(this.dataSourceSubscriber.on(this.attitudeDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isAttitudeDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialTopicSubscribed(topic) {
        this.inertialDataSubs.push(this.dataSourceSubscriber.on(this.inertialDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial/heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialHeadingTopicSubscribed(topic) {
        this.inertialHeadingDataSubs.push(this.dataSourceSubscriber.on(this.inertialHeadingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid || !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onPositionTopicSubscribed(topic) {
        this.positionDataSubs.push(this.dataSourceSubscriber.on(this.positionDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isPositionDataValid));
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        this.isPowered = isPowered;
        this.setState(isPowered ? AvionicsSystemState.On : AvionicsSystemState.Off);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Off) {
            this.setOperatingMode(IrsSystemOperatingMode.Off);
        }
    }
    /**
     * Sets this system's operating mode.
     * @param mode The operating mode to set.
     */
    setOperatingMode(mode) {
        if (this.operatingMode === mode) {
            return;
        }
        this.operatingMode = mode;
        let resetRealignTime = true;
        let disarmRealign = true;
        switch (mode) {
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                this.fullAlignTime = 0;
                this.attitudeAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                break;
            case IrsSystemOperatingMode.FullAlign:
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.isAcceptingPosition.set(true);
                break;
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.AttitudeAlign:
                this.fullAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                break;
            case IrsSystemOperatingMode.Realign:
                this.isAcceptingPosition.set(true);
                resetRealignTime = false;
                break;
            case IrsSystemOperatingMode.Navigation:
                disarmRealign = false;
                break;
        }
        if (resetRealignTime) {
            this.realignTime = 0;
        }
        if (disarmRealign) {
            this.isRealignArmed = false;
        }
        this.isRealignArmed = false;
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.updateHeadingDataState();
        this.updateAttitudeDataState();
        this.updateInertialDataState();
        this.updateInertialHeadingDataState();
        this.updatePositionDataState();
    }
    /**
     * Updates the validity state of this system's heading data. If heading data is valid, this system will start
     * publishing heading data. If heading data is invalid, this system will stop publishing heading data.
     */
    updateHeadingDataState() {
        // TODO: Heading data requires manual heading input in Attitude mode if the IRS does not have an AHRU component.
        const isHeadingDataValid = this.operatingMode === IrsSystemOperatingMode.Attitude
            || this.operatingMode === IrsSystemOperatingMode.Navigation
            || this.operatingMode === IrsSystemOperatingMode.Realign
            || this.attitudeAlignTime >= Math.min(this.fullAlignDuration.get(), IrsSystem.ATTITUDE_ALIGN_DURATION);
        if (isHeadingDataValid !== this.isHeadingDataValid) {
            this.isHeadingDataValid = isHeadingDataValid;
            if (isHeadingDataValid) {
                for (const sub of this.headingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.headingDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(`irs_heading_data_valid_${this.index}`, this.isHeadingDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's attitude data. If attitude data is valid, this system will start
     * publishing attitude data. If attitude data is invalid, this system will stop publishing attitude data.
     */
    updateAttitudeDataState() {
        const isAttitudeDataValid = this.operatingMode === IrsSystemOperatingMode.Attitude
            || this.operatingMode === IrsSystemOperatingMode.Navigation
            || this.operatingMode === IrsSystemOperatingMode.Realign
            || this.attitudeAlignTime >= Math.min(this.fullAlignDuration.get(), IrsSystem.ATTITUDE_ALIGN_DURATION);
        if (isAttitudeDataValid !== this.isAttitudeDataValid) {
            this.isAttitudeDataValid = isAttitudeDataValid;
            if (isAttitudeDataValid) {
                for (const sub of this.attitudeDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.attitudeDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(`irs_attitude_data_valid_${this.index}`, this.isAttitudeDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial data. If inertial data is valid, this system will start
     * publishing inertial data. If inertial data is invalid, this system will stop publishing inertial data.
     */
    updateInertialDataState() {
        const isInertialDataValid = this.operatingMode === IrsSystemOperatingMode.Navigation
            || this.operatingMode === IrsSystemOperatingMode.Realign;
        if (isInertialDataValid !== this.isInertialDataValid) {
            this.isInertialDataValid = isInertialDataValid;
            if (isInertialDataValid) {
                for (const sub of this.inertialDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(`irs_inertial_data_valid_${this.index}`, this.isInertialDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial/heading data. If inertial/heading data is valid, this system
     * will start publishing inertial/heading data. If inertial/heading data is invalid, this system will stop publishing
     * inertial/heading data.
     */
    updateInertialHeadingDataState() {
        const isInertialHeadingDataValid = this.isHeadingDataValid && this.isInertialDataValid;
        if (isInertialHeadingDataValid !== this.isInertialHeadingDataValid) {
            this.isInertialHeadingDataValid = isInertialHeadingDataValid;
            if (isInertialHeadingDataValid) {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.pause();
                }
            }
        }
    }
    /**
     * Updates the validity state of this system's position data. If position data is valid, this system will start
     * publishing position data. If position data is invalid, this system will stop publishing position data.
     */
    updatePositionDataState() {
        const isPositionDataValid = this.isInertialDataValid;
        if (isPositionDataValid !== this.isPositionDataValid) {
            this.isPositionDataValid = isPositionDataValid;
            if (isPositionDataValid) {
                for (const sub of this.positionDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.positionDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(`irs_position_data_valid_${this.index}`, this.isPositionDataValid, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.state === AvionicsSystemState.Off) {
            return;
        }
        const simTime = this.simTime.get();
        const dt = this.lastUpdateSimTime === undefined ? 0 : Math.max(0, simTime - this.lastUpdateSimTime);
        this.lastUpdateSimTime = simTime;
        const modeSetting = this.operatingModeSetting.get();
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Off:
                this.updateOff(modeSetting);
                break;
            case IrsSystemOperatingMode.Standby:
                this.updateStandby(modeSetting);
                break;
            case IrsSystemOperatingMode.FullAlign:
                this.updateFullAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.updateFullAlignPositionPending(modeSetting);
                break;
            case IrsSystemOperatingMode.Navigation:
                this.updateNavigation(modeSetting);
                break;
            case IrsSystemOperatingMode.Realign:
                this.updateRealign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.AttitudeAlign:
                this.updateAttitudeAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.updateAttitude(modeSetting);
                break;
        }
    }
    /**
     * Attempts to start a new full or attitude alignment cycle.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @returns Whether a new alignment cycle was started.
     */
    tryStartFreshAlign(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isOnGround.get()) {
                    if (this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                        return true;
                    }
                }
                else if (this.supportInFlightAlign && this.isGpsAvailable && this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
                    this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                    return true;
                }
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                return true;
        }
        return false;
    }
    /**
     * Updates this system while it is in the Off operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateOff(modeSetting) {
        if (this.tryStartFreshAlign(modeSetting)) {
            return;
        }
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                break;
            default:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
        }
    }
    /**
     * Updates this system while it is in the Standby operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateStandby(modeSetting) {
        this.tryStartFreshAlign(modeSetting);
    }
    /**
     * Updates this system while it is in the FullAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateFullAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                if (this.attitudeAlignTime >= IrsSystem.ATTITUDE_ALIGN_DURATION) {
                    this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                }
                else {
                    this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                }
                return;
        }
        if (this.isOnGround.get()) {
            if (this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
                this.fullAlignTime = 0;
            }
        }
        else if (!this.supportInFlightAlign || !this.isGpsAvailable || !this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
            this.setOperatingMode(IrsSystemOperatingMode.Standby);
            return;
        }
        this.attitudeAlignTime += dt;
        this.fullAlignTime += dt;
        if (this.attitudeAlignTime >= Math.min(this.fullAlignDuration.get(), IrsSystem.ATTITUDE_ALIGN_DURATION)
            && (!this.isAttitudeDataValid || !this.isHeadingDataValid)) {
            this.updateAttitudeDataState();
            this.updateHeadingDataState();
        }
        // TODO: more realistic full align time.
        if (this.fullAlignTime >= 60000) {
            if (this.isPositionInit) {
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            }
            else {
                this.setOperatingMode(IrsSystemOperatingMode.FullAlignPositionPending);
            }
        }
    }
    /**
     * Updates this system while it is in the FullAlignPositionPending operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateFullAlignPositionPending(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        if (this.isPositionInit) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the Navigation operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateNavigation(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.isAcceptingPosition.set(true);
                this.isRealignArmed = true;
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isRealignArmed) {
                    // Realignment requires the airplane be on the ground and not moving.
                    if (this.isOnGround.get() && this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.Realign);
                        return;
                    }
                    else {
                        this.isRealignArmed = false;
                    }
                }
                this.isAcceptingPosition.set(false);
                break;
        }
    }
    /**
     * Updates this system while it is in the Realign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateRealign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        // Realignment requires the airplane be on the ground and not moving.
        if (!this.isOnGround.get() || this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            return;
        }
        this.realignTime += dt;
        if (this.realignTime >= Math.min(this.fullAlignDuration.get(), IrsSystem.REALIGN_DURATION)) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the AttitudeAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateAttitudeAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                return;
        }
        this.attitudeAlignTime += dt;
        if (this.attitudeAlignTime >= Math.min(this.fullAlignDuration.get(), IrsSystem.ATTITUDE_ALIGN_DURATION)) {
            this.setOperatingMode(IrsSystemOperatingMode.Attitude);
        }
    }
    /**
     * Updates this system while it is in the Attitude operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateAttitude(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                break;
        }
    }
}
IrsSystem.ATTITUDE_ALIGN_DURATION = 30000; // milliseconds
IrsSystem.REALIGN_DURATION = 30000; // milliseconds
IrsSystem.ALIGN_SPEED_THRESHOLD = 1; // meters per second

/**
 * Automatically selects the best IRS from a set of candidates based on the current states of all systems. System state
 * desiribility is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class IrsSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the IRS systems from which to select.
     * @param preferredSystemIndex The index of this selector's preferred system, or `-1` if there is no such system.
     * This selector is guaranteed to select the preferred system if its state is at least as desirable as the state of
     * all other systems from which to select. Defaults to `-1`.
     */
    constructor(index, bus, candidateSystemIndexes, preferredSystemIndex) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isAttitudeDataValid = Subject.create(false);
        this.isHeadingDataValid = Subject.create(false);
        this.isInertialDataValid = Subject.create(false);
        this.isInertialHeadingDataValid = Subject.create(false);
        this.isPositionDataValid = Subject.create(false);
        this.irsEntries = new Map();
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        this.preferredSystemIndex = SubscribableUtils.toSubscribable(preferredSystemIndex !== null && preferredSystemIndex !== void 0 ? preferredSystemIndex : -1, true);
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `irs_selector_selected_index_${index}`), true);
        this.isAttitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_attitude_data_valid_${index}`), true);
        this.isHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_heading_data_valid_${index}`), true);
        this.isInertialDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_data_valid_${index}`), true);
        this.isInertialHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_heading_data_valid_${index}`), true);
        this.isPositionDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_position_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.irsEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`irs_attitude_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_heading_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_inertial_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_position_data_valid_${key}`), false)
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.irsEntries.set(key, entry);
                // When there is a change in an IRS state, we don't reselect immediately because the IRS could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.irsEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.preferredSystemIndexSub = this.preferredSystemIndex.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the IRS with the most desirable state.
     */
    selectIndex() {
        var _a, _b;
        let bestIndex;
        let bestState;
        if (this.irsEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.irsEntries.size === 1) {
            const entry = this.irsEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            bestIndex = this.selectedIndex.get();
            bestState = (_a = this.irsEntries.get(bestIndex)) === null || _a === void 0 ? void 0 : _a.state.get();
            for (const index of this.irsEntries.keys()) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const state = this.irsEntries.get(index).state.get();
                if (bestIndex < 0 || !bestState || IrsSystemSelector.compareIrsState(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
            const preferredIndex = this.preferredSystemIndex.get();
            if (preferredIndex >= 0) {
                const preferredIndexState = (_b = this.irsEntries.get(preferredIndex)) === null || _b === void 0 ? void 0 : _b.state.get();
                if (preferredIndexState !== undefined && IrsSystemSelector.compareIrsState(preferredIndexState, bestState) <= 0) {
                    bestIndex = preferredIndex;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isAttitudeDataValid.set(bestState[0]);
            this.isHeadingDataValid.set(bestState[1]);
            this.isInertialDataValid.set(bestState[2]);
            this.isInertialHeadingDataValid.set(bestState[1] && bestState[2]);
            this.isPositionDataValid.set(bestState[3]);
        }
        else {
            this.isAttitudeDataValid.set(false);
            this.isHeadingDataValid.set(false);
            this.isInertialDataValid.set(false);
            this.isInertialHeadingDataValid.set(false);
            this.isPositionDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.irsEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.preferredSystemIndexSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
    /**
     * Compares two IRS states and returns a number whose sign indicates which one is more desirable.
     * @param a The first IRS state to compare.
     * @param b The second IRS state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareIrsState(a, b) {
        // The data validity flags within the state array are ordered such that a false flag cannot precede a true flag,
        // so we can exploit this fact.
        return b.lastIndexOf(true) - a.lastIndexOf(true);
    }
}

/**
 * The GMU44 magnetometer system.
 */
class MagnetometerSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the MagnetometerSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `magnetometer_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.initializationTime = 5000;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
}

/**
 * The Radio Altimeter system.
 */
class RASystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the RASystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param radioAltOffset The radio altimeter offset.
     * @param powerSource The power source.
     */
    constructor(index, bus, radioAltOffset, powerSource) {
        super(index, bus, `ra_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.radioAltOffset = radioAltOffset;
        this.powerSource = powerSource;
        this.initializationTime = 7000;
        const radioAltTopic = `ra_radio_alt_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's radar altitude data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `ra_radio_alt_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.radioAltSub = this.bus.getSubscriber().on('radio_alt').atFrequency(3).handle(val => {
            this.publisher.pub(topic, val + this.radioAltOffset);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.radioAltSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.radioAltSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

/**
 * GPWS operating modes.
 */
var GpwsOperatingMode;
(function (GpwsOperatingMode) {
    GpwsOperatingMode["Off"] = "Off";
    GpwsOperatingMode["Standby"] = "Standby";
    GpwsOperatingMode["Normal"] = "Normal";
    GpwsOperatingMode["Test"] = "Test";
    GpwsOperatingMode["Failed"] = "Failed";
})(GpwsOperatingMode || (GpwsOperatingMode = {}));

/**
 * A Boeing GPWS system.
 */
class Gpws {
    /**
     * Creates a new instance of Gpws.
     * @param bus The event bus.
     * @param fmsPosIndex The index of the FMS geo-positioning system from which to source data.
     */
    constructor(bus, fmsPosIndex) {
        this.bus = bus;
        this.modules = [];
        this.operatingMode = Subject.create(GpwsOperatingMode.Off);
        this.simRate = ConsumerValue.create(null, 1);
        this.isOnGround = ConsumerValue.create(null, false);
        this._hasGpsPos = Subject.create(false);
        this.gpsPos = new GeoPoint(0, 0);
        this.radarAltimeterState = ConsumerSubject.create(null, undefined);
        this.radarAltitudeSource = ConsumerValue.create(null, 0);
        // TODO Copied from Garmin, does it need to change for Boeings?
        this.radarAltitudeSmoother = new ExpSmoother(500 / Math.LN2);
        this.fmaData = ConsumerSubject.create(null, undefined);
        this.data = {
            isOnGround: false,
            isGpsPosValid: false,
            gpsPos: this.gpsPos.readonly,
            gpsAltitude: 0,
            isRadarAltitudeValid: false,
            radarAltitude: 0,
            isGsGpActive: false
        };
        this._isPowered = Subject.create(true);
        this.operatingModeState = MappedSubject.create(this._isPowered);
        this.lastUpdateRealTime = undefined;
        this.isAlive = true;
        this.isInit = false;
        this.fmsPosIndex = SubscribableUtils.toSubscribable(fmsPosIndex, true);
        this.operatingModeState.pipe(this.operatingMode, ([isPowered]) => {
            if (isPowered) {
                return GpwsOperatingMode.Normal;
            }
            else {
                return GpwsOperatingMode.Off;
            }
        });
    }
    /**
     * Adds a module to this system.
     * @param module The module to add.
     * @returns This system, after the module has been added.
     */
    addModule(module) {
        this.modules.push(module);
        if (this.isInit) {
            module.onInit();
        }
        return this;
    }
    /**
     * Initializes this system. Once this system is initialized, it will begin collecting data and updating its modules.
     * @throws Error if this system has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('Gpws: cannot initialize a dead system');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.simRate.setConsumer(sub.on('simRate'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.radarAltimeterState.setConsumer(sub.on('ra_state_1'));
        this.radarAltitudeSource.setConsumer(sub.on('ra_radio_alt_1'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        const updateFmsPosMode = (mode) => {
            this._hasGpsPos.set(mode !== FmsPositionMode.None && mode !== FmsPositionMode.DeadReckoning && mode !== FmsPositionMode.DeadReckoningExpired);
            this.data.isGpsPosValid = this._hasGpsPos.get();
        };
        const updateGpsPos = (lla) => {
            this.gpsPos.set(lla.lat, lla.long);
            this.data.gpsAltitude = UnitType.METER.convertTo(lla.alt, UnitType.FOOT);
        };
        this.fmsPosIndexSub = this.fmsPosIndex.sub(index => {
            var _a, _b;
            (_a = this.fmsPosModeSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.gpsAltitudeSub) === null || _b === void 0 ? void 0 : _b.destroy();
            if (index <= 0) {
                this._hasGpsPos.set(false);
                this.data.isGpsPosValid = false;
            }
            else {
                this.fmsPosModeSub = sub.on(`fms_pos_mode_${index}`).handle(updateFmsPosMode);
                this.gpsAltitudeSub = sub.on(`fms_pos_gps-position_${index}`).handle(updateGpsPos);
            }
        }, true);
        this.radarAltimeterState.sub(state => {
            this.data.isRadarAltitudeValid = state !== undefined && (state.current === undefined || state.current === AvionicsSystemState.On);
        }, true);
        this.fmaData.sub(data => {
            const verticalActive = data === null || data === void 0 ? void 0 : data.verticalActive;
            this.data.isGsGpActive = verticalActive === APVerticalModes.GS || verticalActive === APVerticalModes.GP;
        }, true);
        for (let i = 0; i < this.modules.length; i++) {
            this.modules[i].onInit();
        }
        this.updateSub = sub.on('simTime').whenChanged().handle(this.update.bind(this));
    }
    /**
     * Checks if this system is powered.
     * @returns Whether this is system is powered.
     */
    isPowered() {
        return this._isPowered.get();
    }
    /**
     * Sets whether this system is powered.
     * @param isPowered Whether this system is powered.
     */
    setPowered(isPowered) {
        this._isPowered.set(isPowered);
    }
    /**
     * Updates this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    update(simTime) {
        var _a;
        const realTime = Date.now();
        const simRate = this.simRate.get();
        const dt = Math.min(realTime - ((_a = this.lastUpdateRealTime) !== null && _a !== void 0 ? _a : realTime), 1000) * simRate;
        this.data.isOnGround = this.isOnGround.get();
        this.data.radarAltitude = this.radarAltitudeSmoother.next(this.radarAltitudeSource.get(), dt);
        const operatingMode = this.operatingMode.get();
        for (let i = 0; i < this.modules.length; i++) {
            this.modules[i].onUpdate(operatingMode, this.data, realTime, simTime, simRate);
        }
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Destroys this system.
     */
    destroy() {
        var _a, _b, _c, _d;
        this.isAlive = false;
        this.isOnGround.destroy();
        this.radarAltimeterState.destroy();
        this.radarAltitudeSource.destroy();
        this.fmaData.destroy();
        (_a = this.fmsPosIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.fmsPosModeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.gpsAltitudeSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.updateSub) === null || _d === void 0 ? void 0 : _d.destroy();
        for (let i = 0; i < this.modules.length; i++) {
            this.modules[i].onDestroy();
        }
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * A GPWS module which handles touchdown callouts.
 */
class TouchdownCalloutModule {
    /**
     * Creates a new instance of TouchdownCalloutModule.
     * @param bus The event bus.
     * @param altitudeCallouts Which altitudes to callout.
     */
    constructor(bus, altitudeCallouts) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.registrationManager = new AuralAlertRegistrationManager(this.bus);
        this.isReset = true;
        this.entries = Array.from(altitudeCallouts, altitude => {
            return {
                triggerAltitude: altitude,
                // This is leftover from the garmin, not sure if it needs to change for boeing
                armAltitude: Math.max(altitude * 1.1, altitude + 10),
                isArmed: false,
                alertAlias: `${BoeingAuralAlertIds.TouchdownCallout}-${altitude}`,
                alertSequence: `aural_${altitude}ft`,
            };
        });
        // Only need to register 1 alert, because we override the sequence when we trigger it
        this.registrationManager.register({
            uuid: BoeingAuralAlertIds.TouchdownCallout,
            queue: BoeingAuralAlertUtils.PRIMARY_QUEUE,
            priority: BoeingAuralAlertUtils.PRIORITIES[BoeingAuralAlertIds.TouchdownCallout],
            sequence: 'aural_2500ft',
            continuous: false,
            repeat: false,
            timeout: 3000
        });
    }
    /** @inheritdoc */
    onInit() {
        // noop
    }
    /** @inheritdoc */
    onUpdate(operatingMode, data, realTime) {
        if (operatingMode !== GpwsOperatingMode.Normal || data.isOnGround) {
            this.reset();
            return;
        }
        if (data.isRadarAltitudeValid) {
            this.updateCallouts(data.radarAltitude, data);
        }
    }
    /**
     * Updates the state of all callout alerts.
     * @param altitudeAbove The current altitude, in feet, of the airplane above the ground.
     * @param data The current GPWS data.
     */
    updateCallouts(altitudeAbove, data) {
        for (let i = 0; i < this.entries.length; i++) {
            const entry = this.entries[i];
            if (entry.isArmed) {
                if (altitudeAbove <= entry.triggerAltitude) {
                    this.publisher.pub('aural_alert_trigger', {
                        uuid: BoeingAuralAlertIds.TouchdownCallout,
                        alias: entry.alertAlias,
                        sequence: entry.alertSequence
                    }, true, false);
                    entry.isArmed = false;
                }
            }
            else if (altitudeAbove >= entry.armAltitude) {
                entry.isArmed = true;
                this.publisher.pub('aural_alert_untrigger', entry.alertAlias, true, false);
            }
        }
    }
    /**
     * Disarms all touchdown callout alerts.
     */
    reset() {
        if (this.isReset) {
            return;
        }
        for (let i = 0; i < this.entries.length; i++) {
            this.entries[i].isArmed = false;
        }
        this.isReset = true;
    }
    /** @inheritdoc */
    onDestroy() {
        this.registrationManager.destroy();
    }
}

/**
 * Auto enables TFC when a TA or RA happens. Only need 1 per MFD side.
 */
class BoeingAutoTfcManager {
    /**
     * ctor
     * @param bus The bus.
     * @param tfcEnabledSetting The tfc enabled setting for the mfd side.
     */
    constructor(bus, tfcEnabledSetting) {
        const handleNewTaRa = (count) => {
            if (count > 0) {
                tfcEnabledSetting.set(true);
            }
        };
        bus.getSubscriber().on('tcas_ta_intruder_count').handle(handleNewTaRa);
        bus.getSubscriber().on('tcas_ra_intruder_count').handle(handleNewTaRa);
    }
}

/**
 * TCAS operating mode setting values.
 */
var TcasOperatingModeSetting$1;
(function (TcasOperatingModeSetting) {
    TcasOperatingModeSetting["TA_RA"] = "TA_RA";
    TcasOperatingModeSetting["TAOnly"] = "TAOnly";
    TcasOperatingModeSetting["Standby"] = "Standby";
})(TcasOperatingModeSetting$1 || (TcasOperatingModeSetting$1 = {}));
const trafficSettings$1 = [
    {
        name: 'trafficOperatingMode',
        defaultValue: TcasOperatingModeSetting$1.TAOnly
    },
    {
        name: 'trafficShowOther',
        defaultValue: true
    },
    {
        name: 'trafficAltitudeRelative',
        defaultValue: true
    },
    {
        name: 'trafficShowAbove',
        defaultValue: false
    },
    {
        name: 'trafficShowBelow',
        defaultValue: false
    }
];
/**
 * Utility class for retrieving the traffic user setting manager.
 */
let TrafficUserSettings$1 = class TrafficUserSettings {
    /**
     * Retrieves a setting manager with traffic user settings.
     * @param bus The event bus.
     * @returns A setting manager with traffic user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, trafficSettings$1));
    }
};

/**
 * A TCAS II implementation for the Boeing airplanes.
 */
class BoeingTCAS extends Tcas {
    constructor() {
        super(...arguments);
        this.settings = TrafficUserSettings$1.getManager(this.bus);
        /** All RAs are inhibited when airplane is on ground, or when airplane's radio altitude < 1100ft. */
        this.isRAsInhibited = MappedSubject.create(([radarAlt, isClimbing]) => {
            return radarAlt < (isClimbing ? 900 : 1100);
        }, this.ownAirplaneSubs.radarAltitude.map(radarAlt => Math.round(radarAlt.asUnit(UnitType.FOOT))), this.ownAirplaneSubs.verticalSpeed.map(verticalSpeed => verticalSpeed.number >= 0));
    }
    /** @inheritdoc */
    init() {
        super.init();
        this.settings.whenSettingChanged('trafficOperatingMode').handle(mode => {
            switch (mode) {
                case TcasOperatingModeSetting$1.Standby:
                    this.setOperatingMode(TcasOperatingMode.Standby);
                    break;
                case TcasOperatingModeSetting$1.TAOnly:
                    this.setOperatingMode(TcasOperatingMode.TAOnly);
                    break;
                case TcasOperatingModeSetting$1.TA_RA:
                    if (this.isRAsInhibited.get()) {
                        this.setOperatingMode(TcasOperatingMode.TAOnly);
                    }
                    else {
                        this.setOperatingMode(TcasOperatingMode.TA_RA);
                    }
                    break;
            }
        });
        this.isRAsInhibited.sub(isInhibited => {
            if (this.settings.getSetting('trafficOperatingMode').value === TcasOperatingModeSetting$1.TA_RA) {
                this.setOperatingMode(isInhibited ? TcasOperatingMode.TAOnly : TcasOperatingMode.TA_RA);
            }
        });
    }
    /** @inheritdoc */
    createSensitivity() {
        return new TcasIISensitivity();
    }
    /** @inheritdoc */
    createIntruderEntry(contact) {
        return new DefaultTcasIntruder(contact);
    }
    /** @inheritdoc */
    updateSensitivity() {
        this.sensitivity.updateLevel(this.ownAirplaneSubs.altitude.get(), this.ownAirplaneSubs.radarAltitude.get());
    }
}

/** Class to manage the altitude alerter on the PFD Altimeter */
class BoeingAltitudeAlertController {
    /**
     * Instantiates an instance of the AltitudeAlertController
     * @param bus is the event bus
     * @param performancePlan is the active performance plan
     */
    constructor(bus, performancePlan) {
        this.bus = bus;
        this.performancePlan = performancePlan;
        this.alerterState = Subject.create(AltAlertState.DISABLED);
        this.alertPublisher = this.bus.getPublisher();
        this.debounce = new DebounceTimer();
        this.inApproachLock = Subject.create(false);
        this.flapsPosition = Subject.create(0);
        this.isGearDown = Subject.create(false);
        this.isApproachMode = this.getIsApproachModeSubscribable();
        this.altitude = 0;
        this.targetAltitude = 0;
        this.isOnGround = true;
        const adc = this.bus.getSubscriber();
        const ap = this.bus.getSubscriber();
        const controlSurfaces = this.bus.getSubscriber();
        adc.on('on_ground').whenChanged().handle((g) => {
            this.isOnGround = g;
            if (this.isOnGround) {
                this.alerterState.set(AltAlertState.DISABLED);
                this.updateAltitudeAlerter();
            }
        });
        adc.on('indicated_alt').whenChangedBy(10).handle((altitude) => {
            this.updateAltitudeAlerter(altitude);
        });
        ap.on('ap_altitude_selected_3').whenChanged().handle((v) => {
            this.targetAltitude = Math.round(v);
            this.alerterState.set(AltAlertState.DISABLED);
            this.updateAltitudeAlerter();
        });
        ap.on('ap_lock_set').whenChanged().handle((v) => {
            this.inApproachLock.set(v === APLockType.Approach || v === APLockType.Glideslope);
        });
        controlSurfaces.on('gear_position').whenChanged().handle((v) => {
            this.isGearDown.set(v === 1);
        });
        controlSurfaces.on('flaps_handle_index').whenChanged().handle((v) => {
            this.flapsPosition.set(v);
        });
        this.alerterState.sub((v) => {
            this.alertPublisher.pub('altitude_alert', v);
            if (v === AltAlertState.DISABLED) {
                const armFn = (timeout) => {
                    this.debounce.schedule(() => {
                        if (this.canArm()) {
                            this.alerterState.set(AltAlertState.ARMED);
                            this.updateAltitudeAlerter();
                        }
                        else {
                            armFn(1000);
                        }
                    }, timeout);
                };
                armFn(3000);
            }
        }, true);
    }
    /**
     * A method called to update the altitude alerter
     * @param altitude The current altitude
     * @private
     */
    updateAltitudeAlerter(altitude) {
        if (altitude) {
            this.altitude = altitude;
        }
        if (!this.canArm()) {
            this.alerterState.set(AltAlertState.DISABLED);
        }
        const deltaAlt = Math.abs(this.targetAltitude - this.altitude);
        switch (this.alerterState.get()) {
            case AltAlertState.DISABLED:
                break;
            case AltAlertState.ARMED:
                if (deltaAlt < 100) {
                    this.alerterState.set(AltAlertState.CAPTURED);
                }
                else if (deltaAlt < 200) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                else if (deltaAlt < 900) {
                    this.alerterState.set(AltAlertState.WITHIN_900);
                }
                break;
            case AltAlertState.WITHIN_200:
                if (deltaAlt <= 100) {
                    this.alerterState.set(AltAlertState.CAPTURED);
                }
                else if (deltaAlt > 200) {
                    this.alerterState.set(AltAlertState.WITHIN_900);
                }
                break;
            case AltAlertState.WITHIN_900:
                if (deltaAlt <= 200) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                else if (deltaAlt > 900) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                break;
            case AltAlertState.CAPTURED:
                if (deltaAlt > 200) {
                    this.alerterState.set(AltAlertState.DEVIATION_200);
                }
                break;
            case AltAlertState.DEVIATION_200:
                if (deltaAlt <= 200 || deltaAlt > 900) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                break;
        }
    }
    /**
     * A method called to determine if we can arm the alerter
     * @returns boolean
     */
    canArm() {
        return (!this.isOnGround && !this.isApproachMode.get() && !isNaN(this.targetAltitude));
    }
}

/** Stores wind data associated with a flightplan */
class WindPlan {
    /**
     * Constructs a new WindPlan
     * @param options Options for the WindPlanner
     * @param numberOfLegs Number of legs to initialise the plan with (will be filled with empty data)
     */
    constructor(options, numberOfLegs = 0) {
        this.options = options;
        this.climbData = [];
        this.descentData = [];
        /** Maps global flight plan leg index to wind records */
        this.legWindData = [];
        /** Maps global flight plan leg index to temparture records */
        this.legTemperatureData = [];
        if (numberOfLegs > 0) {
            this.legWindData = Array.from({ length: numberOfLegs }, () => []);
        }
    }
    /**
     * Set wind for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature !== null;
            this.refreshTemperaturePropagation(this.climbData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Deletes a climb wind record
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(altitude) {
        const deleteIndex = this.climbData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.climbData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the climb wind records for a flight plan
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures() {
        return this.climbData;
    }
    /**
     * Set wind for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfDescentAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setDescentTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature === null;
            this.refreshTemperaturePropagation(this.descentData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.descentData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Deletes a descent wind record
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWind(altitude) {
        const deleteIndex = this.descentData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.descentData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the descent wind records for a flight plan
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures() {
        return this.descentData;
    }
    /**
     * Deletes the record for a leg (when the leg is deleted from the flightplan)
     * @param globalLegIndex Index of leg in entire flight plan
     */
    deleteLeg(globalLegIndex) {
        // Does not removed propagated data from other legs... may need an option for this later with other FMS types
        if (this.legWindData[globalLegIndex]) {
            this.legWindData.splice(globalLegIndex, 1);
        }
        if (this.legTemperatureData[globalLegIndex]) {
            this.legTemperatureData.splice(globalLegIndex, 1);
        }
    }
    /**
     * Inserts a new flight plan leg and propagates data from existing legs
     * @param globalLegIndex Index of leg in entire flight plan
     */
    insertLegAndPropagate(globalLegIndex) {
        this.legWindData.splice(globalLegIndex, 0, []);
        const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : 0;
        const propagationData = this.legWindData[propagationIndex];
        if (propagationData) {
            const records = propagationData.map(({ altitude, direction, speed }) => ({ altitude, direction, speed, windPropagated: true }));
            this.legWindData.splice(globalLegIndex, 0, records);
        }
        else {
            this.legWindData.splice(globalLegIndex, 0, []);
        }
        const tempData = this.legTemperatureData[propagationIndex];
        if (tempData) {
            this.legTemperatureData.splice(globalLegIndex, 0, Object.assign(Object.assign({}, tempData), { temperaturePropagated: true }));
        }
    }
    /**
     * Check if all the available leg altitudes are already used
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed() {
        if (this.legWindData.length === 0 || this.options.numberOfLegAltitudes === undefined) {
            return false;
        }
        const windData = this.legWindData[0];
        return windData.length >= this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.legWindData[globalLegIndex]) === null || _a === void 0 ? void 0 : _a.some((record) => record.windPropagated === false)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(globalLegIndex, altitude, speed, direction) {
        var _a, _b, _c, _d;
        const windData = this.legWindData[globalLegIndex];
        if (windData === undefined) {
            return false;
        }
        /** index of existing record for this altitude (same in all legs) */
        const existingRecordIndex = (_a = windData === null || windData === void 0 ? void 0 : windData.findIndex((v) => v.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (existingRecordIndex < 0 && isFinite((_b = this.options.numberOfLegAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
            if (((_c = windData === null || windData === void 0 ? void 0 : windData.length) !== null && _c !== void 0 ? _c : 0) >= ((_d = this.options.numberOfLegAltitudes) !== null && _d !== void 0 ? _d : Infinity)) {
                return false;
            }
        }
        if (existingRecordIndex >= 0 && windData) {
            const existingRecord = windData[existingRecordIndex];
            existingRecord.altitude = altitude;
            existingRecord.speed = speed;
            existingRecord.direction = direction;
            existingRecord.windPropagated = false;
            // propagate backward if needed
            if (this.findNextNonPropagatedLeg(globalLegIndex, altitude, -1) < 0) {
                this.propagateWind(0, globalLegIndex - 1, windData[existingRecordIndex], existingRecordIndex);
            }
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLeg(globalLegIndex, altitude);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateWind(globalLegIndex + 1, propagateTo, windData[existingRecordIndex], existingRecordIndex);
        }
        else {
            const newRecord = {
                altitude,
                speed,
                direction,
                windPropagated: true,
            };
            this.legWindData.forEach((r, index) => r.push(index === globalLegIndex ? Object.assign(Object.assign({}, newRecord), { windPropagated: speed === null }) : Object.assign({}, newRecord)));
        }
        return true;
    }
    /**
     * Delete an altitude from all leg wind records
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(altitude) {
        this.legWindData.forEach((leg) => {
            const idx = leg.findIndex((r) => r.altitude === altitude);
            if (idx >= 0) {
                leg.splice(idx, 1);
            }
        });
    }
    /**
     * Delete wind at a leg at a given altitude (does not delete this altitude globally)
     * @param globalLegIndex Flight plan leg index
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(globalLegIndex, altitude) {
        var _a;
        const leg = this.legWindData[globalLegIndex];
        const recordIndex = (_a = leg === null || leg === void 0 ? void 0 : leg.findIndex((r) => r.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (recordIndex >= 0 && leg) {
            const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : globalLegIndex + 1;
            const propagationData = this.legWindData[propagationIndex][recordIndex];
            if (propagationData) {
                const record = leg[recordIndex];
                Object.assign(record, propagationData);
                record.windPropagated = true;
            }
            else {
                // we must be the only leg
                this.deleteLegAltitude(altitude);
            }
        }
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(globalLegIndex, altitude, temperature) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            const tempData = this.legTemperatureData[globalLegIndex];
            tempData.altitude = altitude;
            tempData.temperature = temperature;
            tempData.temperaturePropagated = temperature === null;
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, 1);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateTemperature(globalLegIndex + 1, propagateTo, tempData);
            // propagate backward if no non-propagated legs behind
            const prevNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, -1);
            if (prevNonPropagatedLeg < 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
        }
        else {
            const tempData = { altitude, temperature, temperaturePropagated: temperature === null };
            this.legTemperatureData[globalLegIndex] = tempData;
            // no data exists, so we can propagate to all legs
            if (globalLegIndex > 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
            if (globalLegIndex < (this.legWindData.length - 1)) {
                this.propagateTemperature(globalLegIndex + 1, this.legWindData.length - 1, tempData);
            }
        }
        return true;
    }
    /**
     * Deletes a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(globalLegIndex) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            this.legTemperatureData[globalLegIndex].temperature = null;
            // TODO propagate from other leg
        }
    }
    /**
     * Gets a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     * @returns the leg temperature record if it exists, else undefined
     */
    getLegTemperature(globalLegIndex) {
        return this.legTemperatureData[globalLegIndex];
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from
     * @param recordIndex The index of the altitude record to propagate
     */
    propagateWind(fromIndex, toIndex, fromRecord, recordIndex) {
        for (let i = fromIndex; i <= toIndex; i++) {
            const record = this.legWindData[i][recordIndex];
            if (!record.windPropagated) {
                console.warn('Overwriting non-propagated wind record with propagated record at global leg', i);
                record.windPropagated = true;
            }
            record.altitude = fromRecord.altitude;
            record.direction = fromRecord.direction;
            record.speed = fromRecord.speed;
        }
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from.
     * @throws if parameters are incompatible with options
     */
    propagateTemperature(fromIndex, toIndex, fromRecord) {
        for (let i = fromIndex; i <= toIndex; i++) {
            if (this.legTemperatureData[i] === undefined) {
                this.legTemperatureData[i] = Object.assign(Object.assign({}, fromRecord), { temperaturePropagated: true });
            }
            else {
                const record = this.legTemperatureData[i];
                if (!record.temperaturePropagated) {
                    console.warn('Overwriting non-propagated temperature record with propagated record at global leg', i);
                    record.temperaturePropagated = true;
                }
                record.altitude = fromRecord.altitude;
                record.temperature = fromRecord.temperature;
            }
        }
    }
    /**
     * Find the next leg that doesn't have a propagated wind
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLeg(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legWindData.length : i >= 0); i += direction) {
            const legData = this.legWindData[i];
            if (legData.find((w) => w.altitude === altitude && !w.windPropagated)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Find the next leg that doesn't have a propagated temperature
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLegTemperature(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legTemperatureData.length : i >= 0); i += direction) {
            const legData = this.legTemperatureData[i];
            if (!legData.temperaturePropagated) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Get the wind records for a flight plan leg
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(globalLegIndex) {
        return this.legWindData[globalLegIndex];
    }
    /**
     * Get the number of legs in the plan
     * @returns the number of legs in the plan
     */
    get legLength() {
        return this.legWindData.length;
    }
    /**
     * Copy all data from another plan into this one
     * @param fromPlan the plan to copy from
     */
    copyFrom(fromPlan) {
        // TODO make this cheaper by re-using existing objects
        this.climbData = fromPlan.climbData.map((r) => (Object.assign({}, r)));
        this.descentData = fromPlan.descentData.map((r) => (Object.assign({}, r)));
        this.legWindData = fromPlan.legWindData.map((r) => r.map((v) => (Object.assign({}, v))));
        this.legTemperatureData = fromPlan.legTemperatureData.map((r) => (Object.assign({}, r)));
    }
    /**
     * Insert a climb or descent record into the array, taking care of temperature propagation and sorting
     * @param records climb or descent records
     * @param newRecord new record to insert
     */
    insertClimbDescentRecord(records, newRecord) {
        const insertAt = Math.max(0, records.findIndex((r) => r.altitude > newRecord.altitude));
        records.splice(insertAt, 0, newRecord);
        this.refreshTemperaturePropagation(records);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Refresh propagated temperature values for climb and descent from the non-propagated records
     * @param records Climb or Descent records
     */
    refreshTemperaturePropagation(records) {
        var _a;
        const anyNonPropagated = records.some((r) => r.temperaturePropagated === false);
        if (anyNonPropagated) {
            let previousAlt = null;
            let previousTemp = null;
            for (const record of records) {
                if ((_a = record.temperaturePropagated) !== null && _a !== void 0 ? _a : true) {
                    const nextHighestNonPropagated = records.find((r) => r.altitude > record.altitude && r.temperature !== null && r.temperaturePropagated === false);
                    if (nextHighestNonPropagated !== undefined && previousTemp !== null && previousAlt !== null && nextHighestNonPropagated.altitude !== previousAlt) {
                        // we have a temp above and below, interpolate isa delta between them
                        /** proportion of the higher ISA delta to take */
                        const k = (record.altitude - previousAlt) / (nextHighestNonPropagated.altitude - previousAlt);
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + k * isaAbove + (1 - k) * isaBelow;
                    }
                    else if (nextHighestNonPropagated !== undefined) {
                        // we have a temp above but not below, use isaDelta directly
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaAbove;
                    }
                    else if (previousTemp !== null && previousAlt !== null) {
                        // we have a temp below but not above, use isaDelta directly
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaBelow;
                    }
                }
                else {
                    previousAlt = record.altitude;
                    previousTemp = record.temperature;
                }
            }
        }
        else {
            records.forEach((r) => r.temperature = this.isaTemperatureFeet(r.altitude));
        }
    }
}

/** Stores and manages wind plans */
class WindPlanner {
    /**
     * Constructs a WindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.plans = [];
        this.syncPublisher = this.bus.getPublisher();
        this.eventPublisher = this.bus.getPublisher();
        this.ignoreSync = false;
        const fpln = this.bus.getSubscriber();
        fpln.on('fplCreated').handle(this.onPlanCreated.bind(this));
        fpln.on('fplCopied').handle(this.onPlanCopied.bind(this));
        fpln.on('fplLoaded').handle(this.onPlanLoaded.bind(this));
        fpln.on('fplDeleted').handle(this.onPlanDeleted.bind(this));
        fpln.on('fplSegmentChange').handle(this.onSegmentChanged.bind(this));
        fpln.on('fplLegChange').handle(this.onLegChanged.bind(this));
        const sync = this.bus.getSubscriber();
        sync.on('windsync_climb_wind_deleted').handle(this.handleClimbWindDelete.bind(this));
        sync.on('windsync_climb_wind_set').handle(this.handleClimbWindSet.bind(this));
        sync.on('windsync_climb_temperature_set').handle(this.handleClimbTemperatureSet.bind(this));
        sync.on('windsync_descent_wind_deleted').handle(this.handleDescentWindDelete.bind(this));
        sync.on('windsync_descent_wind_set').handle(this.handleDescentWindSet.bind(this));
        sync.on('windsync_descent_temperature_set').handle(this.handleDescentTemperatureSet.bind(this));
        sync.on('windsync_leg_wind_deleted').handle(this.handleLegWindDelete.bind(this));
        sync.on('windsync_leg_altitude_deleted').handle(this.handleLegAltitudeDelete.bind(this));
        sync.on('windsync_leg_wind_set').handle(this.handleLegWindSet.bind(this));
        sync.on('windsync_leg_temperature_deleted').handle(this.handleLegTempDelete.bind(this));
        sync.on('windsync_leg_temperature_set').handle(this.handleLegTempSet.bind(this));
    }
    /**
     * Set wind for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbWindSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a climb wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleClimbWindDelete(ev);
    }
    /**
     * Handles climb wind delete events
     * @param ev the event
     */
    handleClimbWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteClimbWindAndTemperature(ev.altitude);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set temperature for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbTemperatureSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the climb wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getClimbWindsAndTemperatures();
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentWindSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a descent wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDescentWindDelete(ev);
    }
    /**
     * Handles descent wind delete events
     * @param ev the event
     */
    handleDescentWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteDescentWind(ev.altitude);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentTemperatureSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the descent wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getDescentWindsAndTemperatures();
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(planIndex, globalLegIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegWindSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegWind(ev.globalLegIndex, ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg wind record
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(planIndex, globalLegIndex, altitude) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegWindDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegWind(ev.globalLegIndex, ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Deletes all leg wind records for a given altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_altitude_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegAltitudeDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegAltitudeDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegAltitude(ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the wind records for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegWinds(globalLegIndex);
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(planIndex, globalLegIndex, altitude, temperature = null) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegTempSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegTempSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegTemperature(ev.globalLegIndex, ev.altitude, ev.temperature);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg temperature record,
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(planIndex, globalLegIndex) {
        const ev = {
            planIndex,
            globalLegIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegTempDelete(ev);
    }
    /**
     * Handles leg temperature delete events
     * @param ev the event
     */
    handleLegTempDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegTemperature(ev.globalLegIndex);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the temperature record for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns A temperature record if one exists, else undefined
     */
    getLegTemperature(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegTemperature(globalLegIndex);
    }
    /**
     * Handles flight plan creation events
     * @param data Event Data
     */
    onPlanCreated(data) {
        this.plans[data.planIndex] = new WindPlan(this.options);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handle flight plan copy events by copying related wind data
     * @param data Event Data
     */
    onPlanCopied(data) {
        const targetPlan = this.plans[data.targetPlanIndex];
        const fromPlan = this.plans[data.planIndex];
        if (!targetPlan || !fromPlan) {
            console.error('WindPlanner: failed to copy plan!');
            return;
        }
        targetPlan.copyFrom(fromPlan);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handles flight plan load events
     * @param data Event Data
     */
    onPlanLoaded(data) {
        const flightPlan = this.flightPlanner.getFlightPlan(data.planIndex);
        if (!flightPlan) {
            this.plans[data.planIndex] = undefined;
            return;
        }
        this.plans[data.planIndex] = new WindPlan(this.options, flightPlan.length);
    }
    /**
     * Handles flight plan deletion events
     * @param data Event Data
     */
    onPlanDeleted(data) {
        this.plans[data.planIndex] = undefined;
    }
    /**
     * Handles flight plan segment change events
     * @param data Event Data
     */
    onSegmentChanged(data) {
        var _a, _b;
        const windPlan = this.plans[data.planIndex];
        if (!windPlan) {
            return;
        }
        switch (data.type) {
            case SegmentEventType.Removed:
                for (let i = 0; i < ((_b = (_a = data.segment) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0); i++) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    windPlan.deleteLeg(data.segment.offset);
                }
                break;
            case SegmentEventType.Changed:
            // fall through, airway changes don't matter to us
            case SegmentEventType.Added:
            case SegmentEventType.Inserted:
            default:
                // nothing we need to do for these as they don't add or remove legs
                return;
        }
    }
    /**
     * Handles flight plan leg change events
     * @param data Event Data
     */
    onLegChanged(data) {
        const globalLegIndex = WindPlanner.getGlobalLegIndex(this.flightPlanner.getFlightPlan(data.planIndex), data.segmentIndex, data.legIndex);
        const plan = this.plans[data.planIndex];
        if (!plan) {
            console.warn('onLegChanged, but the flightplan doesn\'t exist!');
            return;
        }
        switch (data.type) {
            case LegEventType.Added:
                plan.insertLegAndPropagate(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
            case LegEventType.Removed:
                plan.deleteLeg(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
        }
    }
    /**
     * Get a flight plan or error if it doesn't exist
     * @param planIndex Flight Plan index
     * @throws if flight plan doesn't exist
     * @returns FlightPlan
     */
    getPlan(planIndex) {
        const plan = this.plans[planIndex];
        if (plan === undefined) {
            throw new Error(`WindPlanner: wind plan ${planIndex} does not exist!`);
        }
        return plan;
    }
    /**
     * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param segmentIndex The Segment Index.
     * @param segmentLegIndex The Segment Leg Index.
     * @returns The global leg index.
     */
    static getGlobalLegIndex(lateralPlan, segmentIndex, segmentLegIndex) {
        if (segmentIndex < lateralPlan.segmentCount) {
            const segment = lateralPlan.getSegment(segmentIndex);
            return segment.offset + segmentLegIndex;
        }
        return -1;
    }
    /**
     * Check if all the available leg altitudes are already used
     * @param planIndex Flight Plan index
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed(planIndex) {
        const plan = this.getPlan(planIndex);
        return plan.areAllLegAltitudesUsed();
    }
    /**
     * Get the number of leg wind altitudes permitted
     * @returns the maximum number of leg wind altitudes, or undefined if no limit
     */
    getNumberOfLegAltitudes() {
        return this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.legHasNonPropagatedWind(globalLegIndex);
    }
}

// TODO consider average wind entry instead of individual winds
/** Wind Planner that interpolates live wind data along the route for a Boeing FMS */
class InterpolatingWindPlanner extends WindPlanner {
    /**
     * Constructs an InterpolatingWindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        super(bus, flightPlanner, options);
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.vec2Cache = [Vec2Math.create(), Vec2Math.create(), Vec2Math.create()];
        this.filteredLiveWind = Vec2Math.create();
        /** sim wind direction in degrees true */
        this.liveWindDirection = ConsumerValue.create(null, 0);
        /** sim wind speed in knots */
        this.liveWindSpeed = ConsumerValue.create(null, 0);
        /** plane altitude in feet */
        this.planeAltitude = ConsumerValue.create(null, 0);
        /** plane is on the ground */
        this.onGround = ConsumerValue.create(null, true);
        /** static/outside air temperature in degrees celsius */
        this.staticAirTemperature = ConsumerValue.create(null, 0);
        this.filteredCache = [];
        const sub = this.bus.getSubscriber();
        this.liveWindDirection.setConsumer(sub.on('ambient_wind_direction').withPrecision(0));
        this.liveWindSpeed.setConsumer(sub.on('ambient_wind_velocity').withPrecision(0));
        this.planeAltitude.setConsumer(sub.on('indicated_alt').withPrecision(-2));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.staticAirTemperature.setConsumer(sub.on('ambient_temp_c').withPrecision(0));
        sub.on('simTime').atFrequency(1).handle(this.updateLiveWind.bind(this));
    }
    /** Apply an IIR filter to the live wind */
    updateLiveWind() {
        Vec2Math.setFromPolar(this.liveWindSpeed.get(), UnitType.RADIAN.convertFrom(this.liveWindDirection.get(), UnitType.DEGREE), this.vec2Cache[0]);
        Vec2Math.multScalar(this.vec2Cache[0], 0.1, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 0.9, this.filteredLiveWind);
        Vec2Math.add(this.filteredLiveWind, this.vec2Cache[0], this.filteredLiveWind);
    }
    /**
     * Transform a cartesian wind vector to polar direction/speed
     * @param vector Cartesian wind vector or null if no vector
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    windVectorToDirectionSpeed(vector, out) {
        if (vector === null) {
            return null;
        }
        out[0] = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Vec2Math.theta(vector), UnitType.DEGREE));
        out[1] = Vec2Math.abs(vector);
        return out;
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO Does the Boeing use climb and/or descent wind if no leg winds?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.tryGetLeg(globalLegIndex);
        if (!fpLeg) {
            return null;
        }
        /** Stored in this.vec2Cache[0] */
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        /** proportion of live wind to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        Vec2Math.multScalar(forecastWind, 1 - k, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
        return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedWindAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        const wind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get the wind at a given altitude on a given leg
     * @param windPlan The wind plan to use
     * @param globalLegIndex The global index of the desired leg
     * @param altitude Altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getLegWindAtAltitude(windPlan, globalLegIndex, altitude, out) {
        const legWinds = windPlan.getLegWinds(globalLegIndex);
        if (legWinds === undefined) {
            return null;
        }
        return this.getAltitudeInterpolatedWind(legWinds, altitude, out);
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(climbWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = this.vec2Cache[0][0];
        out[1] = this.vec2Cache[0][1];
        return out;
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedClimbWind(planIndex, altitude, liveWind, out) {
        const wind = this.getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get a descent wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedDescentWind(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const desWinds = windPlan.getDescentWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(desWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = UnitType.RADIAN.convertTo(Vec2Math.theta(this.vec2Cache[0]), UnitType.DEGREE);
        out[1] = Vec2Math.abs(this.vec2Cache[0]);
        return out;
    }
    /**
     * Get the wind at a given altitude from a WindRecord, interpolated when it lies between altitudes for which wind is defined
     * Caution: clobbers first 2 elements of this.vec2Cache
     * @param winds Wind records to use
     * @param altitude Desired altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getAltitudeInterpolatedWind(winds, altitude, out) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < winds.length; i++) {
            const wind = winds[i];
            if (wind.direction !== null && wind.speed !== null) {
                this.filteredCache[index++] = wind;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredWinds = this.filteredCache;
        if (filteredWinds.length < 1) {
            return null;
        }
        if (filteredWinds.length === 1 || altitude >= filteredWinds[0].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[0].speed, UnitType.RADIAN.convertFrom(filteredWinds[0].direction, UnitType.DEGREE), out);
        }
        if (altitude <= filteredWinds[filteredWinds.length - 1].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[filteredWinds.length - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[filteredWinds.length - 1].direction, UnitType.DEGREE), out);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredWinds.length; i++) {
            if (filteredWinds[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper wind to take */
            const k = (altitude - filteredWinds[i].altitude) / (filteredWinds[i - 1].altitude - filteredWinds[i].altitude);
            const windUpper = Vec2Math.setFromPolar(filteredWinds[i - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[i - 1].direction, UnitType.DEGREE), this.vec2Cache[0]);
            const windLower = Vec2Math.setFromPolar(filteredWinds[i].speed, UnitType.RADIAN.convertFrom(filteredWinds[i].direction, UnitType.DEGREE), this.vec2Cache[1]);
            Vec2Math.multScalar(windUpper, k, this.vec2Cache[0]);
            Vec2Math.multScalar(windLower, 1 - k, this.vec2Cache[1]);
            return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
        }
        return null;
    }
    /**
     * Get the ISA delta temperature interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @returns ISA temperature delta in °C or null if no data
     */
    getInterpolatedIsaDeltaAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO use climb and/or descent temp if no leg temp?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.getLeg(globalLegIndex);
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        const legTemp = windPlan.getLegTemperature(globalLegIndex);
        if (legTemp === undefined || legTemp.temperature === null) {
            return null;
        }
        /** proportion of live data to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        const isaTemp = this.isaTemperatureFeet(altitude);
        const interpolatedTemp = k * this.staticAirTemperature.get() + (1 - k) * legTemp.temperature;
        return interpolatedTemp - isaTemp;
    }
    /**
     * Get a climb ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedClimbIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(climbWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get a descent ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedDescentIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const descentWinds = windPlan.getDescentWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(descentWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get the ISA temperature delta at a given altitude from a WindAndTemperatureRecord,
     * interpolated when it lies between altitudes for which temperature is defined
     * @param temps Wind/Temperature records to use
     * @param altitude Desired altitude in feet MSL
     * @returns An ISA delta in °C or null if unavailable
     */
    getAltitudeInterpolatedIsaDelta(temps, altitude) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < temps.length; i++) {
            const temp = temps[i];
            if (temp.temperature !== null) {
                this.filteredCache[index++] = temp;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredTemps = this.filteredCache;
        if (filteredTemps.length < 1) {
            return null;
        }
        if (filteredTemps.length === 1 || altitude >= filteredTemps[0].altitude) {
            return filteredTemps[0].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        else if (altitude <= filteredTemps[filteredTemps.length - 1].altitude) {
            return filteredTemps[filteredTemps.length - 1].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredTemps.length; i++) {
            if (filteredTemps[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper temperature to take */
            const k = (altitude - filteredTemps[i].altitude) / (filteredTemps[i - 1].altitude - filteredTemps[i].altitude);
            // we have filtered out null temps above, but the linter isn't quite smart enough to figure that out
            const upperIsaDelta = filteredTemps[i - 1].temperature - this.isaTemperatureFeet(filteredTemps[i - 1].altitude);
            const lowerIsaDelta = filteredTemps[i].temperature - this.isaTemperatureFeet(filteredTemps[i].altitude);
            return k * upperIsaDelta + (1 - k) * lowerIsaDelta;
        }
        return null;
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a distance from the aircraft
     * @param distance distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportion(distance) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        if (distance < 277800) {
            return 1 - 1 / 3 * (distance / 277800) ** 2;
        }
        return 2 / 3 * (Math.E ** (-5 * ((distance - 277800) / 1852000)));
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a height from the aircraft
     * @param height vertical distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportionHeight(height) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        // 243.045 = 6076.12 feet/NM / (17500 ft / 700 NM), the latter from FMS documentation
        return this.getLiveDataProportion(Math.abs(height) * 243.045);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Calculate the wind speed for the ECON speed calculation.
     * Before takeoff, when planning the flight, this shall be taken from the wind plan.
     * Once flying at cruise flight level, ECON speed controls the AT so we want to base the calculation
     * on the actual live wind.
     * @param planIndex Flight Plan index
     * @param cruiseAltitude Planned cruise altitude
     * @param globalLegIndex Index of active leg
     * @param distanceAlongLeg Distance along the active leg
     * @param trueHeading Heading of the aircraft, degree
     * @returns Headwind component (knots)
     */
    getHeadwindForEconSpeedCalculation(planIndex, cruiseAltitude, globalLegIndex, distanceAlongLeg, trueHeading) {
        // Retrieve planned wind (first wind along leg, if unavailble climb wind).
        let planWind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, distanceAlongLeg, this.vec2Cache[2]);
        if (planWind === null) {
            planWind = this.getInterpolatedClimbWindCartesian(planIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, true, this.vec2Cache[2]);
        }
        if (planWind === null) {
            planWind = this.vec2Cache[2];
            this.vec2Cache[2][0] = 0;
            this.vec2Cache[2][1] = 0;
        }
        // Blend gradually between planned wind and live wind using 100% live wind @(plane alt = cruiseAlt) 
        // and 100% planned wind @(alt deviates 500ft or more from cruise alt):
        const planWindProportion = Math.min(1, Math.abs(cruiseAltitude - this.planeAltitude.get()) / 500);
        Vec2Math.multScalar(planWind, planWindProportion, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 1 - planWindProportion, this.vec2Cache[1]);
        Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        // Create unit vector in heading direction:
        Vec2Math.setFromPolar(1, UnitType.RADIAN.convertFrom(trueHeading, UnitType.DEGREE), this.vec2Cache[1]);
        // The dot product returns the projected length of the wind vector onto the heading (unit) vector:
        return VecNMath.dot(this.vec2Cache[0], this.vec2Cache[1]);
    }
}
InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT = (a, b) => b.altitude - a.altitude;

/** The B748Square component. */
class B748Square extends DisplayComponent {
    /** @inheritdoc */
    onAfterRender() {
        // TODO do stuff
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: `b748-square ${this.props.pfdOrMfd} ${this.props.pfdOrMfd}-${this.props.instrumentIndex}` }, this.props.children));
    }
}

/**
 * Indexes for display panes.
 */
var DisplayPaneIndex;
(function (DisplayPaneIndex) {
    // Left
    DisplayPaneIndex[DisplayPaneIndex["MFD_1"] = 1] = "MFD_1";
    // Right
    DisplayPaneIndex[DisplayPaneIndex["MFD_2"] = 2] = "MFD_2";
    // Upper
    DisplayPaneIndex[DisplayPaneIndex["MFD_3"] = 3] = "MFD_3";
    // Lower
    DisplayPaneIndex[DisplayPaneIndex["MFD_4"] = 4] = "MFD_4";
})(DisplayPaneIndex || (DisplayPaneIndex = {}));

/**
 * Keys for standard display pane views.
 */
var DisplayPaneViewKey;
(function (DisplayPaneViewKey) {
    DisplayPaneViewKey["NAV"] = "navigation-display";
    DisplayPaneViewKey["EICAS"] = "eicas";
    DisplayPaneViewKey["ENG"] = "secondary-engine-eicas";
    DisplayPaneViewKey["STAT"] = "status";
    DisplayPaneViewKey["CHKL"] = "checklist";
    DisplayPaneViewKey["ELEC"] = "electrical";
    DisplayPaneViewKey["FUEL"] = "fuel";
    DisplayPaneViewKey["ECS"] = "ecs-air-systems";
    DisplayPaneViewKey["FCTL"] = "flight-controls";
    DisplayPaneViewKey["HYD"] = "hydraulics";
    DisplayPaneViewKey["DRS"] = "doors";
    DisplayPaneViewKey["GEAR"] = "landing-gear";
    DisplayPaneViewKey["INFO"] = "info";
    DisplayPaneViewKey["BLANK"] = "blank";
})(DisplayPaneViewKey || (DisplayPaneViewKey = {}));

/**
 * Utility class for retrieving display pane setting managers.
 */
class DisplayPanesUserSettings {
    /**
     * Retrieves a manager for all true map settings.
     * @param bus The event bus.
     * @returns A manager for all true map settings.
     */
    static getMasterManager(bus) {
        var _a;
        return (_a = DisplayPanesUserSettings.masterInstance) !== null && _a !== void 0 ? _a : (DisplayPanesUserSettings.masterInstance = new DefaultUserSettingManager(bus, [
            ...DisplayPanesUserSettings.getDisplayPaneSettingDefs(DisplayPaneIndex.MFD_1),
            ...DisplayPanesUserSettings.getDisplayPaneSettingDefs(DisplayPaneIndex.MFD_2),
            ...DisplayPanesUserSettings.getDisplayPaneSettingDefs(DisplayPaneIndex.MFD_3),
            ...DisplayPanesUserSettings.getDisplayPaneSettingDefs(DisplayPaneIndex.MFD_4),
        ]));
    }
    /**
     * Retrieves a manager for aliased map settings for a single display pane.
     * @param bus The event bus.
     * @param index The index of the display pane.
     * @returns A manager for aliased map settings for the specified display pane.
     */
    static getDisplayPaneManager(bus, index) {
        var _a;
        var _b;
        return (_a = (_b = DisplayPanesUserSettings.displayPaneInstances)[index]) !== null && _a !== void 0 ? _a : (_b[index] = DisplayPanesUserSettings.getMasterManager(bus).mapTo(DisplayPanesUserSettings.getDisplayPaneAliasMap(index)));
    }
    /**
     * Gets an array of definitions for true map settings for a single display pane.
     * @param index The index of the display pane.
     * @returns An array of definitions for true map settings for the specified display pane.
     */
    static getDisplayPaneSettingDefs(index) {
        let view;
        switch (index) {
            case DisplayPaneIndex.MFD_1:
                view = DisplayPaneViewKey.NAV;
                break;
            case DisplayPaneIndex.MFD_2:
                view = DisplayPaneViewKey.NAV;
                break;
            case DisplayPaneIndex.MFD_3:
                view = DisplayPaneViewKey.EICAS;
                break;
            case DisplayPaneIndex.MFD_4:
                view = DisplayPaneViewKey.ENG;
                break;
        }
        return [
            {
                name: `displayPaneView_${index}`,
                defaultValue: view
            }
        ];
    }
    /**
     * Gets a setting name alias mapping for a display pane.
     * @param index The index of the display pane.
     * @returns A setting name alias mapping for the specified display pane.
     */
    static getDisplayPaneAliasMap(index) {
        const map = {};
        for (const name of DisplayPanesUserSettings.ALIASED_SETTING_NAMES) {
            map[name] = `${name}_${index}`;
        }
        return map;
    }
}
DisplayPanesUserSettings.ALIASED_SETTING_NAMES = [
    'displayPaneView'
];
DisplayPanesUserSettings.displayPaneInstances = [];

/**
 * The DisplayPane component.
 */
class DisplayPane extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.displayPaneContentRef = FSComponent.createRef();
        this.rootCssClass = SetSubject.create(['display-pane']);
        this.refsMap = new Map();
        this.activeViewEntry = Subject.create(null);
        /** The key of the currently active view. */
        this.activeViewKey = this.activeViewEntry.map(entry => { var _a; return (_a = entry === null || entry === void 0 ? void 0 : entry.key) !== null && _a !== void 0 ? _a : ''; });
        /** The currently active view. */
        this.activeView = this.activeViewEntry.map(entry => entry === null || entry === void 0 ? void 0 : entry.view);
        this.paneSettingsManager = DisplayPanesUserSettings.getDisplayPaneManager(this.props.bus, this.props.index);
        this.wasVisible = undefined;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.viewSub = this.paneSettingsManager.getSetting('displayPaneView').sub(this.open.bind(this), true);
        this.eventSub = this.props.bus.getSubscriber()
            .on('display_pane_view_event')
            .handle(this.onEvent.bind(this));
    }
    /**
     * Updates this display pane. Has no effect if this display pane is not visible.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        var _a;
        (_a = this.activeViewEntry.get()) === null || _a === void 0 ? void 0 : _a.view.onUpdate(time);
    }
    /**
     * Opens a view.
     * @param key The key of the view to open.
     */
    open(key) {
        let viewEntry = this.refsMap.get(key);
        if (viewEntry === undefined) {
            viewEntry = this.createView(key);
            this.refsMap.set(key, viewEntry);
        }
        const activeViewEntry = this.activeViewEntry.get();
        if (activeViewEntry !== null) {
            activeViewEntry.isVisible.set(false);
            this.pauseView(activeViewEntry);
        }
        this.activeViewEntry.set(viewEntry);
        viewEntry.isVisible.set(true);
        this.resumeView(viewEntry);
    }
    /**
     * Creates a view.
     * @param type The type string of the view to create.
     * @returns A ViewEntry for the created view.
     */
    createView(type) {
        const node = this.props.displayPaneViewFactory.createViewNode(type, this.props.index);
        const isVisible = Subject.create(false);
        FSComponent.render(FSComponent.buildComponent(DisplayPaneViewWrapper, { isVisible: isVisible }, node), this.displayPaneContentRef.instance);
        const view = node.instance;
        return {
            key: type,
            view,
            isVisible
        };
    }
    /**
     * Resumes a view.
     * @param entry The entry for the view to resume.
     */
    resumeView(entry) {
        entry.view.onResume();
    }
    /**
     * Pauses a view.
     * @param entry The entry for the view to pause.
     */
    pauseView(entry) {
        entry.view.onPause();
    }
    /**
     * Responds to when a display pane view event is received.
     * @param event The received event.
     */
    onEvent(event) {
        var _a;
        if (event.displayPaneIndex === this.props.index) {
            (_a = this.activeView.get()) === null || _a === void 0 ? void 0 : _a.onEvent(event);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        if (typeof this.props.class === 'object') {
            this.cssClassSub = FSComponent.bindCssClassSet(this.rootCssClass, this.props.class, ['display-pane']);
        }
        else {
            const classesToAdd = FSComponent.parseCssClassesFromString((_a = this.props.class) !== null && _a !== void 0 ? _a : '').filter(val => !DisplayPane.RESERVED_CLASSES.includes(val));
            for (const classToAdd of classesToAdd) {
                this.rootCssClass.add(classToAdd);
            }
        }
        return (FSComponent.buildComponent("div", { class: this.rootCssClass },
            FSComponent.buildComponent("div", { ref: this.displayPaneContentRef, class: "display-pane-content" })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d;
        for (const entry of this.refsMap.values()) {
            entry.view.destroy();
        }
        (_a = this.cssClassSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.controllerSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.viewSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.eventSub) === null || _d === void 0 ? void 0 : _d.destroy();
        super.destroy();
    }
}
DisplayPane.RESERVED_CLASSES = ['display-pane', 'display-pane-full', 'display-pane-half'];
/** A simple div wrapper useful for hiding and unhiding its child component */
class DisplayPaneViewWrapper extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.classList = SetSubject.create(['display-pane-view-wrapper']);
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.props.isVisible.sub(isVisible => {
            this.classList.toggle('hidden', !isVisible);
        }, true));
    }
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.classList, style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' }, this.props.children));
    }
    /** @inheritDoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
        super.destroy();
    }
}

/**
 * A container for two display panes: a left pane and a right pane. Automatically controls the size of each display
 * pane such that if both are visible, each is sized as a half pane, and if only one is visible, it is sized as a full
 * pane.
 */
class DisplayPaneContainer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.paneRef = FSComponent.createRef();
        // private readonly paneSettingsManager = DisplayPanesUserSettings.getDisplayPaneManager(this.props.bus, this.props.paneIndex);
        this.cssClassSet = SetSubject.create(['display-pane-container']);
        this.updateFreq = SubscribableUtils.toSubscribable(this.props.updateFreq, true);
        this.updateClock = ConsumerSubject.create(null, 0).pause();
        this.isAlive = true;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.updateClock.sub(this.update.bind(this));
        const realTimeConsumer = this.props.bus.getSubscriber().on('realTime');
        this.updateFreqSub = this.updateFreq.sub(freq => {
            this.updateClock.setConsumer(realTimeConsumer.atFrequency(freq));
        }, true);
    }
    /**
     * Updates this container's panes.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        this.paneRef.instance.update(time);
    }
    /** @inheritdoc */
    render() {
        if (typeof this.props.class === 'object') {
            this.cssClassSub = FSComponent.bindCssClassSet(this.cssClassSet, this.props.class, ['display-pane-container']);
        }
        else if (this.props.class !== undefined) {
            for (const cssClass of FSComponent.parseCssClassesFromString(this.props.class).filter(val => val !== 'display-pane-container')) {
                this.cssClassSet.add(cssClass);
            }
        }
        return (FSComponent.buildComponent("div", { class: this.cssClassSet },
            FSComponent.buildComponent(DisplayPane, { ref: this.paneRef, bus: this.props.bus, index: this.props.paneIndex, displayPaneViewFactory: this.props.displayPaneViewFactory })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        this.updateClock.destroy();
        (_a = this.cssClassSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.updateFreqSub) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}

/** Collection of functions for working with Display Panes. */
class DisplayPaneUtils {
}
/** An array of indexes of all display panes. */
DisplayPaneUtils.ALL_INDEXES = [
    DisplayPaneIndex.MFD_1,
    DisplayPaneIndex.MFD_2,
    DisplayPaneIndex.MFD_3,
    DisplayPaneIndex.MFD_4
];
// public static readonly MFD_INDEXES = [
//   [DisplayPaneIndex.MFD_1_LEFT, DisplayPaneIndex.MFD_1_RIGHT],
//   [DisplayPaneIndex.MFD_2_LEFT, DisplayPaneIndex.MFD_2_RIGHT],
//   [DisplayPaneIndex.MFD_3_LEFT, DisplayPaneIndex.MFD_3_RIGHT]
// ];
DisplayPaneUtils.PILOT_SIDE_PANE_INDEXES = [
    DisplayPaneIndex.MFD_1,
    DisplayPaneIndex.MFD_4,
];
DisplayPaneUtils.COPILOT_SIDE_PANE_INDEXES = [
    DisplayPaneIndex.MFD_3,
];

/* eslint-disable @typescript-eslint/no-unused-vars */
/** A DisplayPaneView component */
class DisplayPaneView extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._title = Subject.create('');
        /** The title of this display pane view. */
        this.title = this._title;
    }
    /**
     * Called when this view is made visible.
     */
    onResume() {
        // noop
    }
    /**
     * Called when this view is hidden.
     */
    onPause() {
        // noop
    }
    /**
     * Called every update cycle.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    onUpdate(time) {
        // noop
    }
    /**
     * Called when a display pane view event is received by this view.
     * @param event The event.
     */
    onEvent(event) {
        // noop
    }
}

/**
 * Creates display pane views.
 */
class DisplayPaneViewFactory {
    constructor() {
        this.registeredViews = new Map();
    }
    /**
     * Registers a display pane view under a specific key. Once a view is registered, new instances can be created
     * using the key under which it was registered via the `createViewNode()` method. Registering a view under an
     * existing key will replace the old view registered under that key.
     * @param key The key of the display pane view to register.
     * @param vnodeFn A function which creates new instances of the display pane view to register as VNodes.
     */
    registerView(key, vnodeFn) {
        this.registeredViews.set(key, vnodeFn);
    }
    /**
     * Creates a new display pane view instance as a VNode.
     * @param key The key of the display pane view to create.
     * @param index The index of the view's parent pane.
     * @throws Error if no view is registered under the given key.
     * @returns A new display pane view instance as a VNode.
     */
    createViewNode(key, index) {
        const vnodeFn = this.registeredViews.get(key);
        if (vnodeFn !== undefined) {
            return vnodeFn(index);
        }
        else {
            console.error(`Could not find a registered display pane view of type ${key.toString()}!`);
            throw new Error(`Could not find a registered display pane view of type ${key.toString()}!`);
        }
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
const B747_8_EICAS_EVT_REGEX = /B747_8_EICAS_2_EICAS_PUSH_(.*)/;
const pageEventKeyMap = {
    nav: DisplayPaneViewKey.NAV,
    eng: DisplayPaneViewKey.ENG,
    stat: DisplayPaneViewKey.STAT,
    chkl: DisplayPaneViewKey.CHKL,
    elec: DisplayPaneViewKey.ELEC,
    fuel: DisplayPaneViewKey.FUEL,
    ecs: DisplayPaneViewKey.ECS,
    fctl: DisplayPaneViewKey.FCTL,
    hyd: DisplayPaneViewKey.HYD,
    drs: DisplayPaneViewKey.DRS,
    gear: DisplayPaneViewKey.GEAR,
    info: DisplayPaneViewKey.INFO,
};
/**
 * A controller for handling EFIS events and managing display panes.
 * Only one instance of this class should exist across the entire aircraft.
 */
class DisplayPaneController {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.hEventSubscriber = this.bus.getSubscriber();
        this.hEventSubscriber.on('hEvent').handle((e) => this.handleHEvent(e));
        if (SimVar.GetSimVarValue('L:WT_MFD_SELECT', SimVarValueType.Number) < 1) {
            SimVar.SetSimVarValue('L:WT_MFD_SELECT', SimVarValueType.Number, 4);
        }
    }
    /**
     * Handles H Events
     * @param evt The h event string.
     */
    handleHEvent(evt) {
        const matches = evt.match(B747_8_EICAS_EVT_REGEX);
        if (matches !== null) {
            if (evt === 'B747_8_EICAS_2_EICAS_PUSH_canc_rcl') {
                this.handleCancelRecall();
            }
            else {
                let mfdIndex = SimVar.GetSimVarValue('L:WT_MFD_SELECT', SimVarValueType.Number);
                mfdIndex = mfdIndex < 1 ? 4 : mfdIndex;
                const page = matches[1];
                this.handleMfdPageSelect(mfdIndex, page);
            }
        }
    }
    /**
     * Handle the CANC/RCL button being pressed.
     */
    handleCancelRecall() {
        // TODO
    }
    /**
     * Handles mfd page selection events.
     * @param mfdIndex The mfd index.
     * @param page The event's type of pane to display.
     */
    handleMfdPageSelect(mfdIndex, page) {
        const setting = DisplayPanesUserSettings.getDisplayPaneManager(this.bus, mfdIndex).getSetting('displayPaneView');
        // If the button pressed matches active pane
        if (setting.get() === pageEventKeyMap[page]) {
            if (mfdIndex === 1 || mfdIndex === 2) {
                // If left or right MFD, show NAV
                setting.set(DisplayPaneViewKey.NAV);
            }
            else {
                // If MFD 4, blank it
                setting.set(DisplayPaneViewKey.BLANK);
            }
        }
        else {
            DisplayPanesUserSettings.getDisplayPaneManager(this.bus, mfdIndex).getSetting('displayPaneView').set(pageEventKeyMap[page]);
        }
    }
    /**
     * Sets the visibility settings of all pane indexes in the array.
     * @param paneIndexes An array of pane indexes.
     * @param shouldBeVisible Whether the panes should be set to visible.
     */
    setPanesVisibility(paneIndexes, shouldBeVisible) {
        // paneIndexes.forEach((p) => {
        //   DisplayPanesUserSettings.getDisplayPaneManager(this.bus, p).getSetting('displayPaneVisible').set(shouldBeVisible);
        // });
    }
    /**
     * Checks if the type of pane is restricted (only one instance per side).
     * @param paneView The key of the pane view to check.
     * @returns True if restricted, false otherwise.
     */
    // private static isRestrictedPane(paneView: DisplayPaneViewKey): boolean {
    //   return (DisplayPaneController.restrictedPanes.includes(paneView));
    // }
    /**
     * Returns a filtered set of pane indexes
     * @param pilotSide Whether the returned indexes should be for the pilot or copilot side.
     * @param includeLower Whether the returned indexes should include the lower MFD indexes.
     * @returns An array of filtered display pane indexes.
     */
    static getFilteredPaneIndexes(pilotSide, includeLower) {
        const indexes = pilotSide === true ? DisplayPaneUtils.PILOT_SIDE_PANE_INDEXES : DisplayPaneUtils.COPILOT_SIDE_PANE_INDEXES;
        return indexes.filter((v) => {
            return includeLower || DisplayPaneController.isLowerMfd(v) === false;
        });
    }
    /**
     * Whether the pane belongs to the pilot side MFD.
     * @param paneIndex The {@link DisplayPaneIndex} to check.
     * @param includeLower Whether the check should include the lower MFD panes.
     * @returns True if pane is on the pilot side, otherwise false.
     */
    static isPilotSideMfd(paneIndex, includeLower = false) {
        return DisplayPaneController.getFilteredPaneIndexes(true, includeLower).includes(paneIndex);
    }
    /**
     * Whether the pane belongs to the copilot side MFD.
     * @param paneIndex The {@link DisplayPaneIndex} to check.
     * @param includeLower Whether the check should include the lower MFD panes.
     * @returns True if pane is on the copilot side, otherwise false.
     */
    static isCoPilotSideMfd(paneIndex, includeLower = false) {
        return DisplayPaneController.getFilteredPaneIndexes(false, includeLower).includes(paneIndex);
    }
    /**
     * Whether the pane belongs to the lower MFD.
     * @param paneIndex The {@link DisplayPaneIndex} to check.
     * @returns True if pane is on the lower side, otherwise false.
     */
    static isLowerMfd(paneIndex) {
        return paneIndex === DisplayPaneIndex.MFD_4;
    }
}

const efisEventMap = {
    'Mins_INC': 'MINS_INC',
    'Mins_DEC': 'MINS_DEC',
    'Mins_Press': 'MINS_PRESS',
    'AUTOPILOT_CTR': 'ND_CTR',
    'WXR': 'WXR',
    'STA': 'STA',
    'WPT': 'WPT',
    'ARPT': 'ARPT',
    'DATA': 'DATA',
    'POS': 'POS',
    'TERR': 'TERR',
    'TFC': 'TFC',
    'FPV': 'FPV',
    'MTRS': 'MTRS',
};
/**
 * The publisher for EFIS panel events.
 */
class EfisEventPublisher extends BasePublisher {
    /**
     * Ctor
     * @param bus The event bus.
     * @param isMfd Whether this instance is on a MFD.
     * @param index The index of the instrument.
     */
    constructor(bus, isMfd, index) {
        super(bus);
        this.isMfd = isMfd;
        this.index = index;
        if (isMfd) {
            this.eventRegx = new RegExp(`AS01B_MFD_${this.index}_(.*)`);
        }
        else {
            // TODO: PFD events have no indexes. Fix Modelbehaviors
            this.eventRegx = /B747_8_PFD_(.*)/;
        }
        this.startPublish();
    }
    /**
     * Handles HEvents to be published as {@link EfisEvent}.
     * @param evt The hevent.
     * @returns True if the event was handled, false otherwise.
     */
    handleHEvent(evt) {
        const matches = evt.match(this.eventRegx);
        if (matches) {
            const efisEvent = efisEventMap[matches[1]];
            if (efisEvent) {
                this.publish(`EFIS.${efisEvent}`, undefined, false, false);
                return true;
            }
        }
        return false;
    }
}

const mapSettings = [
    {
        name: 'mapFormatMFD_1',
        defaultValue: 'MAP'
    },
    {
        name: 'mapFormatMFD_2',
        defaultValue: 'MAP'
    },
    {
        name: 'mapRangePFD_1',
        defaultValue: 20
    },
    {
        name: 'mapRangeMFD_1',
        defaultValue: 10
    },
    {
        name: 'mapRangeMFD_2',
        defaultValue: 10
    },
    {
        name: 'tfcEnabledPFD',
        defaultValue: false
    },
    {
        name: 'tfcEnabledMFD_1',
        defaultValue: false
    },
    {
        name: 'tfcEnabledMFD_2',
        defaultValue: false
    },
    {
        name: 'terrWxStatePFD',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxStateMFD_1',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxStateMFD_2',
        defaultValue: 'OFF'
    },
    {
        name: 'mapWaypointsDisplayPFD',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapWaypointsDisplayMFD_1',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapWaypointsDisplayMFD_2',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'navAidLeftStateMFD_1',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidLeftStateMFD_2',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidRightStateMFD_1',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidRightStateMFD_2',
        defaultValue: 'VOR'
    },
    {
        name: 'mapPosShowPFD',
        defaultValue: false
    },
    {
        name: 'mapPosShowMFD_1',
        defaultValue: false
    },
    {
        name: 'mapPosShowMFD_2',
        defaultValue: false
    }
];
const mapSettingsPfdAliased = [
    {
        name: 'mapRange',
        defaultValue: 20
    },
    {
        name: 'tfcEnabled',
        defaultValue: false
    },
    {
        name: 'terrWxState',
        defaultValue: 'OFF'
    },
    {
        name: 'mapWaypointsDisplay',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapPosShow',
        defaultValue: false
    }
];
const mapSettingsMfdAliased = [
    {
        name: 'mapFormat',
        defaultValue: 'MAP'
    },
    {
        name: 'mapRange',
        defaultValue: 10
    },
    {
        name: 'tfcEnabled',
        defaultValue: false
    },
    {
        name: 'terrWxState',
        defaultValue: 'OFF'
    },
    {
        name: 'mapWaypointsDisplay',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'navAidLeftState',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidRightState',
        defaultValue: 'VOR'
    },
    {
        name: 'mapPosShow',
        defaultValue: false
    }
];
/** Utility class for retrieving map user setting managers. */
class MapUserSettings {
    /**
     * Retrieves a setting manager with all map user settings.
     * @param bus The event bus.
     * @returns A setting manager with all map user settings.
     */
    static getMasterManager(bus) {
        var _a;
        return (_a = MapUserSettings.INSTANCE_MASTER) !== null && _a !== void 0 ? _a : (MapUserSettings.INSTANCE_MASTER = new DefaultUserSettingManager(bus, mapSettings));
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Retrieves a setting manager with aliased map user settings specific to the PFD or MFD.
     * @param bus The event bus.
     * @param pfdOrMfd Whether to get the PFD or MFD setting manager.
     * @param index The map side index.
     * @returns A setting manager with aliased map user settings specific to the PFD or MFD.
     */
    static getAliasedManager(bus, pfdOrMfd, index) {
        return (pfdOrMfd === 'PFD' ? MapUserSettings.getPfdManager(bus) : MapUserSettings.getMfdManager(bus, index));
    }
    /**
     * Retrieves a setting manager with aliased PFD map user settings.
     * @param bus The event bus.
     * @returns A setting manager with aliased PFD map user settings.
     */
    static getPfdManager(bus) {
        if (MapUserSettings.INSTANCE_PFD === undefined) {
            MapUserSettings.INSTANCE_PFD = new AliasedUserSettingManager(bus, mapSettingsPfdAliased);
            MapUserSettings.INSTANCE_PFD.useAliases(MapUserSettings.getMasterManager(bus), {
                tfcEnabled: 'tfcEnabledPFD',
                terrWxState: 'terrWxStatePFD',
                mapWaypointsDisplay: 'mapWaypointsDisplayPFD',
                mapRange: 'mapRangePFD_1',
                mapPosShow: 'mapPosShowPFD',
            });
        }
        return MapUserSettings.INSTANCE_PFD;
    }
    /**
     * Retrieves a setting manager with aliased MFD map user settings.
     * @param bus The event bus.
     * @param index The MFD side index.
     * @returns A setting manager with aliased MFD map user settings.
     */
    static getMfdManager(bus, index) {
        if (MapUserSettings.INSTANCES_MFD[index] === undefined) {
            MapUserSettings.INSTANCES_MFD[index] = new AliasedUserSettingManager(bus, mapSettingsMfdAliased);
            MapUserSettings.INSTANCES_MFD[index].useAliases(MapUserSettings.getMasterManager(bus), {
                mapFormat: `mapFormatMFD_${index}`,
                tfcEnabled: `tfcEnabledMFD_${index}`,
                terrWxState: `terrWxStateMFD_${index}`,
                mapWaypointsDisplay: `mapWaypointsDisplayMFD_${index}`,
                mapRange: `mapRangeMFD_${index}`,
                navAidLeftState: `navAidLeftStateMFD_${index}`,
                navAidRightState: `navAidRightStateMFD_${index}`,
                mapPosShow: `mapPosShowMFD_${index}`,
            });
        }
        return MapUserSettings.INSTANCES_MFD[index];
    }
}
MapUserSettings.INSTANCES_MFD = [];
MapUserSettings.mapFormatsMFD = ['MAP', 'MAPCTR', 'VOR', 'VORCTR', 'APP', 'APPCTR', 'PLAN'];
MapUserSettings.terrWxStates = ['OFF', 'TERR', 'WX'];
MapUserSettings.mapRanges = [0.25, 0.5, 1, 2, 5, 10, 20, 40, 80, 160, 320, 640, 1280];

const mapModeKnobValues = ['APP', 'VOR', 'MAP', 'PLAN'];
const navAidSwitchValues = ['VOR', 'OFF', 'ADF'];
/**
 * Controller that handles EFIS events meant for the navigation display.
 */
class EfisNdController {
    /**
     * Ctor.
     * @param bus The event bus.
     * @param sideIndex The side index.
     */
    constructor(bus, sideIndex) {
        this.bus = bus;
        this.sideIndex = sideIndex;
        this.settings = MapUserSettings.getMfdManager(this.bus, this.sideIndex);
        /**
         * Handles events for the STA, ARPT, WPT, etc buttons.
         * @param flagsToChange which flags to change for this event.
         * @returns event handler
         */
        this.handleMapWptDisplayEvent = (flagsToChange) => () => {
            const mapWptDisplaySetting = this.settings.getSetting('mapWaypointsDisplay');
            const currentFlags = mapWptDisplaySetting.get();
            const isEnabled = BitFlags.isAny(currentFlags, flagsToChange);
            const newFlags = BitFlags.set(currentFlags, isEnabled ? 0 : flagsToChange, flagsToChange);
            mapWptDisplaySetting.set(newFlags);
        };
        /**
         * Handles the nav aid switch events.
         * @param leftOrRight which switch this is for.
         * @returns event handler
         */
        this.handleNavAidSwitchEvent = (leftOrRight) => (newNavAidSwitchIndex) => {
            this.settings.getSetting(`navAid${leftOrRight}State`)
                .set(navAidSwitchValues[newNavAidSwitchIndex]);
        };
        const efisSub = bus.getSubscriber();
        efisSub.on('EFIS.ND_CTR').handle(this.handleCtrEvent.bind(this));
        efisSub.on('EFIS.WXR').handle(this.handleWxrEvent.bind(this));
        efisSub.on('EFIS.TFC').handle(this.handleTfcEvent.bind(this));
        efisSub.on('EFIS.TERR').handle(this.handleTerrEvent.bind(this));
        efisSub.on('EFIS.STA').handle(this.handleMapWptDisplayEvent(MapWaypointsDisplay.HiNavaids | MapWaypointsDisplay.LoNavaids | MapWaypointsDisplay.NDBs).bind(this));
        efisSub.on('EFIS.WPT').handle(this.handleMapWptDisplayEvent(MapWaypointsDisplay.Intersections).bind(this));
        efisSub.on('EFIS.ARPT').handle(this.handleMapWptDisplayEvent(MapWaypointsDisplay.Airports).bind(this));
        efisSub.on('EFIS.DATA').handle(this.handleMapWptDisplayEvent(MapWaypointsDisplay.ETA | MapWaypointsDisplay.Altitude).bind(this));
        efisSub.on('EFIS.POS').handle(this.handlePosEvent.bind(this));
        const sub = this.bus.getSubscriber();
        sub.on(`nd_map_mode_${sideIndex}`).handle(this.handleMapFormatChange.bind(this));
        sub.on(`nd_map_range_${sideIndex}`).handle(this.handleRangeChangeEvents.bind(this));
        sub.on(`nd_nav_aid_left_${sideIndex}`).handle(this.handleNavAidSwitchEvent('Left').bind(this));
        sub.on(`nd_nav_aid_right_${sideIndex}`).handle(this.handleNavAidSwitchEvent('Right').bind(this));
    }
    /** Sets simvars from the settings on load. */
    initLVarsFromSettings() {
        SimVar.SetSimVarValue(`L:B747_8_MFD_${this.sideIndex}_NAV_MODE`, SimVarValueType.Number, mapModeKnobValues.indexOf(this.settings.getSetting('mapFormat').get().replace('CTR', '')));
        SimVar.SetSimVarValue(`L:B747_8_MFD_${this.sideIndex}_Range`, SimVarValueType.Number, MapUserSettings.mapRanges.indexOf(this.settings.getSetting('mapRange').get()));
        const leftOrRight = this.sideIndex === 1 ? 'L' : 'R';
        SimVar.SetSimVarValue(`L:XMLVAR_NAV_AID_SWITCH_${leftOrRight}1_State`, SimVarValueType.Number, navAidSwitchValues.indexOf(this.settings.getSetting('navAidLeftState').get()));
        SimVar.SetSimVarValue(`L:XMLVAR_NAV_AID_SWITCH_${leftOrRight}2_State`, SimVarValueType.Number, navAidSwitchValues.indexOf(this.settings.getSetting('navAidRightState').get()));
    }
    /**
     * Handles map format change event.
     * @param newFormatIndex the new map format index.
     */
    handleMapFormatChange(newFormatIndex) {
        let newFormat = mapModeKnobValues[newFormatIndex];
        const formatSetting = this.settings.getSetting('mapFormat');
        const currentFormat = formatSetting.get();
        // If a CTR format is currently selected, then use the CTR version of the new format, if not PLN
        if (currentFormat.includes('CTR') && newFormat !== 'PLAN') {
            newFormat += 'CTR';
        }
        formatSetting.set(newFormat);
    }
    /**
     * Handles range change events for the ND.
     * @param newRangeIndex the selected range.
     */
    handleRangeChangeEvents(newRangeIndex) {
        const newRange = MapUserSettings.mapRanges[newRangeIndex];
        this.settings.getSetting('mapRange').set(newRange);
    }
    /** Handles the CTR event for the ND. */
    handleCtrEvent() {
        const mapFormatSetting = this.settings.getSetting('mapFormat');
        const format = mapFormatSetting.get();
        switch (format) {
            case 'MAP':
                mapFormatSetting.set('MAPCTR');
                return;
            case 'MAPCTR':
                mapFormatSetting.set('MAP');
                return;
            case 'VOR':
                mapFormatSetting.set('VORCTR');
                return;
            case 'VORCTR':
                mapFormatSetting.set('VOR');
                return;
            case 'APP':
                mapFormatSetting.set('APPCTR');
                return;
            case 'APPCTR':
                mapFormatSetting.set('APP');
                return;
        }
    }
    /** Handles the WXR event for the ND. */
    handleWxrEvent() {
        const terrWxState = this.settings.getSetting('terrWxState');
        terrWxState.set(terrWxState.get() === 'WX' ? 'OFF' : 'WX');
    }
    /** Handles the TFC event for the ND. */
    handleTfcEvent() {
        const tfcEnabled = this.settings.getSetting('tfcEnabled');
        tfcEnabled.set(!tfcEnabled.get());
    }
    /** Handles the TERR event for the ND. */
    handleTerrEvent() {
        const terrWxState = this.settings.getSetting('terrWxState');
        terrWxState.set(terrWxState.get() === 'TERR' ? 'OFF' : 'TERR');
    }
    /** Handles the POS event for the ND. */
    handlePosEvent() {
        const mapPosShow = this.settings.getSetting('mapPosShow');
        mapPosShow.set(!mapPosShow.get());
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/** Publishes events for the efis sim vars. */
class B748EfisSimVarPublisher extends SimVarPublisher {
    /**
     * Create a B748EfisSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(B748EfisSimVarPublisher.simvars, bus, pacer);
    }
}
B748EfisSimVarPublisher.simvars = new Map([
    ['nd_map_mode_1', { name: 'L:B747_8_MFD_1_NAV_MODE', type: SimVarValueType.Number }],
    ['nd_map_mode_2', { name: 'L:B747_8_MFD_2_NAV_MODE', type: SimVarValueType.Number }],
    ['nd_map_range_1', { name: 'L:B747_8_MFD_1_Range', type: SimVarValueType.Number }],
    ['nd_map_range_2', { name: 'L:B747_8_MFD_2_Range', type: SimVarValueType.Number }],
    ['nd_nav_aid_left_1', { name: 'L:XMLVAR_NAV_AID_SWITCH_L1_State', type: SimVarValueType.Number }],
    ['nd_nav_aid_right_1', { name: 'L:XMLVAR_NAV_AID_SWITCH_L2_State', type: SimVarValueType.Number }],
    ['nd_nav_aid_left_2', { name: 'L:XMLVAR_NAV_AID_SWITCH_R1_State', type: SimVarValueType.Number }],
    ['nd_nav_aid_right_2', { name: 'L:XMLVAR_NAV_AID_SWITCH_R2_State', type: SimVarValueType.Number }],
]);

/**
 * A class to emulate and publish APU values.
 */
class B748ApuDataInstrument {
    /**
     * Ctor
     * @param bus The event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.apuEgtTable = new LerpLookupTable([
            [0, 0], [240, 25], [479, 50], [453, 75], [406, 85], [356, 100]
        ]);
        this.apuEgtDownTable = new LerpLookupTable([
            [0, 0], [180, 25], [200, 50], [290, 75], [340, 85], [356, 100]
        ]);
        this.apuOilTempTable = new LerpLookupTable([
            [0, 0], [5, 25], [9, 50], [7, 75], [5, 85], [4, 100]
        ]);
        this.apuOilPressTable = new LerpLookupTable([
            [0, 0], [15, 25], [33, 50], [54, 75], [73, 85], [76, 100]
        ]);
        this.apuOilQuantityTable = new LerpLookupTable([
            [0, 0], [0.8, 25], [2.8, 50], [2.2, 75], [2.6, 85], [2.8, 100]
        ]);
        this.apuRpm = ConsumerValue.create(null, 0);
        this.ambientTempValue = ConsumerValue.create(null, 0);
        this.apuPub = this.bus.getPublisher();
        this.apuEgtRnd = this.getRandomModifier(1, 3);
        this.apuN2Rnd = this.getRandomModifier(850, 890);
        this.apuOilPressRnd = this.getRandomModifier(11, 16);
        this.apuOilTempRnd = this.getRandomModifier(9, 16);
        this.apuOilQtyRnd = this.getRandomModifier(18, 26) / 10;
        this.egtSmoother = new ExpSmoother(4500, 0);
        this.oilPressSmoother = new ExpSmoother(6000, 0);
        this.oilQtySmoother = new ExpSmoother(5000, 0);
        this.lastUpdate = 0;
        this.lastApuRpm = 0;
        this.clockSub = this.bus.getSubscriber();
        this.apuValues = ObjectSubject.create({
            apu_egt: 0,
            apu_n1: 0,
            apu_n2: 0,
            apu_oil_temp: 0,
            apu_oil_press: 0,
            apu_oil_qty: 0
        });
        // noop
    }
    /** @inheritdoc */
    init() {
        this.ambientTempValue.setConsumer(this.bus.getSubscriber().on('ambient_temp_c').whenChangedBy(1));
        this.apuRpm.setConsumer(this.bus.getSubscriber().on('apu_pct').withPrecision(1));
        this.clockSub.on('simTime').atFrequency(3).handle(this.updateMockValues.bind(this));
        this.apuValues.sub((obj, key, newValue) => {
            this.apuPub.pub(key, newValue, true, true);
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // inop
    }
    /**
     * Calculates and updates the APU's mock values.
     */
    updateMockValues() {
        const dt = Date.now() - this.lastUpdate;
        const rpm = this.apuRpm.get();
        const apuDown = rpm < this.lastApuRpm;
        // mock egt
        const egtTable = apuDown ? this.apuEgtDownTable : this.apuEgtTable;
        this.apuValues.set({
            apu_egt: this.egtSmoother.next(egtTable.get(rpm) + (this.ambientTempValue.get() - this.apuEgtRnd), dt),
            apu_n1: rpm,
            apu_n2: rpm * (this.apuN2Rnd * 0.001),
            apu_oil_temp: this.apuOilTempTable.get(rpm) + (this.ambientTempValue.get() + this.apuOilTempRnd),
            apu_oil_press: this.oilPressSmoother.next(this.apuOilPressTable.get(rpm) + this.apuOilPressRnd, dt),
            apu_oil_qty: this.oilQtySmoother.next(this.apuOilQuantityTable.get(rpm) + (this.apuOilQtyRnd), dt)
        });
        this.lastApuRpm = this.apuRpm.get();
        this.lastUpdate = Date.now();
    }
    /**
     * Gets a random integer between min and max
     * @param min The minimum value.
     * @param max The maximum value.
     * @returns A random integer between min and max.
     */
    getRandomModifier(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
}

/**
 * Possible Door status values in the B748
 */
var B74DoorStatus;
(function (B74DoorStatus) {
    B74DoorStatus[B74DoorStatus["BLANK"] = 0] = "BLANK";
    B74DoorStatus[B74DoorStatus["OPEN"] = 1] = "OPEN";
    B74DoorStatus[B74DoorStatus["MANUAL"] = 2] = "MANUAL";
    B74DoorStatus[B74DoorStatus["AUTO"] = 3] = "AUTO";
})(B74DoorStatus || (B74DoorStatus = {}));
/**
 * A class to emulate and publish Door status values.
 */
class B748DoorDataInstrument {
    /**
     * Constructor for B78DoorDataInstrument
     * @param bus The event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.doorPub = this.bus.getPublisher();
        this.doorPositionSub = this.bus.getSubscriber();
        this.brakeSub = this.bus.getSubscriber();
        this.engineSub = this.bus.getSubscriber();
        this.entry1LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_1l_position').whenChanged(), 0);
        this.entry1RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_1r_position').whenChanged(), 0);
        this.entry2LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_2l_position').whenChanged(), 0);
        this.entry2RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_2r_position').whenChanged(), 0);
        this.entry3LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_3l_position').whenChanged(), 0);
        this.entry3RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_3r_position').whenChanged(), 0);
        this.entry4LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_4l_position').whenChanged(), 0);
        this.entry4RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_4r_position').whenChanged(), 0);
        this.entry5LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_5l_position').whenChanged(), 0);
        this.entry5RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_5r_position').whenChanged(), 0);
        this.entryULPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_ul_position').whenChanged(), 0);
        this.entryURPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_ur_position').whenChanged(), 0);
        this.fwdCargoPosition = ConsumerSubject.create(this.doorPositionSub.on('cargo_fwd_position').whenChanged(), 0);
        this.aftCargoPosition = ConsumerSubject.create(this.doorPositionSub.on('cargo_aft_position').whenChanged(), 0);
        this.doorsManual = MappedSubject.create(([parkingBrakeOn, leftN1, rightN1]) => {
            return parkingBrakeOn && leftN1 < 2 && rightN1 < 2;
        }, ConsumerSubject.create(this.brakeSub.on('parking_brake_set').whenChanged(), true), ConsumerSubject.create(this.engineSub.on('n1_1').whenChanged().withPrecision(1), 0), ConsumerSubject.create(this.engineSub.on('n1_2').whenChanged().withPrecision(1), 0));
        // inop
    }
    /** @inheritdoc */
    init() {
        this.entry1LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_1l_status', this.doorsManual.get()));
        this.entry1RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_1r_status', this.doorsManual.get()));
        this.entry2LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_2l_status', this.doorsManual.get()));
        this.entry2RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_2r_status', this.doorsManual.get()));
        this.entry3LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_3l_status', this.doorsManual.get()));
        this.entry3RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_3r_status', this.doorsManual.get()));
        this.entry4LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_4l_status', this.doorsManual.get()));
        this.entry4RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_4r_status', this.doorsManual.get()));
        this.entry5LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_5l_status', this.doorsManual.get()));
        this.entry5RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_5r_status', this.doorsManual.get()));
        this.entryULPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_ul_status', this.doorsManual.get()));
        this.entryURPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_ur_status', this.doorsManual.get()));
        this.fwdCargoPosition.sub(this.updateFwdCargoStatus.bind(this));
        this.aftCargoPosition.sub(this.updateAftCargoStatus.bind(this));
        this.doorsManual.sub(v => {
            this.updateEntryDoorStatus(this.entry1LPosition.get(), 'entry_1l_status', v);
            this.updateEntryDoorStatus(this.entry1RPosition.get(), 'entry_1r_status', v);
            this.updateEntryDoorStatus(this.entry2LPosition.get(), 'entry_2l_status', v);
            this.updateEntryDoorStatus(this.entry2RPosition.get(), 'entry_2r_status', v);
            this.updateEntryDoorStatus(this.entry3LPosition.get(), 'entry_3l_status', v);
            this.updateEntryDoorStatus(this.entry3RPosition.get(), 'entry_3r_status', v);
            this.updateEntryDoorStatus(this.entry4LPosition.get(), 'entry_4l_status', v);
            this.updateEntryDoorStatus(this.entry4RPosition.get(), 'entry_4r_status', v);
            this.updateEntryDoorStatus(this.entry5LPosition.get(), 'entry_5l_status', v);
            this.updateEntryDoorStatus(this.entry5RPosition.get(), 'entry_5r_status', v);
            this.updateEntryDoorStatus(this.entryULPosition.get(), 'entry_ul_status', v);
            this.updateEntryDoorStatus(this.entryURPosition.get(), 'entry_ur_status', v);
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // inop
    }
    /**
     * Publishes updated Entry door status to the bus
     * @param position the new door position
     * @param doorTopic the door event topic to publish
     * @param doorsManual whether doors should be set to manual (auto if false)
     */
    updateEntryDoorStatus(position, doorTopic, doorsManual) {
        this.doorPub.pub(doorTopic, position > 0 ? B74DoorStatus.OPEN : doorsManual ? B74DoorStatus.MANUAL : B74DoorStatus.AUTO, true, true);
    }
    /**
     * Publishes updated FwdCargo door status to the bus
     * @param position the new door position
     */
    updateFwdCargoStatus(position) {
        this.doorPub.pub('fwd_cargo_status', position > 0 ? B74DoorStatus.OPEN : B74DoorStatus.BLANK, true, true);
    }
    /**
     * Publishes updated AftCargo door status to the bus
     * @param position the new door position
     */
    updateAftCargoStatus(position) {
        this.doorPub.pub('aft_cargo_status', position > 0 ? B74DoorStatus.OPEN : B74DoorStatus.BLANK, true, true);
    }
}

/**
 * A publisher for Door Position information in the B748.
 */
class B748DoorPositionPublisher extends SimVarPublisher {
    /**
     * Create a B78DoorPositionPublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['entry_1l_position', { name: 'INTERACTIVE POINT OPEN:10', type: SimVarValueType.Number }],
            ['entry_1r_position', { name: 'INTERACTIVE POINT OPEN:11', type: SimVarValueType.Number }],
            ['entry_2l_position', { name: 'INTERACTIVE POINT OPEN:4', type: SimVarValueType.Number }],
            ['entry_2r_position', { name: 'INTERACTIVE POINT OPEN:5', type: SimVarValueType.Number }],
            ['entry_3l_position', { name: 'INTERACTIVE POINT OPEN:6', type: SimVarValueType.Number }],
            ['entry_3r_position', { name: 'INTERACTIVE POINT OPEN:7', type: SimVarValueType.Number }],
            ['entry_4l_position', { name: 'INTERACTIVE POINT OPEN:8', type: SimVarValueType.Number }],
            ['entry_4r_position', { name: 'INTERACTIVE POINT OPEN:9', type: SimVarValueType.Number }],
            ['entry_5l_position', { name: 'INTERACTIVE POINT OPEN:0', type: SimVarValueType.Number }],
            ['entry_5r_position', { name: 'INTERACTIVE POINT OPEN:1', type: SimVarValueType.Number }],
            ['entry_ul_position', { name: 'INTERACTIVE POINT OPEN:2', type: SimVarValueType.Number }],
            ['entry_ur_position', { name: 'INTERACTIVE POINT OPEN:3', type: SimVarValueType.Number }],
            ['cargo_fwd_position', { name: 'INTERACTIVE POINT OPEN:12', type: SimVarValueType.Number }],
            ['cargo_aft_position', { name: 'INTERACTIVE POINT OPEN:13', type: SimVarValueType.Number }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

const OPTIMAL_NOSE_GEAR_PRESSURE = 198;
const OPTIMAL_MAIN_GEAR_PRESSURE = 230;
const MAXIMUM_BRAKE_TEMPERATURE = 500;
/**
 * A class to emulate and publish Gear and Brakes related values.
 */
class B748GearDataInstrument {
    /** @inheritdoc */
    constructor(bus) {
        this.bus = bus;
        this.gearPub = this.bus.getPublisher();
        this.clock = this.bus.getSubscriber();
        this.controlEvents = this.bus.getSubscriber();
        this.adc = this.bus.getSubscriber();
        this.brakes = this.bus.getSubscriber();
        this.BASE_NOSE_PRESSURES = Array.from({ length: 2 }, () => OPTIMAL_NOSE_GEAR_PRESSURE + Math.floor(Math.random() * 6 - 3));
        this.BASE_MAIN_PRESSURES = Array.from({ length: 16 }, () => OPTIMAL_MAIN_GEAR_PRESSURE + Math.floor(Math.random() * 6 - 3));
        this.isOnGroundSubject = ConsumerSubject.create(this.adc.on('on_ground').whenChanged(), true);
        this.weightMultiplier = MappedSubject.create(([onGround]) => {
            if (onGround) {
                return 1;
            }
            const grossWeight = SimVar.GetSimVarValue('TOTAL WEIGHT', SimVarValueType.Pounds);
            return 1 - ((grossWeight / 987000) * 0.04);
        }, this.isOnGroundSubject);
        this.ambientPressure = ConsumerSubject.create(this.adc.on('ambient_pressure_inhg').atFrequency(0.1, true), 0);
        this.pressureDifferential = MappedSubject.create(([p]) => 14.7 - p / 2.036, this.ambientPressure);
        this.ambientTempSubject = ConsumerSubject.create(this.adc.on('ambient_temp_c').atFrequency(0.1, true), 21.1);
        this.tempMultiplier = MappedSubject.create(([temp]) => (100 + ((temp - 21.1) * 0.4 / 2.8)) / 100, this.ambientTempSubject);
        this.gearPositionSubject = [
            ConsumerSubject.create(this.controlEvents.on('gear_position_0').withPrecision(2), 1),
            ConsumerSubject.create(this.controlEvents.on('gear_position_1').withPrecision(2), 1),
            ConsumerSubject.create(this.controlEvents.on('gear_position_2').withPrecision(2), 1),
        ];
        /* BRAKES */
        this.previousTimestamp = -1;
        // TODO: Wire hydraulic pressure if system is available
        this.hydraulicPressure = Subject.create(4999);
        this.leftBrakePressure = MappedSubject.create(([hydPressure, brakeInput]) => {
            return hydPressure * brakeInput;
        }, this.hydraulicPressure, ConsumerSubject.create(this.brakes.on('brake_position_left').atFrequency(5), 0));
        this.rightBrakePressure = MappedSubject.create(([hydPressure, brakeInput]) => {
            return hydPressure * brakeInput;
        }, this.hydraulicPressure, ConsumerSubject.create(this.brakes.on('brake_position_right').atFrequency(5), 0));
        this.oat = ConsumerValue.create(this.adc.on('ambient_temp_c')
            .atFrequency(1, true), SimVar.GetSimVarValue('AMBIENT TEMPERATURE', SimVarValueType.Celsius));
        this.leftWheelRpm = ConsumerValue.create(this.brakes.on('left_wheel_rpm').atFrequency(5), 0);
        this.rightWheelRpm = ConsumerValue.create(this.brakes.on('right_wheel_rpm').atFrequency(5), 0);
        this.previousValues = [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]];
        this.leftBrakeTemps = Array.from({ length: 8 }, () => new TemperatureSystem(600));
        this.rightBrakeTemps = Array.from({ length: 8 }, () => new TemperatureSystem(600));
        // inop
    }
    /** @inheritdoc */
    init() {
        this.initializeSimulatingTirePressures();
        this.initializeGearDoorStatusUpdates();
        this.setInitialBrakeTemps();
        this.clock.on('simTime').atFrequency(5).handle(this.updateBrakes.bind(this));
    }
    /** @inheritdoc */
    onUpdate() {
        // inop
    }
    /**
     * Generates randomized tire pressures with updates for temperature and pressure changes, and weight on wheels
     * @private
     */
    initializeSimulatingTirePressures() {
        MappedSubject.create(this.pressureDifferential, this.tempMultiplier, this.weightMultiplier)
            .sub(([pressureDiff, tempMultiplier, weightMultiplier]) => {
            this.gearPub.pub('nose_tire_pressures', this.BASE_NOSE_PRESSURES.map(p => Math.floor((p + pressureDiff) * tempMultiplier * weightMultiplier)), true);
            this.gearPub.pub('main_tire_pressures', this.BASE_MAIN_PRESSURES.map(p => Math.floor((p + pressureDiff) * tempMultiplier * weightMultiplier)), true);
        }, true);
    }
    /**
     * Creates subscription for the gear door statuses
     * @private
     */
    initializeGearDoorStatusUpdates() {
        this.gearPositionSubject[0].sub(value => this.gearPub.pub('nose_gear_door_closed', !(value > 0 && value < 1), true));
        this.gearPositionSubject[1].sub(value => this.gearPub.pub('left_main_gear_door_closed', !(value > 0 && value < 1), true));
        this.gearPositionSubject[2].sub(value => this.gearPub.pub('right_main_gear_door_closed', !(value > 0 && value < 1), true));
    }
    /* BRAKE TEMPERATURE SIMULATION */
    /**
     * Initializes brake temperatures to equal the outside temperature
     * @private
     */
    setInitialBrakeTemps() {
        const oat = this.oat.get();
        const left = this.leftBrakeTemps.map(sys => {
            this.initializeBrakeSystem(sys, oat);
            return this.mapTemperatureToDisplayNumber(oat);
        });
        const right = this.rightBrakeTemps.map(sys => {
            this.initializeBrakeSystem(sys, oat);
            return this.mapTemperatureToDisplayNumber(oat);
        });
        this.previousValues = [left, right];
        this.gearPub.pub('left_main_gear_brake_temps', left, true);
        this.gearPub.pub('right_main_gear_brake_temps', right, true);
    }
    /**
     * Updates brake temperatures and publishes them to the
     * @param timestamp the current timestamp
     * @private
     */
    updateBrakes(timestamp) {
        if (this.previousTimestamp === -1) {
            this.previousTimestamp = timestamp;
        }
        const deltaTime = MathUtils.clamp(timestamp - this.previousTimestamp, 0, 10000);
        const oat = this.oat.get();
        const leftWheelRpm = this.leftWheelRpm.get();
        const rightWheelRpm = this.rightWheelRpm.get();
        const left = this.leftBrakeTemps.map(sys => {
            this.updateBrakeTemperature(sys, oat, leftWheelRpm, this.leftBrakePressure.get(), deltaTime);
            return this.mapTemperatureToDisplayNumber(sys.value.get());
        });
        if (this.previousValues[0].some((v, i) => left[i] !== v)) {
            this.gearPub.pub('left_main_gear_brake_temps', left, true);
            this.previousValues[0] = left;
        }
        const right = this.rightBrakeTemps.map(sys => {
            this.updateBrakeTemperature(sys, oat, rightWheelRpm, this.rightBrakePressure.get(), deltaTime);
            return this.mapTemperatureToDisplayNumber(sys.value.get());
        });
        if (this.previousValues[1].some((v, i) => right[i] !== v)) {
            this.gearPub.pub('right_main_gear_brake_temps', right, true);
            this.previousValues[1] = right;
        }
        this.previousTimestamp = timestamp;
    }
    /**
     * Updates brake temperature in the TemperatureSystem
     * @param system a TemperatureSystem
     * @param oat the outside air temperature
     * @param rpm wheel rpm
     * @param pressure brake pressure in psi
     * @param deltaTime elapsed time
     * @private
     */
    updateBrakeTemperature(system, oat, rpm, pressure, deltaTime) {
        system.setSourceTemp(0, oat);
        system.setSourceTemp(1, this.getPadTemp(rpm, pressure, oat, system));
        system.setSourceConductivity(0, MathUtils.clamp(Math.max(rpm, 1) / 80 + (Math.random() * 5 - 2.5), 2, 40));
        system.setSourceConductivity(1, MathUtils.clamp(Math.max(rpm, 1) / 40 + (Math.random() * 10 - 5), 2, 60));
        system.update(deltaTime);
    }
    /**
     * Initializes brake temperature system with the given temperature
     * @param system the TemperatureSystem
     * @param temp a temperature
     * @private
     */
    initializeBrakeSystem(system, temp) {
        system.addSource({ temperature: temp, conductivity: 200 });
        system.addSource({ temperature: temp, conductivity: 200 });
        system.set(temp);
    }
    /**
     * Utility function to calculate display value
     * @param temp new temperature
     * @returns number to display in system synoptics (MFD SYS)
     * @private
     */
    mapTemperatureToDisplayNumber(temp) {
        return MathUtils.clamp(temp < 40 ? 0 : ((temp - 40) / (MAXIMUM_BRAKE_TEMPERATURE - 40)) * 10, 0, 9.9);
    }
    /**
     * Gets the brake pad temp given a wheelspeed and brake pressure.
     * @param rpm The wheel speed.
     * @param pressure The brake pressure in psi.
     * @param oat The outside air temperature.
     * @param tempSystem The temperature system to which this pad temp is being applied.
     * @returns A brake pad temp.
     */
    getPadTemp(rpm, pressure, oat, tempSystem) {
        let spread = 1000 - oat;
        if (pressure > 1500) {
            spread = 1250 - oat;
        }
        else if (pressure > 4000) {
            spread = 1350 - oat;
        }
        let rpmCoefficient = 0;
        if (rpm >= 1) {
            rpmCoefficient = MathUtils.clamp(rpm / 1000, 0.3, 1);
        }
        const addTemp = spread * MathUtils.clamp(pressure / 5000, 0, 1) * rpmCoefficient;
        return rpm < 1 ? oat : Math.max(oat + addTemp, tempSystem.value.get());
    }
}

/**
 * Boeing 747-8 MFD side selections.
 */
var MFD_SIDE_SELECT;
(function (MFD_SIDE_SELECT) {
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["LEFT"] = 0] = "LEFT";
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["RIGHT"] = 1] = "RIGHT";
})(MFD_SIDE_SELECT || (MFD_SIDE_SELECT = {}));
/**
 * Boeing 747 transponder modes.
 */
var B74_XPDR_MODE;
(function (B74_XPDR_MODE) {
    B74_XPDR_MODE[B74_XPDR_MODE["STBY"] = 0] = "STBY";
    B74_XPDR_MODE[B74_XPDR_MODE["ON"] = 1] = "ON";
    B74_XPDR_MODE[B74_XPDR_MODE["TA_Only"] = 2] = "TA_Only";
    B74_XPDR_MODE[B74_XPDR_MODE["TA_RA"] = 3] = "TA_RA";
})(B74_XPDR_MODE || (B74_XPDR_MODE = {}));
/**
 * Boeing 747-8 hydraulic pump states
 */
var B74_HYDRAULIC_PUMP_MODE;
(function (B74_HYDRAULIC_PUMP_MODE) {
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["OFF"] = 0] = "OFF";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["AUTO"] = 1] = "AUTO";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["ON"] = 2] = "ON";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["AUX"] = 3] = "AUX";
})(B74_HYDRAULIC_PUMP_MODE || (B74_HYDRAULIC_PUMP_MODE = {}));
/**
 * Boeing 747-8 standby power knob states.
 */
var StandbyPowerKnobState;
(function (StandbyPowerKnobState) {
    StandbyPowerKnobState[StandbyPowerKnobState["Off"] = 0] = "Off";
    StandbyPowerKnobState[StandbyPowerKnobState["Auto"] = 1] = "Auto";
    StandbyPowerKnobState[StandbyPowerKnobState["Batt"] = 2] = "Batt";
})(StandbyPowerKnobState || (StandbyPowerKnobState = {}));
/**
 * Boeing 747-8 IRS knob states.
 */
var IrsKnobState;
(function (IrsKnobState) {
    IrsKnobState[IrsKnobState["Off"] = 0] = "Off";
    IrsKnobState[IrsKnobState["Align"] = 1] = "Align";
    IrsKnobState[IrsKnobState["Nav"] = 2] = "Nav";
    IrsKnobState[IrsKnobState["Att"] = 3] = "Att";
})(IrsKnobState || (IrsKnobState = {}));
/**
 * Boeing 747-8 IRS source select knob states.
 */
var IrsSourceKnobState;
(function (IrsSourceKnobState) {
    IrsSourceKnobState[IrsSourceKnobState["Left"] = 0] = "Left";
    IrsSourceKnobState[IrsSourceKnobState["Center"] = 1] = "Center";
    IrsSourceKnobState[IrsSourceKnobState["Right"] = 2] = "Right";
    IrsSourceKnobState[IrsSourceKnobState["Auto"] = 3] = "Auto";
})(IrsSourceKnobState || (IrsSourceKnobState = {}));
/**
 * A publisher for 787 Cockpit Variables or Events.
 */
class CockpitVarsPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of CockpitVarsPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(new Map([
            ['b74_minimums_mode', { name: 'L:XMLVAR_Mins_Selector_Baro', type: SimVarValueType.Number }],
            ['pilot_transmitting', { name: 'PILOT TRANSMITTING', type: SimVarValueType.Bool }],
            ['b74_xpdr_mode', { name: 'L:XMLVAR_Transponder_Mode', type: SimVarValueType.Number }],
            ['b74_stby_power_mode', { name: 'L:XMLVAR_StandbyPower_Selector', type: SimVarValueType.Number }],
            ['b74_hyd_pump', { name: 'L:XMLVAR_HYDRAULICS_DEMAND_#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['mfd_side_select', { name: 'L:XMLVAR_MFD_Side_#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['baro_ref_hpa', { name: 'L:XMLVAR_Baro_Selector_HPA_#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_irs_knob_state', { name: 'L:B748_IRS_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['b74_irs_source_knob_state', { name: 'L:B748_IRS_Source_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b74_elec_bus_1_connection_on', { name: 'L:XMLVAR_Bus1ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_2_connection_on', { name: 'L:XMLVAR_Bus2ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_3_connection_on', { name: 'L:XMLVAR_Bus3ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_4_connection_on', { name: 'L:XMLVAR_Bus4ToMain_Connected', type: SimVarValueType.Bool }],
        ]), bus);
    }
}

const LVAR_AC_BUS_ENERGIZED = 'L:B74_AC_BUS_ENERGIZED';
/**
 * The B748 electrical system.
 */
class B748ElectricalSystem {
    /**
     * Ctor
     * @param bus The event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.elecSub = this.bus.getSubscriber();
        this.engSub = this.bus.getSubscriber();
        this.cVarSub = this.bus.getSubscriber();
        this.isAcBusEnergized = Subject.create(false);
        this.isApuStarted = Subject.create(false);
        this.apuStartedTimer = new DebounceTimer();
        this.isEng1Running = Subject.create(false);
        this.isEng2Running = Subject.create(false);
        this.isEng3Running = Subject.create(false);
        this.isEng4Running = Subject.create(false);
        // noop
    }
    /** @inheritdoc */
    init() {
        const isExtPwrOn = MappedSubject.create(([a1, o1, a2, o2]) => {
            return a1 && o1 || a2 && o2;
        }, ConsumerSubject.create(this.elecSub.on('elec_ext_power_available_1').whenChanged(), false), ConsumerSubject.create(this.elecSub.on('elec_ext_power_on_1').whenChanged(), false), ConsumerSubject.create(this.elecSub.on('elec_ext_power_available_2').whenChanged(), false), ConsumerSubject.create(this.elecSub.on('elec_ext_power_on_2').whenChanged(), false));
        const isGensPowered = MappedSubject.create(([g1, g2, g3, g4, g5, g6]) => {
            return g1 > 1 || g2 > 1 || g3 > 1 || g4 > 1 || g5 > 1 || g6 > 1;
        }, ConsumerSubject.create(this.elecSub.on('elec_bus_genalt_1_a').whenChangedBy(1), 0), ConsumerSubject.create(this.elecSub.on('elec_bus_genalt_2_a').whenChangedBy(1), 0), ConsumerSubject.create(this.elecSub.on('elec_bus_genalt_3_a').whenChangedBy(1), 0), ConsumerSubject.create(this.elecSub.on('elec_bus_genalt_4_a').whenChangedBy(1), 0), ConsumerSubject.create(this.elecSub.on('elec_bus_genalt_5_a').whenChangedBy(1), 0), ConsumerSubject.create(this.elecSub.on('elec_bus_genalt_6_a').whenChangedBy(1), 0));
        const isAcPowered = MappedSubject.create(([ext, gens]) => {
            return ext || gens;
        }, isExtPwrOn, isGensPowered);
        // check if ac bus is energized
        isAcPowered.sub((v) => {
            SimVar.SetSimVarValue(LVAR_AC_BUS_ENERGIZED, SimVarValueType.Bool, v);
            this.isAcBusEnergized.set(v);
        }, true);
        const isStbyOnBat = MappedSubject.create(([hasAc, standbyBat]) => {
            return (!hasAc && standbyBat === StandbyPowerKnobState.Auto) || standbyBat === StandbyPowerKnobState.Batt;
        }, this.isAcBusEnergized, ConsumerSubject.create(this.cVarSub.on('b74_stby_power_mode'), 0));
        KeyEventManager.getManager(this.bus).then((manager) => {
            this.isAcBusEnergized.sub((v) => {
                // connect/disconnect acdc bus based on ac power state
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 1, Number(v), 0);
            }, true);
            isStbyOnBat.sub((v) => {
                // connect/disconnect standby bus and ac3 based on ac power and stby power state
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 8, Number(!v), 0);
            }, true);
            // check if apu is fully started
            this.engSub.on('apu_pct').whenChangedBy(1).handle((v) => {
                if (v < 95) {
                    this.apuStartedTimer.clear();
                    this.isApuStarted.set(false);
                }
                else if (this.apuStartedTimer.isPending() === false) {
                    this.apuStartedTimer.schedule(() => {
                        this.isApuStarted.set(true);
                    }, 2000);
                }
            });
            this.engSub.on('n1_1').whenChangedBy(1).handle((v) => {
                this.isEng1Running.set(v > B748ElectricalSystem.MIN_N1_THRESHOLD);
            });
            this.engSub.on('n1_2').whenChangedBy(1).handle((v) => {
                this.isEng2Running.set(v > B748ElectricalSystem.MIN_N1_THRESHOLD);
            });
            this.engSub.on('n1_3').whenChangedBy(1).handle((v) => {
                this.isEng3Running.set(v > B748ElectricalSystem.MIN_N1_THRESHOLD);
            });
            this.engSub.on('n1_4').whenChangedBy(1).handle((v) => {
                this.isEng4Running.set(v > B748ElectricalSystem.MIN_N1_THRESHOLD);
            });
            // toggle apu gen breakers based on apu state
            this.isApuStarted.sub((apuStarted) => {
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 2, Number(apuStarted), 0);
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 3, Number(apuStarted), 0);
            }, true);
            // toggle eng gen breakers based on eng state
            this.isEng1Running.sub((eng1Running) => {
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 4, Number(eng1Running), 0);
            }, true);
            this.isEng2Running.sub((eng2Running) => {
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 5, Number(eng2Running), 0);
            }, true);
            this.isEng3Running.sub((eng2Running) => {
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 6, Number(eng2Running), 0);
            }, true);
            this.isEng4Running.sub((eng2Running) => {
                manager.triggerKey('ELECTRICAL_EXECUTE_PROCEDURE', true, 7, Number(eng2Running), 0);
            }, true);
            // toggle circuits
            // this.cVarSub.on('b78_elec_ife_seats').whenChanged().handle((v) => {
            //   this.toggleCircuit(91, v);
            // });
            // this.cVarSub.on('b78_elec_cabin_util').whenChanged().handle((v) => {
            //   this.toggleCircuit(92, v);
            // });
        });
    }
    /**
     * Toggles a circuit
     * @param circuit The circuit to toggle
     * @param state The state to set
     */
    toggleCircuit(circuit, state) {
        const isOn = SimVar.GetSimVarValue(`CIRCUIT SWITCH ON:${circuit}`, SimVarValueType.Number) === 1;
        if (isOn !== state) {
            SimVar.SetSimVarValue('K:ELECTRICAL_CIRCUIT_TOGGLE', SimVarValueType.Number, circuit);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
}
B748ElectricalSystem.MIN_N1_THRESHOLD = 16;

/**
 * The B74 hydraulics system.
 */
class B748HydraulicsSystem {
    /**
     * Ctor
     * @param bus The event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.hydSub = this.bus.getSubscriber();
        this.miscSub = this.bus.getSubscriber();
        this.cvarSub = this.bus.getSubscriber();
        this.clockSub = this.bus.getSubscriber();
        this.isOnGround = ConsumerValue.create(this.miscSub.on('on_ground').whenChanged(), false);
        this.isFlapsInMotion = false;
        this.isFlapsExtendedPast1 = false;
        this.isFlapsExtendedPast20 = false;
        this.flapsInMotionTimeout = new DebounceTimer();
        this.flapsPosition = ConsumerSubject.create(this.miscSub.on('flap_computer_interpolated_position').withPrecision(1), 0);
        this.demandPumps = [
            {
                pumpId: 5,
                switchState: ConsumerValue.create(this.hydSub.on('hyd_pump_switch_state_5').whenChanged(), false),
                circuitPressure: ConsumerValue.create(this.hydSub.on('hyd_pressure_1').whenChanged(), 0),
                selector: ConsumerValue.create(this.cvarSub.on('b74_hyd_pump_1').whenChanged(), B74_HYDRAULIC_PUMP_MODE.OFF),
                fuelValveSwitchState: ConsumerValue.create(this.miscSub.on('fuel_system_valve_switch_5').whenChanged(), false)
            },
            {
                pumpId: 6,
                switchState: ConsumerValue.create(this.hydSub.on('hyd_pump_switch_state_6').whenChanged(), false),
                circuitPressure: ConsumerValue.create(this.hydSub.on('hyd_pressure_2').whenChanged(), 0),
                selector: ConsumerValue.create(this.cvarSub.on('b74_hyd_pump_2').whenChanged(), B74_HYDRAULIC_PUMP_MODE.OFF),
                fuelValveSwitchState: ConsumerValue.create(this.miscSub.on('fuel_system_valve_switch_6').whenChanged(), false)
            },
            {
                pumpId: 7,
                switchState: ConsumerValue.create(this.hydSub.on('hyd_pump_switch_state_7').whenChanged(), false),
                circuitPressure: ConsumerValue.create(this.hydSub.on('hyd_pressure_3').whenChanged(), 0),
                selector: ConsumerValue.create(this.cvarSub.on('b74_hyd_pump_3').whenChanged(), B74_HYDRAULIC_PUMP_MODE.OFF),
                fuelValveSwitchState: ConsumerValue.create(this.miscSub.on('fuel_system_valve_switch_7').whenChanged(), false)
            },
            {
                pumpId: 8,
                switchState: ConsumerValue.create(this.hydSub.on('hyd_pump_switch_state_8').whenChanged(), false),
                circuitPressure: ConsumerValue.create(this.hydSub.on('hyd_pressure_4').whenChanged(), 0),
                selector: ConsumerValue.create(this.cvarSub.on('b74_hyd_pump_4').whenChanged(), B74_HYDRAULIC_PUMP_MODE.OFF),
                fuelValveSwitchState: ConsumerValue.create(this.miscSub.on('fuel_system_valve_switch_8').whenChanged(), false)
            }
        ];
    }
    /**
     * Toggles the state of the given pump in the simulator.
     * @param state The state to switch to.
     * @param pump The pump to switch.
     */
    switchSimPumpState(state, pump) {
        if (state !== pump.switchState.get()) {
            SimVar.SetSimVarValue('K:HYDRAULIC_SWITCH_TOGGLE', 'number', pump.pumpId);
        }
    }
    /** @inheritdoc */
    init() {
        this.clockSub.on('simTime').atFrequency(1).handle(this.updatePumps.bind(this));
        // run timeout when flaps are in motion
        const flapsInMotionReset = () => {
            this.isFlapsInMotion = false;
        };
        this.flapsPosition.sub((v) => {
            this.isFlapsInMotion = true;
            this.isFlapsExtendedPast1 = v > 1;
            this.isFlapsExtendedPast20 = v > 20;
            this.flapsInMotionTimeout.clear();
            this.flapsInMotionTimeout.schedule(flapsInMotionReset, 3000);
        }, true);
    }
    /**
     * Updates the state of the pumps.
     */
    updatePumps() {
        this.updateElecDemandPump(this.demandPumps[0], true);
        this.updateElecDemandPump(this.demandPumps[1], false);
        this.updateElecDemandPump(this.demandPumps[2], false);
        this.updateElecDemandPump(this.demandPumps[3], true);
    }
    /**
     * Updates the state of a demand pump.
     * @param pump The pump to update.
     * @param isOuterPump Whether the pump is an outer pump (1 and 4).
     */
    updateElecDemandPump(pump, isOuterPump) {
        if (pump.selector.get() !== B74_HYDRAULIC_PUMP_MODE.AUTO) {
            this.switchSimPumpState(pump.selector.get() === B74_HYDRAULIC_PUMP_MODE.ON, pump);
        }
        else {
            // if the pump is in demand mode, check if it should be switched
            const sysLowPressure = pump.circuitPressure.get() < 2500;
            let shouldUseDemand = sysLowPressure || !pump.fuelValveSwitchState.get();
            if (isOuterPump) {
                shouldUseDemand || (shouldUseDemand = this.isFlapsInMotion || (!this.isOnGround.get() && this.isFlapsExtendedPast1));
            }
            else {
                shouldUseDemand || (shouldUseDemand = !this.isOnGround.get() && this.isFlapsExtendedPast20);
            }
            this.switchSimPumpState(shouldUseDemand, pump);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
}

/**
 * The B748 fuel system.
 */
class B748FuelSystemInstrument {
    /**
     * Ctor
     * @param bus The event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.fuelPub = this.bus.getPublisher();
        this.engineSub = this.bus.getSubscriber();
        this.clockSub = this.bus.getSubscriber();
        // FUEL TEMP SIMULATION
        this.previousTimestamp = 0;
        this.fuelTemp = Subject.create(NaN);
        this.ramAirTemp = ConsumerValue.create(this.bus.getSubscriber().on('ram_air_temp_c').whenChanged(), 0);
        this.engine1FuelFlow = ConsumerValue.create(this.engineSub.on('fuel_flow_1').whenChanged(), 0);
        this.engine2FuelFlow = ConsumerValue.create(this.engineSub.on('fuel_flow_1').whenChanged(), 0);
        this.engine3FuelFlow = ConsumerValue.create(this.engineSub.on('fuel_flow_1').whenChanged(), 0);
        this.engine4FuelFlow = ConsumerValue.create(this.engineSub.on('fuel_flow_1').whenChanged(), 0);
        // noop
    }
    /** @inheritdoc */
    init() {
        this.clockSub.on('simTime').atFrequency(1 / 3).handle(this.updateFuelTemperature.bind(this));
        this.fuelTemp.sub((v) => {
            this.fuelPub.pub('fuel_temp', v, true, true);
        }, true);
    }
    /**
     * Updates the fuel temp value.
     * @param timestamp The current simtime timestamp.
     */
    updateFuelTemperature(timestamp) {
        this.setInitialFuelTemperature();
        if (this.previousTimestamp === -1) {
            this.previousTimestamp = timestamp;
        }
        let targetTemp = this.ramAirTemp.get();
        if (this.engine1FuelFlow.get() > 10 || this.engine2FuelFlow.get() > 10 || this.engine3FuelFlow.get() > 10 || this.engine4FuelFlow.get() > 10) {
            const lineTargetTemp = 28 + ((-40 - this.ramAirTemp.get()) * -0.1473);
            targetTemp += (lineTargetTemp - targetTemp) * 0.215;
        }
        // maximum deltaTime is higher than the frequency to allow sim rate changes
        const deltaTime = NavMath.clamp(timestamp - this.previousTimestamp, 0, 12000);
        const tankTc = 1 / 100;
        BoeingTemperatureUtils.adjustTemp(targetTemp, this.fuelTemp, tankTc, deltaTime);
        this.previousTimestamp = timestamp;
    }
    /**
     * Sets the initial temperatures if not already set.
     */
    setInitialFuelTemperature() {
        if (isNaN(this.fuelTemp.get())) {
            this.fuelTemp.set(this.ramAirTemp.get());
        }
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
}

/**
 * An instrument to emulate and publish 787 specific hydraulics events.
 */
class B748HydraulicsDataInstrument extends BoeingHydraulicDataInstrument {
    constructor() {
        super(...arguments);
        this.pub = this.bus.getPublisher();
        this.hydSystemSub = this.bus.getSubscriber();
        this.clockSub = this.bus.getSubscriber();
        this.ramAirTemp = ConsumerValue.create(this.bus.getSubscriber().on('ram_air_temp_c').whenChanged(), 0);
        this.previousTimestamp = 0;
        this.systemTemps = Array.from({ length: 4 }, () => Subject.create(NaN));
        this.systemPressures = [
            ConsumerValue.create(this.hydSystemSub.on('b748_hyd_pressure_1'), 0),
            ConsumerValue.create(this.hydSystemSub.on('b748_hyd_pressure_2'), 0),
            ConsumerValue.create(this.hydSystemSub.on('b748_hyd_pressure_3'), 0),
            ConsumerValue.create(this.hydSystemSub.on('b748_hyd_pressure_4'), 0)
        ];
    }
    /** @inheritdoc */
    init() {
        super.init();
        this.mapCircuitToTopic(v => this.pub.pub('b748_hyd_pressure_1', v, true, true), 1, 5);
        this.mapReservoirToTopic(v => this.pub.pub('b748_hyd_reservoir_1', v, true, true), 1, 5);
        this.mapCircuitToTopic(v => this.pub.pub('b748_hyd_pressure_2', v, true, true), 2, 6);
        this.mapReservoirToTopic(v => this.pub.pub('b748_hyd_reservoir_2', v, true, true), 2, 6);
        this.mapCircuitToTopic(v => this.pub.pub('b748_hyd_pressure_3', v, true, true), 3, 7);
        this.mapReservoirToTopic(v => this.pub.pub('b748_hyd_reservoir_3', v, true, true), 3, 7);
        this.mapCircuitToTopic(v => this.pub.pub('b748_hyd_pressure_4', v, true, true), 4, 8);
        this.mapReservoirToTopic(v => this.pub.pub('b748_hyd_reservoir_4', v, true, true), 4, 8);
        this.clockSub.on('simTime').atFrequency(1).handle(this.updateFluidTemperatures.bind(this));
        this.systemTemps.forEach((temp, i) => temp.sub(v => {
            this.pub.pub(`b748_hyd_temperature_${i + 1}`, MathUtils.round(v), true, true);
        }));
    }
    /**
     * Updates the hydraulic temp values.
     * @param timestamp The current simtime timestamp.
     */
    updateFluidTemperatures(timestamp) {
        this.setInitialFluidTemperatures();
        if (this.previousTimestamp === -1) {
            this.previousTimestamp = timestamp;
        }
        this.systemTemps.forEach((temp, i) => {
            const pressure = this.systemPressures[i].get();
            const ramAirTemp = this.ramAirTemp.get();
            const targetTemp = pressure > 500 ? Math.max(B748HydraulicsDataInstrument.TARGET_HYD_TEMP * (pressure / 3000), ramAirTemp) : ramAirTemp;
            // maximum deltaTime is higher than the frequency to allow sim rate changes
            const deltaTime = MathUtils.clamp(timestamp - this.previousTimestamp, 0, 4000);
            // quicker to heat up than to cool down
            const tankTc = temp.get() > targetTemp ? 1 / 10 : 1 / (Math.random() + 2.5);
            BoeingTemperatureUtils.adjustTemp(targetTemp, temp, tankTc, deltaTime);
        });
        this.previousTimestamp = timestamp;
    }
    /**
     * Sets the initial temperatures if not already set.
     */
    setInitialFluidTemperatures() {
        this.systemTemps.forEach(temp => {
            if (isNaN(temp.get())) {
                temp.set(this.ramAirTemp.get());
            }
        });
    }
}
/** The target optimal hydraulic fluid temperature when the system is operational,
 * accounting for the "randomization" based on the system pressure.
 * Based on https://www.youtube.com/watch?v=2dgzXFC0zhw */
B748HydraulicsDataInstrument.TARGET_HYD_TEMP = 72;

/** Class to manage the altitude alerter on the PFD Altimeter */
class B748AltitudeAlertController extends BoeingAltitudeAlertController {
    /** @inheritdoc */
    getIsApproachModeSubscribable() {
        return MappedSubject.create(([gearDown, flapPosition, approachFlapsSpeed, inApproachLock]) => {
            var _a;
            // if no landing flaps are selected, check for flaps full
            const landingFlaps = approachFlapsSpeed ? (_a = approachFlapsSpeed[0]) !== null && _a !== void 0 ? _a : 30 : 30;
            let isLandingFlapsSet;
            switch (landingFlaps) {
                case 25:
                    isLandingFlapsSet = flapPosition === 5;
                    break;
                case 30:
                default:
                    isLandingFlapsSet = flapPosition === 6;
            }
            return inApproachLock || (gearDown && isLandingFlapsSet);
        }, this.isGearDown, this.flapsPosition, this.performancePlan.approachFlapSpeed, this.inApproachLock);
    }
}

/**
 * B747-8 GENX-2B67 Engine Data Utility Class.
 */
class B748EngineData {
    /**
     * Creates an instance of B787 Engine Data
     * @param bus The Event Bus.
     * @param performanceData An instance of the BoeingPerformanceDataProvider.
     */
    constructor(bus, performanceData) {
        this.performanceData = performanceData;
        this.engineCount = 4;
        // 23.2 is best guess, and matches engines.cfg
        this.IDLE_N1 = 23.2;
        // 102.9 is the highest N1 value found in perf tables.
        // (This is still a best guess as to what maximum rated thrust means, we know max rated is below redline, based on the FCOM)
        this.MAX_RATED_N1 = 102.9;
        // 106 from the GEnx cert docs.
        this.RED_LINE_N1 = 106;
        // 58 is best guess from looking at videos.
        this.IDLE_N2 = 58;
        // 118 is pulled from the GEnx cert docs.
        this.RED_LINE_N2 = 118;
        // 750 comes from the GEnx cert docs.
        this.START_LIMIT_EGT = 750;
        // 1005 comes from GEnx cert docs, EGT Max Continuous max temp C
        this.CONTINUOUS_LIMIT_EGT = 1005;
        // 1040 comes from GEnx cert docs, 30 sec max transient temp C
        // (we used the highest egt limit in that table)
        this.RED_LINE_EGT = 1040;
        this.mach = ConsumerValue.create(null, 0);
        this.sat = ConsumerValue.create(null, 0);
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.mach.setConsumer(bus.getSubscriber().on('mach_number').withPrecision(2));
        this.sat.setConsumer(bus.getSubscriber().on('ambient_temp_c').withPrecision(0));
        this.pressureAlt.setConsumer(bus.getSubscriber().on('pressure_alt').withPrecision(0));
    }
    /** @inheritdoc */
    getMaxConN1(pressureAltitude, tat) {
        return B748EngineData.max_con_n1.get(tat, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMaxConTpr(pressureAltitude, tat) {
        return -1;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getToMaxTpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getToMaxN1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTo1Tpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getTo1N1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to1_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTo2Tpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getTo2N1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to2_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClbMaxTpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClbMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.clb_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClb1Tpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClb1N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 5% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxClb, mach);
        const derate = thrustScalar * 0.05 * (1 - MathUtils.clamp(pressureAltitude - 25000 / 8000, 0, 1));
        const deratedThrustScalar = thrustScalar - derate;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(deratedThrustScalar, mach);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClb2Tpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClb2N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 15% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxClb, mach);
        const derate = thrustScalar * 0.15 * (1 - MathUtils.clamp(pressureAltitude - 25000 / 8000, 0, 1));
        const deratedThrustScalar = thrustScalar - derate;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(deratedThrustScalar, mach);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getGaMaxTpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getGaMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.ga_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getCruiseMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.cru_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getOptimumAltitude(aircraftWeight) {
        return Math.min(B748EngineData.alt_opt.get(aircraftWeight), 41000);
    }
    /** @inheritdoc */
    getMaximumAltitude(aircraftWeight) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(this.pressureAlt.get());
        const isaTempC = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const isaDev = this.sat.get() - isaTempC;
        return Math.min(B748EngineData.alt_max.get(aircraftWeight, isaDev), 41000);
    }
    /** @inheritdoc */
    getLongRangeCruiseMach(aircraftWeight, pressureAltitude) {
        return B748EngineData.lrc_mach.get(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    getEconCruiseMach(aircraftWeight, pressureAltitude) {
        return 0.95 * this.getLongRangeCruiseMach(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTprFromN1(n1, tat, pressureAltitude) {
        return -1;
    }
    /** @inheritDoc */
    getTakeoffDeratePercentage(targetN1, maxN1) {
        const targetThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(targetN1, 0);
        const maxThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxN1, 0);
        return (maxThrustScalar - targetThrustScalar) / maxThrustScalar * 100;
    }
}
B748EngineData.to_n1_max = new LerpLookupTable([
    [89.7, 70, -2000], [90.1, 70, -1000], [90.6, 70, 0], [90.6, 70, 1000], [90.6, 70, 2000], [90.5, 70, 3000], [90.4, 70, 4000], [90.4, 70, 5000], [90.3, 70, 6000],
    [90.3, 70, 7000], [89.7, 70, 8000], [89.2, 70, 9000], [88.5, 70, 10000],
    [92.5, 60, -2000], [93, 60, -1000], [93.4, 60, 0], [93.4, 60, 1000], [93.4, 60, 2000], [93.3, 60, 3000], [93.3, 60, 4000], [93.2, 60, 5000], [93.2, 60, 6000],
    [93.2, 60, 7000], [92.6, 60, 8000], [92, 60, 9000], [91.4, 60, 10000],
    [93.9, 55, -2000], [94.4, 55, -1000], [94.8, 55, 0], [94.8, 55, 1000], [94.8, 55, 2000], [94.7, 55, 3000], [94.6, 55, 4000], [94.6, 55, 5000], [94.6, 55, 6000],
    [94.5, 55, 7000], [94, 55, 8000], [93.4, 55, 9000], [92.8, 55, 10000],
    [95.2, 50, -2000], [95.7, 50, -1000], [96.2, 50, 0], [96.1, 50, 1000], [96.1, 50, 2000], [96, 50, 3000], [96, 50, 4000], [95.9, 50, 5000], [95.9, 50, 6000],
    [95.9, 50, 7000], [95.3, 50, 8000], [94.7, 50, 9000], [94.2, 50, 10000],
    [96.5, 45, -2000], [97, 45, -1000], [97.5, 45, 0], [97.4, 45, 1000], [97.3, 45, 2000], [97.3, 45, 3000], [97.3, 45, 4000], [97.2, 45, 5000], [97.2, 45, 6000],
    [97.2, 45, 7000], [96.6, 45, 8000], [96, 45, 9000], [95.5, 45, 10000],
    [97.5, 40, -2000], [98.2, 40, -1000], [98.9, 40, 0], [98.7, 40, 1000], [98.5, 40, 2000], [98.4, 40, 3000], [98.4, 40, 4000], [98.5, 40, 5000], [98.4, 40, 6000],
    [98.4, 40, 7000], [97.9, 40, 8000], [97.3, 40, 9000], [96.7, 40, 10000],
    [97.8, 35, -2000], [98.9, 35, -1000], [99.8, 35, 0], [99.7, 35, 1000], [99.7, 35, 2000], [99.5, 35, 3000], [99.3, 35, 4000], [99.3, 35, 5000], [99.2, 35, 6000],
    [99.3, 35, 7000], [98.8, 35, 8000], [98.4, 35, 9000], [98, 35, 10000],
    [97.2, 30, -2000], [98.8, 30, -1000], [100.4, 30, 0], [100.4, 30, 1000], [100.4, 30, 2000], [100.4, 30, 3000], [100.4, 30, 4000], [100.1, 30, 5000], [100, 30, 6000],
    [99.9, 30, 7000], [99.5, 30, 8000], [99.2, 30, 9000], [98.8, 30, 10000],
    [96.4, 25, -2000], [98, 25, -1000], [99.6, 25, 0], [100.1, 25, 1000], [100.7, 25, 2000], [101.1, 25, 3000], [101.1, 25, 4000], [101.1, 25, 5000], [101.7, 25, 6000],
    [101.3, 25, 7000], [100.3, 25, 8000], [99.9, 25, 9000], [99.5, 25, 10000],
    [95.6, 20, -2000], [97.2, 20, -1000], [98.8, 20, 0], [99.3, 20, 1000], [99.9, 20, 2000], [100.5, 20, 3000], [101.1, 20, 4000], [101.8, 20, 5000], [102.2, 20, 6000],
    [102.4, 20, 7000], [102.1, 20, 8000], [101.5, 20, 9000], [100.3, 20, 10000],
    [94.8, 15, -2000], [96.3, 15, -1000], [97.9, 15, 0], [98.4, 15, 1000], [99, 15, 2000], [99.6, 15, 3000], [100.2, 15, 4000], [101, 15, 5000], [101.7, 15, 6000],
    [102.5, 15, 7000], [102.5, 15, 8000], [102.2, 15, 9000], [101.2, 15, 10000],
    [93.9, 10, -2000], [95.5, 10, -1000], [97.1, 10, 0], [97.6, 10, 1000], [98.2, 10, 2000], [98.8, 10, 3000], [99.4, 10, 4000], [100.1, 10, 5000], [100.8, 10, 6000],
    [101.6, 10, 7000], [101.8, 10, 8000], [102, 10, 9000], [102.3, 10, 10000],
    [93.1, 5, -2000], [94.7, 5, -1000], [96.2, 5, 0], [96.7, 5, 1000], [97.3, 5, 2000], [97.9, 5, 3000], [98.5, 5, 4000], [99.2, 5, 5000], [99.9, 5, 6000], [100.7, 5, 7000],
    [100.9, 5, 8000], [101.2, 5, 9000], [101.4, 5, 10000],
    [92.3, 0, -2000], [93.8, 0, -1000], [95.3, 0, 0], [95.8, 0, 1000], [96.4, 0, 2000], [97, 0, 3000], [97.6, 0, 4000], [98.3, 0, 5000], [99.1, 0, 6000], [99.8, 0, 7000],
    [100, 0, 8000], [100.3, 0, 9000], [100.6, 0, 10000],
    [90.6, -10, -2000], [92.1, -10, -1000], [93.6, -10, 0], [94.1, -10, 1000], [94.6, -10, 2000], [95.2, -10, 3000], [95.9, -10, 4000], [96.6, -10, 5000], [97.3, -10, 6000],
    [98, -10, 7000], [98.3, -10, 8000], [98.5, -10, 9000], [98.8, -10, 10000],
    [88.8, -20, -2000], [90.3, -20, -1000], [91.8, -20, 0], [92.3, -20, 1000], [92.8, -20, 2000], [93.4, -20, 3000], [94.1, -20, 4000], [94.8, -20, 5000], [95.5, -20, 6000],
    [96.3, -20, 7000], [96.5, -20, 8000], [96.7, -20, 9000], [97, -20, 10000],
    [87, -30, -2000], [88.5, -30, -1000], [89.9, -30, 0], [90.4, -30, 1000], [91, -30, 2000], [91.6, -30, 3000], [92.3, -30, 4000], [93, -30, 5000], [93.7, -30, 6000],
    [94.4, -30, 7000], [94.7, -30, 8000], [94.9, -30, 9000], [95.2, -30, 10000],
    [85.2, -40, -2000], [86.7, -40, -1000], [88.1, -40, 0], [88.6, -40, 1000], [89.1, -40, 2000], [89.8, -40, 3000], [90.5, -40, 4000], [91.2, -40, 5000], [91.9, -40, 6000],
    [92.6, -40, 7000], [92.8, -40, 8000], [93.1, -40, 9000], [93.4, -40, 10000],
    [83.4, -50, -2000], [84.8, -50, -1000], [86.2, -50, 0], [86.7, -50, 1000], [87.3, -50, 2000], [87.9, -50, 3000], [88.6, -50, 4000], [89.3, -50, 5000], [90, -50, 6000],
    [90.7, -50, 7000], [91, -50, 8000], [91.2, -50, 9000], [91.5, -50, 10000]
]);
B748EngineData.to1_n1_max = new LerpLookupTable([
    [86, 70, -2000], [86.5, 70, -1000], [86.9, 70, 0], [86.9, 70, 1000], [86.8, 70, 2000], [86.8, 70, 3000], [86.7, 70, 4000],
    [86.6, 70, 5000], [86.6, 70, 6000], [86.6, 70, 7000], [86.1, 70, 8000], [85.9, 70, 9000], [86, 70, 10000],
    [88.7, 60, -2000], [89.1, 60, -1000], [89.6, 60, 0], [89.6, 60, 1000], [89.5, 60, 2000], [89.5, 60, 3000], [89.4, 60, 4000],
    [89.3, 60, 5000], [89.3, 60, 6000], [89.3, 60, 7000], [88.8, 60, 8000], [88.2, 60, 9000], [87.6, 60, 10000],
    [90, 55, -2000], [90.5, 55, -1000], [90.9, 55, 0], [90.9, 55, 1000], [90.9, 55, 2000], [90.8, 55, 3000], [90.7, 55, 4000],
    [90.7, 55, 5000], [90.7, 55, 6000], [90.6, 55, 7000], [90.1, 55, 8000], [89.5, 55, 9000], [89, 55, 10000],
    [91.3, 50, -2000], [91.8, 50, -1000], [92.2, 50, 0], [92.1, 50, 1000], [92.1, 50, 2000], [92.1, 50, 3000], [92, 50, 4000],
    [92, 50, 5000], [92, 50, 6000], [91.9, 50, 7000], [91.4, 50, 8000], [90.8, 50, 9000], [90.3, 50, 10000],
    [92.6, 45, -2000], [93.1, 45, -1000], [93.5, 45, 0], [93.4, 45, 1000], [93.4, 45, 2000], [93.3, 45, 3000], [93.3, 45, 4000],
    [93.2, 45, 5000], [93.2, 45, 6000], [93.2, 45, 7000], [92.7, 45, 8000], [92.1, 45, 9000], [91.5, 45, 10000],
    [93.5, 40, -2000], [94.3, 40, -1000], [94.9, 40, 0], [94.7, 40, 1000], [94.5, 40, 2000], [94.5, 40, 3000], [94.5, 40, 4000],
    [94.5, 40, 5000], [94.4, 40, 6000], [94.4, 40, 7000], [93.9, 40, 8000], [93.4, 40, 9000], [92.8, 40, 10000],
    [93.9, 35, -2000], [94.8, 35, -1000], [95.6, 35, 0], [95.5, 35, 1000], [95.5, 35, 2000], [95.3, 35, 3000], [95.2, 35, 4000],
    [95.1, 35, 5000], [95.1, 35, 6000], [95.1, 35, 7000], [94.8, 35, 8000], [94.4, 35, 9000], [94, 35, 10000],
    [93.3, 30, -2000], [94.7, 30, -1000], [96.1, 30, 0], [96, 30, 1000], [96, 30, 2000], [96, 30, 3000], [96, 30, 4000],
    [95.8, 30, 5000], [95.7, 30, 6000], [95.6, 30, 7000], [95.3, 30, 8000], [95, 30, 9000], [94.7, 30, 10000],
    [92.5, 25, -2000], [93.9, 25, -1000], [95.3, 25, 0], [95.7, 25, 1000], [96.2, 25, 2000], [96.5, 25, 3000],
    [96.6, 25, 4000], [96.6, 25, 5000], [97, 25, 6000], [96.7, 25, 7000], [95.9, 25, 8000], [95.5, 25, 9000], [95.2, 25, 10000],
    [91.7, 20, -2000], [93.1, 20, -1000], [94.5, 20, 0], [94.9, 20, 1000], [95.4, 20, 2000], [95.9, 20, 3000],
    [96.3, 20, 4000], [96.8, 20, 5000], [97, 20, 6000], [97.1, 20, 7000], [97, 20, 8000], [96.6, 20, 9000], [95.7, 20, 10000],
    [90.9, 15, -2000], [92.3, 15, -1000], [93.6, 15, 0], [94.1, 15, 1000], [94.6, 15, 2000], [95.1, 15, 3000],
    [95.5, 15, 4000], [96, 15, 5000], [96.4, 15, 6000], [96.9, 15, 7000], [96.9, 15, 8000], [96.7, 15, 9000], [96.1, 15, 10000],
    [90.1, 10, -2000], [91.5, 10, -1000], [92.8, 10, 0], [93.3, 10, 1000], [93.8, 10, 2000], [94.3, 10, 3000],
    [94.7, 10, 4000], [95.1, 10, 5000], [95.6, 10, 6000], [96, 10, 7000], [96.2, 10, 8000], [96.3, 10, 9000],
    [96.5, 10, 10000], [89.3, 5, -2000], [90.7, 5, -1000], [92, 5, 0], [92.5, 5, 1000], [93, 5, 2000], [93.4, 5, 3000],
    [93.8, 5, 4000], [94.3, 5, 5000], [94.7, 5, 6000], [95.2, 5, 7000], [95.3, 5, 8000], [95.5, 5, 9000], [95.6, 5, 10000],
    [88.5, 0, -2000], [89.9, 0, -1000], [91.2, 0, 0], [91.6, 0, 1000], [92.1, 0, 2000], [92.6, 0, 3000], [93, 0, 4000],
    [93.4, 0, 5000], [93.9, 0, 6000], [94.3, 0, 7000], [94.5, 0, 8000], [94.6, 0, 9000], [94.8, 0, 10000],
    [86.9, -10, -2000], [88.2, -10, -1000], [89.5, -10, 0], [89.9, -10, 1000], [90.4, -10, 2000], [90.9, -10, 3000],
    [91.3, -10, 4000], [91.8, -10, 5000], [92.2, -10, 6000], [92.6, -10, 7000], [92.8, -10, 8000], [92.9, -10, 9000], [93.1, -10, 10000],
    [85.2, -20, -2000], [86.5, -20, -1000], [87.8, -20, 0], [88.2, -20, 1000], [88.7, -20, 2000], [89.2, -20, 3000],
    [89.6, -20, 4000], [90, -20, 5000], [90.5, -20, 6000], [90.9, -20, 7000], [91.1, -20, 8000], [91.2, -20, 9000], [91.4, -20, 10000],
    [83.5, -30, -2000], [84.8, -30, -1000], [86, -30, 0], [86.4, -30, 1000], [86.9, -30, 2000], [87.4, -30, 3000],
    [87.9, -30, 4000], [88.3, -30, 5000], [88.7, -30, 6000], [89.2, -30, 7000], [89.3, -30, 8000], [89.5, -30, 9000], [89.6, -30, 10000],
    [81.8, -40, -2000], [83, -40, -1000], [84.2, -40, 0], [84.7, -40, 1000], [85.1, -40, 2000], [85.7, -40, 3000],
    [86.1, -40, 4000], [86.5, -40, 5000], [87, -40, 6000], [87.4, -40, 7000], [87.6, -40, 8000], [87.7, -40, 9000], [87.9, -40, 10000],
    [80, -50, -2000], [81.2, -50, -1000], [82.4, -50, 0], [82.9, -50, 1000], [83.4, -50, 2000], [83.9, -50, 3000],
    [84.3, -50, 4000], [84.7, -50, 5000], [85.2, -50, 6000], [85.6, -50, 7000], [85.7, -50, 8000], [85.9, -50, 9000], [86.1, -50, 10000]
]);
B748EngineData.to2_n1_max = new LerpLookupTable([
    [85.9, 70, -2000], [85.9, 70, -1000], [85.9, 70, 0], [85.9, 70, 1000], [85.9, 70, 2000], [85.9, 70, 3000], [85.9, 70, 4000],
    [85.9, 70, 5000], [85.9, 70, 6000], [85.9, 70, 7000], [85.9, 70, 8000], [85.9, 70, 9000], [86, 70, 10000],
    [84.7, 60, -2000], [85.1, 60, -1000], [85.5, 60, 0], [85.5, 60, 1000], [85.5, 60, 2000], [85.4, 60, 3000], [85.3, 60, 4000],
    [85.3, 60, 5000], [85.3, 60, 6000], [85.2, 60, 7000], [84.7, 60, 8000], [84.7, 60, 9000], [84.7, 60, 10000],
    [85.9, 55, -2000], [86.4, 55, -1000], [86.8, 55, 0], [86.7, 55, 1000], [86.7, 55, 2000], [86.7, 55, 3000], [86.6, 55, 4000],
    [86.5, 55, 5000], [86.5, 55, 6000], [86.5, 55, 7000], [86, 55, 8000], [85.5, 55, 9000], [84.9, 55, 10000],
    [87.1, 50, -2000], [87.6, 50, -1000], [88.1, 50, 0], [88, 50, 1000], [88, 50, 2000], [87.9, 50, 3000], [87.8, 50, 4000],
    [87.8, 50, 5000], [87.8, 50, 6000], [87.8, 50, 7000], [87.2, 50, 8000], [86.7, 50, 9000], [86.1, 50, 10000],
    [88.4, 45, -2000], [88.9, 45, -1000], [89.3, 45, 0], [89.2, 45, 1000], [89.1, 45, 2000], [89.1, 45, 3000], [89.1, 45, 4000],
    [89, 45, 5000], [89, 45, 6000], [89, 45, 7000], [88.5, 45, 8000], [87.9, 45, 9000], [87.4, 45, 10000],
    [89.3, 40, -2000], [90, 40, -1000], [90.6, 40, 0], [90.4, 40, 1000], [90.2, 40, 2000], [90.2, 40, 3000], [90.2, 40, 4000],
    [90.2, 40, 5000], [90.1, 40, 6000], [90.2, 40, 7000], [89.7, 40, 8000], [89.1, 40, 9000], [88.6, 40, 10000],
    [89.6, 35, -2000], [90.5, 35, -1000], [91.2, 35, 0], [91.2, 35, 1000], [91.2, 35, 2000], [91, 35, 3000], [90.9, 35, 4000],
    [90.8, 35, 5000], [90.8, 35, 6000], [90.8, 35, 7000], [90.5, 35, 8000], [90.1, 35, 9000], [89.8, 35, 10000],
    [89.1, 30, -2000], [90.4, 30, -1000], [91.7, 30, 0], [91.7, 30, 1000], [91.7, 30, 2000], [91.7, 30, 3000],
    [91.7, 30, 4000], [91.4, 30, 5000], [91.4, 30, 6000], [91.3, 30, 7000], [91, 30, 8000], [90.7, 30, 9000], [90.4, 30, 10000],
    [88.3, 25, -2000], [89.6, 25, -1000], [90.9, 25, 0], [91.4, 25, 1000], [91.9, 25, 2000], [92.1, 25, 3000],
    [92.2, 25, 4000], [92.2, 25, 5000], [92.6, 25, 6000], [92.4, 25, 7000], [91.5, 25, 8000], [91.2, 25, 9000], [90.9, 25, 10000],
    [87.6, 20, -2000], [88.9, 20, -1000], [90.2, 20, 0], [90.6, 20, 1000], [91.1, 20, 2000], [91.6, 20, 3000],
    [91.9, 20, 4000], [92.4, 20, 5000], [92.5, 20, 6000], [92.7, 20, 7000], [92.5, 20, 8000], [92.2, 20, 9000], [91.4, 20, 10000],
    [86.8, 15, -2000], [88.1, 15, -1000], [89.4, 15, 0], [89.8, 15, 1000], [90.3, 15, 2000], [90.8, 15, 3000],
    [91.1, 15, 4000], [91.6, 15, 5000], [92, 15, 6000], [92.4, 15, 7000], [92.4, 15, 8000], [92.3, 15, 9000], [91.7, 15, 10000],
    [86.1, 10, -2000], [87.4, 10, -1000], [88.6, 10, 0], [89.1, 10, 1000], [89.5, 10, 2000], [90, 10, 3000],
    [90.4, 10, 4000], [90.8, 10, 5000], [91.2, 10, 6000], [91.6, 10, 7000], [91.7, 10, 8000], [91.8, 10, 9000], [92, 10, 10000],
    [85.3, 5, -2000], [86.6, 5, -1000], [87.8, 5, 0], [88.3, 5, 1000], [88.8, 5, 2000], [89.2, 5, 3000], [89.6, 5, 4000],
    [90, 5, 5000], [90.4, 5, 6000], [90.8, 5, 7000], [90.9, 5, 8000], [91, 5, 9000], [91.2, 5, 10000],
    [84.5, 0, -2000], [85.8, 0, -1000], [87, 0, 0], [87.5, 0, 1000], [87.9, 0, 2000], [88.4, 0, 3000],
    [88.8, 0, 4000], [89.2, 0, 5000], [89.6, 0, 6000], [90, 0, 7000], [90.1, 0, 8000], [90.2, 0, 9000], [90.4, 0, 10000],
    [83, -10, -2000], [84.2, -10, -1000], [85.4, -10, 0], [85.9, -10, 1000], [86.3, -10, 2000], [86.8, -10, 3000],
    [87.1, -10, 4000], [87.6, -10, 5000], [88, -10, 6000], [88.4, -10, 7000], [88.5, -10, 8000], [88.6, -10, 9000], [88.8, -10, 10000],
    [81.4, -20, -2000], [82.6, -20, -1000], [83.8, -20, 0], [84.2, -20, 1000], [84.7, -20, 2000], [85.1, -20, 3000],
    [85.5, -20, 4000], [85.9, -20, 5000], [86.3, -20, 6000], [86.7, -20, 7000], [86.8, -20, 8000], [87, -20, 9000], [87.1, -20, 10000],
    [79.8, -30, -2000], [81, -30, -1000], [82.1, -30, 0], [82.5, -30, 1000], [83, -30, 2000], [83.5, -30, 3000],
    [83.9, -30, 4000], [84.3, -30, 5000], [84.6, -30, 6000], [85, -30, 7000], [85.2, -30, 8000], [85.3, -30, 9000], [85.5, -30, 10000],
    [78.1, -40, -2000], [79.3, -40, -1000], [80.4, -40, 0], [80.8, -40, 1000], [81.3, -40, 2000], [81.8, -40, 3000],
    [82.2, -40, 4000], [82.6, -40, 5000], [83, -40, 6000], [83.4, -40, 7000], [83.5, -40, 8000], [83.6, -40, 9000], [83.8, -40, 10000],
    [76.4, -50, -2000], [77.6, -50, -1000], [78.7, -50, 0], [79.1, -50, 1000], [79.6, -50, 2000], [80.1, -50, 3000],
    [80.5, -50, 4000], [80.8, -50, 5000], [81.2, -50, 6000], [81.6, -50, 7000], [81.7, -50, 8000], [81.9, -50, 9000], [82, -50, 10000]
]);
B748EngineData.ga_n1_max = new LerpLookupTable([
    [85.9, 74, 0], [86.7, 74, 1000], [87.5, 74, 2000], [88.3, 74, 3000], [88.7, 74, 4000], [89.1, 74, 5000],
    [89.4, 74, 6000], [89.8, 74, 7000], [89.9, 74, 8000], [89.6, 74, 9000], [89, 74, 10000],
    [87.9, 64, 0], [88.8, 64, 1000], [89.7, 64, 2000], [90.7, 64, 3000], [91.2, 64, 4000], [91.7, 64, 5000],
    [92.1, 64, 6000], [92.5, 64, 7000], [92.7, 64, 8000], [92.4, 64, 9000], [91.8, 64, 10000],
    [88.8, 59, 0], [89.8, 59, 1000], [90.8, 59, 2000], [91.8, 59, 3000], [92.4, 59, 4000], [93, 59, 5000],
    [93.4, 59, 6000], [93.9, 59, 7000], [94.1, 59, 8000], [93.8, 59, 9000], [93.2, 59, 10000],
    [90.2, 54, 0], [90.9, 54, 1000], [91.9, 54, 2000], [92.9, 54, 3000], [93.6, 54, 4000], [94.2, 54, 5000],
    [94.6, 54, 6000], [95.1, 54, 7000], [95.4, 54, 8000], [95.1, 54, 9000], [94.5, 54, 10000],
    [91.5, 49, 0], [92.3, 49, 1000], [93.2, 49, 2000], [94.2, 49, 3000], [94.8, 49, 4000], [95.3, 49, 5000],
    [95.9, 49, 6000], [96.4, 49, 7000], [96.7, 49, 8000], [96.4, 49, 9000], [95.8, 49, 10000],
    [92.8, 44, 0], [93.6, 44, 1000], [94.5, 44, 2000], [95.4, 44, 3000], [96, 44, 4000], [96.6, 44, 5000],
    [97.1, 44, 6000], [97.6, 44, 7000], [98, 44, 8000], [97.7, 44, 9000], [97.1, 44, 10000],
    [94.2, 39, 0], [94.9, 39, 1000], [95.8, 39, 2000], [96.8, 39, 3000], [97.2, 39, 4000], [97.7, 39, 5000],
    [98.3, 39, 6000], [99, 39, 7000], [99, 39, 8000], [98.8, 39, 9000], [98.3, 39, 10000],
    [94.8, 34, 0], [95.7, 34, 1000], [96.6, 34, 2000], [97.6, 34, 3000], [98.2, 34, 4000], [98.7, 34, 5000],
    [99.2, 34, 6000], [99.7, 34, 7000], [99.9, 34, 8000], [99.5, 34, 9000], [99.2, 34, 10000],
    [94.1, 29, 0], [95.5, 29, 1000], [97, 29, 2000], [98.1, 29, 3000], [98.7, 29, 4000], [99.2, 29, 5000],
    [100.3, 29, 6000], [100.8, 29, 7000], [100.7, 29, 8000], [100.3, 29, 9000], [99.9, 29, 10000],
    [93.3, 24, 0], [94.7, 24, 1000], [96.2, 24, 2000], [97.7, 24, 3000], [98.9, 24, 4000], [100.1, 24, 5000],
    [100.9, 24, 6000], [101.7, 24, 7000], [102.2, 24, 8000], [101.6, 24, 9000], [100.7, 24, 10000],
    [92.5, 19, 0], [93.9, 19, 1000], [95.4, 19, 2000], [96.8, 19, 3000], [98, 19, 4000], [99.3, 19, 5000],
    [100.7, 19, 6000], [102.4, 19, 7000], [102.9, 19, 8000], [102.4, 19, 9000], [101.6, 19, 10000],
    [91.7, 14, 0], [93.1, 14, 1000], [94.5, 14, 2000], [96, 14, 3000], [97.2, 14, 4000], [98.5, 14, 5000],
    [99.8, 14, 6000], [101.5, 14, 7000], [102.5, 14, 8000], [102.5, 14, 9000], [102.5, 14, 10000],
    [90.8, 8, 0], [92.1, 8, 1000], [93.5, 8, 2000], [95, 8, 3000], [96.2, 8, 4000], [97.4, 8, 5000], [98.8, 8, 6000],
    [100.4, 8, 7000], [101.4, 8, 8000], [101.4, 8, 9000], [101.5, 8, 10000],
    [90, 3, 0], [91.3, 3, 1000], [92.7, 3, 2000], [94.2, 3, 3000], [95.3, 3, 4000], [96.6, 3, 5000], [97.9, 3, 6000],
    [99.6, 3, 7000], [100.5, 3, 8000], [100.5, 3, 9000], [100.7, 3, 10000],
    [88.3, -7, 0], [89.6, -7, 1000], [91, -7, 2000], [92.4, -7, 3000], [93.6, -7, 4000], [94.9, -7, 5000],
    [96.2, -7, 6000], [97.8, -7, 7000], [98.8, -7, 8000], [98.8, -7, 9000], [98.9, -7, 10000],
    [86.6, -17, 0], [87.9, -17, 1000], [89.3, -17, 2000], [90.7, -17, 3000], [91.9, -17, 4000],
    [93.2, -17, 5000], [94.5, -17, 6000], [96.1, -17, 7000], [97, -17, 8000], [97, -17, 9000], [97.1, -17, 10000],
    [84.9, -27, 0], [86.2, -27, 1000], [87.6, -27, 2000], [89, -27, 3000], [90.2, -27, 4000], [91.4, -27, 5000],
    [92.7, -27, 6000], [94.3, -27, 7000], [95.2, -27, 8000], [95.2, -27, 9000], [95.3, -27, 10000],
    [83.2, -37, 0], [84.4, -37, 1000], [85.8, -37, 2000], [87.2, -37, 3000], [88.5, -37, 4000], [89.7, -37, 5000],
    [90.9, -37, 6000], [92.5, -37, 7000], [93.4, -37, 8000], [93.4, -37, 9000], [93.5, -37, 10000],
    [81.4, -47, 0], [82.7, -47, 1000], [84, -47, 2000], [85.5, -47, 3000], [86.7, -47, 4000], [87.9, -47, 5000],
    [89.1, -47, 6000], [90.6, -47, 7000], [91.5, -47, 8000], [91.6, -47, 9000], [91.7, -47, 10000]
]);
B748EngineData.clb_n1_max = new LerpLookupTable([
    [91, 60, 0], [91.6, 60, 5000], [92.9, 60, 10000], [94.1, 60, 15000], [96.1, 60, 20000], [97.6, 60, 25000], [99.8, 60, 30000], [101.2, 60, 35000],
    [101.5, 60, 40000], [100.7, 60, 45000], [92.8, 50, 0], [93.2, 50, 5000], [93.8, 50, 10000], [93.1, 50, 15000], [94.7, 50, 20000], [96.2, 50, 25000],
    [98.3, 50, 30000], [99.7, 50, 35000], [100, 50, 40000], [99.2, 50, 45000], [94.2, 40, 0], [95, 40, 5000], [95.4, 40, 10000], [94.8, 40, 15000], [95, 40, 20000],
    [94.9, 40, 25000], [96.7, 40, 30000], [98.2, 40, 35000], [98.4, 40, 40000], [97.7, 40, 45000], [92.7, 30, 0], [95.5, 30, 5000], [97, 30, 10000], [96.4, 30, 15000],
    [96.6, 30, 20000], [96.5, 30, 25000], [95.2, 30, 30000], [96.6, 30, 35000], [96.8, 30, 40000], [96.1, 30, 45000], [91.2, 20, 0], [93.9, 20, 5000], [96.6, 20, 10000],
    [97.9, 20, 15000], [98.2, 20, 20000], [98, 20, 25000], [96.9, 20, 30000], [95.5, 20, 35000], [95.2, 20, 40000], [94.5, 20, 45000], [90.4, 15, 0], [93.1, 15, 5000],
    [95.8, 15, 10000], [97.3, 15, 15000], [99, 15, 20000], [98.9, 15, 25000], [97.8, 15, 30000], [96.5, 15, 35000], [95.9, 15, 40000], [95.2, 15, 45000], [89.6, 10, 0],
    [92.3, 10, 5000], [95, 10, 10000], [96.5, 10, 15000], [98.7, 10, 20000], [99.7, 10, 25000], [98.7, 10, 30000], [97.6, 10, 35000], [97, 10, 40000], [96.3, 10, 45000],
    [88.8, 5, 0], [91.5, 5, 5000], [94.1, 5, 10000], [95.6, 5, 15000], [97.9, 5, 20000], [99.6, 5, 25000], [99.7, 5, 30000], [98.6, 5, 35000], [98, 5, 40000], [97.3, 5, 45000],
    [88, 0, 0], [90.7, 0, 5000], [93.3, 0, 10000], [94.8, 0, 15000], [97, 0, 20000], [98.7, 0, 25000], [100.8, 0, 30000], [99.6, 0, 35000], [99, 0, 40000], [98.3, 0, 45000],
    [87.2, -5, 0], [89.8, -5, 5000], [92.4, -5, 10000], [93.9, -5, 15000], [96.1, -5, 20000], [97.8, -5, 25000], [101.1, -5, 30000], [100.8, -5, 35000], [100, -5, 40000],
    [99.3, -5, 45000], [86.4, -10, 0], [89, -10, 5000], [91.5, -10, 10000], [93, -10, 15000], [95.2, -10, 20000], [96.8, -10, 25000], [100.2, -10, 30000], [101.4, -10, 35000],
    [100.9, -10, 40000], [100.3, -10, 45000], [85.5, -15, 0], [88.1, -15, 5000], [90.7, -15, 10000], [92.1, -15, 15000], [94.3, -15, 20000], [95.9, -15, 25000],
    [99.2, -15, 30000], [101, -15, 35000], [100.9, -15, 40000], [100.8, -15, 45000], [84.7, -20, 0], [87.3, -20, 5000], [89.8, -20, 10000], [91.2, -20, 15000], [93.4, -20, 20000],
    [95, -20, 25000], [98.3, -20, 30000], [100, -20, 35000], [99.9, -20, 40000], [99.9, -20, 45000], [83.9, -25, 0], [86.4, -25, 5000], [88.9, -25, 10000], [90.3, -25, 15000],
    [92.4, -25, 20000], [94, -25, 25000], [97.3, -25, 30000], [99, -25, 35000], [98.9, -25, 40000], [98.9, -25, 45000], [83, -30, 0], [85.5, -30, 5000], [88, -30, 10000],
    [89.4, -30, 15000], [91.5, -30, 20000], [93.1, -30, 25000], [96.3, -30, 30000], [98, -30, 35000], [97.9, -30, 40000], [97.9, -30, 45000], [82.2, -35, 0], [84.7, -35, 5000],
    [87.1, -35, 10000], [88.5, -35, 15000], [90.6, -35, 20000], [92.1, -35, 25000], [95.3, -35, 30000], [97, -35, 35000], [96.9, -35, 40000], [96.8, -35, 45000], [81.3, -40, 0],
    [83.8, -40, 5000], [86.2, -40, 10000], [87.5, -40, 15000], [89.6, -40, 20000], [91.2, -40, 25000], [94.3, -40, 30000], [96, -40, 35000], [95.9, -40, 40000], [95.8, -40, 45000]
]);
B748EngineData.cru_n1_max = new LerpLookupTable([
    [91, 60, 0], [91.6, 60, 5000], [92.9, 60, 10000], [94.1, 60, 15000], [96.1, 60, 20000], [97.6, 60, 25000], [99.8, 60, 30000], [101.2, 60, 35000],
    [101.5, 60, 40000], [100.7, 60, 45000], [92.8, 50, 0], [93.2, 50, 5000], [93.8, 50, 10000], [93.1, 50, 15000], [94.7, 50, 20000], [96.2, 50, 25000],
    [98.3, 50, 30000], [99.7, 50, 35000], [100, 50, 40000], [99.2, 50, 45000], [94.2, 40, 0], [95, 40, 5000], [95.4, 40, 10000], [94.8, 40, 15000], [95, 40, 20000],
    [94.9, 40, 25000], [96.7, 40, 30000], [98.2, 40, 35000], [98.4, 40, 40000], [97.7, 40, 45000], [92.7, 30, 0], [95.5, 30, 5000], [97, 30, 10000], [96.4, 30, 15000],
    [96.6, 30, 20000], [96.5, 30, 25000], [95.2, 30, 30000], [96.6, 30, 35000], [96.8, 30, 40000], [96.1, 30, 45000], [91.2, 20, 0], [93.9, 20, 5000], [96.6, 20, 10000],
    [97.9, 20, 15000], [98.2, 20, 20000], [98, 20, 25000], [96.9, 20, 30000], [95.5, 20, 35000], [95.2, 20, 40000], [94.5, 20, 45000], [90.4, 15, 0], [93.1, 15, 5000],
    [95.8, 15, 10000], [97.3, 15, 15000], [99, 15, 20000], [98.9, 15, 25000], [97.8, 15, 30000], [96.5, 15, 35000], [95.9, 15, 40000], [95.2, 15, 45000], [89.6, 10, 0],
    [92.3, 10, 5000], [95, 10, 10000], [96.5, 10, 15000], [98.7, 10, 20000], [99.7, 10, 25000], [98.7, 10, 30000], [97.6, 10, 35000], [97, 10, 40000], [96.3, 10, 45000],
    [88.8, 5, 0], [91.5, 5, 5000], [94.1, 5, 10000], [95.6, 5, 15000], [97.9, 5, 20000], [99.6, 5, 25000], [99.7, 5, 30000], [98.6, 5, 35000], [98, 5, 40000], [97.3, 5, 45000],
    [88, 0, 0], [90.7, 0, 5000], [93.3, 0, 10000], [94.8, 0, 15000], [97, 0, 20000], [98.7, 0, 25000], [100.8, 0, 30000], [99.6, 0, 35000], [99, 0, 40000], [98.3, 0, 45000],
    [87.2, -5, 0], [89.8, -5, 5000], [92.4, -5, 10000], [93.9, -5, 15000], [96.1, -5, 20000], [97.8, -5, 25000], [101.1, -5, 30000], [100.8, -5, 35000], [100, -5, 40000],
    [99.3, -5, 45000], [86.4, -10, 0], [89, -10, 5000], [91.5, -10, 10000], [93, -10, 15000], [95.2, -10, 20000], [96.8, -10, 25000], [100.2, -10, 30000], [101.4, -10, 35000],
    [100.9, -10, 40000], [100.3, -10, 45000], [85.5, -15, 0], [88.1, -15, 5000], [90.7, -15, 10000], [92.1, -15, 15000], [94.3, -15, 20000], [95.9, -15, 25000],
    [99.2, -15, 30000], [101, -15, 35000], [100.9, -15, 40000], [100.8, -15, 45000], [84.7, -20, 0], [87.3, -20, 5000], [89.8, -20, 10000], [91.2, -20, 15000], [93.4, -20, 20000],
    [95, -20, 25000], [98.3, -20, 30000], [100, -20, 35000], [99.9, -20, 40000], [99.9, -20, 45000], [83.9, -25, 0], [86.4, -25, 5000], [88.9, -25, 10000], [90.3, -25, 15000],
    [92.4, -25, 20000], [94, -25, 25000], [97.3, -25, 30000], [99, -25, 35000], [98.9, -25, 40000], [98.9, -25, 45000], [83, -30, 0], [85.5, -30, 5000], [88, -30, 10000],
    [89.4, -30, 15000], [91.5, -30, 20000], [93.1, -30, 25000], [96.3, -30, 30000], [98, -30, 35000], [97.9, -30, 40000], [97.9, -30, 45000], [82.2, -35, 0], [84.7, -35, 5000],
    [87.1, -35, 10000], [88.5, -35, 15000], [90.6, -35, 20000], [92.1, -35, 25000], [95.3, -35, 30000], [97, -35, 35000], [96.9, -35, 40000], [96.8, -35, 45000], [81.3, -40, 0],
    [83.8, -40, 5000], [86.2, -40, 10000], [87.5, -40, 15000], [89.6, -40, 20000], [91.2, -40, 25000], [94.3, -40, 30000], [96, -40, 35000], [95.9, -40, 40000], [95.8, -40, 45000]
]);
B748EngineData.max_con_n1 = new LerpLookupTable([
    [95.8, 30, 5000], [97.2, 30, 10000], [96.7, 30, 16000], [96.8, 30, 20000], [97.3, 30, 25000], [95, 30, 29000], [94.4, 30, 33000], [93.3, 30, 37000],
    [95.4, 20, 5000], [97.7, 20, 10000], [97.9, 20, 16000], [98.4, 20, 20000], [97.3, 20, 25000], [96.8, 20, 29000], [95.4, 20, 33000], [95.8, 20, 37000],
    [93.4, 10, 5000], [96.7, 10, 10000], [98.4, 10, 16000], [99.2, 10, 20000], [99, 10, 25000], [97.8, 10, 29000], [97.3, 10, 33000], [98.1, 10, 37000],
    [92.1, 0, 5000], [95, 0, 10000], [98.1, 0, 16000], [99.4, 0, 20000], [100, 0, 25000], [100.9, 0, 29000], [99.4, 0, 33000], [99.2, 0, 37000],
    [90.4, -10, 5000], [93.3, -10, 10000], [96.3, -10, 16000], [98.5, -10, 20000], [100.2, -10, 25000], [100.8, -10, 29000], [101, -10, 33000], [100.9, -10, 37000],
    [88.6, -20, 5000], [91.5, -20, 10000], [94.5, -20, 16000], [96.6, -20, 20000], [99.2, -20, 25000], [100.1, -20, 29000], [100.1, -20, 33000], [99.8, -20, 37000],
    [87.8, -30, 5000], [90.6, -30, 10000], [93.5, -30, 16000], [95.6, -30, 20000], [97.3, -30, 25000], [98.1, -30, 29000], [98.2, -30, 33000], [97.9, -30, 37000],
    [87.8, -40, 5000], [90.6, -40, 10000], [93.5, -40, 16000], [95.6, -40, 20000], [96.3, -40, 25000], [96, -40, 29000], [96.1, -40, 33000], [95.9, -40, 37000],
    [87.8, -50, 5000], [90.6, -50, 10000], [93.5, -50, 16000], [95.6, -50, 20000], [95.3, -50, 25000], [95, -50, 29000], [94.9, -50, 33000], [93.8, -50, 37000]
]);
B748EngineData.lrc_mach = new LerpLookupTable([
    [0.852, 1014300, 25000], [0.86, 1014300, 27000], [0.86, 1014300, 29000], [0.859, 1014300, 31000], [0.859, 1014300, 33000], [0.859, 1014300, 35000],
    [0.859, 1014300, 37000], [0.859, 1014300, 39000], [0.859, 1014300, 41000], [0.859, 1014300, 43000], [0.845, 970200, 25000], [0.858, 970200, 27000],
    [0.86, 970200, 29000], [0.859, 970200, 31000], [0.854, 970200, 33000], [0.854, 970200, 35000], [0.854, 970200, 37000], [0.854, 970200, 39000],
    [0.854, 970200, 41000], [0.854, 970200, 43000], [0.836, 926100, 25000], [0.852, 926100, 27000], [0.86, 926100, 29000], [0.86, 926100, 31000],
    [0.859, 926100, 33000], [0.859, 926100, 35000], [0.859, 926100, 37000], [0.859, 926100, 39000], [0.859, 926100, 41000], [0.859, 926100, 43000],
    [0.827, 882000, 25000], [0.843, 882000, 27000], [0.858, 882000, 29000], [0.86, 882000, 31000], [0.859, 882000, 33000], [0.854, 882000, 35000],
    [0.854, 882000, 37000], [0.854, 882000, 39000], [0.854, 882000, 41000], [0.854, 882000, 43000], [0.817, 837900, 25000], [0.834, 837900, 27000],
    [0.85, 837900, 29000], [0.859, 837900, 31000], [0.86, 837900, 33000], [0.859, 837900, 35000], [0.859, 837900, 37000], [0.859, 837900, 39000],
    [0.859, 837900, 41000], [0.859, 837900, 43000], [0.805, 793800, 25000], [0.824, 793800, 27000], [0.84, 793800, 29000], [0.856, 793800, 31000],
    [0.86, 793800, 33000], [0.859, 793800, 35000], [0.856, 793800, 37000], [0.856, 793800, 39000], [0.856, 793800, 41000], [0.856, 793800, 43000],
    [0.792, 749700, 25000], [0.812, 749700, 27000], [0.83, 749700, 29000], [0.846, 749700, 31000], [0.859, 749700, 33000], [0.86, 749700, 35000],
    [0.859, 749700, 37000], [0.849, 749700, 39000], [0.849, 749700, 41000], [0.849, 749700, 43000], [0.776, 705600, 25000], [0.798, 705600, 27000],
    [0.818, 705600, 29000], [0.836, 705600, 31000], [0.852, 705600, 33000], [0.86, 705600, 35000], [0.859, 705600, 37000], [0.858, 705600, 39000],
    [0.858, 705600, 41000], [0.858, 705600, 43000], [0.758, 661500, 25000], [0.782, 661500, 27000], [0.804, 661500, 29000], [0.823, 661500, 31000],
    [0.841, 661500, 33000], [0.857, 661500, 35000], [0.86, 661500, 37000], [0.859, 661500, 39000], [0.854, 661500, 41000], [0.854, 661500, 43000],
    [0.737, 617400, 25000], [0.763, 617400, 27000], [0.787, 617400, 29000], [0.809, 617400, 31000], [0.828, 617400, 33000], [0.845, 617400, 35000],
    [0.859, 617400, 37000], [0.86, 617400, 39000], [0.859, 617400, 41000], [0.859, 617400, 43000], [0.686, 529200, 25000], [0.716, 529200, 27000],
    [0.744, 529200, 29000], [0.771, 529200, 31000], [0.795, 529200, 33000], [0.816, 529200, 35000], [0.835, 529200, 37000], [0.852, 529200, 39000],
    [0.86, 529200, 41000], [0.859, 529200, 43000], [0.626, 441000, 25000], [0.654, 441000, 27000], [0.684, 441000, 29000], [0.715, 441000, 31000],
    [0.744, 441000, 33000], [0.772, 441000, 35000], [0.797, 441000, 37000], [0.818, 441000, 39000], [0.837, 441000, 41000], [0.853, 441000, 43000]
]);
/** Output: Opt Altitude in Ft; Term 1: Weight in LBS */
B748EngineData.alt_opt = new LerpLookupTable([
    [29000, 1014125.2],
    [30000, 970032.8],
    [31000, 925940.4],
    [32100, 881848],
    [33200, 837755.6],
    [34300, 793663.2],
    [35500, 749570.8],
    [36800, 705478.4],
    [38100, 661386],
    [39600, 617293.6],
    [41100, 573201.2],
    [42800, 529108.8],
    [43100, 485016.4],
    [43100, 440924]
]);
/** Output: Max Altitude in Ft; Term 1: Weight in LBS; Term 2: ISA Tem Deviation in C */
B748EngineData.alt_max = new LerpLookupTable([
    [32500, 1014125.2, -100], [32500, 1014125.2, 10], [31300, 1014125.2, 15], [29600, 1014125.2, 20],
    [33700, 970032.8, -100], [33700, 970032.8, 10], [32800, 970032.8, 15], [31000, 970032.8, 20],
    [34800, 925940.4, -100], [34800, 925940.4, 10], [34100, 925940.4, 15], [32500, 925940.4, 20],
    [35800, 881848, -100], [35800, 881848, 10], [35500, 881848, 15], [33900, 881848, 20],
    [36800, 837755.6, -100], [36800, 837755.6, 10], [36600, 837755.6, 15], [35500, 837755.6, 20],
    [38000, 793663.2, -100], [38000, 793663.2, 10], [37700, 793663.2, 15], [36700, 793663.2, 20],
    [39200, 749570.8, -100], [39200, 749570.8, 10], [38800, 749570.8, 15], [37800, 749570.8, 20],
    [40400, 705478.4, -100], [40400, 705478.4, 10], [40000, 705478.4, 15], [38900, 705478.4, 20],
    [41700, 661386, -100], [41700, 661386, 10], [41200, 661386, 15], [40100, 661386, 20],
    [43100, 617293.6, -100], [43100, 617293.6, 10], [42400, 617293.6, 15], [41300, 617293.6, 20],
    [43100, 573201.2, -100], [43100, 573201.2, 10], [43100, 573201.2, 15], [42600, 573201.2, 20],
    [43100, 529108.8, -100], [43100, 529108.8, 10], [43100, 529108.8, 15], [43100, 529108.8, 20],
    [43100, 485016.4, -100], [43100, 485016.4, 10], [43100, 485016.4, 15], [43100, 485016.4, 20],
    [43100, 440924, -100], [43100, 440924, 10], [43100, 440924, 15], [43100, 440924, 20]
]);

/** B747-8i Performance Math Utility Class. */
class B748PerformanceMath extends BoeingPerformanceDataProvider {
    /** @inheritdoc */
    getAircraftFlightModel() {
        return {
            wing_span: 224.57,
            wing_area: 5960,
            //From the lift_coef_aoa_table: the value at aoa_0.
            lift_coef_aoa_0: 0.20,
            drag_coef_zero_lift: 0.018,
            induced_drag_scalar: 1,
            oswald_efficiency_factor: 0.75,
            inlet_area: 60,
            low_idle_n1: 23.2,
            mach_influence_on_n1: 10,
            static_thrust: 66500,
            ThrustSpecificFuelConsumption: 0.27,
            n1_and_mach_on_thrust_table: new LerpLookupTable([
                [0, 0, 0], [0, 0, 0.9],
                [0.053978, 20, 0], [0.080724, 20, 0.9],
                [0.072647, 25, 0], [0.109233, 25, 0.9],
                [0.092571, 30, 0], [0.132834, 30, 0.9],
                [0.114397, 35, 0], [0.150788, 35, 0.9],
                [0.133584, 40, 0], [0.17369, 40, 0.9],
                [0.163657, 45, 0], [0.204467, 45, 0.9],
                [0.201611, 50, 0], [0.254152, 50, 0.9],
                [0.247145, 55, 0], [0.322773, 55, 0.9],
                [0.306598, 60, 0], [0.408744, 60, 0.9],
                [0.404374, 65, 0], [0.512374, 65, 0.9],
                [0.472288, 70, 0], [0.602012, 70, 0.9],
                [0.543975, 75, 0], [0.67375, 75, 0.9],
                [0.628349, 80, 0], [0.766623, 80, 0.9],
                [0.735036, 85, 0], [0.857414, 85, 0.9],
                [0.837808, 90, 0], [0.97479, 90, 0.9],
                [0.956614, 95, 0], [1.083902, 95, 0.9],
                [1.090953, 100, 0], [1.221156, 100, 0.9],
                [1.234866, 105, 0], [1.35787, 105, 0.9],
                [1.325555, 110, 0], [1.43502, 110, 0.9]
            ]),
            thrust_and_mach_on_n1_table: new LerpLookupTable([
                [0, 0, 0], [0, 0, 0.9],
                [20, 0.053978, 0], [20, 0.080724, 0.9],
                [25, 0.072647, 0], [25, 0.109233, 0.9],
                [30, 0.092571, 0], [30, 0.132834, 0.9],
                [35, 0.114397, 0], [35, 0.150788, 0.9],
                [40, 0.133584, 0], [40, 0.17369, 0.9],
                [45, 0.163657, 0], [45, 0.204467, 0.9],
                [50, 0.201611, 0], [50, 0.254152, 0.9],
                [55, 0.247145, 0], [55, 0.322773, 0.9],
                [60, 0.306598, 0], [60, 0.408744, 0.9],
                [65, 0.404374, 0], [65, 0.512374, 0.9],
                [70, 0.472288, 0], [70, 0.602012, 0.9],
                [75, 0.543975, 0], [75, 0.67375, 0.9],
                [80, 0.628349, 0], [80, 0.766623, 0.9],
                [85, 0.735036, 0], [85, 0.857414, 0.9],
                [90, 0.837808, 0], [90, 0.97479, 0.9],
                [95, 0.956614, 0], [95, 1.083902, 0.9],
                [100, 1.090953, 0], [100, 1.221156, 0.9],
                [105, 1.234866, 0], [105, 1.35787, 0.9],
                [110, 1.325555, 0], [110, 1.43502, 0.9]
            ]),
            corrected_airflow_table: new LerpLookupTable([
                [0, 0, 0], [0, 0, 0.9],
                [4.29, 20, 0], [14.081, 20, 0.9],
                [22, 85, 0], [24, 85, 0.9],
                [25, 90, 0], [25, 90, 0.9],
                [27, 95, 0], [27, 95, 0.9],
                [28, 100, 0], [28, 100, 0.9],
                [29, 105, 0], [29, 105, 0.9],
                [30, 110, 0], [30, 110, 0.9]
            ])
        };
    }
}

/**
 * A class which adapts {@link B748PerformanceMath} to the {@link BoeingPathPerformanceProvider} interface.
 */
class B748PerformanceProvider {
    /**
     * Creates an instance of the B787PerformanceProvider.
     * @param performanceMath The aircraft's performance math class.
     */
    constructor(performanceMath) {
        this.performanceMath = performanceMath;
    }
    /** @inheritdoc */
    getWingArea() {
        return this.performanceMath.aircraftFlightModel.wing_area * 0.09290304;
    }
    /** @inheritdoc */
    getThrustCorrectionFactor(pressure, mach) {
        return BoeingAeroMath.calculateThrustCorrectionFactor(mach, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineIdleCorrectedN1(temperature, mach) {
        return this.performanceMath.calculateIdleCorrectedN1(temperature, mach);
    }
    /** @inheritdoc */
    getEngineCorrectedGrossThrust(n1, mach) {
        return this.performanceMath.calculateThrustFromCorrectedN1(n1, mach);
    }
    /** @inheritdoc */
    getEngineRamDrag(n1, mach, pressure, temperature) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(temperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        return this.performanceMath.calculateRamDrag(mach, n1, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG), inletTemp);
    }
    /** @inheritdoc */
    getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) {
        return this.getEngineCorrectedGrossThrust(n1, mach) / this.getThrustCorrectionFactor(pressure, mach) - this.getEngineRamDrag(n1, mach, pressure, temperature);
    }
    /** @inheritdoc */
    estimateGrossThrustFromNetThrust(netThrust, mach, pressure, temperature) {
        return this.performanceMath.findGrossThrustFromNetThrust(netThrust, mach, 0, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineFuelFlow(grossThrust) {
        return this.performanceMath.calculateFuelFlowFromThrust(grossThrust);
    }
    /** @inheritdoc */
    getRequiredThrust(weight, cl, tas, vs) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return weight * (sin + this.performanceMath.calculateCD(cl) / (cl * cos));
    }
    /** @inheritdoc */
    getLevelFlightRequiredThrust(weight, cl) {
        return this.performanceMath.calculateThrustRequired(weight, cl);
    }
    /** @inheritdoc */
    getVerticalSpeed(netThrust, weight, cl, tas) {
        return UnitType.FPM.convertTo(this.performanceMath.calculateConstantSpeedVerticalSpeedFromThrust(netThrust, UnitType.MPS.convertTo(tas, UnitType.KNOT), weight, cl), UnitType.MPS);
    }
    /** @inheritdoc */
    getAcceleration(netThrust, weight, cl, tas, vs) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return UnitType.G_ACCEL.convertTo(netThrust / weight - sin - this.performanceMath.calculateCD(cl) / (cl * cos), UnitType.MPS_PER_SEC);
    }
    /** @inheritdoc */
    estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineNetThrust, engineCount, wingArea, weight, pressure, temperature, out, density, soundSpeed) {
        let totalTime = 0;
        let totalDistance = 0;
        if (density === undefined) {
            density = AeroMath.densityAir(pressure, temperature);
        }
        // For performance reasons, only calculate engine fuel flow at the starting speed.
        const initialMach = AeroMath.tasToMach(initialTas, soundSpeed !== null && soundSpeed !== void 0 ? soundSpeed : AeroMath.soundSpeedAir(temperature));
        const grossThrustPerEngineRequired = this.estimateGrossThrustFromNetThrust(engineNetThrust, initialMach, pressure, temperature);
        const engineFuelFlow = this.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
        let currentTas = initialTas;
        while (Math.abs(finalTas - currentTas) > 0.1) {
            const weightNewtons = weight * 4.44822;
            let acceleration = this.getAcceleration(engineNetThrust * engineCount, weight, AeroMath.liftCoefficient(weightNewtons, wingArea, density, currentTas), currentTas, vs);
            if (finalTas - currentTas > 0) {
                acceleration = Math.max(0.1, acceleration);
            }
            else {
                acceleration = Math.min(-0.1, acceleration);
            }
            const tasStep = MathUtils.clamp(finalTas - currentTas, -3, 3);
            const timeStep = tasStep / acceleration;
            totalTime += timeStep;
            totalDistance += currentTas * timeStep + acceleration * timeStep * timeStep / 2;
            currentTas += acceleration * timeStep;
            weight = Math.max(0, weight - engineFuelFlow * timeStep);
        }
        return Vec2Math.set(totalTime, totalDistance, out);
    }
    /** @inheritDoc */
    get operatingEmptyWeight() {
        return 467160; // 211,900 kg
    }
    /** @inheritDoc */
    get maxZeroFuelWeight() {
        return 651000; // 295,288 kg
    }
    /** @inheritDoc */
    get maxGrossWeight() {
        return 975000; // 442,252 kg
    }
    /** @inheritDoc */
    get maxReserveFuel() {
        return Number.MAX_SAFE_INTEGER; // TODO Replace with actual value
    }
    /** @inheritDoc */
    get fuelFreezeTemp() {
        return -37;
    }
}

/** Boeing Speed Data */
class B748SpeedData {
    /**
     * Construct an instance of the 748 speed provider
     * @param bus Event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.pressureAlt.setConsumer(this.bus.getSubscriber().on('pressure_alt'));
    }
    /** @inheritdoc */
    getFlapManeuverSpeed(flapPos, weight, pressureAlt) {
        return B748SpeedData.flap_maneuver_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVrefSpeed(flapPos, weight, pressureAlt) {
        if (flapPos === 25 || flapPos === 30) {
            // the flap maneuver speeds for 25 and 30 are vref
            return this.getFlapManeuverSpeed(flapPos, weight, pressureAlt);
        }
        throw new Error('25 and 30 are the only valid 748 VREF flap positions');
    }
    /** @inheritdoc */
    getHoldingSpeed(flapPos, weight, pressureAlt) {
        return B748SpeedData.holding_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVmo() {
        return B748SpeedData.vmo;
    }
    /** @inheritdoc */
    getMmo() {
        return B748SpeedData.mmo;
    }
    /** @inheritdoc */
    getGearLimitSpeed() {
        return B748SpeedData.vle;
    }
}
/** Maximum Speed Limit Mach Number */
B748SpeedData.mmo = 0.9;
/** Maximum Speed Limit KCAS */
B748SpeedData.vmo = 365;
/** Landing Gear Placard Speed KIAS */
B748SpeedData.vle = 270;
/** Flap Maneuver Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B748SpeedData.flap_maneuver_speeds = new LerpLookupTable([
    [266, 1014126, 0, 0], [244, 1014126, 1, 0], [224, 1014126, 5, 0], [204, 1014126, 10, 0], [194, 1014126, 20, 0], [191, 1014126, 25, 0], [187, 1014126, 30, 0],
    [260, 970034, 0, 0], [240, 970034, 1, 0], [220, 970034, 5, 0], [201, 970034, 10, 0], [190, 970034, 20, 0], [187, 970034, 25, 0], [183, 970034, 30, 0],
    [256, 925942, 0, 0], [236, 925942, 1, 0], [216, 925942, 5, 0], [198, 925942, 10, 0], [186, 925942, 20, 0], [182, 925942, 25, 0], [178, 925942, 30, 0],
    [252, 881849, 0, 0], [232, 881849, 1, 0], [212, 881849, 5, 0], [195, 881849, 10, 0], [181, 881849, 20, 0], [177, 881849, 25, 0], [173, 881849, 30, 0],
    [247, 837757, 0, 0], [227, 837757, 1, 0], [207, 837757, 5, 0], [192, 837757, 10, 0], [177, 837757, 20, 0], [172, 837757, 25, 0], [169, 837757, 30, 0],
    [243, 793664, 0, 0], [223, 793664, 1, 0], [202, 793664, 5, 0], [190, 793664, 10, 0], [174, 793664, 20, 0], [167, 793664, 25, 0], [164, 793664, 30, 0],
    [239, 749572, 0, 0], [219, 749572, 1, 0], [199, 749572, 5, 0], [186, 749572, 10, 0], [172, 749572, 20, 0], [163, 749572, 25, 0], [160, 749572, 30, 0],
    [234, 705479, 0, 0], [214, 705479, 1, 0], [194, 705479, 5, 0], [180, 705479, 10, 0], [166, 705479, 20, 0], [158, 705479, 25, 0], [155, 705479, 30, 0],
    [229, 661387, 0, 0], [209, 661387, 1, 0], [189, 661387, 5, 0], [174, 661387, 10, 0], [161, 661387, 20, 0], [153, 661387, 25, 0], [150, 661387, 30, 0],
    [224, 617294, 0, 0], [204, 617294, 1, 0], [184, 617294, 5, 0], [168, 617294, 10, 0], [155, 617294, 20, 0], [147, 617294, 25, 0], [144, 617294, 30, 0],
    [219, 573202, 0, 0], [199, 573202, 1, 0], [178, 573202, 5, 0], [162, 573202, 10, 0], [150, 573202, 20, 0], [141, 573202, 25, 0], [139, 573202, 30, 0],
    [213, 529109, 0, 0], [193, 529109, 1, 0], [173, 529109, 5, 0], [155, 529109, 10, 0], [144, 529109, 20, 0], [136, 529109, 25, 0], [133, 529109, 30, 0],
    [208, 485017, 0, 0], [188, 485017, 1, 0], [168, 485017, 5, 0], [149, 485017, 10, 0], [138, 485017, 20, 0], [130, 485017, 25, 0], [127, 485017, 30, 0],
    [205, 440925, 0, 0], [185, 440925, 1, 0], [164, 440925, 5, 0], [144, 440925, 10, 0], [134, 440925, 20, 0], [124, 440925, 25, 0], [121, 440925, 30, 0],
    [271, 1014126, 0, 10000], [247, 1014126, 1, 10000], [227, 1014126, 5, 10000], [211, 1014126, 10, 10000], [197, 1014126, 20, 10000], [191, 1014126, 25, 10000], [187, 1014126, 30, 10000],
    [265, 970034, 0, 10000], [243, 970034, 1, 10000], [223, 970034, 5, 10000], [207, 970034, 10, 10000], [193, 970034, 20, 10000], [187, 970034, 25, 10000], [183, 970034, 30, 10000],
    [259, 925942, 0, 10000], [238, 925942, 1, 10000], [218, 925942, 5, 10000], [204, 925942, 10, 10000], [189, 925942, 20, 10000], [182, 925942, 25, 10000], [178, 925942, 30, 10000],
    [254, 881849, 0, 10000], [234, 881849, 1, 10000], [213, 881849, 5, 10000], [200, 881849, 10, 10000], [184, 881849, 20, 10000], [177, 881849, 25, 10000], [173, 881849, 30, 10000],
    [249, 837757, 0, 10000], [229, 837757, 1, 10000], [209, 837757, 5, 10000], [197, 837757, 10, 10000], [180, 837757, 20, 10000], [172, 837757, 25, 10000], [169, 837757, 30, 10000],
    [244, 793664, 0, 10000], [224, 793664, 1, 10000], [206, 793664, 5, 10000], [194, 793664, 10, 10000], [176, 793664, 20, 10000], [167, 793664, 25, 10000], [164, 793664, 30, 10000],
    [240, 749572, 0, 10000], [220, 749572, 1, 10000], [204, 749572, 5, 10000], [190, 749572, 10, 10000], [173, 749572, 20, 10000], [163, 749572, 25, 10000], [160, 749572, 30, 10000],
    [235, 705479, 0, 10000], [215, 705479, 1, 10000], [197, 705479, 5, 10000], [184, 705479, 10, 10000], [168, 705479, 20, 10000], [158, 705479, 25, 10000], [155, 705479, 30, 10000],
    [230, 661387, 0, 10000], [210, 661387, 1, 10000], [190, 661387, 5, 10000], [177, 661387, 10, 10000], [162, 661387, 20, 10000], [153, 661387, 25, 10000], [150, 661387, 30, 10000],
    [225, 617294, 0, 10000], [205, 617294, 1, 10000], [185, 617294, 5, 10000], [170, 617294, 10, 10000], [156, 617294, 20, 10000], [147, 617294, 25, 10000], [144, 617294, 30, 10000],
    [220, 573202, 0, 10000], [200, 573202, 1, 10000], [179, 573202, 5, 10000], [163, 573202, 10, 10000], [150, 573202, 20, 10000], [141, 573202, 25, 10000], [139, 573202, 30, 10000],
    [214, 529109, 0, 10000], [194, 529109, 1, 10000], [174, 529109, 5, 10000], [157, 529109, 10, 10000], [144, 529109, 20, 10000], [136, 529109, 25, 10000], [133, 529109, 30, 10000],
    [208, 485017, 0, 10000], [188, 485017, 1, 10000], [168, 485017, 5, 10000], [150, 485017, 10, 10000], [138, 485017, 20, 10000], [130, 485017, 25, 10000], [127, 485017, 30, 10000],
    [205, 440925, 0, 10000], [185, 440925, 1, 10000], [164, 440925, 5, 10000], [144, 440925, 10, 10000], [134, 440925, 20, 10000], [124, 440925, 25, 10000], [121, 440925, 30, 10000],
    [288, 1014126, 0, 20000], [252, 1014126, 1, 20000], [232, 1014126, 5, 20000], [219, 1014126, 10, 20000], [202, 1014126, 20, 20000], [191, 1014126, 25, 20000], [187, 1014126, 30, 20000],
    [280, 970034, 0, 20000], [247, 970034, 1, 20000], [227, 970034, 5, 20000], [215, 970034, 10, 20000], [198, 970034, 20, 20000], [187, 970034, 25, 20000], [183, 970034, 30, 20000],
    [271, 925942, 0, 20000], [242, 925942, 1, 20000], [222, 925942, 5, 20000], [209, 925942, 10, 20000], [194, 925942, 20, 20000], [182, 925942, 25, 20000], [178, 925942, 30, 20000],
    [263, 881849, 0, 20000], [237, 881849, 1, 20000], [217, 881849, 5, 20000], [204, 881849, 10, 20000], [189, 881849, 20, 20000], [177, 881849, 25, 20000], [173, 881849, 30, 20000],
    [255, 837757, 0, 20000], [232, 837757, 1, 20000], [214, 837757, 5, 20000], [200, 837757, 10, 20000], [184, 837757, 20, 20000], [172, 837757, 25, 20000], [169, 837757, 30, 20000],
    [250, 793664, 0, 20000], [227, 793664, 1, 20000], [214, 793664, 5, 20000], [197, 793664, 10, 20000], [180, 793664, 20, 20000], [167, 793664, 25, 20000], [164, 793664, 30, 20000],
    [246, 749572, 0, 20000], [223, 749572, 1, 20000], [211, 749572, 5, 20000], [193, 749572, 10, 20000], [177, 749572, 20, 20000], [163, 749572, 25, 20000], [160, 749572, 30, 20000],
    [238, 705479, 0, 20000], [218, 705479, 1, 20000], [203, 705479, 5, 20000], [186, 705479, 10, 20000], [171, 705479, 20, 20000], [158, 705479, 25, 20000], [155, 705479, 30, 20000],
    [233, 661387, 0, 20000], [213, 661387, 1, 20000], [196, 661387, 5, 20000], [180, 661387, 10, 20000], [165, 661387, 20, 20000], [153, 661387, 25, 20000], [150, 661387, 30, 20000],
    [227, 617294, 0, 20000], [207, 617294, 1, 20000], [188, 617294, 5, 20000], [173, 617294, 10, 20000], [159, 617294, 20, 20000], [147, 617294, 25, 20000], [144, 617294, 30, 20000],
    [221, 573202, 0, 20000], [201, 573202, 1, 20000], [181, 573202, 5, 20000], [166, 573202, 10, 20000], [153, 573202, 20, 20000], [141, 573202, 25, 20000], [139, 573202, 30, 20000],
    [215, 529109, 0, 20000], [195, 529109, 1, 20000], [175, 529109, 5, 20000], [158, 529109, 10, 20000], [146, 529109, 20, 20000], [136, 529109, 25, 20000], [133, 529109, 30, 20000],
    [209, 485017, 0, 20000], [189, 485017, 1, 20000], [169, 485017, 5, 20000], [151, 485017, 10, 20000], [139, 485017, 20, 20000], [130, 485017, 25, 20000], [127, 485017, 30, 20000],
    [205, 440925, 0, 20000], [185, 440925, 1, 20000], [164, 440925, 5, 20000], [145, 440925, 10, 20000], [134, 440925, 20, 20000], [124, 440925, 25, 20000], [121, 440925, 30, 20000],
]);
/** Holding Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B748SpeedData.holding_speeds = new LerpLookupTable([
    [267, 1014126, 0, 1500], [269, 1014126, 0, 5000], [271, 1014126, 0, 10000], [277, 1014126, 0, 15000], [318, 1014126, 0, 20000], [323, 1014126, 0, 25000], [316, 1014126, 0, 30000],
    [261, 970034, 0, 1500], [263, 970034, 0, 5000], [265, 970034, 0, 10000], [269, 970034, 0, 15000], [311, 970034, 0, 20000], [315, 970034, 0, 25000], [316, 970034, 0, 30000],
    [257, 925942, 0, 1500], [257, 925942, 0, 5000], [259, 925942, 0, 10000], [262, 925942, 0, 15000], [303, 925942, 0, 20000], [307, 925942, 0, 25000], [312, 925942, 0, 30000],
    [252, 881849, 0, 1500], [252, 881849, 0, 5000], [254, 881849, 0, 10000], [255, 881849, 0, 15000], [296, 881849, 0, 20000], [299, 881849, 0, 25000], [304, 881849, 0, 30000], [283, 881849, 0, 35000],
    [248, 837757, 0, 1500], [248, 837757, 0, 5000], [249, 837757, 0, 10000], [250, 837757, 0, 15000], [288, 837757, 0, 20000], [291, 837757, 0, 25000], [295, 837757, 0, 30000], [283, 837757, 0, 35000],
    [243, 793664, 0, 1500], [243, 793664, 0, 5000], [244, 793664, 0, 10000], [246, 793664, 0, 15000], [280, 793664, 0, 20000], [283, 793664, 0, 25000], [287, 793664, 0, 30000], [283, 793664, 0, 35000],
    [239, 749572, 0, 1500], [239, 749572, 0, 5000], [240, 749572, 0, 10000], [242, 749572, 0, 15000], [272, 749572, 0, 20000], [275, 749572, 0, 25000], [278, 749572, 0, 30000], [283, 749572, 0, 35000],
    [235, 705479, 0, 1500], [235, 705479, 0, 5000], [235, 705479, 0, 10000], [237, 705479, 0, 15000], [263, 705479, 0, 20000], [266, 705479, 0, 25000], [269, 705479, 0, 30000], [273, 705479, 0, 35000], [252, 705479, 0, 40000],
    [230, 661387, 0, 1500], [230, 661387, 0, 5000], [230, 661387, 0, 10000], [231, 661387, 0, 15000], [254, 661387, 0, 20000], [257, 661387, 0, 25000], [260, 661387, 0, 30000], [264, 661387, 0, 35000], [252, 661387, 0, 40000],
    [224, 617294, 0, 1500], [224, 617294, 0, 5000], [225, 617294, 0, 10000], [226, 617294, 0, 15000], [246, 617294, 0, 20000], [248, 617294, 0, 25000], [250, 617294, 0, 30000], [254, 617294, 0, 35000], [252, 617294, 0, 40000], [235, 617294, 0, 43000],
    [219, 573202, 0, 1500], [219, 573202, 0, 5000], [220, 573202, 0, 10000], [220, 573202, 0, 15000], [236, 573202, 0, 20000], [238, 573202, 0, 25000], [241, 573202, 0, 30000], [244, 573202, 0, 35000], [247, 573202, 0, 40000], [235, 573202, 0, 43000],
    [213, 529109, 0, 1500], [213, 529109, 0, 5000], [214, 529109, 0, 10000], [214, 529109, 0, 15000], [227, 529109, 0, 20000], [228, 529109, 0, 25000], [231, 529109, 0, 30000], [233, 529109, 0, 35000], [237, 529109, 0, 40000], [234, 529109, 0, 43000],
    [208, 485017, 0, 1500], [208, 485017, 0, 5000], [208, 485017, 0, 10000], [209, 485017, 0, 15000], [217, 485017, 0, 20000], [218, 485017, 0, 25000], [220, 485017, 0, 30000], [223, 485017, 0, 35000], [226, 485017, 0, 40000], [228, 485017, 0, 43000],
    [205, 440925, 0, 1500], [205, 440925, 0, 5000], [205, 440925, 0, 10000], [205, 440925, 0, 15000], [208, 440925, 0, 20000], [209, 440925, 0, 25000], [210, 440925, 0, 30000], [212, 440925, 0, 35000], [215, 440925, 0, 40000], [216, 440925, 0, 43000],
    [245, 1014126, 1, 1500], [246, 1014126, 1, 5000], [247, 1014126, 1, 10000], [249, 1014126, 1, 15000], [252, 1014126, 1, 20000],
    [241, 970034, 1, 1500], [241, 970034, 1, 5000], [243, 970034, 1, 10000], [245, 970034, 1, 15000], [247, 970034, 1, 20000],
    [236, 925942, 1, 1500], [237, 925942, 1, 5000], [238, 925942, 1, 10000], [240, 925942, 1, 15000], [242, 925942, 1, 20000],
    [232, 881849, 1, 1500], [232, 881849, 1, 5000], [234, 881849, 1, 10000], [235, 881849, 1, 15000], [237, 881849, 1, 20000],
    [227, 837757, 1, 1500], [228, 837757, 1, 5000], [229, 837757, 1, 10000], [230, 837757, 1, 15000], [232, 837757, 1, 20000],
    [223, 793664, 1, 1500], [223, 793664, 1, 5000], [224, 793664, 1, 10000], [225, 793664, 1, 15000], [227, 793664, 1, 20000],
    [219, 749572, 1, 1500], [219, 749572, 1, 5000], [220, 749572, 1, 10000], [221, 749572, 1, 15000], [223, 749572, 1, 20000],
    [214, 705479, 1, 1500], [215, 705479, 1, 5000], [215, 705479, 1, 10000], [216, 705479, 1, 15000], [218, 705479, 1, 20000],
    [209, 661387, 1, 1500], [210, 661387, 1, 5000], [210, 661387, 1, 10000], [211, 661387, 1, 15000], [213, 661387, 1, 20000],
    [204, 617294, 1, 1500], [204, 617294, 1, 5000], [205, 617294, 1, 10000], [206, 617294, 1, 15000], [207, 617294, 1, 20000],
    [199, 573202, 1, 1500], [199, 573202, 1, 5000], [200, 573202, 1, 10000], [200, 573202, 1, 15000], [201, 573202, 1, 20000],
    [193, 529109, 1, 1500], [193, 529109, 1, 5000], [194, 529109, 1, 10000], [194, 529109, 1, 15000], [195, 529109, 1, 20000],
    [188, 485017, 1, 1500], [188, 485017, 1, 5000], [188, 485017, 1, 10000], [189, 485017, 1, 15000], [189, 485017, 1, 20000],
    [185, 440925, 1, 1500], [185, 440925, 1, 5000], [185, 440925, 1, 10000], [185, 440925, 1, 15000], [185, 440925, 1, 20000],
]);

/**
 * Automatically selects the best IRS for a Boeing 747-8.
 *
 * The selected IRS depends on the state of the IRS source select knob. If the knob has Left, Center, or Right
 * selected, then that IRS will be selected. If the knob has Auto selected, then the most desirable from among all
 * three IRSes will be selected. Desirability is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class B748IrsSystemSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param sourceSelectSide The system source select side that determines the preferred IRS and which IRS candidates
     * are available from which to select.
     */
    constructor(bus, sourceSelectSide) {
        this.bus = bus;
        this.sourceSelectSide = sourceSelectSide;
        this.candidates = SetSubject.create([1, 2, 3]);
        this.selector = new IrsSystemSelector(1, this.bus, this.candidates, this.sourceSelectSide === 'right' ? 3 : 1);
        this.isAlive = true;
        this.isInit = false;
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('B748IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.bus.getSubscriber()
            .on(`b74_irs_source_knob_state_${this.sourceSelectSide === 'right' ? 2 : 1}`)
            .handle(state => {
            let left = false, center = false, right = false;
            switch (state) {
                case IrsSourceKnobState.Left:
                    left = true;
                    break;
                case IrsSourceKnobState.Center:
                    center = true;
                    break;
                case IrsSourceKnobState.Right:
                    right = true;
                    break;
                default:
                    left = true;
                    center = true;
                    right = true;
            }
            this.candidates.toggle(1, left);
            this.candidates.toggle(2, center);
            this.candidates.toggle(3, right);
        });
        this.selector.init();
    }
}

/**
 * A TCAS II implementation for the B748.
 */
class B748TCAS extends BoeingTCAS {
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * A common instrument for the B747-8i displays.
 */
class WTB748FsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        this.instrument = instrument;
        this.config = config;
        this.isInstrumentPowered = false;
        this.isPowerValid = false;
        this.isPowered = undefined;
        this.bus = new EventBus();
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.hEventPublisher = new HEventPublisher(this.bus);
        this.flightPathCalculator = new FlightPathCalculator(this.facLoader, {
            defaultClimbRate: 2000,
            defaultSpeed: 180,
            bankAngle: BoeingFlightPathUtils.flightPathBankAngleTable,
            holdBankAngle: null,
            courseReversalBankAngle: null,
            turnAnticipationBankAngle: null,
            maxBankAngle: 25,
            airplaneSpeedMode: FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
        }, this.bus);
        this.flightPlanner = FlightPlanner.getPlanner(this.bus, this.flightPathCalculator, BoeingFmsUtils.buildBoeingLegName);
        this.perfPlanRepository = new PerformancePlanRepository(this.flightPlanner, this.bus);
        this.activeRoutePerformancePlan = this.perfPlanRepository.getActivePlan();
        this.performanceMath = new B748PerformanceMath();
        this.performanceProvider = new B748PerformanceProvider(this.performanceMath);
        this.engineDataProvider = new B748EngineData(this.bus, this.performanceMath);
        this.windPlanner = new InterpolatingWindPlanner(this.bus, this.flightPlanner, {
            numberOfClimbAltitudes: 4,
            numberOfDescentAltitudes: 4,
            numberOfLegAltitudes: 4,
        });
        this.verticalPathCalculator = new BoeingPathCalculator(this.bus, this.flightPlanner, BoeingFms.ACT_RTE_PLAN_INDEX, this.performanceProvider, this.engineDataProvider, this.perfPlanRepository, this.windPlanner, {
            engineCount: 4
        });
        this.activeRoutePredictor = new BoeingFlightPlanPredictionsProvider(this.bus, 1, BoeingFms.ACT_RTE_PLAN_INDEX, 1000, this.flightPlanner, this.verticalPathCalculator, this.perfPlanRepository, this.performanceProvider, this.facLoader);
        this.altitudeAlertController = new B748AltitudeAlertController(this.bus, this.activeRoutePerformancePlan);
        this.backplane = new InstrumentBackplane();
        this.clock = new Clock(this.bus);
        this.baseInstrumentPublisher = new BaseInstrumentPublisher(this.instrument, this.bus);
        this.gnssPublisher = new GNSSPublisher(this.bus);
        this.adcPublisher = new AdcPublisher(this.bus);
        this.ahrsPublisher = new AhrsPublisher(this.bus);
        this.lNavPublisher = new LNavSimVarPublisher(this.bus);
        this.lNavDataPublisher = new BoeingLNavDataSimVarPublisher(this.bus);
        this.vNavPublisher = new VNavSimVarPublisher(this.bus);
        this.boeingVNavPublisher = new BoeingVNavSimVarPublisher(this.bus);
        this.navComSimVarPublisher = new NavComSimVarPublisher(this.bus);
        this.cockpitVarsPublisher = new CockpitVarsPublisher(this.bus);
        this.electricalPublisher = new ElectricalPublisher(this.bus);
        this.eisPublisher = new EISPublisher(this.bus);
        this.timerPublisher = new FlightTimerPublisher(this.bus, 2);
        this.trafficInstrument = new TrafficInstrument(this.bus, { realTimeUpdateFreq: 2, simTimeUpdateFreq: 1, contactDeprecateTime: 10 });
        this.weightAndBalancePublisher = new WeightBalanceSimvarPublisher(this.bus);
        this.tcas = new B748TCAS(this.bus, this.trafficInstrument, 30, 2, 1);
        this.gameUnitsPublisher = new BoeingGameUnitsPublisher(this.bus);
        this.xpdrInstrument = new XPDRInstrument(this.bus);
        this.speedData = new B748SpeedData(this.bus);
        this.brakesPublisher = new BrakeSimvarPublisher(this.bus);
        this.flapComputer = new FlapComputer(this.bus, {
            flap_positions: [
                { label: 0, flapAngle: 0, slatAngle: 0, speedLimit: Infinity },
                { label: 1, flapAngle: 0, slatAngle: 21, speedLimit: 285 },
                { label: 5, flapAngle: 5, slatAngle: 21, speedLimit: 265 },
                { label: 10, flapAngle: 10, slatAngle: 21, speedLimit: 245 },
                { label: 20, flapAngle: 20, slatAngle: 21, speedLimit: 235 },
                { label: 25, flapAngle: 25, slatAngle: 21, speedLimit: 210 },
                { label: 30, flapAngle: 30, slatAngle: 21, speedLimit: 185 },
            ],
            speed_data: this.speedData,
        });
        this.apInstrument = new AutopilotInstrument(this.bus);
        this.apRadioNavInstrument = new APRadioNavInstrument(this.bus);
        this.systems = [];
        this.sourceSelectSide = this.getSourceSelectSide();
        this.irsSystemSelector = new B748IrsSystemSelector(this.bus, this.sourceSelectSide);
        /** Whether this instrument has started updating. */
        this.haveUpdatesStarted = false;
        this.backplane.addInstrument(InstrumentBackplaneNames.Clock, this.clock);
        this.backplane.addInstrument(InstrumentBackplaneNames.Autopilot, this.apInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.AutopilotRadioNav, this.apRadioNavInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Traffic, this.trafficInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Xpdr, this.xpdrInstrument);
        this.backplane.addPublisher(InstrumentBackplaneNames.Base, this.baseInstrumentPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.HEvents, this.hEventPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Adc, this.adcPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ahrs, this.ahrsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Gnss, this.gnssPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNav, this.lNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNavData, this.lNavDataPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.VNav, this.vNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingVNav, this.boeingVNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.NavCom, this.navComSimVarPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.CockpitVars, this.cockpitVarsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Electrical, this.electricalPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Eis, this.eisPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.WeightAndBalance, this.weightAndBalancePublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Units, this.gameUnitsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Timer, this.timerPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Brakes, this.brakesPublisher);
        this.tcas.init();
        // force enable animations
        document.documentElement.classList.add('animationsEnabled');
        // Wait until game has entered briefing or in-game mode before initializing the avionics status client. This
        // ensures that we do not publish any statuses based on erroneous power states.
        Wait.awaitSubscribable(GameStateProvider.get(), gameState => gameState === GameState.briefing || gameState === GameState.ingame, true).then(async () => {
            this.isPowerValid = true;
            // Wait until updates have started before initializing the power state because instrument power is not
            // initialized until the first update.
            await Wait.awaitCondition(() => this.haveUpdatesStarted);
            if (this.isPowered === undefined) {
                this.isPowered = this.isInstrumentPowered;
                this.onPowerChanged(this.isPowered, undefined);
            }
        });
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSoundEnd(soundEventId) {
        // noop
    }
    /** @inheritdoc */
    Update() {
        this.haveUpdatesStarted = true;
        this.backplane.onUpdate();
        this.updateSystems();
    }
    /**
     * Updates this instrument's systems.
     */
    updateSystems() {
        for (let i = 0; i < this.systems.length; i++) {
            this.systems[i].onUpdate();
        }
    }
    /**
     * Creates this instrument's avionics systems. This method should be called after `this.iauIndex` has been defined.
     */
    createSystems() {
        // TODO the B787 doesn't have a magnetometer
        const magnetometers = [new MagnetometerSystem(1, this.bus, 'elec_master_battery')];
        const adcSystems = this.config.sensors.adcDefinitions.slice(1, this.config.sensors.adcCount + 1).map((def, index) => {
            return new AdcSystem(index + 1, this.bus, def.airspeedIndicatorIndex, def.altimeterIndex, def.electricity);
        });
        // TODO: Remove AHRS when we change all the dependencies over to IRS.
        const ahrsSystems = this.config.sensors.ahrsDefinitions.slice(1, this.config.sensors.ahrsCount + 1).map((def, index) => {
            return new AhrsSystem(index + 1, this.bus, def.attitudeIndicatorIndex, def.directionIndicatorIndex, def.electricity);
        });
        const raSystems = this.config.sensors.radarAltimeterDefinitions.slice(1, this.config.sensors.radarAltimeterCount + 1).map((def, index) => {
            /** Videos show the radio altimeter at about -8 on the ground,
             * the RADIO HEIGHT simvar is about +16 feet, so we use offset of -24. */
            return new RASystem(index + 1, this.bus, -24, def.electricity);
        });
        const gpsSystems = [1, 2].map(index => new GpsReceiverSystem(index, this.bus, new GPSSatComputer(index, this.bus, 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/Data/gps_ephemeris.json', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/Data/gps_sbas.json', 5000, [], this.instrument.instrumentIndex === 3 ? 'primary' : 'replica')));
        // TODO: Remove automatic position downlink from GPS receivers and hook up FMC IRS position set event.
        const irsSystems = [1, 2, 3].map(index => {
            const modeSetting = ConsumerSubject.create(this.bus.getSubscriber().on(`b74_irs_knob_state_${index}`), IrsKnobState.Nav)
                .map(state => {
                switch (state) {
                    case IrsKnobState.Align:
                        return IrsSystemOperatingModeSetting.Align;
                    case IrsKnobState.Nav:
                        return IrsSystemOperatingModeSetting.Navigation;
                    case IrsKnobState.Att:
                        return IrsSystemOperatingModeSetting.Attitude;
                    default:
                        return IrsSystemOperatingModeSetting.Off;
                }
            });
            return new IrsSystem(index, this.bus, 1, 1, true, modeSetting, 60000, [1, 2], `elec_circuit_on_${124 + index}`);
        });
        this.gpsReceiverSelector = new GpsReceiverSelector(this.bus, Array.from({ length: this.config.sensors.gpsCount }, (v, index) => index + 1), 1 // Math.min(this.iauIndex, this.config.sensors.gpsCount)
        );
        this.gpsReceiverSelector.init();
        // One FMS geo-positioning system for each PFD (technically IAU)
        const fmsPosSystems = [0].map(index => {
            return new FmsPositionSystem(index + 1, this.bus, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.gpsReceiverSelector.selectedIndex, 1, // pfdSettingManager.getSetting('pfdAdcIndex'),
            1);
        });
        this.systems.push(...magnetometers, ...adcSystems, ...ahrsSystems, ...raSystems, ...gpsSystems, ...irsSystems, ...fmsPosSystems, new AoaSystem(1, this.bus, 'elec_master_battery'), new MarkerBeaconSystem(1, this.bus, 'elec_master_battery'));
        this.irsSystemSelector.init();
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        this.hEventPublisher.dispatchHEvent(args[0]);
    }
    /** @inheritdoc */
    onFlightStart() {
        SimVar.SetSimVarValue('L:WT_Flight_Started', SimVarValueType.Bool, true);
    }
    /**
     * Attempt to run onFlightStart in case the instrument was reloaded.
     */
    tryRunOnFlightStart() {
        // Only try to start if ingame during the constructor.
        // If not ingame, then user will get a briefing and will eventually trigger onFlightStart.
        if (GameStateProvider.get().get() === GameState.ingame) {
            this.onFlightStart();
        }
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onGameStateChanged(oldState, newState) {
        // TODO
    }
    /**
     * A callback which is executed when this instrument transitions from a power-off to power-on state.
     */
    onPowerOn() {
        this.isInstrumentPowered = true;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = true;
            if (old !== true) {
                this.onPowerChanged(true, old);
            }
        }
    }
    /**
     * A callback which is executed when this instrument transitions from a power-on to power-off state.
     */
    onPowerOff() {
        this.isInstrumentPowered = false;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = false;
            if (old !== false) {
                this.onPowerChanged(false, old);
            }
        }
    }
    /**
     * Responds to when this instrument's power state changes.
     * @param current The current power state.
     * @param previous The previous power state, or `undefined` if the previous state was invalid.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPowerChanged(current, previous) {
        //
    }
}

/* eslint-disable jsdoc/require-jsdoc,@typescript-eslint/no-unused-vars */
/** The MfdReferenceOverlay component. */
class MfdReferenceOverlay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.referencePhotoOverlayRef = FSComponent.createRef();
        this.imgSrc = Subject.create('');
        this.overlayEnabled = false;
        this.enableOverlay = () => {
            this.referencePhotoOverlayRef.instance.style.display = 'block';
            this.overlayEnabled = true;
        };
        this.hideOverlay = () => {
            this.referencePhotoOverlayRef.instance.style.display = 'none';
            this.overlayEnabled = false;
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.setupReferenceOverlayToggle();
    }
    addDebugButton(name, image) {
        g_modDebugMgr.AddDebugButton(name, () => {
            if (this.overlayEnabled) {
                if (this.imgSrc.get() === image) {
                    this.hideOverlay();
                }
                else {
                    this.imgSrc.set(image);
                }
            }
            else {
                this.enableOverlay();
                this.imgSrc.set(image);
            }
        });
    }
    /** Adds a debug button to toggle the reference photo overlay. */
    setupReferenceOverlayToggle() {
        if (typeof g_modDebugMgr !== 'undefined') {
            g_modDebugMgr.AddDebugButton('Disable Overlay', this.hideOverlay);
            for (const [name, uri] of MfdReferenceOverlay.IMAGES) {
                this.addDebugButton(name, MfdReferenceOverlay.IMAGE_PREFIX + uri);
            }
        }
    }
    /** @inheritdoc */
    render() {
        const display = 'display: none;';
        // const display = 'display: unset;';
        return (FSComponent.buildComponent("div", { class: "reference-photo-overlay", ref: this.referencePhotoOverlayRef, style: display + 'position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 10000; opacity: 0.5; pointer-events: none;' },
            FSComponent.buildComponent("img", { alt: "", src: this.imgSrc })));
    }
}
MfdReferenceOverlay.IMAGE_PREFIX = '/Pages/VCockpit/Instruments/Airliners/WTB747_8i/MFD/MfdReferenceOverlay/';
/** Pairs of name and image URI */
MfdReferenceOverlay.IMAGES = [
    ['ND', 'nd.png'],
    ['EICAS', 'eicas.png'],
    ['ENG 1', 'eng-1.png'],
    ['ENG 2', 'eng-2.png'],
];

/** The B78xNavigationMap component. */
class BlankMfd extends DisplayPaneView {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "blank-mfd-page" }));
    }
}

/** The B747ChecklistPage component. */
class B748ChecklistPage extends DisplayPaneView {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(BoeingChecklistPage, { bus: this.props.bus, repo: this.props.repo }));
    }
}

// const POWER_UP = new BoeingChecklist(
//   'POWER UP',
//   [
//     new BoeingChecklistItem('Parking Brake', 'SET'),
//     new BoeingChecklistItem('BATTERY switch', 'ON'),
//     new BoeingChecklistItem('STANDBY POWER selector', 'AUTO'),
//     // TODO
//     // new BoeingChecklistItem('Hydraulic DEMAND pump selectors', 'OFF'),
//     new BoeingChecklistItem('Windshield WIPER selectos', 'OFF'),
//     // new BoeingChecklistItem('ALTERNATE FLAPS selector', 'OFF'),
//     new BoeingChecklistItem('Landing gear lever', 'DN'),
//     new BoeingChecklistItem('BUS TIE switches', 'AUTO'),
//     new BoeingChecklistItem('External Power', 'ON'),
//     // new BoeingChecklistItem('APU Start Source switch', 'TR/APU BAT'),
//     new BoeingChecklistItem('APU selector', 'START, then ON'),
//     new BoeingChecklistItem('APU GEN 1-2', 'ON'),
//     new BoeingChecklistItem('NAV light switch', 'ON'),
//   ]
// );
const PREFLIGHT = new BoeingChecklist('PREFLIGHT', [
    // new BoeingChecklistItem('Parking Brake', 'SET'),
    // Electrical panel ... Set
    new BoeingChecklistItem('STANDBY POWER selector', 'AUTO'),
    // new BoeingChecklistItem('UTILITY power switches', 'ON'),
    new BoeingChecklistItem('BATTERY switch', 'ON'),
    new BoeingChecklistItem('EXT POWER switches', 'ON'),
    // new BoeingChecklistItem('BUS TIE switches', 'AUTO'),
    // new BoeingChecklistItem('GENERATOR CONTROL switches', 'ON'),
    new BoeingChecklistItem('APU selector', 'START, then ON'),
    new BoeingChecklistItem('APU GEN 1-2', 'ON'),
    // HYDRAULIC panel ... Set
    // TODO - stuck in AUTO right now
    // new BoeingChecklistItem('Hydraulic DEMAND pump selectors', 'OFF'),
    // new BoeingChecklistItem('Hydraulic ENGINE pump switches', 'ON'),
    // TODO
    // new BoeingChecklistItem('EMERGENCY LIGHTS switch', 'Guard closed'),
    // TODO? Can't find the switches
    // new BoeingChecklistItem('FUEL TRANSFER MAIN 1 AND 4 switch', 'OFF'),
    // Fuel panel ... Set
    // new BoeingChecklistItem('All CROSSFEED valve switches', 'ON'),
    // new BoeingChecklistItem('All fuel pump switches', 'Off'),
    // new BoeingChecklistItem('APU bleed air switch', 'ON'),
    new BoeingChecklistItem('NAV light switch', 'ON'),
    // new BoeingChecklistItem('LOGO light switch', 'ON'),
    new BoeingChecklistItem('FLIGHT DIRECTOR switch', 'ON'),
    // new BoeingChecklistItem('BANK LIMIT selector', 'AUTO'),
    new BoeingChecklistItem('SEATBELTS selector', 'ON'),
    // new BoeingChecklistItem('SPEEDBRAKE lever', 'DN'),
]);
const BEFORE_START_CHKL = new BoeingChecklist('BEFORE START', [
    // new BoeingChecklistItem('Flight deck door', 'Closed and locked'),
    new BoeingChecklistItem('Transponder panel', 'SET'),
    new BoeingChecklistItem('AUTOTHROTTLE ARM switch', 'ON'),
    new BoeingChecklistItem('Takeoff speeds', 'Set'),
    new BoeingChecklistItem('TO Trim', 'SET'),
    new BoeingChecklistItem('Altimeter', 'SET'),
    new BoeingChecklistItem('Taxi and takeoff briefing', 'Completed'),
    new BoeingChecklistItem('BEACON light switch', 'BOTH'),
    new BoeingChecklistItem('ENGINE BLEED air switches', 'ON'),
]);
const BEFORE_TAXI = new BoeingChecklist('BEFORE TAXI', [
    new BoeingChecklistItem('APU bleed air switch', 'OFF'),
    new BoeingChecklistItem('APU selector', 'OFF'),
    new BoeingChecklistItem('SPEED BRAKE lever', 'ARMED'),
    new BoeingChecklistItem('AUTOBRAKE selector', 'RTO'),
    // TODO
    // new BoeingChecklistItem('EICAS', 'RECALL'),
    new BoeingChecklistItem('T/O Flaps', 'SET'),
    new BoeingChecklistItem('TAXI light switch', 'ON'),
]);
const BEFORE_TAKEOFF_CHKL = new BoeingChecklist('BEFORE TAKEOFF', [
    new BoeingChecklistItem('Flight controls', 'Checked'),
    new BoeingChecklistItem('VNAV CLB Page', 'Display'),
    new BoeingChecklistItem('Engine Anti-Ice', 'As Req\'d'),
    new BoeingChecklistItem('STROBE light switch', 'ON'),
    new BoeingChecklistItem('LANDING light switches', 'ON'),
    new BoeingChecklistItem('TAXI light switch', 'OFF'),
    new BoeingChecklistItem('XPDR', 'TA/RA'),
]);
const AFTER_TAKEOFF = new BoeingChecklist('AFTER TAKEOFF', [
    new BoeingChecklistItem('Landing Gear Lever', 'UP'),
    new BoeingChecklistItem('Flaps', 'UP'),
    new BoeingChecklistItem('Wing Anti-Ice', 'As Req\'d'),
    new BoeingChecklistItem('Spoilers', 'DN'),
    // TODO - support text line items
    // At Transition Altitude
    // new BoeingChecklistItem('Altimeter', 'STD'),
    // new BoeingChecklistItem('LANDING light switches', 'OFF'),
    // new BoeingChecklistItem('SEATBELTS selector', 'As Req\'d'),
]);
const DESCENT = new BoeingChecklist('DESCENT', [
    new BoeingChecklistItem('AUTOBRAKE selector', 'As Req\'d'),
    new BoeingChecklistItem('Anti-Ice', 'As Req\'d'),
    new BoeingChecklistItem('Altimeter', 'SET'),
    // TODO - support text line items
    // At Transition Level
    // new BoeingChecklistItem('Altimeter', 'SET'),
    // new BoeingChecklistItem('LANDING light switches', 'ON'),
    // new BoeingChecklistItem('SEATBELTS selector', 'ON'),
]);
const APPROACH = new BoeingChecklist('APPROACH', [
    new BoeingChecklistItem('LANDING light switches', 'ON'),
    new BoeingChecklistItem('SEATBELTS selector', 'ON'),
]);
const LANDING = new BoeingChecklist('LANDING', [
    new BoeingChecklistItem('Landing Gear', 'DN'),
    new BoeingChecklistItem('SPEED BRAKE lever', 'ARMED'),
    new BoeingChecklistItem('Flaps (Landing)', 'SET'),
]);
const SHUTDOWN = new BoeingChecklist('SHUTDOWN', [
    new BoeingChecklistItem('LANDING light switches', 'OFF'),
    new BoeingChecklistItem('TAXI light switch', 'OFF'),
    new BoeingChecklistItem('Throttle', 'IDLE'),
    new BoeingChecklistItem('Parking Brake', 'SET'),
    new BoeingChecklistItem('SEATBLETS selector', 'OFF'),
    new BoeingChecklistItem('Anti-Ice', 'OFF'),
    new BoeingChecklistItem('Fuel Flow', 'CUTOFF'),
    new BoeingChecklistItem('BEACON light switch', 'OFF'),
]);
const SECURE = new BoeingChecklist('SECURE', [
    new BoeingChecklistItem('Fuel Pumps', 'OFF'),
    new BoeingChecklistItem('APU GEN 1-2', 'OFF'),
    new BoeingChecklistItem('APU selector', 'OFF'),
    new BoeingChecklistItem('BATTERY switch', 'OFF'),
    new BoeingChecklistItem('STANDBY POWER selector', 'OFF'),
]);
/**
 * B748 Checklist class that holds the checklists
 */
class B748Checklists {
    /**
     * Gets all the normal checklists.
     * @returns the normal checklists.
     */
    static getNormalChecklists() {
        return [
            PREFLIGHT,
            BEFORE_START_CHKL,
            BEFORE_TAXI,
            BEFORE_TAKEOFF_CHKL,
            AFTER_TAKEOFF,
            DESCENT,
            APPROACH,
            LANDING,
            SHUTDOWN,
            SECURE,
        ];
    }
    /**
     * Gets all the non-normal checklists.
     * @returns the non-normal checklists.
     */
    static getNonNormalChecklists() {
        return [];
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
/** The B78xNavigationMap component. */
class B748Doors extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.doorSub = this.props.bus.getSubscriber();
        this.engineSub = this.props.bus.getSubscriber();
        this.engine1N1 = ConsumerValue.create(this.engineSub.on('n1_1').whenChanged().withPrecision(1), 0);
        this.entry1LStatus = ConsumerSubject.create(this.doorSub.on('entry_1l_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry1RStatus = ConsumerSubject.create(this.doorSub.on('entry_1r_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry2LStatus = ConsumerSubject.create(this.doorSub.on('entry_2l_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry2RStatus = ConsumerSubject.create(this.doorSub.on('entry_2r_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry3LStatus = ConsumerSubject.create(this.doorSub.on('entry_3l_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry3RStatus = ConsumerSubject.create(this.doorSub.on('entry_3r_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry4LStatus = ConsumerSubject.create(this.doorSub.on('entry_4l_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry4RStatus = ConsumerSubject.create(this.doorSub.on('entry_4r_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry5LStatus = ConsumerSubject.create(this.doorSub.on('entry_5l_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entry5RStatus = ConsumerSubject.create(this.doorSub.on('entry_5r_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entryULStatus = ConsumerSubject.create(this.doorSub.on('entry_ul_status').whenChanged(), B74DoorStatus.MANUAL);
        this.entryURStatus = ConsumerSubject.create(this.doorSub.on('entry_ur_status').whenChanged(), B74DoorStatus.MANUAL);
        this.fwdCargoStatus = ConsumerSubject.create(this.doorSub.on('fwd_cargo_status').whenChanged(), B74DoorStatus.BLANK);
        this.aftCargoStatus = ConsumerSubject.create(this.doorSub.on('aft_cargo_status').whenChanged(), B74DoorStatus.BLANK);
        this.entry1LDisplayRef = FSComponent.createRef();
        this.entry1LAutoRef = FSComponent.createRef();
        this.entry1LManualRef = FSComponent.createRef();
        this.entry1RDisplayRef = FSComponent.createRef();
        this.entry1RAutoRef = FSComponent.createRef();
        this.entry1RManualRef = FSComponent.createRef();
        this.entry2LDisplayRef = FSComponent.createRef();
        this.entry2LAutoRef = FSComponent.createRef();
        this.entry2LManualRef = FSComponent.createRef();
        this.entry2RDisplayRef = FSComponent.createRef();
        this.entry2RAutoRef = FSComponent.createRef();
        this.entry2RManualRef = FSComponent.createRef();
        this.entry3LDisplayRef = FSComponent.createRef();
        this.entry3LAutoRef = FSComponent.createRef();
        this.entry3LManualRef = FSComponent.createRef();
        this.entry3RDisplayRef = FSComponent.createRef();
        this.entry3RAutoRef = FSComponent.createRef();
        this.entry3RManualRef = FSComponent.createRef();
        this.entry4LDisplayRef = FSComponent.createRef();
        this.entry4LAutoRef = FSComponent.createRef();
        this.entry4LManualRef = FSComponent.createRef();
        this.entry4RDisplayRef = FSComponent.createRef();
        this.entry4RAutoRef = FSComponent.createRef();
        this.entry4RManualRef = FSComponent.createRef();
        this.entry5LDisplayRef = FSComponent.createRef();
        this.entry5LAutoRef = FSComponent.createRef();
        this.entry5LManualRef = FSComponent.createRef();
        this.entry5RDisplayRef = FSComponent.createRef();
        this.entry5RAutoRef = FSComponent.createRef();
        this.entry5RManualRef = FSComponent.createRef();
        this.entryULDisplayRef = FSComponent.createRef();
        this.entryULAutoRef = FSComponent.createRef();
        this.entryULManualRef = FSComponent.createRef();
        this.entryURDisplayRef = FSComponent.createRef();
        this.entryURAutoRef = FSComponent.createRef();
        this.entryURManualRef = FSComponent.createRef();
        this.fwdCargoRef = FSComponent.createRef();
        this.aftCargoRef = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate(time) {
        // noop
    }
    /** @inheritdoc */
    onAfterRender() {
        // start with doors AUTO if initialized with engines running
        if (this.engine1N1.get() > 1) {
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry1LDisplayRef, this.entry1LAutoRef, this.entry1LManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry1RDisplayRef, this.entry1RAutoRef, this.entry1RManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry2LDisplayRef, this.entry2LAutoRef, this.entry2LManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry2RDisplayRef, this.entry2RAutoRef, this.entry2RManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry3LDisplayRef, this.entry3LAutoRef, this.entry3LManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry3RDisplayRef, this.entry3RAutoRef, this.entry3RManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry4LDisplayRef, this.entry4LAutoRef, this.entry4LManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry4RDisplayRef, this.entry4RAutoRef, this.entry4RManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry5LDisplayRef, this.entry5LAutoRef, this.entry5LManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entry5RDisplayRef, this.entry5RAutoRef, this.entry5RManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entryULDisplayRef, this.entryULAutoRef, this.entryULManualRef, true);
            this.updateEntryDoorDisplay(B74DoorStatus.AUTO, this.entryURDisplayRef, this.entryURAutoRef, this.entryURManualRef, true);
        }
        this.subs.push(this.entry1LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry1LDisplayRef, this.entry1LAutoRef, this.entry1LManualRef), true));
        this.subs.push(this.entry1RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry1RDisplayRef, this.entry1RAutoRef, this.entry1RManualRef), true));
        this.subs.push(this.entry2LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry2LDisplayRef, this.entry2LAutoRef, this.entry2LManualRef), true));
        this.subs.push(this.entry2RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry2RDisplayRef, this.entry2RAutoRef, this.entry2RManualRef), true));
        this.subs.push(this.entry3LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry3LDisplayRef, this.entry3LAutoRef, this.entry3LManualRef), true));
        this.subs.push(this.entry3RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry3RDisplayRef, this.entry3RAutoRef, this.entry3RManualRef), true));
        this.subs.push(this.entry4LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry4LDisplayRef, this.entry4LAutoRef, this.entry4LManualRef), true));
        this.subs.push(this.entry4RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry4RDisplayRef, this.entry4RAutoRef, this.entry4RManualRef), true));
        this.subs.push(this.entry5LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry5LDisplayRef, this.entry5LAutoRef, this.entry5LManualRef), true));
        this.subs.push(this.entry5RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry5RDisplayRef, this.entry5RAutoRef, this.entry5RManualRef), true));
        this.subs.push(this.entryULStatus.sub(v => this.updateEntryDoorDisplay(v, this.entryULDisplayRef, this.entryULAutoRef, this.entryULManualRef), true));
        this.subs.push(this.entryURStatus.sub(v => this.updateEntryDoorDisplay(v, this.entryURDisplayRef, this.entryURAutoRef, this.entryURManualRef), true));
        this.subs.push(this.fwdCargoStatus.sub(v => this.updateOtherDoorDisplay(v, this.fwdCargoRef), true));
        this.subs.push(this.aftCargoStatus.sub(v => this.updateOtherDoorDisplay(v, this.aftCargoRef), true));
    }
    /**
     * Updates Entry door status display (with randomized delay on closing doors)
     * @param doorStatus the new door status
     * @param doorDisplayRef the door display div reference to update
     * @param doorAutoRef the door auto div reference to update
     * @param doorManualRef the door manual div reference to update
     * @param force whether to force immediate change (skip the random timeout)
     * @private
     */
    updateEntryDoorDisplay(doorStatus, doorDisplayRef, doorAutoRef, doorManualRef, force = false) {
        switch (doorStatus) {
            case B74DoorStatus.OPEN:
                doorDisplayRef.instance.classList.add('door-not-locked');
                doorAutoRef.instance.classList.add('hidden');
                doorManualRef.instance.classList.remove('hidden');
                break;
            case B74DoorStatus.AUTO:
                setTimeout(() => {
                    doorDisplayRef.instance.classList.remove('door-not-locked');
                    doorAutoRef.instance.classList.remove('hidden');
                    doorManualRef.instance.classList.add('hidden');
                }, force ? 0 : Math.random() * 5000);
                break;
            case B74DoorStatus.MANUAL:
                setTimeout(() => {
                    doorDisplayRef.instance.classList.remove('door-not-locked');
                    doorAutoRef.instance.classList.add('hidden');
                    doorManualRef.instance.classList.remove('hidden');
                }, force ? 0 : Math.random() * 5000);
                break;
        }
    }
    /**
     * Updates other (cargo/e-bay etc.) door status display
     * @param doorStatus the new door status
     * @param door the door div reference to update
     * @private
     */
    updateOtherDoorDisplay(doorStatus, door) {
        switch (doorStatus) {
            case B74DoorStatus.BLANK:
                door.instance.classList.remove('door-not-locked');
                break;
            case B74DoorStatus.OPEN:
                door.instance.classList.add('door-not-locked');
                break;
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "sys-doors-container" },
            FSComponent.buildComponent("div", { class: "sys-doors-aircraft-diagram-container" },
                FSComponent.buildComponent("svg", { class: "sys-doors-aircraft-diagram", viewBox: "-6 106 966 1109" },
                    FSComponent.buildComponent("path", { d: "M 409 304 L 409 1076 C 411 1126 413 1140 424 1207 M 532.108 1207.548 C 542 1147 545 1126 547.7 1076 L 548 304 C 545 214 509 112 477 112 C 449 112 412 214 409 304", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 409 1076 C 418 1167 538 1167 548 1076 M 415 1149 L 350 1209 M 541 1149 L 606 1209", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 360 498 L 0 788 M 600 498 L 954 788 M 548 710 L 727 794 M 409 710 L 230 794", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "sys-doors-left-column-grid" },
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container fd-ovhd" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "F/D OVHD"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }))),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "MAIN ELEC"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }))),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 1"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }),
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry1LAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry1LManualRef }, "M"))),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" }),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "UPPER DECK"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }),
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entryULAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entryULManualRef }, "M"))),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 2"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }),
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry2LAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry2LManualRef }, "M"))),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 3"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }),
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry3LAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry3LManualRef }, "M"))),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 4"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }),
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry4LAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry4LManualRef }, "M"))),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container" },
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 5"),
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" }),
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry5LAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry5LManualRef }, "M")))),
            FSComponent.buildComponent("div", { class: "sys-doors-right-column-grid" },
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry1RAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry1RManualRef }, "M"),
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 1")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "FWD CARGO")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entryURAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entryURManualRef }, "M"),
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "UPPER DECK")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry2RAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry2RManualRef }, "M"),
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 2")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                            FSComponent.buildComponent("div", { class: "sys-doors-pointer" }))),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "CTR ELEC")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry3RAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry3RManualRef }, "M"),
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 3")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" }),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry4RAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry4RManualRef }, "M"),
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 4")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "AFT CARGO")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "BULK CARGO")),
                FSComponent.buildComponent("div", { class: "sys-doors-grid-container right-aligned" },
                    FSComponent.buildComponent("div", { class: "sys-doors-pointer-container" },
                        FSComponent.buildComponent("div", { class: "sys-doors-auto-display hidden", ref: this.entry5RAutoRef }, "A"),
                        FSComponent.buildComponent("div", { class: "sys-doors-manual-display", ref: this.entry5RManualRef }, "M"),
                        FSComponent.buildComponent("div", { class: "sys-doors-pointer" })),
                    FSComponent.buildComponent("div", { class: "sys-doors-name-text" }, "ENTRY 5"))),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-1L entry-door", ref: this.entry1LDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-1R entry-door", ref: this.entry1RDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-UL entry-door", ref: this.entryULDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-UR entry-door", ref: this.entryURDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-2L entry-door", ref: this.entry2LDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-2R entry-door", ref: this.entry2RDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-3L entry-door", ref: this.entry3LDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-3R entry-door", ref: this.entry3RDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-4L entry-door", ref: this.entry4LDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-4R entry-door", ref: this.entry4RDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-5L entry-door", ref: this.entry5LDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-entry-5R entry-door", ref: this.entry5RDisplayRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-fwd-cargo cargo-door", ref: this.fwdCargoRef }),
            FSComponent.buildComponent("div", { class: "sys-doors-aft-cargo cargo-door", ref: this.aftCargoRef })));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}

/** The Ecs Temps Display component. */
class B748EcsTempsDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.tempUnit = Subject.create('C');
        this.masterTargetTemp = Subject.create(24);
        this.flightDeckCurrentTemp = Subject.create(22);
        this.flightDeckTargetTemp = Subject.create(23);
        this.upperDeckCurrentTemp = Subject.create(23);
        this.upperDeckTargetTemp = Subject.create(24);
        this.mainDeckCurrentTemps = [
            Subject.create(23),
            Subject.create(22),
            Subject.create(24),
            Subject.create(25),
            Subject.create(27)
        ];
        this.mainDeckTargetTemps = [
            Subject.create(21),
            Subject.create(22),
            Subject.create(23),
            Subject.create(24),
            Subject.create(25)
        ];
        this.fwdCargoCurrentTemp = Subject.create(19);
        this.aftCargoCurrentTemp = Subject.create(19);
        this.aftCargoTargetTemp = Subject.create(17);
        this.bulkCargoCurrentTemp = Subject.create(16);
        this.subs = [];
    }
    /** @inheritDoc */
    onSuspend() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritDoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "sys-ecs-temps-display-container" },
            FSComponent.buildComponent("div", { class: "ecs-temps-upper-deck ecs-temps-row" },
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.flightDeckCurrentTemp, targetTemp: this.flightDeckTargetTemp, label: 'F/D' }),
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.upperDeckCurrentTemp, targetTemp: this.upperDeckTargetTemp, label: 'U/D' })),
            FSComponent.buildComponent("div", { class: "ecs-temps-lower-deck ecs-temps-row" },
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.mainDeckCurrentTemps[0], targetTemp: this.mainDeckTargetTemps[0], label: 'A' }),
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.mainDeckCurrentTemps[1], targetTemp: this.mainDeckTargetTemps[1], label: 'B' }),
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.mainDeckCurrentTemps[2], targetTemp: this.mainDeckTargetTemps[2], label: 'C' }),
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.mainDeckCurrentTemps[3], targetTemp: this.mainDeckTargetTemps[3], label: 'D' }),
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.mainDeckCurrentTemps[4], targetTemp: this.mainDeckTargetTemps[4], label: 'E' })),
            FSComponent.buildComponent("div", { class: "ecs-temps-cargo ecs-temps-row" },
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.fwdCargoCurrentTemp, label: 'FWD' }),
                FSComponent.buildComponent("div", { class: "ecs-cargo-spacer" }),
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.aftCargoCurrentTemp, targetTemp: this.aftCargoTargetTemp, label: 'AFT' }),
                FSComponent.buildComponent(EcsTempDisplay, { currentTemp: this.bulkCargoCurrentTemp, label: 'BULK' })),
            FSComponent.buildComponent("div", { class: "ecs-temps-master" },
                FSComponent.buildComponent("div", { class: "ecs-temps-master-label sys-ecs-label-text" }, "MASTER"),
                FSComponent.buildComponent("div", { class: "ecs-temps-master-value" }, this.masterTargetTemp)),
            FSComponent.buildComponent("div", { class: "ecs-temps-unit sys-ecs-label-text" },
                "TEMP \u00B0",
                this.tempUnit)));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}
/** Component to display target and current temperatures for a section */
class EcsTempDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.targetTempRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        if (!this.props.targetTemp) {
            this.targetTempRef.instance.classList.add('ecs-hidden');
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: "ecs-temps-display" },
            FSComponent.buildComponent("div", { class: "ecs-temps-display-label" },
                FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, this.props.label)),
            FSComponent.buildComponent("div", { class: "ecs-temp-value-container" },
                FSComponent.buildComponent("div", { class: "ecs-temp-target", ref: this.targetTempRef }, (_a = this.props.targetTemp) !== null && _a !== void 0 ? _a : ''),
                FSComponent.buildComponent("div", { class: "ecs-temp-current" }, this.props.currentTemp))));
    }
}

/** The Ecs Valve Display component. */
class B748EcsValveDisplay extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "sys-ecs-valves-display-container" },
            FSComponent.buildComponent("div", { class: "sys-ecs-recirc-status-container" },
                FSComponent.buildComponent("div", { class: "ecs-recirc-title sys-ecs-label-text" },
                    "LWR",
                    FSComponent.buildComponent("br", null),
                    "RECIRC"),
                FSComponent.buildComponent("div", { class: "ecs-recirc-status" }, "ON"),
                FSComponent.buildComponent("div", { class: "ecs-recirc-status" }, "OFF"),
                FSComponent.buildComponent("div", { class: "ecs-recirc-status ecs-recirc-fail" }, "FAIL"),
                FSComponent.buildComponent("div", { class: "ecs-recirc-label-1 sys-ecs-label-text" }, "1"),
                FSComponent.buildComponent("div", { class: "ecs-recirc-label-2 sys-ecs-label-text" }, "2"),
                FSComponent.buildComponent("div", { class: "ecs-recirc-label-3 sys-ecs-label-text" }, "3")),
            FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-container" },
                FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-template" },
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-needle" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-left-tick" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-top-tick" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-bottom-tick" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-switch-status" }, "AUTO")),
                FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-template" },
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-needle" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-left-tick" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-top-tick" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-bottom-tick" }),
                    FSComponent.buildComponent("div", { class: "ecs-cabin-press-switch-status" }, "MAN")),
                FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-title sys-ecs-label-text" }, "OUTFLOW VALVES"),
                FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-fwd sys-ecs-label-text" }, "L"),
                FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-aft sys-ecs-label-text" }, "R"),
                FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-open sys-ecs-label-text" }, "OP"),
                FSComponent.buildComponent("div", { class: "ecs-cabin-press-valve-closed sys-ecs-label-text" }, "CL"))));
    }
}

/** The B748 Ecs Air System synoptics component. */
class B748EcsAirSystem extends DisplayPaneView {
    constructor() {
        super(...arguments);
        // engine 1 lines
        this.e1ToEai1JctLine = FSComponent.createRef();
        this.eai1JctToEai1Line = FSComponent.createRef();
        this.eai1JctToE1E2JctLine = FSComponent.createRef();
        // engine 2 lines
        this.e2ToEai2JctLine = FSComponent.createRef();
        this.eai2JctToEai2Line = FSComponent.createRef();
        this.eai2JctToE1E2JctLine = FSComponent.createRef();
        // left side combined
        this.e1E2JctToWaiLeftJctLine = FSComponent.createRef();
        this.waiLeftLine = FSComponent.createRef();
        this.waiLeftJctToCrossLeftJctLine = FSComponent.createRef();
        // to packs
        this.crossLeftJctToPack1Line = FSComponent.createRef();
        this.crossCtrJctToPack2Line = FSComponent.createRef();
        this.crossRightJctToPack3Line = FSComponent.createRef();
        // engine 3 lines
        this.e3ToEai3JctLine = FSComponent.createRef();
        this.eai3JctToEai3Line = FSComponent.createRef();
        this.eai3JctToE3E4JctLine = FSComponent.createRef();
        // engine 4 lines
        this.e4ToEai4JctLine = FSComponent.createRef();
        this.eai4JctToEai4Line = FSComponent.createRef();
        this.eai4JctToE3E4JctLine = FSComponent.createRef();
        // right side combined
        this.e3E4JctToWaiRightJctLine = FSComponent.createRef();
        this.waiRightLine = FSComponent.createRef();
        this.waiRightJctToCrossRightJctLine = FSComponent.createRef();
        // crossbleed lines
        this.crossbleedLeftLine = FSComponent.createRef();
        this.crossbleedRightLine = FSComponent.createRef();
        // apu line
        this.apuLine = FSComponent.createRef();
        // HI FLOW labels
        this.hiFlowLeftRef = FSComponent.createRef();
        this.hiFlowCtrRef = FSComponent.createRef();
        this.hiFlowRightRef = FSComponent.createRef();
        // Pack labels
        this.packLeftRef = FSComponent.createRef();
        this.packCtrRef = FSComponent.createRef();
        this.packRightRef = FSComponent.createRef();
        // external air label
        this.extAirRef = FSComponent.createRef();
        // engine bleed labels
        this.eng1BleedLabelRef = FSComponent.createRef();
        this.eng2BleedLabelRef = FSComponent.createRef();
        this.eng3BleedLabelRef = FSComponent.createRef();
        this.eng4BleedLabelRef = FSComponent.createRef();
        // duct PSI values
        this.ductLeftPresRef = Subject.create(21);
        this.ductCtrPresRef = Subject.create(23);
        this.ductRightPresRef = Subject.create(22);
        // engine bleed status
        this.engine1BleedOpen = Subject.create(true);
        this.engine2BleedOpen = Subject.create(true);
        this.engine3BleedOpen = Subject.create(false);
        this.engine4BleedOpen = Subject.create(false);
        this.apuBleedOpen = Subject.create(true);
        this.leftCrossbleedOpen = Subject.create(true);
        this.rightCrossbleedOpen = Subject.create(false);
        this.subs = [];
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /** @inheritdoc */
    onAfterRender() {
        // TODO
    }
    /** @inheritdoc */
    render() {
        // ENGINE BLEED CLOSED: show text (remove 'hidden' from label ref)
        // PACK OFF: add 'ecs-pack-off' class
        // LINE: hide when inactive with class 'hidden'
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("div", { class: "display-pane-info" }, "ECS FUNCTION NOT AVAILABLE"),
            FSComponent.buildComponent("div", { class: "sys-ecs-page-container hidden" },
                FSComponent.buildComponent(B748EcsTempsDisplay, { bus: this.props.bus }),
                FSComponent.buildComponent(B748EcsValveDisplay, { bus: this.props.bus }),
                FSComponent.buildComponent("div", { class: "sys-ecs-diagram-container" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 784 548" },
                        FSComponent.buildComponent("path", { d: "M 99 470 l 22 0 l -6 -20 l 0 -25 l 20 0 l 5 -5 l -5 -5 l -20 0 l 0 -83 m -10 0 l 0 118 l -6 20", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 249 470 l 22 0 l -6 -20 l 0 -118 m -10 0 l 0 83 l -20 0 l -5 5 l 5 5 l 20 0 l 0 25 l -6 20", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 115 332 l 0 -47 l 140 0 l 0 47 m 10 0 l 0 -57 l -150 0 l 0 -95 m -10 152 l 0 -82 l -25 0 l -5 -5 l 5 -5 l 25 0 l 0 -55 m -30 0 l 30 0 l 0 -10", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 105 175 l 0 -61 l 10 0 l 0 56 l 75 0 m 0 10 l -75 0", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 365 279.5 l 0 -99.5 l -175 0 m 0 -10 l 175 0 l 0 -35 l -30 0 m 30 0 l 0 -21 l 10 0 l 0 56 l 175 0 m 0 10 l -175 0 l 0 99.5", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 550 170 l 75 0 l 0 -56 l 10 0 l 0 71 l 30 0 m -30 0 l 0 55 l 25 0 l 5 5 l -5 5 l -25 0 l 0 82 m -10 0 l 0 -47 m 0 -10 l 0 -95 l -75 0", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 625 275 l -150 0 l 0 57 m 10 0 l 0 -47 l 140 0", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 475 332 l 0 118 l -6 20 l 22 0 l -6 -20 l 0 -25 l 20 0 l 5 -5 l -5 -5 l -20 0 l 0 -83", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 635 332 l 0 118 l 6 20 l -22 0 l 6 -20 l 0 -25 l -20 0 l -5 -5 l 5 -5 l 20 0 l 0 -83", stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" }),
                        FSComponent.buildComponent(BleedValvePath, { coords: { x: 110, y: 386 }, open: this.engine1BleedOpen, isVertical: true, showClosedValveLines: false }),
                        FSComponent.buildComponent(BleedValvePath, { coords: { x: 260, y: 386 }, open: this.engine2BleedOpen, isVertical: true, showClosedValveLines: false }),
                        FSComponent.buildComponent(BleedValvePath, { coords: { x: 480, y: 386 }, open: this.engine3BleedOpen, isVertical: true, showClosedValveLines: false }),
                        FSComponent.buildComponent(BleedValvePath, { coords: { x: 630, y: 386 }, open: this.engine4BleedOpen, isVertical: true, showClosedValveLines: false }),
                        FSComponent.buildComponent(BleedValvePath, { coords: { x: 370, y: 280 }, open: this.apuBleedOpen, isVertical: true, showClosedValveLines: true }),
                        FSComponent.buildComponent(BleedValvePath, { coords: { x: 235, y: 203 }, open: this.leftCrossbleedOpen, isVertical: false, showClosedValveLines: true }),
                        FSComponent.buildComponent(BleedValvePath, { coords: { x: 503, y: 203 }, open: this.rightCrossbleedOpen, isVertical: false, showClosedValveLines: true }),
                        FSComponent.buildComponent("path", { ref: this.e1ToEai1JctLine, d: "M 103 467 l 14 0 l -5 -17 l 0 -30 l -4 0 l 0 30 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai1JctToEai1Line, d: "M 108 422 l 27 0 l 2 -2 l -2 -2 l -27 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai1JctToE1E2JctLine, d: "M 112 420 l 0 -140 l -4 0 l 0 140 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.e2ToEai2JctLine, d: "M 253 467 l 14 0 l -5 -17 l 0 -30 l -4 0 l 0 30 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai2JctToEai2Line, d: "M 262 422 l -27 0 l -2 -2 l 2 -2 l 27 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai2JctToE1E2JctLine, d: "M 262 420 l 0 -142 l -154 0 l 0 4 l 150 0 l 0 138 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.e1E2JctToWaiLeftJctLine, d: "M 112 280 l 0 -35 l -4 0 l 0 35 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.waiLeftLine, d: "M 112 243 l 0 4 l -32 0 l -2 -2 l 2 -2 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.waiLeftJctToCrossLeftJctLine, d: "M 112 245 l 0 -70 l -4 0 l 0 70 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.e3ToEai3JctLine, class: "hidden", d: "M 473 467 l 14 0 l -5 -17 l 0 -30 l -4 0 l 0 30 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai3JctToEai3Line, class: "hidden", d: "M 478 422 l 27 0 l 2 -2 l -2 -2 l -27 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai3JctToE3E4JctLine, class: "hidden", d: "M 478 420 l 0 -142 l 154 0 l 0 4 l -150 0 l 0 138 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.e4ToEai4JctLine, class: "hidden", d: "M 623 467 l 14 0 l -5 -17 l 0 -30 l -4 0 l 0 30 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai4JctToEai4Line, class: "hidden", d: " M 632 422 l 0 -4 l -27 0 l -2 2 l 2 2 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.eai4JctToE3E4JctLine, class: "hidden", d: "M 632 420 l 0 -140 l -4 0 l 0 140 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.e3E4JctToWaiRightJctLine, class: "hidden", d: "M 628 280 l 0 -35 l 4 0 l 0 35 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.waiRightLine, class: "hidden", d: "M 628 247 l 32 0 l 2 -2 l -2 -2 l -32 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.waiRightJctToCrossRightJctLine, class: "hidden", d: "M 628 245 l 0 -70 l 4 0 l 0 70 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.crossbleedLeftLine, d: "M 372 177 l 0 -4 l -264 0 l 0 4 l 264 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.crossbleedRightLine, class: "hidden", d: "M 368 173 l 264 0 l 0 4 l -264 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.apuLine, d: "M 368 280 l 4 0 l 0 -105 l -4 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.crossLeftJctToPack1Line, d: "M 112 175 l 0 -60 l -4 0 l 0 60 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.crossCtrJctToPack2Line, class: "hidden", d: "M 368 175 l 4 0 l 0 -60 l -4 0 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { ref: this.crossRightJctToPack3Line, class: "hidden", d: "M 628 175 l 0 -60 l 4 0 l 0 60 z", stroke: "none", fill: "var(--boeing-colors-green)" }),
                        FSComponent.buildComponent("path", { d: "M 110 115 a 1 1 0 0 0 0 -55 a 1 1 0 0 0 0 55", stroke: "var(--boeing-colors-white)", "stroke-width": "5", fill: "var(--boeing-colors-black)" }),
                        FSComponent.buildComponent("path", { d: "M 370 115 a 1 1 0 0 0 0 -55 a 1 1 0 0 0 0 55", stroke: "var(--boeing-colors-white)", "stroke-width": "5", fill: "var(--boeing-colors-black)" }),
                        FSComponent.buildComponent("path", { d: "M 630 115 a 1 1 0 0 0 0 -55 a 1 1 0 0 0 0 55", stroke: "var(--boeing-colors-white)", "stroke-width": "5", fill: "var(--boeing-colors-black)" })),
                    FSComponent.buildComponent("div", { class: "ecs-hi-flow-labels" },
                        FSComponent.buildComponent("div", { ref: this.hiFlowLeftRef }, "HI FLOW"),
                        FSComponent.buildComponent("div", { class: "hi-flow-hidden", ref: this.hiFlowCtrRef }, "HI FLOW"),
                        FSComponent.buildComponent("div", { class: "hi-flow-hidden", ref: this.hiFlowRightRef }, "HI FLOW")),
                    FSComponent.buildComponent("div", { class: "ecs-pack-labels" },
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "1"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "2"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "3")),
                    FSComponent.buildComponent("div", { class: "ecs-pack-status ecs-pack-1", ref: this.packLeftRef },
                        FSComponent.buildComponent("span", { class: "pack-on-text" }, "ON"),
                        FSComponent.buildComponent("span", { class: "pack-off-text" }, "OFF")),
                    FSComponent.buildComponent("div", { class: "ecs-pack-status ecs-pack-2 ecs-pack-off", ref: this.packCtrRef },
                        FSComponent.buildComponent("span", { class: "pack-on-text" }, "ON"),
                        FSComponent.buildComponent("span", { class: "pack-off-text" }, "OFF")),
                    FSComponent.buildComponent("div", { class: "ecs-pack-status ecs-pack-3 ecs-pack-off", ref: this.packRightRef },
                        FSComponent.buildComponent("span", { class: "pack-on-text" }, "ON"),
                        FSComponent.buildComponent("span", { class: "pack-off-text" }, "OFF")),
                    FSComponent.buildComponent("div", { class: "ecs-pack-control-labels" },
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "PACK CONTROL"),
                        FSComponent.buildComponent("div", { class: "ecs-pack-control-spacer" }),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "PACK CONTROL")),
                    FSComponent.buildComponent("div", { class: "ecs-top-duct-psi-container" },
                        FSComponent.buildComponent("div", { class: "ecs-duct-psi-label sys-ecs-label-text" },
                            "DUCT",
                            FSComponent.buildComponent("br", null),
                            "PSI"),
                        FSComponent.buildComponent("div", { class: "ecs-duct-psi-value" }, this.ductCtrPresRef)),
                    FSComponent.buildComponent("div", { class: "ecs-left-duct-psi-container" },
                        FSComponent.buildComponent("div", { class: "ecs-duct-psi-label sys-ecs-label-text" },
                            "DUCT",
                            FSComponent.buildComponent("br", null),
                            "PSI"),
                        FSComponent.buildComponent("div", { class: "ecs-duct-psi-value" }, this.ductLeftPresRef)),
                    FSComponent.buildComponent("div", { class: "ecs-right-duct-psi-container" },
                        FSComponent.buildComponent("div", { class: "ecs-duct-psi-label sys-ecs-label-text" },
                            "DUCT",
                            FSComponent.buildComponent("br", null),
                            "PSI"),
                        FSComponent.buildComponent("div", { class: "ecs-duct-psi-value" }, this.ductRightPresRef)),
                    FSComponent.buildComponent("div", { class: "ecs-wai-label-left sys-ecs-label-text" }, "WAI"),
                    FSComponent.buildComponent("div", { class: "ecs-wai-label-right sys-ecs-label-text" }, "WAI"),
                    FSComponent.buildComponent("div", { class: "ecs-ext-air-label-container", ref: this.extAirRef },
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "EXT"),
                        FSComponent.buildComponent("div", { class: "ecs-ext-air-spacer" }),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "AIR")),
                    FSComponent.buildComponent("div", { class: "ecs-apu-label sys-ecs-label-text" }, "APU"),
                    FSComponent.buildComponent("div", { class: "ecs-eng-labels ecs-eng-left" },
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "1"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "ENG"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "2"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-eng-eai-label sys-ecs-label-text" }, "EAI")),
                    FSComponent.buildComponent("div", { class: "ecs-eng-labels ecs-eng-right" },
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "3"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "ENG"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-label-text" }, "4"),
                        FSComponent.buildComponent("div", { class: "sys-ecs-eng-eai-label sys-ecs-label-text" }, "EAI")),
                    FSComponent.buildComponent("div", { class: "ecs-eng-bleed-off left-outboard hidden", ref: this.eng1BleedLabelRef }, "OFF"),
                    FSComponent.buildComponent("div", { class: "ecs-eng-bleed-off left-inboard hidden", ref: this.eng2BleedLabelRef }, "OFF"),
                    FSComponent.buildComponent("div", { class: "ecs-eng-bleed-off right-inboard", ref: this.eng3BleedLabelRef }, "OFF"),
                    FSComponent.buildComponent("div", { class: "ecs-eng-bleed-off right-outboard", ref: this.eng4BleedLabelRef }, "OFF")))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}
/** Component for engine bleed valves */
class BleedValvePath extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.bleedValveMask = FSComponent.createRef();
        this.bleedValveFill = FSComponent.createRef();
        this.bleedValveClosed = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.sub = this.props.open.sub(open => {
            this.bleedValveFill.instance.classList.toggle('ecs-bleed-valve-open', open);
            this.bleedValveFill.instance.classList.toggle('ecs-bleed-valve-closed', !open);
            this.bleedValveMask.instance.classList.toggle('hidden', !open);
            if (this.props.showClosedValveLines) {
                this.bleedValveClosed.instance.classList.toggle('hidden', open);
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        const bleedValveMaskPath = this.props.isVertical
            ? `M ${this.props.coords.x - 3.5} ${this.props.coords.y + 4} l 0 -61 l 7 0 l 0 61 z`
            : `M ${this.props.coords.x + 30} ${this.props.coords.y - 24.5} l -60 0 l 0 -7 l 60 0 z`;
        const bleedValveClosedPath = this.props.isVertical
            ? `M ${this.props.coords.x - 27} ${this.props.coords.y - 22.5} l 54 0 m 0 -10 l -54 0`
            : `M ${this.props.coords.x - 5} ${this.props.coords.y - 0.5} l 0 -54 m 10 0 l 0 54`;
        const bleedValveClosed = this.props.showClosedValveLines
            ? FSComponent.buildComponent("path", { ref: this.bleedValveClosed, class: "hidden", d: bleedValveClosedPath, stroke: "var(--boeing-colors-white)", "stroke-width": "3", fill: "none" })
            : FSComponent.buildComponent(FSComponent.Fragment, null);
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("path", { ref: this.bleedValveFill, class: "ecs-bleed-valve-open", d: `M ${this.props.coords.x} ${this.props.coords.y} a 1 1 0 0 0 0 -55 a 1 1 0 0 0 0 55` }),
            FSComponent.buildComponent("path", { ref: this.bleedValveMask, d: bleedValveMaskPath, stroke: "none", fill: "var(--boeing-colors-black)" }),
            bleedValveClosed));
    }
    /** @inheritdoc */
    destroy() {
        if (this.sub) {
            this.sub.destroy();
        }
    }
}

/** The B748Eicas component. */
class B748EicasBase extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.airborne = ConsumerSubject.create(this.props.bus.getSubscriber().on('on_ground'), true).map((onGround) => !onGround);
        this.engineRevDownTimers = {
            1: new DebounceTimer(),
            2: new DebounceTimer(),
            3: new DebounceTimer(),
            4: new DebounceTimer(),
        };
        this.showEngineData = {
            1: Subject.create(false),
            2: Subject.create(false),
            3: Subject.create(false),
            4: Subject.create(false),
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.forEachEngine(i => {
            const engStarterSwitchProp = `eng_starter_on_${i}`;
            this.props.dataProvider[`fadec_eng_start_state_${i}`].sub(() => this.updateShowEngineData(i), true);
            this.props.dataProvider.engineData.sub((_, prop) => {
                if (prop === engStarterSwitchProp) {
                    this.updateShowEngineData(i);
                }
            }, true);
            this.airborne.sub(() => this.updateShowEngineData(i), true);
        });
    }
    /**
     * This method handles whenever the fuel switch is called, and determines what should be showing in the given moment.
     * @param engineIndex The engine index to update.
     */
    updateShowEngineData(engineIndex) {
        const isAirborne = this.airborne.get();
        const engStarterSwitchOn = this.props.dataProvider.engineData.get()[`eng_starter_on_${engineIndex}`];
        const engStartState = this.props.dataProvider[`fadec_eng_start_state_${engineIndex}`].get();
        const engineRevDownTimer = this.engineRevDownTimers[engineIndex];
        const engineDisplayDataSubject = this.showEngineData[engineIndex];
        if (isAirborne || engStarterSwitchOn || engStartState !== BoeingEngineStartState.STOPPED) {
            engineRevDownTimer.clear();
            engineDisplayDataSubject.set(true);
        }
        else {
            engineRevDownTimer.schedule(() => engineDisplayDataSubject.set(false), 35000);
        }
    }
    /**
     * Calls a function once per engine.
     * @param func The function.
     */
    forEachEngine(func) {
        [1, 2, 3, 4].map(func);
    }
}

/** The BarGauge component. */
class BarGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.barBoxContainerRef = FSComponent.createRef();
        this.whiteBarRef = FSComponent.createRef();
        this.aboveBoxTextColor = SubscribableUtils.toSubscribable(this.props.aboveBoxTextColor, true);
        this.whiteBarTranslateYPercentage = MappedSubject.create(this.inputToPercentageY.bind(this), this.props.whiteBarValue, this.props.maxValue);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.whiteBarTranslateYPercentage.sub(percentageY => {
            this.whiteBarRef.instance.style.transform = `translate3d(0, ${percentageY}%, 0)`;
        }, true);
        this.props.lineDescriptions.forEach(this.renderLine.bind(this));
    }
    /**
     * Renders a line using the line description.
     * @param lineDesc The line description.
     */
    renderLine(lineDesc) {
        var _a;
        const isHidden = MappedSubject.create(([hideData, isVisible]) => {
            return (hideData && (lineDesc.staysVisibleWhenHidingData !== true)) || isVisible === false;
        }, this.props.hideData, SubscribableUtils.toSubscribable(lineDesc.isVisible, true));
        const style = MappedSubject.create(([inputValue, maxValue]) => {
            const percentageY = this.inputToPercentageY([inputValue, maxValue]);
            return `
        color: ${lineDesc.color};
        width: ${lineDesc.widthPx}px;
        transform: translate3d(0, ${percentageY}%, 0);
      `;
        }, lineDesc.inputValue, this.props.maxValue);
        FSComponent.render(FSComponent.buildComponent("div", { class: {
                'bar-line': true,
                'hidden': isHidden,
                [(_a = lineDesc.lineClass) !== null && _a !== void 0 ? _a : '']: true,
            }, style: style }), this.barBoxContainerRef.instance);
    }
    /**
     * Converts input value to a percentage for translateY.
     * @param root0 input data
     * @param root0."0" inputValue
     * @param root0."1" maxValue
     * @returns translate y percentage.
     */
    inputToPercentageY([inputValue, maxValue]) {
        return ((1 - MathUtils.clamp(inputValue / maxValue, 0, 1)) * 97) + 0.5;
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: `bar-gauge ${this.props.class}` },
            FSComponent.buildComponent("div", { class: `above-box-text ${this.props.aboveBoxText === undefined ? 'hidden' : ''}`, style: { color: this.aboveBoxTextColor } }, (_a = this.props.aboveBoxText) === null || _a === void 0 ? void 0 : _a.map(StringUtils.useZeroWidthDecimal.bind(this))),
            FSComponent.buildComponent("div", { class: "value-box" },
                FSComponent.buildComponent("div", { class: {
                        'value-box-text': true,
                        'hidden': this.props.hideData.map(hideData => hideData && !this.props.valueBoxTextShowsZeroWhenHideData),
                    } }, MappedSubject.create(([valueBoxText, hideData]) => {
                    const show00 = hideData && this.props.valueBoxTextShowsZeroWhenHideData;
                    const text = show00 ? '0.0' : valueBoxText;
                    return StringUtils.useZeroWidthDecimal(text);
                }, this.props.valueBoxText, this.props.hideData))),
            FSComponent.buildComponent("div", { class: "bar-box-container", ref: this.barBoxContainerRef },
                FSComponent.buildComponent("div", { class: "bar-box" },
                    FSComponent.buildComponent("div", { ref: this.whiteBarRef, class: {
                            'bar-white-bar': true,
                            'hidden': this.props.hideData,
                        } })),
                FSComponent.buildComponent("div", { class: "bar-red-line", style: `width: ${BarGauge.redLineWidthPx}px;` }))));
    }
}
BarGauge.whiteLineWidthPx = 26;
BarGauge.greenLineWidthPx = 46;
BarGauge.amberLineWidthPx = BarGauge.whiteLineWidthPx;
BarGauge.redLineWidthPx = 36;

/** The cabin pressure data component. */
class CabinPressurizationGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.cabinPressDivRef = FSComponent.createRef();
        this.cabinDiffPressureRef = FSComponent.createRef();
        this.cabinAltSub = ComputedSubject.create(0, v => MathUtils.round(v, 100).toFixed(0));
        this.pressureDiffSub = ComputedSubject.create(0, v => (v * 10).toFixed(0).padStart(2, '0'));
        this.landingAltSub = ComputedSubject.create(0, v => MathUtils.round(v, 100).toFixed(0));
        this.cabinAltRateSub = ComputedSubject.create(0, v => v > 25 ? `+${MathUtils.round(v, 50).toFixed(0)}` : MathUtils.round(v, 50).toFixed(0));
        this.cabinLdgAltText = Subject.create('AUTO');
        this.cabinAltAboveNormalRange = Subject.create(false);
        this.cabinDiffPressAboveNormalRange = Subject.create(false);
        this.ductPressAboveNormalRange = Subject.create(false);
        //TODO these need to be updated from other data.
        this.ductPressLeftValue = Subject.create(23);
        this.ductPressRightValue = Subject.create(10);
        this.ductPressRightRef = FSComponent.createRef();
        this.ductPressLeftRef = FSComponent.createRef();
        this.isEcsOrEngActive = MappedSubject.create(([mfd1, mfd2, mfd4]) => {
            return mfd1 === DisplayPaneViewKey.ECS || mfd1 === DisplayPaneViewKey.ENG ||
                mfd2 === DisplayPaneViewKey.ECS || mfd2 === DisplayPaneViewKey.ENG ||
                mfd4 === DisplayPaneViewKey.ECS || mfd4 === DisplayPaneViewKey.ENG;
        }, DisplayPanesUserSettings.getDisplayPaneManager(this.props.bus, 1).getSetting('displayPaneView'), DisplayPanesUserSettings.getDisplayPaneManager(this.props.bus, 2).getSetting('displayPaneView'), DisplayPanesUserSettings.getDisplayPaneManager(this.props.bus, 4).getSetting('displayPaneView'));
        this.showCabinPressureDisplay = MappedSubject.create((([cabinLdgAltText, cabinAltAboveNormalRange, cabinDiffPressAboveNormalRange, ductPressAboveNormalRange, isEcsOrEngPageActive]) => {
            const displayData = (cabinLdgAltText === 'MAN') || cabinAltAboveNormalRange || cabinDiffPressAboveNormalRange || ductPressAboveNormalRange || isEcsOrEngPageActive;
            return displayData;
        }), this.cabinLdgAltText, this.cabinAltAboveNormalRange, this.cabinDiffPressAboveNormalRange, this.ductPressAboveNormalRange, this.isEcsOrEngActive);
    }
    /** @inheritdoc */
    onAfterRender() {
        // TODO do stuff
        // this.cabinPressValveRef.instance.classList.add('hidden');
        // this.cabinPressDivRef.instance.classList.add('hidden');
        this.props.bus.getSubscriber().on('system_air_page_active').handle(this.showCabinPressureData.bind(this));
        //To animate the outflow valves, 0deg is straight up and -180deg is straight down.
        //The outflow valves and manual system are currently inop on the overhead panel.
        this.ductPressLeftValue.sub((v) => {
            const shouldBeAmber = v >= CabinPressurizationGauge.BLEED_AIR_DUCT_NORMAL_VALUE;
            this.ductPressLeftRef.instance.classList.toggle('eicas-caution', shouldBeAmber);
        }, true);
        this.ductPressRightValue.sub((v) => {
            const shouldBeAmber = v >= CabinPressurizationGauge.BLEED_AIR_DUCT_NORMAL_VALUE;
            this.ductPressRightRef.instance.classList.toggle('eicas-caution', shouldBeAmber);
        }, true);
        this.cabinAltAboveNormalRange.sub((v) => {
            this.ductPressRightRef.instance.classList.toggle('eicas-caution', v);
        }, true);
        this.cabinDiffPressAboveNormalRange.sub((v) => {
            this.cabinDiffPressureRef.instance.classList.toggle('eicas-caution', v);
        }, true);
        this.showCabinPressureDisplay.sub((v) => {
            this.cabinPressDivRef.instance.classList.toggle('hidden', !v);
        }, true);
    }
    /**
     * Updates the cabin altitude.
     * @param data Cabin altitude data.
     */
    updateCabinAlt(data) {
        //TODO find what number make the cabin alt change colors.
        // data >= 6250 ? this.cabinAltAboveNormalRange.set(true) : this.cabinAltAboveNormalRange.set(false);
        this.cabinAltSub.set(data);
    }
    /**
     * Updates the cabin altitude rate.
     * @param data Cabin altitude rate data.
     */
    updateCabinAltRate(data) {
        this.cabinAltRateSub.set(data);
    }
    /**
     * Updates the cabin pressure differential .
     * @param data Cabin altitude data.
     */
    updatePressureDiff(data) {
        //will need to find a value for this
        this.pressureDiffSub.set(data);
    }
    /**
     *This changes the state on whether or not the cabin pressurization data is displayed.
     * @param show A boolean showing whether or not the AIR synoptics page is open.
     */
    showCabinPressureData(show) {
        if (show) {
            this.cabinPressDivRef.instance.classList.remove('hidden');
        }
        else {
            this.cabinPressDivRef.instance.classList.add('hidden');
        }
    }
    /**
     * Updates the landing altitude based on airport runway elevation data.
     * @param data Runway elevation data.
     */
    updateLandingAlt(data) {
        this.landingAltSub.set(data);
    }
    /**
     * pdates the bleed air duct value to its propper color
     * @param data Bleed air duct value
     */
    updateBleedAirDuctPressure(data) {
        data >= CabinPressurizationGauge.BLEED_AIR_DUCT_NORMAL_VALUE
            ? this.ductPressAboveNormalRange.set(false)
            : this.ductPressAboveNormalRange.set(true);
        this.ductPressLeftValue.set(data);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "cabin-press-container", ref: this.cabinPressDivRef },
            FSComponent.buildComponent("div", { class: "cabin-press-data-container" },
                FSComponent.buildComponent("div", { class: 'cabin-press-duct-press' },
                    FSComponent.buildComponent("div", { class: 'duct-press-left-value', ref: this.ductPressLeftRef }, this.ductPressLeftValue),
                    FSComponent.buildComponent("div", { class: 'duct-press-title' }, "DUCT PRESS"),
                    FSComponent.buildComponent("div", { class: 'duct-press-right-value', ref: this.ductPressRightRef }, this.ductPressRightValue)),
                FSComponent.buildComponent("div", { class: "cabin-press-data-row-cab-alt" },
                    FSComponent.buildComponent("div", null, "CAB ALT"),
                    FSComponent.buildComponent("div", { class: "white-text" }, this.cabinAltSub)),
                FSComponent.buildComponent("div", { class: "cabin-press-data-row-rate" },
                    FSComponent.buildComponent("div", null, "RATE"),
                    FSComponent.buildComponent("div", { class: "white-text" }, this.cabinAltRateSub)),
                FSComponent.buildComponent("div", { class: "cabin-press-data-ldg-alt" },
                    FSComponent.buildComponent("div", null, "LDG ALT"),
                    FSComponent.buildComponent("div", { class: "white-text" }, this.landingAltSub)),
                FSComponent.buildComponent("div", { class: "ldg-alt-auto-man" },
                    FSComponent.buildComponent("div", { class: "ldg-alt-auto-man-text" }, this.cabinLdgAltText)),
                FSComponent.buildComponent("div", { class: "cabin-press-data-p" },
                    FSComponent.buildComponent("div", null, "\u25B3P"),
                    FSComponent.buildComponent("div", { class: "cabin-press-data-p-value", ref: this.cabinDiffPressureRef }, this.pressureDiffSub),
                    FSComponent.buildComponent("div", { class: 'cabin-press-data-p-decimal' }, ".")))));
    }
}
//got the const from the FCOM on page 905
CabinPressurizationGauge.BLEED_AIR_DUCT_NORMAL_VALUE = 12;

/** The EngineThrustMode component. */
class EngineThrustMode extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.tatDisplay = ConsumerSubject.create(this.props.bus.getSubscriber().on('ram_air_temp_c'), 0).map(EngineThrustMode.formatTemp);
        this.thrustModeDisplay = ConsumerSubject.create(this.props.bus.getSubscriber().on('fadec_thrust_mode'), null).map((mode) => mode === null ? '' : mode);
        this.assumedTempDisplay = ConsumerSubject.create(this.props.bus.getSubscriber().on('fadec_assumed_temp'), null).map(EngineThrustMode.formatTemp);
    }
    /**
     * Formats temps
     * @param temp The temp
     * @returns A formatted temp string with forced sign
     * */
    static formatTemp(temp) {
        return temp === null ? '' : `${temp >= 0 ? '+' : ''}${temp.toFixed(0).padStart(2, '')}c`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "engine-thrust-mode-container" },
            FSComponent.buildComponent("div", { class: "engine-thrust-mode-TAT-container" },
                FSComponent.buildComponent("div", { class: "engine-thrust-mode-TAT-text" },
                    FSComponent.buildComponent("span", null, "TAT")),
                FSComponent.buildComponent("div", { class: "engine-thrust-mode-TAT-value" }, this.tatDisplay)),
            FSComponent.buildComponent("div", { class: "engine-thrust-mode-display" }, this.thrustModeDisplay),
            FSComponent.buildComponent("div", { class: "engine-thrust-mode-flex-temp" }, this.assumedTempDisplay)));
    }
}

var FlapsState;
(function (FlapsState) {
    FlapsState[FlapsState["ZEROFLAPS"] = 0] = "ZEROFLAPS";
    FlapsState[FlapsState["FLAPS"] = 1] = "FLAPS";
})(FlapsState || (FlapsState = {}));
/** The FlapsGauge component. */
class FlapsGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.flapsLerpTable = new LerpLookupTable([
            [0, 0],
            [1, 1],
            [2, 5],
            [3, 10],
            [4, 20],
            [5, 25],
            [6, 30]
        ]);
        this.handleIndexToAngleMap = [0, 1, 5, 10, 20, 25, 30];
        this.flapsWhiteBoxTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('px')));
        this.flapsPositionRefTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('px')));
        this.flapsStatus = Subject.create(FlapsState.FLAPS);
        this.showFlapsDisplay = Subject.create(true);
        this.initialLoadInTimer = new DebounceTimer();
        this.flapStateDelayTimer = new DebounceTimer();
        this.desiredPosition = Subject.create(0);
        this.flapsPositionText = this.desiredPosition.map((v) => {
            return v === 0 ? 'UP' : v.toString();
        });
        this.actualPosition = Subject.create(0);
        this.isAtDesiredPosition = MappedSubject.create(([desired, actual]) => Math.abs(desired - actual) < 0.1, this.desiredPosition, this.actualPosition);
        this.flapsWhiteBox = FSComponent.createRef();
        this.flapsGreenLine = FSComponent.createRef();
        this.flapsPositionRef = FSComponent.createRef();
        this.flapsContainerRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        /**
         * The sim loads the plane in with an initial value of zero before reading the actual flaps value, which triggers the state change.
         * This timer holds the initial flaps position state check for 5 seconds to avoid that from happening.
         */
        this.initialLoadInTimer.schedule(() => {
            this.flapsStatus.sub(v => this.onFlapStateChanged(v));
        }, 5000);
        this.showFlapsDisplay.sub(v => this.flapsContainerRef.instance.style.visibility = v ? 'visible' : 'hidden');
        this.flapsWhiteBoxTransform.sub(transform => { this.flapsWhiteBox.instance.style.transform = transform; }, true);
        this.flapsPositionRefTransform.sub(transform => {
            this.flapsGreenLine.instance.style.transform = transform;
            this.flapsPositionRef.instance.style.transform = transform;
        }, true);
        this.isAtDesiredPosition.sub((atTarget) => {
            this.flapsPositionRef.instance.classList.toggle('flaps-gauge-value-target', !atTarget);
            this.flapsGreenLine.instance.classList.toggle('flaps-gauge-vertical-box-green-line-target', !atTarget);
        });
    }
    /**
     * Updates the flaps white box according to current flap position.
     * @param angle The flaps position angle.
     */
    updateFlapsWhiteBox(angle) {
        this.flapsStatus.set(angle === 0 ? FlapsState.ZEROFLAPS : FlapsState.FLAPS);
        const flapsTableFromAngle = this.flapsLerpTable.get(angle);
        this.actualPosition.set(angle);
        // -77px to 97px
        const verticalPx = this.mapRange(flapsTableFromAngle, 0, 6, -77, 97);
        this.flapsWhiteBoxTransform.transform.getChild(0).set(0, verticalPx, 1);
        this.flapsWhiteBoxTransform.resolve();
    }
    /**
     * Maps an input value to an output range.
     * @param value The value to map.
     * @param inMin The input minimum value.
     * @param inMax The input maximum value.
     * @param outMin The output minimum value.
     * @param outMax The output maximum value.
     * @returns The mappe output value.
     */
    mapRange(value, inMin, inMax, outMin, outMax) {
        return Math.floor((((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin) * 10) / 10;
    }
    /**
     * Updates the flaps data displayed on the Eicas
     * @param flapIndex The data the engine gives.
     */
    updateFlapsHandle(flapIndex) {
        this.desiredPosition.set(this.handleIndexToAngleMap[flapIndex]);
        const desiredVerticalPx = this.mapRange(flapIndex, 0, 6, -155, 21);
        this.flapsPositionRefTransform.transform.getChild(0).set(0, desiredVerticalPx, 1);
        this.flapsPositionRefTransform.resolve();
    }
    /**
     * This checks what the flap position is to decide if the flap display should show.
     * A 10 second delay is applied before it hides the display after flaps are at setting 0.
     * @param v The flap position value from the sim.
     */
    onFlapStateChanged(v) {
        this.flapStateDelayTimer.clear();
        if (v === FlapsState.FLAPS) {
            this.showFlapsDisplay.set(true);
        }
        else if (v === FlapsState.ZEROFLAPS) {
            this.flapStateDelayTimer.schedule(() => {
                this.showFlapsDisplay.set(false);
            }, 10000);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "flaps-gauge-container", ref: this.flapsContainerRef },
            FSComponent.buildComponent("div", { class: "flaps-gauge-title" }, "FLAPS"),
            FSComponent.buildComponent("div", { class: "flaps-vertical-bar-container" },
                FSComponent.buildComponent("div", { class: "flaps-gauge-box box-fill", ref: this.flapsWhiteBox }),
                FSComponent.buildComponent("div", { class: "flaps-gauge-box" }),
                FSComponent.buildComponent("div", { class: "flaps-gauge-vertical-box-green-line", ref: this.flapsGreenLine })),
            FSComponent.buildComponent("div", { class: "flaps-gauge-value", ref: this.flapsPositionRef }, this.flapsPositionText)));
    }
}

/**
 * Fuel constants that are used on multiple fuel displays in the 747-8.
 */
class B748FuelConstants {
}
/** Minimum allowable fuel temperature in Celsius */
B748FuelConstants.DEFAULT_MINIMUM_FUEL_TEMP = -37;
/** Fuel quantity threshold in gallons for the main tanks to display warnings (approx. 900 kgs) */
B748FuelConstants.FUEL_LOW_MAINS_THRESHOLD = 299;
/** Fuel quantity threshold in gallons for the stab tank to display warnings when pumps on (approx. 1130 kgs) */
B748FuelConstants.FUEL_LOW_STAB_THRESHOLD = 372;
/** Fuel quantity threshold in gallons for the stab tank to display warnings when jettisoning and pumps on (approx. 1130 kgs) */
B748FuelConstants.FUEL_LOW_STAB_THRESHOLD_JETTISON = 76;
/** Fuel quantity threshold in gallons for the center tank to display warnings when pumps on before start (approx. 7700 kgs) */
B748FuelConstants.FUEL_LOW_CTR_THRESHOLD_BEFORESTART = 2533;
/** Fuel quantity threshold in gallons for the center tank to display warnings when pumps on during climb (approx. 3200 kgs) */
B748FuelConstants.FUEL_LOW_CTR_THRESHOLD_CLIMB = 1053;
/** Fuel quantity threshold in gallons for the center tank to display warnings when pumps on during cruise (approx. 1300 kgs) */
B748FuelConstants.FUEL_LOW_CTR_THRESHOLD_CRUISE = 428;
/** Fuel imbalance threshold in gallons for the main tanks 1 and 4 to display warnings (approx. 1360 kgs) */
B748FuelConstants.FUEL_IMBALANCE_MAINS_14_THRESHOLD = 448;
/** Fuel imbalance threshold in gallons for the main tanks 2 and 3, and main tanks on the same side
 * to display warnings (approx. 2720 kgs) */
B748FuelConstants.FUEL_IMBALANCE_MAINS_23_THRESHOLD = 895;
/** Fuel imbalance threshold in gallons for all main tanks to stop warnings (approx. 450 kgs) */
B748FuelConstants.FUEL_IMBALANCE_OFF_THRESHOLD = 148;

/** The FuelQtyGauge component. */
class FuelQtyGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.gameUnitsMetric = ConsumerSubject.create(this.props.bus.getSubscriber().on('game_units_metric'), false);
        this.fuelQtyContainerRef = FSComponent.createRef();
        this.normalFuelQtyBottomMenu = FSComponent.createRef();
        this.totalFuelQtyGals = Subject.create(0);
        this.grossWeightPounds = Subject.create(0);
        this.leftEngineN2 = Subject.create(0);
        this.rightEngineN2 = Subject.create(0);
        /**Fuel weight in pounds per gallon. */
        this.fuelPoundsPerGallon = Subject.create(0);
        this.totalFuelWeightPounds = MappedSubject.create((([qty, weight, isMetric]) => {
            const fuelInPounds = qty * weight / 1000;
            const finalValue = (isMetric ? UnitType.POUND.convertTo(fuelInPounds, UnitType.KILOGRAM) : fuelInPounds).toFixed(1).padStart(2, '0');
            return StringUtils.useZeroWidthDecimal(finalValue);
        }), this.totalFuelQtyGals, this.fuelPoundsPerGallon, this.gameUnitsMetric);
        this.grossWeight = MappedSubject.create((([weight, isMetric]) => {
            const weightInPounds = weight / 1000;
            const finalValue = (isMetric ? UnitType.POUND.convertTo(weightInPounds, UnitType.KILOGRAM) : weightInPounds).toFixed(1);
            return StringUtils.useZeroWidthDecimal(finalValue);
        }), this.grossWeightPounds, this.gameUnitsMetric);
        this.unitString = this.gameUnitsMetric.map((isMetric) => {
            return BoeingUnitUtils.getUnitString(isMetric ? UnitType.KILOGRAM : UnitType.POUND);
        });
        this.sat = ComputedSubject.create(0, v => { return v >= 0 ? `+${v}` : v.toString(); });
        this.fuelTempDisplayRef = FSComponent.createRef();
        this.fuelTemp = ConsumerSubject.create(this.props.bus.getSubscriber().on('fuel_temp'), SimVar.GetSimVarValue('TOTAL AIR TEMPERATURE', SimVarValueType.Celsius));
        this.fuelTempDisplay = ComputedSubject.create(0, v => `${v > 0 ? '+' : ''}${MathUtils.round(v, 1)}`);
        this.minFuelTemp = Subject.create(B748FuelConstants.DEFAULT_MINIMUM_FUEL_TEMP);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.bus.getSubscriber().on('ambient_temp_c').withPrecision(0).handle(v => this.sat.set(v));
        // TODO, need to use FUELSYSTEM VALVE SWITCH:3 simvar for the crossfeed valve state. These need to be put in their own publisher first.
        // Fuel temp
        this.fuelTemp.sub(v => {
            this.fuelTempDisplay.set(v);
            this.fuelTempDisplayRef.instance.classList.toggle('fuel-temp-warning', v <= this.minFuelTemp.get());
        }, true);
    }
    /**
     * Updates the fuel weight per gallon.
     * @param data Fuel weight per gallon.
     */
    updateFuelWeight(data) {
        this.fuelPoundsPerGallon.set(data);
    }
    /**
     * Updates the total fuel qty.
     * @param data Total fuel qty.
     */
    updateFuelTotal(data) {
        this.totalFuelQtyGals.set(data);
    }
    /**
     * Updates the gross weight.
     * @param data Gross weight in pounds.
     */
    updateGrossWeight(data) {
        this.grossWeightPounds.set(data);
    }
    /**
     * Updates the left engine N2 value.
     * @param data The left N2 value.
     */
    updateLeftN2(data) {
        this.leftEngineN2.set(data);
    }
    /**
     * Updates the right engine N2 value.
     * @param data The right N2 value.
     */
    updateRightN2(data) {
        this.rightEngineN2.set(data);
    }
    /**
     * Updates the Fuel Qty gauge to show the jettison data if the plane is in jettison mode.
     * @param show If the fuel jettison should be showing or the normal fuel view
     */
    updateJettisonView(show) {
        this.normalFuelQtyBottomMenu.instance.classList.toggle('hidden', show);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "fuel-qty-gauge-container", ref: this.fuelQtyContainerRef },
            FSComponent.buildComponent("div", { class: "fuel-qty-gross-weight fuel-pair" },
                FSComponent.buildComponent("div", { class: "gross-weight-title fuel-title " }, "GROSS WT"),
                FSComponent.buildComponent("div", { class: "fuel-value" }, this.grossWeight)),
            FSComponent.buildComponent("div", { class: "fuel-units-text" },
                FSComponent.buildComponent("div", null,
                    this.unitString,
                    "S X"),
                FSComponent.buildComponent("div", null, "1000")),
            FSComponent.buildComponent("div", { class: "fuel-qty-total fuel-pair" },
                FSComponent.buildComponent("div", { class: "total-fuel-title fuel-title" }, "TOTAL FUEL"),
                FSComponent.buildComponent("div", { class: "total-fuel-value fuel-value" }, this.totalFuelWeightPounds)),
            FSComponent.buildComponent("div", { class: "sat-fuel-temp-group", ref: this.normalFuelQtyBottomMenu },
                FSComponent.buildComponent("div", { class: "fuel-qty-SAT fuel-pair-row" },
                    FSComponent.buildComponent("div", { class: "fuel-SAT-title fuel-title" }, "SAT"),
                    FSComponent.buildComponent("div", { class: "fuel-value-sat-left" },
                        this.sat,
                        FSComponent.buildComponent("span", null, "c"))),
                FSComponent.buildComponent("div", { class: "fuel-gauge-temp fuel-pair-row" },
                    FSComponent.buildComponent("div", { class: "fuel-temp-title fuel-title" }, "FUEL TEMP"),
                    FSComponent.buildComponent("div", { class: "fuel-value-temp-right", ref: this.fuelTempDisplayRef },
                        this.fuelTempDisplay,
                        FSComponent.buildComponent("span", null, "c"))))));
    }
}

var GearLocation;
(function (GearLocation) {
    GearLocation[GearLocation["Nose"] = 0] = "Nose";
    GearLocation[GearLocation["Left"] = 1] = "Left";
    GearLocation[GearLocation["Right"] = 2] = "Right";
})(GearLocation || (GearLocation = {}));
var GearState;
(function (GearState) {
    GearState[GearState["UP"] = 0] = "UP";
    GearState[GearState["TRANSIT"] = 1] = "TRANSIT";
    GearState[GearState["DOWN"] = 2] = "DOWN";
})(GearState || (GearState = {}));
/** The LandingGearGauge component. */
class LandingGearGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.gearStatus = FSComponent.createRef();
        this.landingGearGaugeRef = FSComponent.createRef();
        this.showGearDisplay = Subject.create(true);
        this.gearState = Subject.create(GearState.DOWN);
        this.gearStateText = ComputedSubject.create(GearState.DOWN, (v) => {
            return v === GearState.UP ? 'UP' : v === GearState.DOWN ? 'DOWN' : '';
        });
        this.gearStateDelayTimer = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.showGearDisplay.sub(v => this.landingGearGaugeRef.instance.style.visibility = v ? 'visible' : 'hidden');
        this.gearState.sub((v) => {
            this.onGearStateChanged(v);
            this.gearStateText.set(v);
            this.gearStatus.instance.classList.toggle('gear-in-transit', v === GearState.TRANSIT);
            this.gearStatus.instance.classList.toggle('gear-down', v === GearState.DOWN);
            this.gearStatus.instance.classList.toggle('gear-up', v === GearState.UP);
        }, true);
        //CSS selectors avail for all gear states.
    }
    /**
     * This checks if the gear position is up and we are airborne, to decide if the trim gauges should show.
     * A 10 second delay is applied before it hides the gauges after gear is up.
     * @param v The gear position value from the sim.
     */
    onGearStateChanged(v) {
        var _a;
        this.gearStateDelayTimer.clear();
        if (v === GearState.TRANSIT || v === GearState.DOWN) {
            this.showGearDisplay.set(true);
        }
        else if (v === GearState.UP && ((_a = this.props.airborne) === null || _a === void 0 ? void 0 : _a.get()) === true) {
            this.gearStateDelayTimer.schedule(() => {
                this.showGearDisplay.set(false);
            }, 10000);
        }
    }
    /**
     * Updates the gear state.
     * @param location The gear location.
     * @param position The gear position.
     */
    updateGear(location, position) {
        this.gearState.set(position === 0 ? GearState.UP : position === 1 ? GearState.DOWN : GearState.TRANSIT);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "landing-gear-gauge-container", ref: this.landingGearGaugeRef },
            FSComponent.buildComponent("div", { class: "landing-gear-normal-box gear-in-transit", ref: this.gearStatus },
                FSComponent.buildComponent("div", { class: "landing-gear-position-text" }, this.gearStateText)),
            FSComponent.buildComponent("div", { class: "landing-gear-title" }, "GEAR")));
    }
}

/** The TrimGauge component. */
class TrimGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.pitchPointer = FSComponent.createRef();
        this.pitchCurrent = Subject.create(0);
        this.pitchCurrentString = Subject.create('');
        this.showTrimBoxes = Subject.create(true);
        this.classList = SetSubject.create(['trim-gauge-container']);
        this.pitchTrimInGreenAndIsOnGround = MappedSubject.create(([trimValue, isAirborne]) => {
            const pitchTrimIsGreen = this.isPitchTrimValueInGreenZone(trimValue);
            return pitchTrimIsGreen && !isAirborne;
        }, this.pitchCurrent, this.props.airborne);
        this.airborneStateDelayTimer = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.showTrimBoxes.sub(v => {
            this.classList.toggle('hide-trim-boxes', !v);
        }, true);
        this.pitchTrimInGreenAndIsOnGround.sub(v => {
            this.classList.toggle('pitch-trim-in-green', v);
        }, true);
        //TODO green box is set with FMC takeoff perf data.
        this.props.airborne.sub(this.onIsAirborneChanged.bind(this));
    }
    /**
     * This checks if there is a change in airborne status.
     * If you are airborne it hides the trim green box and value box.
     * @param airborne Whether the airborne boolean from the sim is true/false.
     */
    onIsAirborneChanged(airborne) {
        if (!airborne) {
            this.airborneStateDelayTimer.schedule(() => {
                this.showTrimBoxes.set(true);
            }, 1500);
        }
        else if (airborne) {
            this.airborneStateDelayTimer.schedule(() => {
                this.showTrimBoxes.set(false);
            }, 1500);
        }
    }
    /**
     * Updates the stabilizer trim.
     * @param data The data the sim gives.
     * Trim pitch is -4 to +11 degrees. The 748 displays 0 to 15. This turns -4/14 to 0/1 and converts it.
     * Value from flight_model.cfg, recommended from https://www.pprune.org/tech-log/446606-747-400-other-boeing-aircraft-trim-question.html
     * The trim indication line is 164px.
     */
    updatePitchTrim(data) {
        const newData = MathUtils.round(data + 4, .1);
        const newDataString = StringUtils.useZeroWidthDecimal(newData.toFixed(1));
        const translateData = (MathUtils.clamp(newData / 15, 0, 1) * 164);
        this.pitchPointer.instance.style.transform = `translate3d(0px, ${translateData}px, 1px)`;
        this.pitchCurrentString.set(newDataString);
        this.pitchCurrent.set(newData);
    }
    /**
     * Checks what the pitch trim green zone is.
     * @param v The pitch trim value the gauge receives.
     * @returns The boolean check for being in the green zone.
     */
    isPitchTrimValueInGreenZone(v) {
        return v >= 5.8 && v <= 10;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.classList },
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-ND-text" }, "ND"),
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-box" }),
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-0-text" }, "0"),
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-15-text" }, "15"),
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-green-box" }),
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-pointer", ref: this.pitchPointer },
                FSComponent.buildComponent("svg", { width: "16", height: "20" },
                    FSComponent.buildComponent("path", { d: "M 16 20 l -0 -20 l -16 10 z", fill: "currentcolor" }))),
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-NU-text" }, "NU"),
            FSComponent.buildComponent("div", { class: "stab-trim-gauge-STAB-text" }, "STAB"),
            FSComponent.buildComponent("div", { class: "stab-value-box" }, this.pitchCurrentString)));
    }
}

/** The B748Eicas component. */
class B748EicasPrimary extends B748EicasBase {
    constructor() {
        super(...arguments);
        this.ias = ConsumerSubject.create(this.props.bus.getSubscriber().on('ias').whenChangedBy(1), 0);
        this.airborne = ConsumerSubject.create(this.props.bus.getSubscriber().on('on_ground'), true).map((onGround) => !onGround);
        this.fuelQtyRef = FSComponent.createRef();
        this.cabinPressureRef = FSComponent.createRef();
        this.trimGaugeRef = FSComponent.createRef();
        this.landingGearRef = FSComponent.createRef();
        this.flapsGaugeRef = FSComponent.createRef();
        this.engineDataUpdateHandler = this.onEngineDataUpdate.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.props.dataProvider.engineData.sub(this.engineDataUpdateHandler, true);
        this.props.dataProvider.surfacesData.sub(this.onSurfacesDataUpdate.bind(this), true);
        this.props.dataProvider.flapsData.sub(this.onFlapsDataUpdate.bind(this), true);
        this.props.dataProvider.weightBalanceData.sub(this.onWeightBalanceDataUpdate.bind(this), true);
        this.props.dataProvider.pressurizationData.sub(this.onPressurizationUpdate.bind(this), true);
        this.props.dataProvider.destinationFacility.sub(this.onDestinationUpdate.bind(this), true);
        //this.props.dataProvider.fuelSystemData.sub(this.onFuelSystemDataUpdate.bind(this), true);
    }
    /**
     * Called when the engine data updates.
     * @param data The engine data.
     * @param prop The engine property that changed.
     * @param newValue The new value of the property.
     */
    onEngineDataUpdate(data, prop, newValue) {
        switch (prop) {
            case 'fuel_usable_total':
                this.fuelQtyRef.instance.updateFuelTotal(newValue);
                break;
            case 'fuel_weight_per_gallon':
                this.fuelQtyRef.instance.updateFuelWeight(newValue);
                break;
        }
    }
    /**
     * Called when flaps data is updated.
     * @param data New data
     * @param prop the prop that changed
     * @param newValue value for the changed prop
     */
    onFlapsDataUpdate(data, prop, newValue) {
        switch (prop) {
            case 'flap_computer_interpolated_position':
                this.flapsGaugeRef.instance.updateFlapsWhiteBox(newValue);
                break;
        }
    }
    /**
     * Called when the surfaces data updates.
     * @param data The surfaces data.
     * @param prop The surfaces property that changed.
     * @param newValue The new value of the property.
     */
    onSurfacesDataUpdate(data, prop, newValue) {
        switch (prop) {
            case 'flaps_handle_index':
                this.flapsGaugeRef.instance.updateFlapsHandle(newValue);
                break;
            case 'elevator_trim_angle':
                this.trimGaugeRef.instance.updatePitchTrim(newValue);
                break;
            case 'gear_position_2':
                this.landingGearRef.instance.updateGear(GearLocation.Right, newValue);
                break;
        }
    }
    /**
     * Called when weight balance data is updated.
     * @param data Weight balance data.
     * @param prop The weight balance property.
     * @param newValue The new value of the property.
     */
    onWeightBalanceDataUpdate(data, prop, newValue) {
        switch (prop) {
            case 'total_weight':
                this.fuelQtyRef.instance.updateGrossWeight(newValue);
        }
    }
    /**
     * Called when cabin pressure data updates.
     * @param data The cabin pressure data.
     * @param prop The cabin pressure property that has changed.
     * @param newValue The new value of the property.
     */
    onPressurizationUpdate(data, prop, newValue) {
        switch (prop) {
            case 'cabin_altitude':
                this.cabinPressureRef.instance.updateCabinAlt(newValue);
                break;
            case 'cabin_altitude_rate':
                this.cabinPressureRef.instance.updateCabinAltRate(newValue);
                break;
            case 'pressure_diff':
                this.cabinPressureRef.instance.updatePressureDiff(newValue);
                break;
        }
    }
    /**
     * Updates the cabin pressure data landing alt with the airport facility elevation data.
     * @param data The airport facility data.
     */
    onDestinationUpdate(data) {
        if (data !== undefined) {
            //TODO Can we get airport elevation or should we get runway elevation if a runway has been selected.
            this.cabinPressureRef.instance.updateLandingAlt(UnitType.METER.convertTo(data.runways[0].elevation, UnitType.FOOT));
        }
        else {
            this.cabinPressureRef.instance.updateLandingAlt(0);
        }
    }
    /** @inheritdoc */
    render() {
        const engineEvents = this.props.bus.getSubscriber();
        const boeingFadecEvents = this.props.bus.getSubscriber();
        const boeingTurbineEvents = this.props.bus.getSubscriber();
        return (FSComponent.buildComponent("div", { class: "eicas-main-container" },
            FSComponent.buildComponent(EngineThrustMode, { bus: this.props.bus }),
            FSComponent.buildComponent("div", { class: "b748-EICAS-primary-gauge-container" }, [1, 2, 3, 4].map(index => {
                const trPos = ConsumerSubject.create(boeingTurbineEvents.on(`thrust_reverser_pos_${index}`), 0);
                const trInactive = trPos.map((x) => x === 0);
                return (FSComponent.buildComponent("div", { class: "upper-bar-column" },
                    FSComponent.buildComponent(BarGauge, { class: "n1-bar-gauge", valueBoxText: ConsumerSubject.create(engineEvents.on(`n1_${index}`), 0).map(x => x.toFixed(1)), whiteBarValue: ConsumerSubject.create(engineEvents.on(`n1_${index}`), 0), aboveBoxText: MappedSubject.create(([n1String, tr]) => {
                            return tr > 0 ? 'REV' : n1String;
                        }, ConsumerSubject.create(boeingFadecEvents.on(`fadec_ref_n1_${index}`), 0).map(x => x.toFixed(1)), trPos), aboveBoxTextColor: trPos.map((tr) => {
                            return (tr > 0 && tr < 1) ? BoeingColors.amber : BoeingColors.green;
                        }), maxValue: ConsumerSubject.create(boeingFadecEvents.on(`fadec_n1_redline_${index}`), 0), hideData: this.showEngineData[index].map(x => !x), lineDescriptions: [{
                                color: BoeingColors.green,
                                inputValue: ConsumerSubject.create(boeingFadecEvents.on(`fadec_ref_n1_${index}`), 0),
                                widthPx: BarGauge.greenLineWidthPx,
                                staysVisibleWhenHidingData: true,
                                isVisible: trInactive,
                            }, {
                                color: BoeingColors.amber,
                                inputValue: ConsumerSubject.create(boeingFadecEvents.on(`fadec_n1_amberline_${index}`), 0),
                                widthPx: BarGauge.amberLineWidthPx,
                                staysVisibleWhenHidingData: true,
                                isVisible: trInactive,
                            }, {
                                color: BoeingColors.white,
                                inputValue: ConsumerSubject.create(boeingFadecEvents.on(`fadec_target_n1_${index}`), 0),
                                widthPx: BarGauge.whiteLineWidthPx,
                                isVisible: trInactive,
                            }] }),
                    FSComponent.buildComponent(BarGauge, { class: "egt-bar-gauge", valueBoxText: ConsumerSubject.create(engineEvents.on(`egt_${index}`), 0).map(x => UnitType.FAHRENHEIT.convertTo(x, UnitType.CELSIUS).toFixed(0)), whiteBarValue: ConsumerSubject.create(engineEvents.on(`egt_${index}`), 0).map(x => UnitType.FAHRENHEIT.convertTo(x, UnitType.CELSIUS)), maxValue: ConsumerSubject.create(boeingFadecEvents.on(`fadec_egt_redline_${index}`), 0), hideData: this.showEngineData[index].map(x => !x), lineDescriptions: [{
                                color: BoeingColors.amber,
                                inputValue: ConsumerSubject.create(boeingFadecEvents.on(`fadec_egt_amberline_${index}`), 0),
                                widthPx: BarGauge.amberLineWidthPx
                            }, {
                                color: BoeingColors.red,
                                inputValue: ConsumerSubject.create(boeingFadecEvents.on(`fadec_egt_startline_${index}`), 0),
                                widthPx: BarGauge.amberLineWidthPx,
                                isVisible: ConsumerSubject.create(boeingFadecEvents.on(`fadec_eng_start_state_${index}`), BoeingEngineStartState.STOPPED)
                                    .map(x => x === BoeingEngineStartState.AUTOSTART),
                            }] })));
            })),
            FSComponent.buildComponent("div", { class: "gauge-titles title-N1" },
                "N",
                FSComponent.buildComponent("span", null, "1")),
            FSComponent.buildComponent("div", { class: "gauge-titles title-EGT" }, "EGT"),
            FSComponent.buildComponent("div", { class: "b748-CAS-container" },
                FSComponent.buildComponent(CAS, { casPresentationController: this.props.casPresentationController, bus: this.props.bus })),
            FSComponent.buildComponent(LandingGearGauge, { bus: this.props.bus, airborne: this.airborne, ref: this.landingGearRef }),
            FSComponent.buildComponent(FlapsGauge, { bus: this.props.bus, ref: this.flapsGaugeRef }),
            FSComponent.buildComponent(TrimGauge, { bus: this.props.bus, airborne: this.airborne, ref: this.trimGaugeRef }),
            FSComponent.buildComponent(CabinPressurizationGauge, { bus: this.props.bus, ref: this.cabinPressureRef }),
            FSComponent.buildComponent(FuelQtyGauge, { bus: this.props.bus, airborne: this.airborne, ref: this.fuelQtyRef })));
    }
}

var AircraftStateCrewAlertIDs;
(function (AircraftStateCrewAlertIDs) {
    AircraftStateCrewAlertIDs["DoorAftCargo"] = "74-acstate-door-aft-cargo-open";
    AircraftStateCrewAlertIDs["DoorFwdCargo"] = "74-acstate-door-fwd-cargo-open";
    AircraftStateCrewAlertIDs["DoorsAllInAuto"] = "74-acstate-door-auto-all";
    AircraftStateCrewAlertIDs["DoorsAllInManual"] = "74-acstate-door-manual-all";
    AircraftStateCrewAlertIDs["DoorsAutoManualMixed"] = "74-acstate-door-auto-manual-mixed";
    AircraftStateCrewAlertIDs["SeatBeltsOn"] = "74-acstate-seatbelts-on";
    AircraftStateCrewAlertIDs["DoorEntry1L"] = "74-door-entry-1L";
    AircraftStateCrewAlertIDs["DoorEntry2L"] = "74-door-entry-2L";
    AircraftStateCrewAlertIDs["DoorEntry4L"] = "74-door-entry-4L";
    AircraftStateCrewAlertIDs["DoorEntry1R"] = "74-door-entry-1R";
    AircraftStateCrewAlertIDs["DoorEntry4R"] = "74-door-entry-4R";
})(AircraftStateCrewAlertIDs || (AircraftStateCrewAlertIDs = {}));
/**
 * Updates the CAS for the basic aircraft states.
 */
class DoorsStateCrewAlerts {
    /**
     * Creates an instance of DoorsStateCrewAlerts.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.sub = this.bus.getSubscriber();
        this.entry1LStatus = ConsumerSubject.create(this.sub.on('entry_1l_status'), B74DoorStatus.MANUAL);
        this.entry1RStatus = ConsumerSubject.create(this.sub.on('entry_1r_status'), B74DoorStatus.MANUAL);
        this.entry2LStatus = ConsumerSubject.create(this.sub.on('entry_2l_status'), B74DoorStatus.MANUAL);
        this.entry2RStatus = ConsumerSubject.create(this.sub.on('entry_2r_status'), B74DoorStatus.MANUAL);
        this.entry3LStatus = ConsumerSubject.create(this.sub.on('entry_3l_status'), B74DoorStatus.MANUAL);
        this.entry3RStatus = ConsumerSubject.create(this.sub.on('entry_3r_status'), B74DoorStatus.MANUAL);
        this.entry4LStatus = ConsumerSubject.create(this.sub.on('entry_4l_status'), B74DoorStatus.MANUAL);
        this.entry4RStatus = ConsumerSubject.create(this.sub.on('entry_4r_status'), B74DoorStatus.MANUAL);
        this.entry5LStatus = ConsumerSubject.create(this.sub.on('entry_5l_status'), B74DoorStatus.MANUAL);
        this.entry5RStatus = ConsumerSubject.create(this.sub.on('entry_5r_status'), B74DoorStatus.MANUAL);
        this.fwdCargoStatus = ConsumerSubject.create(this.sub.on('fwd_cargo_status'), B74DoorStatus.BLANK);
        this.aftCargoStatus = ConsumerSubject.create(this.sub.on('aft_cargo_status'), B74DoorStatus.BLANK);
        //private readonly refuelDoorStatus = ConsumerSubject.create(this.doorSub.on('refuel_door_status'), B74DoorStatus.BLANK);
        this.onGround = ConsumerSubject.create(this.sub.on('on_ground'), false);
        // To remove all door alerts at the beginning of the takeoff-run:
        this.n1Array = [...Array(4).keys()].map(index => ConsumerSubject.create(this.sub.on(`n1_${index + 1}`), 0));
        this.pastTakeOffThrustSet = MappedSubject.create((dataInput) => {
            const onGround = dataInput[0];
            const n1Array = dataInput.slice(1);
            return n1Array.some(n1 => n1 > DoorsStateCrewAlerts.n1TransitionToTakeoffThrust) || (onGround == false);
        }, this.onGround, // Consider pastTakeOffThrust during whole flight (also for descend and approach, where n1 drops below the treshold again)
        ...this.n1Array);
        const cas = this.bus.getPublisher();
        const engStartingAndTakingoff = [BoeingInhibitStates.EngineStarting, BoeingInhibitStates.TakingOff]; // For advisories
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorAftCargo, message: 'DOOR AFT CARGO', inhibitedBy: [''], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorFwdCargo, message: 'DOOR FWD CARGO', inhibitedBy: [''], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorsAllInAuto, message: 'DOORS AUTO', inhibitedBy: [''], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorsAllInManual, message: 'DOORS MANUAL', inhibitedBy: [''], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorsAutoManualMixed, message: 'DOORS AUTO/MANUAL', inhibitedBy: [''], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.SeatBeltsOn, message: 'SEATBELTS ON', inhibitedBy: [''], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorEntry1L, message: 'ENTRY 1L', inhibitedBy: [...engStartingAndTakingoff], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorEntry2L, message: 'ENTRY 2L', inhibitedBy: [...engStartingAndTakingoff], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorEntry4L, message: 'ENTRY 4L', inhibitedBy: [...engStartingAndTakingoff], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorEntry1R, message: 'ENTRY 1R', inhibitedBy: [...engStartingAndTakingoff], debounceTime: 2000 }, true, false);
        cas.pub('cas_register_alert', { uuid: AircraftStateCrewAlertIDs.DoorEntry4R, message: 'ENTRY 4R', inhibitedBy: [...engStartingAndTakingoff], debounceTime: 2000 }, true, false);
        this.initAlerts();
    }
    /**
     * Initalizes the basic aircraft alerts.
     */
    initAlerts() {
        // One of the cargo doors is not closed and secure:
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorAftCargo, AnnunciationType.Caution)
            .bind(this.aftCargoStatus, v => v === B74DoorStatus.OPEN);
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorFwdCargo, AnnunciationType.Caution)
            .bind(this.fwdCargoStatus, v => v === B74DoorStatus.OPEN);
        // Messages for single doors
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorEntry1L, AnnunciationType.Advisory)
            .bind(this.entry1LStatus, v => v === B74DoorStatus.OPEN);
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorEntry2L, AnnunciationType.Advisory)
            .bind(this.entry2LStatus, v => v === B74DoorStatus.OPEN);
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorEntry4L, AnnunciationType.Advisory)
            .bind(this.entry4LStatus, v => v === B74DoorStatus.OPEN);
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorEntry1R, AnnunciationType.Advisory)
            .bind(this.entry1RStatus, v => v === B74DoorStatus.OPEN);
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorEntry4R, AnnunciationType.Advisory)
            .bind(this.entry4RStatus, v => v === B74DoorStatus.OPEN);
        // All passenger doors are in the automatic mode:
        // This alert needs to be switched off when the take off run begins.
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorsAllInAuto, AnnunciationType.SafeOp)
            .bind(MappedSubject.create(this.entry1LStatus, this.entry1RStatus, this.entry2LStatus, this.entry2RStatus, this.entry3LStatus, this.entry3RStatus, this.entry4LStatus, this.entry4RStatus, this.entry5LStatus, this.entry5RStatus, this.pastTakeOffThrustSet), doorStates => {
            const isValid = (doorStates[10] == false);
            return doorStates.slice(0, -1).every(status => status === B74DoorStatus.AUTO) && isValid;
        });
        // All passenger doors are in the manual mode:
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorsAllInManual, AnnunciationType.SafeOp)
            .bind(MappedSubject.create(this.entry1LStatus, this.entry1RStatus, this.entry2LStatus, this.entry2RStatus, this.entry3LStatus, this.entry3RStatus, this.entry4LStatus, this.entry4RStatus, this.entry5LStatus, this.entry5RStatus), statuses => statuses.every(status => status === B74DoorStatus.MANUAL));
        // Some passenger entry doors are in the automatic mode and some are in the manual mode:
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.DoorsAutoManualMixed, AnnunciationType.SafeOp)
            .bind(MappedSubject.create(this.entry1LStatus, this.entry1RStatus, this.entry2LStatus, this.entry2RStatus, this.entry3LStatus, this.entry3RStatus, this.entry4LStatus, this.entry4RStatus, this.entry5LStatus, this.entry5RStatus), statuses => {
            return (statuses.reduce((sum, status) => sum + (status === B74DoorStatus.AUTO ? 1 : 0), 0) > 0) &&
                (statuses.reduce((sum, status) => sum + (status === B74DoorStatus.MANUAL ? 1 : 0), 0) > 0);
        });
        CasAlertTransporter.create(this.bus, AircraftStateCrewAlertIDs.SeatBeltsOn, AnnunciationType.SafeOp)
            .bindUpdate(() => SimVar.GetSimVarValue('CABIN SEATBELTS ALERT SWITCH', SimVarValueType.Bool) !== 0);
    }
}
DoorsStateCrewAlerts.n1TransitionToTakeoffThrust = 60.0; // Above 60% N1 the takeoff run shall begin for the door alerts, https://youtu.be/4e5JTchiajA?t=5

/** The FuelFlow component. */
class FuelFlowGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.gameUnitsMetric = ConsumerSubject.create(this.props.bus.getSubscriber().on('game_units_metric'), false);
        this.totalFuelFlowRef = FSComponent.createRef();
        this.fuelFlowGauge = Subject.create(0);
        this.totalFuelFlow = MappedSubject.create((([data, isMetric]) => {
            return isMetric ? StringUtils.useZeroWidthDecimal(UnitType.PPH.convertTo(data, UnitType.KGH).toFixed(1))
                : StringUtils.useZeroWidthDecimal(data.toFixed(1));
        }), this.fuelFlowGauge, this.gameUnitsMetric);
        this.fuelDisplayDelay = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        // TODO do stuff
    }
    /**
     * Updates the fuel flow value.
     * @param data The new fuel gauge value.
     */
    updateFuelFlow(data) {
        this.setValueOnGauge(data);
    }
    /**
     * Determines if the data should be showing on the fuel flow gauges.
     * @param showData If the data should be showing in the box.
     */
    updateDisplayVisibility(showData) {
        this.fuelDisplayDelay.schedule(() => this.totalFuelFlowRef.instance.style.visibility = showData ? 'visible' : 'hidden', 2000);
    }
    /**
     * Sets the data with the right decimal.
     * @param data The data that needs to be displayed.
     */
    setValueOnGauge(data) {
        this.fuelFlowGauge.set(data / 1000);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "fuel-flow-value-box" },
            FSComponent.buildComponent("div", { class: "fuel-flow-value", ref: this.totalFuelFlowRef }, this.totalFuelFlow)));
    }
}

/** The N2BarGauge component. */
class N2BarGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.engineEvents = this.props.bus.getSubscriber();
        this.fadecEvents = this.props.bus.getSubscriber();
        this.n2 = ConsumerSubject.create(this.engineEvents.on(`n2_${this.props.engineIndex}`), 0);
        this.idleN2 = ConsumerSubject.create(this.fadecEvents.on(`fadec_idle_n2_${this.props.engineIndex}`), 0);
        this.n2RedLine = ConsumerSubject.create(this.fadecEvents.on(`fadec_n2_redline_${this.props.engineIndex}`), 0);
        this.engStartState = ConsumerSubject.create(this.fadecEvents.on(`fadec_eng_start_state_${this.props.engineIndex}`), BoeingEngineStartState.STOPPED);
        this.startModeText = Subject.create('');
        this.greenLineIsVisible = Subject.create(false);
        this.runningToNoneDelay = new DebounceTimer();
        this.idleLineDelay = new DebounceTimer();
        this.autostartDelay = new DebounceTimer();
        this.previousEngStartState = BoeingEngineStartState.STOPPED;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.engStartState.sub(this.updateGreenLineVisibility.bind(this), true);
        this.engStartState.sub(state => {
            if (state === BoeingEngineStartState.STOPPED) {
                this.autostartDelay.clear();
                this.runningToNoneDelay.clear();
                this.startModeText.set('');
            }
            if (state === BoeingEngineStartState.AUTOSTART) {
                this.runningToNoneDelay.clear();
                this.startModeText.set('');
                this.autostartDelay.schedule(() => {
                    this.startModeText.set('AUTOSTART');
                }, 1500);
            }
            if (state === BoeingEngineStartState.RUNNING && this.previousEngStartState === BoeingEngineStartState.AUTOSTART) {
                this.autostartDelay.clear();
                this.startModeText.set('RUNNING');
                this.runningToNoneDelay.schedule(() => {
                    this.startModeText.set('');
                }, 30000);
            }
            this.previousEngStartState = state;
        }, true);
    }
    /**
     * This method creates actions on the idle lines when the state has changed.
     * @param engStartState The new start state.
     */
    updateGreenLineVisibility(engStartState) {
        if (engStartState === BoeingEngineStartState.AUTOSTART) {
            this.idleLineDelay.schedule(() => {
                this.greenLineIsVisible.set(true);
            }, 2000);
        }
        else {
            this.idleLineDelay.schedule(() => {
                this.greenLineIsVisible.set(false);
            }, 2000);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(BarGauge, { class: "n2-bar-gauge", valueBoxText: this.n2.map(x => x.toFixed(1)), whiteBarValue: this.n2, aboveBoxText: this.startModeText, aboveBoxTextColor: this.engStartState.map(state => state === BoeingEngineStartState.AUTOSTART ? BoeingColors.white : BoeingColors.green), maxValue: this.n2RedLine, hideData: this.props.hideData, valueBoxTextShowsZeroWhenHideData: true, lineDescriptions: [{
                    lineClass: 'n2-green-line-split',
                    color: BoeingColors.green,
                    inputValue: this.idleN2,
                    // This green line is same width as red line
                    widthPx: BarGauge.redLineWidthPx,
                    isVisible: this.greenLineIsVisible,
                }] }));
    }
}

/** The OilPressureGauge component. */
class OilPressureGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        /** The number corresponds to the engine number, 1 being the far left value and 4 being the far right value.
         * Arrow div is to transform the arrow with a temp value. Arrow Svg is to reference a color change if conditions are met.
         */
        this.oilPressValueRef1 = FSComponent.createRef();
        this.oilPressValueRef2 = FSComponent.createRef();
        this.oilPressValueRef3 = FSComponent.createRef();
        this.oilPressValueRef4 = FSComponent.createRef();
        this.arrowDivRef1 = FSComponent.createRef();
        this.arrowDivRef2 = FSComponent.createRef();
        this.arrowDivRef3 = FSComponent.createRef();
        this.arrowDivRef4 = FSComponent.createRef();
        this.redLineRef1 = FSComponent.createRef();
        this.redLineRef2 = FSComponent.createRef();
        this.redLineRef3 = FSComponent.createRef();
        this.redLineRef4 = FSComponent.createRef();
        this.arrowSvgRef1 = FSComponent.createRef();
        this.arrowSvgRef2 = FSComponent.createRef();
        this.arrowSvgRef3 = FSComponent.createRef();
        this.arrowSvgRef4 = FSComponent.createRef();
        this.oilPressGauge1 = Subject.create(0);
        this.oilPressGauge2 = Subject.create(0);
        this.oilPressGauge3 = Subject.create(0);
        this.oilPressGauge4 = Subject.create(0);
        this.oilPressInRedEng1 = ComputedSubject.create(0, v => {
            return v <= 1;
        });
        this.oilPressInRedEng2 = ComputedSubject.create(0, v => {
            return v <= 1;
        });
        this.oilPressInRedEng3 = ComputedSubject.create(0, v => {
            return v <= 1;
        });
        this.oilPressInRedEng4 = ComputedSubject.create(0, v => {
            return v <= 1;
        });
        this.redLineDelay = {
            1: new DebounceTimer(),
            2: new DebounceTimer(),
            3: new DebounceTimer(),
            4: new DebounceTimer(),
        };
        this.valueAndArrowDelay = {
            1: new DebounceTimer(),
            2: new DebounceTimer(),
            3: new DebounceTimer(),
            4: new DebounceTimer(),
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.oilPressInRedEng1.sub(v => {
            this.arrowSvgRef1.instance.classList.toggle('eicas-warning', v);
            this.oilPressValueRef1.instance.classList.toggle('eicas-warning', v);
        }, true);
        this.oilPressInRedEng2.sub(v => {
            this.arrowSvgRef2.instance.classList.toggle('eicas-warning', v);
            this.oilPressValueRef2.instance.classList.toggle('eicas-warning', v);
        }, true);
        this.oilPressInRedEng3.sub(v => {
            this.arrowSvgRef3.instance.classList.toggle('eicas-warning', v);
            this.oilPressValueRef3.instance.classList.toggle('eicas-warning', v);
        }, true);
        this.oilPressInRedEng4.sub(v => {
            this.arrowSvgRef4.instance.classList.toggle('eicas-warning', v);
            this.oilPressValueRef4.instance.classList.toggle('eicas-warning', v);
        }, true);
    }
    /**
     * Updates the oil pressure data displayed on the Eicas.
     * @param engineNumber 1 being the far left value and 4 being the far right value.
     * @param data The data the sim gives.
     */
    updateOilPressure(engineNumber, data) {
        const newData = this.getGaugeDisplayValue(data, 140);
        switch (engineNumber) {
            case 1:
                this.oilPressInRedEng1.set(data);
                this.arrowDivRef1.instance.style.transform = `translate3d(0px, ${-newData}px, 0px) scale(${0.65})`;
                this.oilPressGauge1.set(data);
                break;
            case 2:
                this.oilPressInRedEng2.set(data);
                this.arrowDivRef2.instance.style.transform = `translate3d(0px, ${-newData}px, 0px) scale(${0.65})`;
                this.oilPressGauge2.set(data);
                break;
            case 3:
                this.oilPressInRedEng3.set(data);
                this.arrowDivRef3.instance.style.transform = `translate3d(0px, ${-newData}px, 0px) scale(${0.65})`;
                this.oilPressGauge3.set(data);
                break;
            case 4:
                this.oilPressInRedEng4.set(data);
                this.arrowDivRef4.instance.style.transform = `translate3d(0px, ${-newData}px, 0px) scale(${0.65})`;
                this.oilPressGauge4.set(data);
                break;
        }
    }
    /**
     * Gets the range that the tape gauge should be showing.
     * @param press Oil press value.
     * @param gaugeLimit What the max value should be on the gauge. (upper limit)
     * @returns The value that fits within the gauge.
     */
    getGaugeDisplayValue(press, gaugeLimit) {
        return (MathUtils.clamp(press / gaugeLimit, 0, 1) * 91);
    }
    /**
     * Determines if the data should be displaying on the oil temp gauges based on the engine status.
     * @param engineOn If the engine is on or off.
     * @param engineNumber Engine number 1 - 4. 1 is far left, 4 is far right.
     */
    updateDisplayVisibility(engineOn, engineNumber) {
        const valueAndArrowDelayTimer = this.valueAndArrowDelay[engineNumber];
        const redLineDelayTimer = this.redLineDelay[engineNumber];
        if (engineNumber === 1) {
            valueAndArrowDelayTimer.schedule(() => {
                this.arrowDivRef1.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.oilPressValueRef1.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 4000);
            redLineDelayTimer.schedule(() => this.redLineRef1.instance.style.visibility = engineOn ? 'visible' : 'hidden', 6000);
        }
        else if (engineNumber === 2) {
            valueAndArrowDelayTimer.schedule(() => {
                this.arrowDivRef2.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.oilPressValueRef2.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 4000);
            redLineDelayTimer.schedule(() => this.redLineRef2.instance.style.visibility = engineOn ? 'visible' : 'hidden', 6000);
        }
        else if (engineNumber === 3) {
            valueAndArrowDelayTimer.schedule(() => {
                this.arrowDivRef3.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.oilPressValueRef3.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 4000);
            redLineDelayTimer.schedule(() => this.redLineRef3.instance.style.visibility = engineOn ? 'visible' : 'hidden', 6000);
        }
        else {
            valueAndArrowDelayTimer.schedule(() => {
                this.arrowDivRef4.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.oilPressValueRef4.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 4000);
            redLineDelayTimer.schedule(() => this.redLineRef4.instance.style.visibility = engineOn ? 'visible' : 'hidden', 6000);
        }
    }
    /** @inheritdoc */
    render() {
        const leftArrowPath = 'M 33 13 l -30 -10 l 0 20 z';
        const rightArrowPath = 'M 3 13 l 30 -10 l 0 20 z';
        return (FSComponent.buildComponent("div", { class: "oil-press-gauge-container" },
            FSComponent.buildComponent("div", { class: "oil-press-gauge-package" },
                FSComponent.buildComponent("div", { class: "oil-press-value left-value", ref: this.oilPressValueRef1 }, this.oilPressGauge1.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-press-vert-line-container" },
                    FSComponent.buildComponent("div", { class: "oil-press-vert-line" }),
                    FSComponent.buildComponent("div", { class: "oil-press-left-red-line", ref: this.redLineRef1 }),
                    FSComponent.buildComponent("div", { class: "oil-press-right-red-line", ref: this.redLineRef2 })),
                FSComponent.buildComponent("div", { class: "oil-press-value", ref: this.oilPressValueRef2 }, this.oilPressGauge2.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-press-arrow left-arrow", ref: this.arrowDivRef1 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: leftArrowPath, stroke: "currentcolor", ref: this.arrowSvgRef1 }))),
                FSComponent.buildComponent("div", { class: "oil-press-arrow right-arrow", ref: this.arrowDivRef2 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: rightArrowPath, stroke: "currentcolor", ref: this.arrowSvgRef2 })))),
            FSComponent.buildComponent("div", { class: "oil-press-gauge-package" },
                FSComponent.buildComponent("div", { class: "oil-press-value left-value", ref: this.oilPressValueRef3 }, this.oilPressGauge3.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-press-vert-line-container" },
                    FSComponent.buildComponent("div", { class: "oil-press-vert-line" }),
                    FSComponent.buildComponent("div", { class: "oil-press-left-red-line", ref: this.redLineRef3 }),
                    FSComponent.buildComponent("div", { class: "oil-press-right-red-line", ref: this.redLineRef4 })),
                FSComponent.buildComponent("div", { class: "oil-press-value", ref: this.oilPressValueRef4 }, this.oilPressGauge4.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-press-arrow left-arrow", ref: this.arrowDivRef3 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: leftArrowPath, stroke: "currentcolor", ref: this.arrowSvgRef3 }))),
                FSComponent.buildComponent("div", { class: "oil-press-arrow right-arrow", ref: this.arrowDivRef4 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: rightArrowPath, stroke: "currentcolor", ref: this.arrowSvgRef4 }))))));
    }
}

/** The FuelFlow component. */
class OilQtyGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.oilGaugeQty = Subject.create('0');
        this.n2EngineData = Subject.create(0);
    }
    /** @inheritdoc */
    onAfterRender() {
        const oilQtyRandom = Math.floor(Math.random() * (23 - 18) + 18);
        this.oilGaugeQty.set(oilQtyRandom.toFixed(0));
        this.n2EngineData.sub(v => this.oilGaugeQty.set((oilQtyRandom - (5 * Math.min(v / 60, 1))).toFixed(0)), true);
    }
    /**
     * This updates n2 engine data that is used to simulate
     * the oil qty being pumped from the oil reservoir dependant on the engines n2 percentage.
     * @param data N2 data from the sim.
     */
    updateN2Value(data) {
        this.n2EngineData.set(data);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "oil-qty-value-box" },
            FSComponent.buildComponent("div", { class: "oil-qty-value" }, this.oilGaugeQty)));
    }
}

/** The OilTempGauge component. */
class OilTempGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        /** The number corresponds to the engine number, 1 being the far left value and 4 being the far right value.
         * Arrow div is to transform the arrow with a temp value. Arrow Svg is to reference a color change if conditions are met.
         */
        this.tempValueRef1 = FSComponent.createRef();
        this.tempValueRef2 = FSComponent.createRef();
        this.tempValueRef3 = FSComponent.createRef();
        this.tempValueRef4 = FSComponent.createRef();
        this.arrowDivRef1 = FSComponent.createRef();
        this.arrowDivRef2 = FSComponent.createRef();
        this.arrowDivRef3 = FSComponent.createRef();
        this.arrowDivRef4 = FSComponent.createRef();
        this.amberBox1Ref = FSComponent.createRef();
        this.amberBox2Ref = FSComponent.createRef();
        this.amberBox3Ref = FSComponent.createRef();
        this.amberBox4Ref = FSComponent.createRef();
        this.arrowSvgRef1 = FSComponent.createRef();
        this.arrowSvgRef2 = FSComponent.createRef();
        this.arrowSvgRef3 = FSComponent.createRef();
        this.arrowSvgRef4 = FSComponent.createRef();
        this.tempValueEng1 = Subject.create(0);
        this.tempValueEng2 = Subject.create(0);
        this.tempValueEng3 = Subject.create(0);
        this.tempValueEng4 = Subject.create(0);
        this.oilTempIsWarningEng1 = ComputedSubject.create(0, v => {
            return this.getColorFromOilTemp(v);
        });
        this.oilTempIsWarningEng2 = ComputedSubject.create(0, v => {
            return this.getColorFromOilTemp(v);
        });
        this.oilTempIsWarningEng3 = ComputedSubject.create(0, v => {
            return this.getColorFromOilTemp(v);
        });
        this.oilTempIsWarningEng4 = ComputedSubject.create(0, v => {
            return this.getColorFromOilTemp(v);
        });
        this.tempDisplayDelay = {
            1: new DebounceTimer(),
            2: new DebounceTimer(),
            3: new DebounceTimer(),
            4: new DebounceTimer(),
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.oilTempIsWarningEng1.sub(color => {
            this.arrowSvgRef1.instance.style.stroke = color;
            this.tempValueRef1.instance.style.color = color;
        }, true);
        this.oilTempIsWarningEng2.sub(color => {
            this.arrowSvgRef2.instance.style.stroke = color;
            this.tempValueRef2.instance.style.color = color;
        }, true);
        this.oilTempIsWarningEng3.sub(color => {
            this.arrowSvgRef3.instance.style.stroke = color;
            this.tempValueRef3.instance.style.color = color;
        }, true);
        this.oilTempIsWarningEng4.sub(color => {
            this.arrowSvgRef4.instance.style.stroke = color;
            this.tempValueRef4.instance.style.color = color;
        }, true);
    }
    /**
     * Updates the oil temperature data displayed on the Eicas.
     * @param engineNumber 1 being the far left value and 4 being the far right value.
     * @param data The data the sim gives.
     */
    updateOilTemp(engineNumber, data) {
        const gaugeDataValue = this.getGaugeDisplayValue(data, 160);
        switch (engineNumber) {
            case 1:
                this.oilTempIsWarningEng1.set(data);
                this.arrowDivRef1.instance.style.transform = `translate3d(0px, ${-gaugeDataValue}px, 0px) scale(${0.65})`;
                this.tempValueEng1.set(data);
                break;
            case 2:
                this.oilTempIsWarningEng2.set(data);
                this.arrowDivRef2.instance.style.transform = `translate3d(0px, ${-gaugeDataValue}px, 0px) scale(${0.65})`;
                this.tempValueEng2.set(data);
                break;
            case 3:
                this.oilTempIsWarningEng3.set(data);
                this.arrowDivRef3.instance.style.transform = `translate3d(0px, ${-gaugeDataValue}px, 0px) scale(${0.65})`;
                this.tempValueEng3.set(data);
                break;
            case 4:
                this.oilTempIsWarningEng4.set(data);
                this.arrowDivRef4.instance.style.transform = `translate3d(0px, ${-gaugeDataValue}px, 0px) scale(${0.65})`;
                this.tempValueEng4.set(data);
                break;
        }
    }
    /**
     * Gets the range that the tape gauge should be showing for translating the arrow pointers.
     * @param temp Oil temp value.
     * @param gaugeLimit What the max value should be on the gauge. (upper limit)
     * @returns The value that fits within the gauge.
     */
    getGaugeDisplayValue(temp, gaugeLimit) {
        return (MathUtils.clamp(temp / gaugeLimit, 0, 1) * 91);
    }
    /**
     * Checks if the values the gauge is receiving are between specific ranges, and changes them to the proper colors.
     * @param v The oil temp value the gauge receives.
     * @returns The different colors it can have.
     */
    getColorFromOilTemp(v) {
        if (v >= 160) {
            return 'var(--boeing-colors-red)';
        }
        else if (v >= 141 && v < 160) {
            return 'var(--boeing-colors-amber)';
        }
        else {
            return 'var(--boeing-colors-white)';
        }
    }
    /**
     * Determines if the data should be displaying on the oil temp gauges based on the engine status.
     * @param engineOn If the engine is on or off.
     * @param engineNumber Engine number 1 - 4. 1 is far left, 4 is far right.
     */
    updateDisplayVisibility(engineOn, engineNumber) {
        const tempDisplayDelayTimer = this.tempDisplayDelay[engineNumber];
        if (engineNumber === 1) {
            tempDisplayDelayTimer.schedule(() => {
                this.tempValueRef1.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.amberBox1Ref.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.arrowDivRef1.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 7000);
        }
        else if (engineNumber === 2) {
            tempDisplayDelayTimer.schedule(() => {
                this.tempValueRef2.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.amberBox2Ref.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.arrowDivRef2.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 7000);
        }
        else if (engineNumber === 3) {
            tempDisplayDelayTimer.schedule(() => {
                this.tempValueRef3.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.amberBox3Ref.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.arrowDivRef3.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 7000);
        }
        else {
            tempDisplayDelayTimer.schedule(() => {
                this.tempValueRef4.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.amberBox4Ref.instance.style.visibility = engineOn ? 'visible' : 'hidden';
                this.arrowDivRef4.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            }, 7000);
        }
    }
    /** @inheritdoc */
    render() {
        const leftArrowPath = 'M 33 13 l -30 -10 l 0 20 z';
        const rightArrowPath = 'M 3 13 l 30 -10 l 0 20 z';
        return (FSComponent.buildComponent("div", { class: "oil-temp-gauge-container" },
            FSComponent.buildComponent("div", { class: "oil-temp-gauge-package" },
                FSComponent.buildComponent("div", { class: "oil-temp-value left-value", ref: this.tempValueRef1 }, this.tempValueEng1.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-temp-vert-line-container" },
                    FSComponent.buildComponent("div", { class: "oil-temp-vert-line" }),
                    FSComponent.buildComponent("div", { class: "oil-temp-red-line" }),
                    FSComponent.buildComponent("div", { class: "oil-temp-amber-box1", ref: this.amberBox1Ref }),
                    FSComponent.buildComponent("div", { class: "oil-temp-amber-box2", ref: this.amberBox2Ref })),
                FSComponent.buildComponent("div", { class: "oil-temp-value right-value", ref: this.tempValueRef2 }, this.tempValueEng2.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-temp-arrow left-arrow", ref: this.arrowDivRef1 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: leftArrowPath, ref: this.arrowSvgRef1 }))),
                FSComponent.buildComponent("div", { class: "oil-temp-arrow right-arrow", ref: this.arrowDivRef2 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: rightArrowPath, ref: this.arrowSvgRef2 })))),
            FSComponent.buildComponent("div", { class: "oil-temp-gauge-package" },
                FSComponent.buildComponent("div", { class: "oil-temp-value left-value", ref: this.tempValueRef3 }, this.tempValueEng3.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-temp-vert-line-container" },
                    FSComponent.buildComponent("div", { class: "oil-temp-vert-line" }),
                    FSComponent.buildComponent("div", { class: "oil-temp-red-line" }),
                    FSComponent.buildComponent("div", { class: "oil-temp-amber-box1", ref: this.amberBox3Ref }),
                    FSComponent.buildComponent("div", { class: "oil-temp-amber-box2", ref: this.amberBox4Ref })),
                FSComponent.buildComponent("div", { class: "oil-temp-value right-value", ref: this.tempValueRef4 }, this.tempValueEng4.map(v => v.toFixed(0))),
                FSComponent.buildComponent("div", { class: "oil-temp-arrow left-arrow", ref: this.arrowDivRef3 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: leftArrowPath, ref: this.arrowSvgRef3 }))),
                FSComponent.buildComponent("div", { class: "oil-temp-arrow right-arrow", ref: this.arrowDivRef4 },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: rightArrowPath, ref: this.arrowSvgRef4 }))))));
    }
}

/** The VibrationGauge component. */
class VibrationGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.arrowDivRef = FSComponent.createRef();
        this.vibrationValueRef = FSComponent.createRef();
        this.vibAboveThreshold = Subject.create(false);
        this.vibrationValue = Subject.create('0.0');
        this.vibrationText = Subject.create('BB');
        this.vibrationDisplayDelay = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.vibAboveThreshold.sub(v => {
            this.vibrationValueRef.instance.classList.toggle('vibration-gauge-upper-limit-toggle', v);
        }, true);
    }
    /**
     * Updates the vibration data displayed on the Eicas.
     * @param data The data the engine gives.
     */
    updateVibrationGauge(data) {
        const gaugeDataValue = this.getGaugeDisplayValue(data, 4.5);
        const scaleSign = this.props.index % 2 === 0 ? -1 : 1;
        const scale = scaleSign * 0.65;
        this.vibAboveThreshold.set(data >= 3.6);
        this.arrowDivRef.instance.style.transform = `translate3d(0px, ${-gaugeDataValue}px, 0px) scale(${scale})`;
        this.vibrationValue.set(StringUtils.useZeroWidthDecimal((data.toFixed(1))));
    }
    /**
     * Gets the range that the vibration gauge should be showing.
     * @param vib A vibration value.
     * @param gaugeLimit What the max value should be on the gauge. (upper limit)
     * @returns The value that fits within the gauge.
     */
    getGaugeDisplayValue(vib, gaugeLimit) {
        return (MathUtils.clamp(vib / gaugeLimit, 0, 1) * 85);
    }
    /**
     * Determines if the data should be showing on the vibration gauges depending on engine status.
     * @param engineOn If the engine is on or off.
     */
    updateDisplayVisibility(engineOn) {
        this.vibrationDisplayDelay.schedule(() => {
            this.vibrationText.set(engineOn ? 'BB' : '');
            this.arrowDivRef.instance.style.visibility = engineOn ? 'visible' : 'hidden';
            this.vibrationValueRef.instance.style.visibility = engineOn ? 'visible' : 'hidden';
        }, 2500);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: `vibration-gauge-inner-package vibration-gauge-${this.props.index % 2 === 0 ? 'even' : 'odd'}` },
            FSComponent.buildComponent("div", { class: "vibration-gauge-info-box" },
                FSComponent.buildComponent("div", { class: "vibration-gauge-text-box" }, this.vibrationText),
                FSComponent.buildComponent("div", { class: "vibration-gauge-value-box" },
                    FSComponent.buildComponent("div", { class: "vibration-gauge-value", ref: this.vibrationValueRef }, this.vibrationValue))),
            FSComponent.buildComponent("div", { class: "vibration-vert-line-container" },
                FSComponent.buildComponent("div", { class: "vibration-vert-line" }),
                FSComponent.buildComponent("div", { class: "vibration-horizontal-line" }),
                FSComponent.buildComponent("div", { class: "vibration-gauge-arrow", ref: this.arrowDivRef },
                    FSComponent.buildComponent("svg", { height: "26", width: "36" },
                        FSComponent.buildComponent("path", { d: "M 3 13 l 30 -10 l 0 20 z", fill: "none", stroke: "white", "stroke-width": "3px" }))))));
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
/** The B748Eicas component. */
class B748EicasSecondary extends B748EicasBase {
    constructor() {
        super(...arguments);
        this.fuelFlowRef1 = FSComponent.createRef();
        this.fuelFlowRef2 = FSComponent.createRef();
        this.fuelFlowRef3 = FSComponent.createRef();
        this.fuelFlowRef4 = FSComponent.createRef();
        this.oilPressGaugeRef = FSComponent.createRef();
        this.oilTempGaugeRef = FSComponent.createRef();
        this.oilQtyRef1 = FSComponent.createRef();
        this.oilQtyRef2 = FSComponent.createRef();
        this.oilQtyRef3 = FSComponent.createRef();
        this.oilQtyRef4 = FSComponent.createRef();
        this.eng1VibrationRef = FSComponent.createRef();
        this.eng2VibrationRef = FSComponent.createRef();
        this.eng3VibrationRef = FSComponent.createRef();
        this.eng4VibrationRef = FSComponent.createRef();
        this.engineDataUpdateHandler = this.onEngineDataUpdate.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.props.dataProvider.engineData.sub(this.engineDataUpdateHandler, true);
        this.forEachEngine(i => {
            this.showEngineData[i].sub(showData => {
                this.updateEngineStatus(showData, i);
            }, true);
        });
    }
    /**
     * Called when the engine data updates.
     * @param data The engine data.
     * @param prop The engine property that changed.
     * @param newValue The new value of the property.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onEngineDataUpdate(data, prop, newValue) {
        switch (prop) {
            case 'n2_1':
                this.oilQtyRef1.instance.updateN2Value(newValue);
                break;
            case 'n2_2':
                this.oilQtyRef2.instance.updateN2Value(newValue);
                break;
            case 'n2_3':
                this.oilQtyRef3.instance.updateN2Value(newValue);
                break;
            case 'n2_4':
                this.oilQtyRef4.instance.updateN2Value(newValue);
                break;
            case 'fuel_flow_pph_1':
                this.fuelFlowRef1.instance.updateFuelFlow(newValue);
                break;
            case 'fuel_flow_pph_2':
                this.fuelFlowRef2.instance.updateFuelFlow(newValue);
                break;
            case 'fuel_flow_pph_3':
                this.fuelFlowRef3.instance.updateFuelFlow(newValue);
                break;
            case 'fuel_flow_pph_4':
                this.fuelFlowRef4.instance.updateFuelFlow(newValue);
                break;
            case 'oil_press_1':
                this.oilPressGaugeRef.instance.updateOilPressure(1, newValue);
                break;
            case 'oil_press_2':
                this.oilPressGaugeRef.instance.updateOilPressure(2, newValue);
                break;
            case 'oil_press_3':
                this.oilPressGaugeRef.instance.updateOilPressure(3, newValue);
                break;
            case 'oil_press_4':
                this.oilPressGaugeRef.instance.updateOilPressure(4, newValue);
                break;
            case 'oil_temp_1':
                this.oilTempGaugeRef.instance.updateOilTemp(1, UnitType.FAHRENHEIT.convertTo(newValue, UnitType.CELSIUS));
                break;
            case 'oil_temp_2':
                this.oilTempGaugeRef.instance.updateOilTemp(2, UnitType.FAHRENHEIT.convertTo(newValue, UnitType.CELSIUS));
                break;
            case 'oil_temp_3':
                this.oilTempGaugeRef.instance.updateOilTemp(3, UnitType.FAHRENHEIT.convertTo(newValue, UnitType.CELSIUS));
                break;
            case 'oil_temp_4':
                this.oilTempGaugeRef.instance.updateOilTemp(4, UnitType.FAHRENHEIT.convertTo(newValue, UnitType.CELSIUS));
                break;
            case 'eng_vibration_1':
                this.eng1VibrationRef.instance.updateVibrationGauge(newValue);
                break;
            case 'eng_vibration_2':
                this.eng2VibrationRef.instance.updateVibrationGauge(newValue);
                break;
            case 'eng_vibration_3':
                this.eng3VibrationRef.instance.updateVibrationGauge(newValue);
                break;
            case 'eng_vibration_4':
                this.eng4VibrationRef.instance.updateVibrationGauge(newValue);
                break;
        }
    }
    /**
     * Updates whether the engines are on or off to determine if the gauges should be displayed or not.
     * @param showEngineData Whether engine data should currently be displayed.
     * @param engineNumber What engine number is being turned on or off.
     */
    updateEngineStatus(showEngineData, engineNumber) {
        if (engineNumber === 1) {
            this.fuelFlowRef1.instance.updateDisplayVisibility(showEngineData);
            this.eng1VibrationRef.instance.updateDisplayVisibility(showEngineData);
        }
        else if (engineNumber === 2) {
            this.fuelFlowRef2.instance.updateDisplayVisibility(showEngineData);
            this.eng2VibrationRef.instance.updateDisplayVisibility(showEngineData);
        }
        else if (engineNumber === 3) {
            this.fuelFlowRef3.instance.updateDisplayVisibility(showEngineData);
            this.eng3VibrationRef.instance.updateDisplayVisibility(showEngineData);
        }
        else {
            this.fuelFlowRef4.instance.updateDisplayVisibility(showEngineData);
            this.eng4VibrationRef.instance.updateDisplayVisibility(showEngineData);
        }
        this.oilPressGaugeRef.instance.updateDisplayVisibility(showEngineData, engineNumber);
        this.oilTempGaugeRef.instance.updateDisplayVisibility(showEngineData, engineNumber);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "b748-EICAS-secondary-gauge-container" },
            FSComponent.buildComponent("div", { class: "upper-bar-gauge-container-secondary" }, [1, 2, 3, 4].map(index => (FSComponent.buildComponent("div", { class: "upper-bar-column" },
                FSComponent.buildComponent(N2BarGauge, { bus: this.props.bus, hideData: this.showEngineData[index].map(x => !x), engineIndex: index }),
                FSComponent.buildComponent(FuelFlowGauge, { bus: this.props.bus, ref: index === 1 ? this.fuelFlowRef1 :
                        index === 2 ? this.fuelFlowRef2 :
                            index === 3 ? this.fuelFlowRef3 : this.fuelFlowRef4 }))))),
            FSComponent.buildComponent(OilPressureGauge, { bus: this.props.bus, ref: this.oilPressGaugeRef }),
            FSComponent.buildComponent(OilTempGauge, { bus: this.props.bus, ref: this.oilTempGaugeRef }),
            FSComponent.buildComponent("div", { class: "oil-qty-container" },
                FSComponent.buildComponent("div", { class: "oil-qty-left" }, [1, 2].map(index => (FSComponent.buildComponent(OilQtyGauge, { ref: index === 1 ? this.oilQtyRef1 : this.oilQtyRef2, bus: this.props.bus, index: index })))),
                FSComponent.buildComponent("div", { class: "oil-qty-right" }, [3, 4].map(index => (FSComponent.buildComponent(OilQtyGauge, { ref: index === 3 ? this.oilQtyRef3 : this.oilQtyRef4, bus: this.props.bus, index: index }))))),
            FSComponent.buildComponent("div", { class: "vibration-gauge-section" },
                FSComponent.buildComponent("div", { class: "vibration-gauge-left" }, [1, 2].map(index => (FSComponent.buildComponent(VibrationGauge, { bus: this.props.bus, ref: index === 1 ? this.eng1VibrationRef : this.eng2VibrationRef, index: index })))),
                FSComponent.buildComponent("div", { class: "vibration-gauge-right" }, [3, 4].map(index => (FSComponent.buildComponent(VibrationGauge, { bus: this.props.bus, ref: index === 3 ? this.eng3VibrationRef : this.eng4VibrationRef, index: index }))))),
            FSComponent.buildComponent("div", { class: "gauge-titles title-N2" },
                "N",
                FSComponent.buildComponent("span", null, "2")),
            FSComponent.buildComponent("div", { class: "gauge-titles title-FF" }, "FF"),
            FSComponent.buildComponent("div", { class: "gauge-titles title-OILP" }, "OIL P"),
            FSComponent.buildComponent("div", { class: "gauge-titles title-OILT" }, "OIL T"),
            FSComponent.buildComponent("div", { class: "gauge-titles title-OILQ" }, "OIL Q"),
            FSComponent.buildComponent("div", { class: "gauge-titles title-VIB" }, "VIB")));
    }
}

/** The B78xNavigationMap component. */
class B748Electrical extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.elecSub = this.props.bus.getSubscriber();
        this.cockpitSub = this.props.bus.getSubscriber();
        this.autolandInhibitRef = FSComponent.createRef();
        this.gen1Powered = Subject.create(false);
        this.gen2Powered = Subject.create(false);
        this.gen3Powered = Subject.create(false);
        this.gen4Powered = Subject.create(false);
        this.bus1Powered = Subject.create(false);
        this.bus2Powered = Subject.create(false);
        this.bus3Powered = Subject.create(false);
        this.bus4Powered = Subject.create(false);
        this.bus1IslnSwitchStatus = ConsumerSubject.create(this.cockpitSub.on('b74_elec_bus_1_connection_on').whenChanged(), true);
        this.bus2IslnSwitchStatus = ConsumerSubject.create(this.cockpitSub.on('b74_elec_bus_2_connection_on').whenChanged(), true);
        this.bus3IslnSwitchStatus = ConsumerSubject.create(this.cockpitSub.on('b74_elec_bus_3_connection_on').whenChanged(), true);
        this.bus4IslnSwitchStatus = ConsumerSubject.create(this.cockpitSub.on('b74_elec_bus_4_connection_on').whenChanged(), true);
        this.ext1Powered = Subject.create(false);
        this.ext2Powered = Subject.create(false);
        this.apu1Powered = Subject.create(false);
        this.apu2Powered = Subject.create(false);
        this.busTie1Ref = FSComponent.createRef();
        this.busTie2Ref = FSComponent.createRef();
        this.busTie3Ref = FSComponent.createRef();
        this.busTie4Ref = FSComponent.createRef();
        this.bus1Ref = FSComponent.createRef();
        this.bus1UtilityRef = FSComponent.createRef();
        this.bus1GalleyRef = FSComponent.createRef();
        this.bus2Ref = FSComponent.createRef();
        this.bus2UtilityRef = FSComponent.createRef();
        this.bus2GalleyRef = FSComponent.createRef();
        this.bus3Ref = FSComponent.createRef();
        this.bus3UtilityRef = FSComponent.createRef();
        this.bus3GalleyRef = FSComponent.createRef();
        this.bus4Ref = FSComponent.createRef();
        this.bus4UtilityRef = FSComponent.createRef();
        this.bus4GalleyRef = FSComponent.createRef();
        this.genCont1Ref = FSComponent.createRef();
        this.genCont2Ref = FSComponent.createRef();
        this.genCont3Ref = FSComponent.createRef();
        this.genCont4Ref = FSComponent.createRef();
        this.drive1Ref = FSComponent.createRef();
        this.drive2Ref = FSComponent.createRef();
        this.drive3Ref = FSComponent.createRef();
        this.drive4Ref = FSComponent.createRef();
        this.splitSystemBreakerRef = FSComponent.createRef();
        this.bus1GenContLine = FSComponent.createRef();
        this.bus2GenContLine = FSComponent.createRef();
        this.bus3GenContLine = FSComponent.createRef();
        this.bus4GenContLine = FSComponent.createRef();
        this.bus1IslnLine = FSComponent.createRef();
        this.bus2IslnLine = FSComponent.createRef();
        this.bus3IslnLine = FSComponent.createRef();
        this.bus4IslnLine = FSComponent.createRef();
        this.ssbLine = FSComponent.createRef();
        this.bus1ToExt1Line = FSComponent.createRef();
        this.ext1ToApu1Line = FSComponent.createRef();
        this.ext1OutputLine = FSComponent.createRef();
        this.apu1OutputLine = FSComponent.createRef();
        this.apu1ToBus2JctLine = FSComponent.createRef();
        this.bus2OutputLine = FSComponent.createRef();
        this.bus2JctToSsbLine = FSComponent.createRef();
        this.bus3JctToSsbLine = FSComponent.createRef();
        this.bus3OutputLine = FSComponent.createRef();
        this.apu2ToBus3JctLine = FSComponent.createRef();
        this.apu2OutputLine = FSComponent.createRef();
        this.ext2OutputLine = FSComponent.createRef();
        this.ext2ToApu2Line = FSComponent.createRef();
        this.bus4ToExt2Line = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /** @inheritdoc */
    onAfterRender() {
        this.wireEngineGenStates();
        this.wireBusState();
        this.wireApuStates();
        this.wireExternalPwrStates();
        this.wireMainBusLines();
    }
    /**
     * Wires up the state of the engine generators.
     */
    wireEngineGenStates() {
        this.subs.push(
        // eng gens flow
        this.elecSub.on('elec_bus_genalt_1_a').whenChangedBy(1).handle((v) => {
            this.gen1Powered.set(v > 0);
            this.bus1GenContLine.instance.classList.toggle('active', v > 0);
            this.drive1Ref.instance.classList.toggle('drive-disabled', v <= 0);
        }), this.elecSub.on('elec_bus_genalt_2_a').whenChangedBy(1).handle((v) => {
            this.gen2Powered.set(v > 0);
            this.bus2GenContLine.instance.classList.toggle('active', v > 0);
            this.drive2Ref.instance.classList.toggle('drive-disabled', v <= 0);
        }), this.elecSub.on('elec_bus_genalt_3_a').whenChangedBy(1).handle((v) => {
            this.gen3Powered.set(v > 0);
            this.bus3GenContLine.instance.classList.toggle('active', v > 0);
            this.drive3Ref.instance.classList.toggle('drive-disabled', v <= 0);
        }), this.elecSub.on('elec_bus_genalt_4_a').whenChangedBy(1).handle((v) => {
            this.gen4Powered.set(v > 0);
            this.bus4GenContLine.instance.classList.toggle('active', v > 0);
            this.drive4Ref.instance.classList.toggle('drive-disabled', v <= 0);
        }), 
        // eng gen switches
        this.elecSub.on('elec_eng_gen_switch_1').whenChanged().handle(v => {
            this.genCont1Ref.instance.classList.toggle('gen-cont-off', !v);
        }), this.elecSub.on('elec_eng_gen_switch_2').whenChanged().handle(v => {
            this.genCont2Ref.instance.classList.toggle('gen-cont-off', !v);
        }), this.elecSub.on('elec_eng_gen_switch_3').whenChanged().handle(v => {
            this.genCont3Ref.instance.classList.toggle('gen-cont-off', !v);
        }), this.elecSub.on('elec_eng_gen_switch_4').whenChanged().handle(v => {
            this.genCont4Ref.instance.classList.toggle('gen-cont-off', !v);
        }));
    }
    /**
     * Wires up the state of the main buses to the html elements.
     */
    wireBusState() {
        this.subs.push(this.elecSub.on('elec_bus_main_v_2').whenChangedBy(1).handle((v) => {
            this.bus1Powered.set(v > 0);
            this.bus1Ref.instance.classList.toggle('bus-disabled', v <= 0);
            this.bus1UtilityRef.instance.classList.toggle('active', v > 0);
            this.bus1GalleyRef.instance.classList.toggle('active', v > 0);
        }), this.elecSub.on('elec_bus_main_v_3').whenChangedBy(1).handle((v) => {
            this.bus2Powered.set(v > 0);
            this.bus2Ref.instance.classList.toggle('bus-disabled', v <= 0);
            this.bus2UtilityRef.instance.classList.toggle('active', v > 0);
            this.bus2GalleyRef.instance.classList.toggle('active', v > 0);
        }), this.elecSub.on('elec_bus_main_v_4').whenChangedBy(1).handle((v) => {
            this.bus3Powered.set(v > 0);
            this.bus3Ref.instance.classList.toggle('bus-disabled', v <= 0);
            this.bus3UtilityRef.instance.classList.toggle('active', v > 0);
            this.bus3GalleyRef.instance.classList.toggle('active', v > 0);
        }), this.elecSub.on('elec_bus_main_v_5').whenChangedBy(1).handle((v) => {
            this.bus4Powered.set(v > 0);
            this.bus4Ref.instance.classList.toggle('bus-disabled', v <= 0);
            this.bus4UtilityRef.instance.classList.toggle('active', v > 0);
            this.bus4GalleyRef.instance.classList.toggle('active', v > 0);
        }), this.bus1IslnSwitchStatus.sub(v => this.busTie1Ref.instance.classList.toggle('isolated', !v), true), this.bus2IslnSwitchStatus.sub(v => this.busTie2Ref.instance.classList.toggle('isolated', !v), true), this.bus3IslnSwitchStatus.sub(v => this.busTie3Ref.instance.classList.toggle('isolated', !v), true), this.bus4IslnSwitchStatus.sub(v => this.busTie4Ref.instance.classList.toggle('isolated', !v), true));
    }
    /**
     * Wires up the external power state.
     */
    wireExternalPwrStates() {
        const isLine1Powered = MappedSubject.create(([pwrAvail, pwrOn]) => {
            return pwrAvail && pwrOn;
        }, ConsumerSubject.create(this.elecSub.on('elec_ext_power_available_1').whenChanged(), false), ConsumerSubject.create(this.elecSub.on('elec_ext_power_on_1').whenChanged(), false));
        const isLine2Powered = MappedSubject.create(([pwrAvail, pwrOn]) => {
            return pwrAvail && pwrOn;
        }, ConsumerSubject.create(this.elecSub.on('elec_ext_power_available_2').whenChanged(), false), ConsumerSubject.create(this.elecSub.on('elec_ext_power_on_2').whenChanged(), false));
        const anyBusConsuming = MappedSubject.create(([bus1, bus2, bus3, bus4, isln1, isln2, isln3, isln4, gen1, gen2, gen3, gen4]) => {
            return (bus1 && isln1 && !gen1) || (bus2 && isln2 && !gen2) || (bus3 && isln3 && !gen3) || (bus4 && isln4 && !gen4);
        }, this.bus1Powered, this.bus2Powered, this.bus3Powered, this.bus4Powered, this.bus1IslnSwitchStatus, this.bus2IslnSwitchStatus, this.bus3IslnSwitchStatus, this.bus4IslnSwitchStatus, this.gen1Powered, this.gen2Powered, this.gen3Powered, this.gen4Powered);
        this.subs.push(isLine1Powered.sub((v) => this.ext1Powered.set(v), true), isLine2Powered.sub((v) => this.ext2Powered.set(v), true), MappedSubject.create(([ext1, anyBusConnectedStatus]) => ext1 && anyBusConnectedStatus, this.ext1Powered, anyBusConsuming)
            .sub(v => this.ext1OutputLine.instance.classList.toggle('active', v), true), MappedSubject.create(([ext2, anyBusConnectedStatus]) => ext2 && anyBusConnectedStatus, this.ext2Powered, anyBusConsuming)
            .sub(v => this.ext2OutputLine.instance.classList.toggle('active', v), true));
    }
    /**
     * Wires up the state of the APU generators.
     */
    wireApuStates() {
        const anyBusConsuming = MappedSubject.create(([bus1, bus2, bus3, bus4, isln1, isln2, isln3, isln4, gen1, gen2, gen3, gen4]) => {
            return (bus1 && isln1 && !gen1) || (bus2 && isln2 && !gen2) || (bus3 && isln3 && !gen3) || (bus4 && isln4 && !gen4);
        }, this.bus1Powered, this.bus2Powered, this.bus3Powered, this.bus4Powered, this.bus1IslnSwitchStatus, this.bus2IslnSwitchStatus, this.bus3IslnSwitchStatus, this.bus4IslnSwitchStatus, this.gen1Powered, this.gen2Powered, this.gen3Powered, this.gen4Powered);
        this.subs.push(
        // apu gens state
        this.elecSub.on('elec_bus_genalt_5_a').whenChangedBy(1).handle((v) => {
            this.apu1Powered.set(v > 0);
        }), this.elecSub.on('elec_bus_genalt_6_a').whenChangedBy(1).handle((v) => {
            this.apu2Powered.set(v > 0);
        }), MappedSubject.create(([apu1, anyBusConnectedStatus]) => apu1 && anyBusConnectedStatus, this.apu1Powered, anyBusConsuming)
            .sub(v => this.apu1OutputLine.instance.classList.toggle('active', v), true), MappedSubject.create(([apu2, anyBusConnectedStatus]) => apu2 && anyBusConnectedStatus, this.apu2Powered, anyBusConsuming)
            .sub(v => this.apu2OutputLine.instance.classList.toggle('active', v), true));
    }
    /**
     * Wires up the state of the lines connected to the Synchronous Bus.
     */
    wireMainBusLines() {
        /** Whether Bus 1 is consuming power from the main bus */
        const _bus1C = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && !gen;
        }, this.bus1Powered, this.bus1IslnSwitchStatus, this.gen1Powered);
        /** Whether Bus 1 is providing power to the main bus */
        const _bus1P = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && gen;
        }, this.bus1Powered, this.bus1IslnSwitchStatus, this.gen1Powered);
        /** Whether Bus 2 is consuming power from the main bus */
        const _bus2C = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && !gen;
        }, this.bus2Powered, this.bus2IslnSwitchStatus, this.gen2Powered);
        /** Whether Bus 2 is providing power to the main bus */
        const _bus2P = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && gen;
        }, this.bus2Powered, this.bus2IslnSwitchStatus, this.gen2Powered);
        /** Whether Bus 3 is consuming power from the main bus */
        const _bus3C = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && !gen;
        }, this.bus3Powered, this.bus3IslnSwitchStatus, this.gen3Powered);
        /** Whether Bus 3 is providing power to the main bus */
        const _bus3P = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && gen;
        }, this.bus3Powered, this.bus3IslnSwitchStatus, this.gen3Powered);
        /** Whether Bus 4 is consuming power from the main bus */
        const _bus4C = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && !gen;
        }, this.bus4Powered, this.bus4IslnSwitchStatus, this.gen4Powered);
        /** Whether Bus 4 is providing power to the main bus */
        const _bus4P = MappedSubject.create(([bus, isln, gen]) => {
            return bus && isln && gen;
        }, this.bus4Powered, this.bus4IslnSwitchStatus, this.gen4Powered);
        this.subs.push(MappedSubject.create(_bus1C, _bus1P, _bus2C, _bus2P, _bus3C, _bus3P, _bus4C, _bus4P, this.apu1Powered, this.apu2Powered, this.ext1Powered, this.ext2Powered).sub(([bus1C, bus1P, bus2C, bus2P, bus3C, bus3P, bus4C, bus4P, apu1, apu2, ext1, ext2]) => {
            // MAIN BUS CONNECTIONS
            const bus1Connected = (bus1C && (bus2P || bus3P || bus4P || ext1 || ext2 || apu1 || apu2)) || (bus1P && (bus2C || bus3C || bus4C));
            this.bus1IslnLine.instance.classList.toggle('active', bus1Connected);
            this.bus1ToExt1Line.instance.classList.toggle('active', bus1Connected);
            const bus2Connected = (bus2C && (bus1P || bus3P || bus4P || ext1 || ext2 || apu1 || apu2)) || (bus2P && (bus1C || bus3C || bus4C));
            this.bus2IslnLine.instance.classList.toggle('active', bus2Connected);
            this.bus2OutputLine.instance.classList.toggle('active', bus2Connected);
            const bus3Connected = (bus3C && (bus1P || bus2P || bus4P || ext1 || ext2 || apu1 || apu2)) || (bus3P && (bus1C || bus2C || bus4C));
            this.bus3IslnLine.instance.classList.toggle('active', bus3Connected);
            this.bus3OutputLine.instance.classList.toggle('active', bus3Connected);
            const bus4Connected = (bus4C && (bus1P || bus2P || bus3P || ext1 || ext2 || apu1 || apu2)) || (bus4P && (bus1C || bus2C || bus3C));
            this.bus4IslnLine.instance.classList.toggle('active', bus4Connected);
            this.bus4ToExt2Line.instance.classList.toggle('active', bus4Connected);
            // RIGHT SIDE
            this.ext2ToApu2Line.instance.classList.toggle('active', ((bus4P || ext2) && (bus1C || bus2C || bus3C)) || (bus4C && (bus1P || bus2P || bus3P || ext1 || apu1 || apu2)));
            this.apu2ToBus3JctLine.instance.classList.toggle('active', ((bus4P || ext2 || apu2) && (bus1C || bus2C || bus3C)) || (bus4C && (bus1P || bus2P || bus3P || ext1 || apu1)));
            // LEFT SIDE
            this.ext1ToApu1Line.instance.classList.toggle('active', ((bus1P || ext1) && (bus2C || bus3C || bus4C)) || (bus1C && (bus2P || bus3P || bus4P || ext2 || apu1 || apu2)));
            this.apu1ToBus2JctLine.instance.classList.toggle('active', ((bus1P || ext1 || apu1) && (bus2C || bus3C || bus4C)) || (bus1C && (bus2P || bus3P || bus4P || ext2 || apu2)));
            // SSB
            const ssbActive = ((bus1P || bus2P || ext1 || apu1) && (bus3C || bus4C)) || ((bus3P || bus4P || apu2 || ext2) && (bus1C || bus2C));
            this.bus2JctToSsbLine.instance.classList.toggle('active', ssbActive);
            this.bus3JctToSsbLine.instance.classList.toggle('active', ssbActive);
            this.ssbLine.instance.classList.toggle('active', ssbActive);
        }, true));
    }
    /** @inheritdoc */
    render() {
        // AUTOLAND INHIBIT: add .autoland to the autolandInihibitRef div
        // BUS TIE: add .isolated to show warning
        // BUS DISPLAYS: add .bus-disabled to show warning
        //    UTILITIES, GALLEYS: add .active when active
        // GEN CONT: add .gen-cont-off to show warning
        // DRIVES: add .drive-disabled to show warning
        // SSB: add .ssb-open to splitSystemBreakerRef if open
        // LINES: (including line in SSB) add .active to show green line
        return (FSComponent.buildComponent("div", { class: "sys-elec-page-container", ref: this.autolandInhibitRef },
            FSComponent.buildComponent("div", { class: "autoland-inhibit-container display-pane-info" }, "ELECTRICAL SYNOPTIC INHIBITED FOR AUTOLAND"),
            FSComponent.buildComponent("div", { class: "elec-diagram-container" },
                FSComponent.buildComponent("div", { class: "elec-page-label ext-1-label" }, "EXT 1"),
                FSComponent.buildComponent("div", { class: "elec-page-label apu-1-label" }, "APU 1"),
                FSComponent.buildComponent("div", { class: "elec-page-label apu-2-label" }, "APU 2"),
                FSComponent.buildComponent("div", { class: "elec-page-label ext-2-label" }, "EXT 2"),
                FSComponent.buildComponent("div", { class: "elec-page-label center-label ssb-label" }, "SSB"),
                FSComponent.buildComponent("div", { class: "elec-page-label center-label bus-tie-label" }, "BUS TIE"),
                FSComponent.buildComponent("div", { class: "elec-page-label center-label gen-cont-label" }, "GEN CONT"),
                FSComponent.buildComponent("div", { class: "elec-page-label center-label drive-label" }, "DRIVE"),
                FSComponent.buildComponent("div", { class: "elec-line gen-bus-1-line", ref: this.bus1GenContLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "180px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 158 m 8 0 l 0 -158", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 160 l 4 0 l 0 -160 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line gen-bus-2-line", ref: this.bus2GenContLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "180px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 158 m 8 0 l 0 -158", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 160 l 4 0 l 0 -160 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line gen-bus-3-line", ref: this.bus3GenContLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "180px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 158 m 8 0 l 0 -158", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 160 l 4 0 l 0 -160 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line gen-bus-4-line", ref: this.bus4GenContLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "180px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 158 m 8 0 l 0 -158", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 160 l 4 0 l 0 -160 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line bus-isln-1-line", ref: this.bus1IslnLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "201px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 201 m 8 0 l 0 -201", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 201 l 4 0 l 0 -201 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line bus-isln-2-line", ref: this.bus2IslnLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "201px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 201 m 8 0 l 0 -201", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 201 l 4 0 l 0 -201 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line bus-isln-3-line", ref: this.bus3IslnLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "201px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 201 m 8 0 l 0 -201", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 201 l 4 0 l 0 -201 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line bus-isln-4-line", ref: this.bus4IslnLine },
                    FSComponent.buildComponent("svg", { width: "12px", height: "201px" },
                        FSComponent.buildComponent("path", { d: "M 2 0 l 0 201 m 8 0 l 0 -201", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "elec-line-active", d: "M 4 0 l 0 201 l 4 0 l 0 -201 z" }))),
                FSComponent.buildComponent("div", { class: "elec-line-base-top", ref: this.splitSystemBreakerRef },
                    FSComponent.buildComponent("svg", { width: "700px", height: "150px" },
                        FSComponent.buildComponent("path", { d: "M 2 87 l 0 -45 l 35 0 l 0 -40 l 8 0 l 0 40 l 82 0 l 0 -40 l 8 0 l 0 40 l 126 0 l 0 8", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 10 87 l 0 -37 l 152 0 l 0 37 m 8 0 l 0 -37 l 91 0 M 266 50 a 1 1 0 0 0 0 -8 a 1 1 0 0 0 0 8", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "ssb-line", d: "M 271 50 l 44 0 l 0 -8 l -44 0 l 0 8", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 320 50 a 1 1 0 0 0 0 -8 a 1 1 0 0 0 0 8 M 325 50 l 91 0 l 0 37 M 424 87 l 0 -37 l 152 0 l 0 37", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 584 87 l 0 -45 l -35 0 l 0 -40 l -8 0 l 0 40 l -82 0 l 0 -40 l -8 0 l 0 40 l -126 0 l 0 8", stroke: "var(--boeing-colors-white)", "stroke-width": "2", fill: "none" }),
                        FSComponent.buildComponent("path", { ref: this.ssbLine, class: "elec-line-top", d: "M 271 48 l 44 0 l 0 -4 l -44 0 z" }),
                        FSComponent.buildComponent("path", { ref: this.bus1ToExt1Line, class: "elec-line-top", d: "M 4 87 l 0 -43 l 35 0 l 0 4 l -31 0 l 0 39 z" }),
                        FSComponent.buildComponent("path", { ref: this.ext1OutputLine, class: "elec-line-top", d: "M 39 4 l 0 44 l 4 0 l 0 -44 z" }),
                        FSComponent.buildComponent("path", { ref: this.ext1ToApu1Line, class: "elec-line-top", d: "M 39 48 l 90 0 l 0 -4 l -90 0 z" }),
                        FSComponent.buildComponent("path", { ref: this.apu1OutputLine, class: "elec-line-top", d: "M 129 4 l 0 44 l 4 0 l 0 -44 z" }),
                        FSComponent.buildComponent("path", { ref: this.apu1ToBus2JctLine, class: "elec-line-top", d: "M 129 48 l 35 0 l 0 -4 l -35 0 z" }),
                        FSComponent.buildComponent("path", { ref: this.bus2OutputLine, class: "elec-line-top", d: "M 164 87 l 0 -43 l 4 0 l 0 43 z" }),
                        FSComponent.buildComponent("path", { ref: this.bus2JctToSsbLine, class: "elec-line-top", d: "M 164 48 l 97 0 l 0 -4 l -97 0 z" }),
                        FSComponent.buildComponent("path", { ref: this.bus3JctToSsbLine, class: "elec-line-top", d: "M 325 48 l 93 0 l 0 -4 l -93 0 z" }),
                        FSComponent.buildComponent("path", { ref: this.bus3OutputLine, class: "elec-line-top", d: "M 418 87 l 0 -43 l 4 0 l 0 43 z" }),
                        FSComponent.buildComponent("path", { ref: this.apu2ToBus3JctLine, class: "elec-line-top", d: "M 418 48 l 39 0 l 0 -4 l -39 0 z" }),
                        FSComponent.buildComponent("path", { ref: this.apu2OutputLine, class: "elec-line-top", d: "M 453 4 l 0 44 l 4 0 l 0 -44 z" }),
                        FSComponent.buildComponent("path", { ref: this.ext2ToApu2Line, class: "elec-line-top", d: "M 547 44 l -90 0 l 0 4 l 90 0 z" }),
                        FSComponent.buildComponent("path", { ref: this.ext2OutputLine, class: "elec-line-top", d: "M 543 4 l 0 44 l 4 0 l 0 -44 z" }),
                        FSComponent.buildComponent("path", { ref: this.bus4ToExt2Line, class: "elec-line-top", d: "M 582 87 l 0 -43 l -35 0 l 0 4 l 31 0 l 0 39 z" }))),
                FSComponent.buildComponent("div", { class: "elec-bus-tie elec-bus-tie-1", ref: this.busTie1Ref },
                    FSComponent.buildComponent("div", { class: "elec-bus-tie-isln" }, "ISLN")),
                FSComponent.buildComponent("div", { class: "elec-bus-tie elec-bus-tie-2", ref: this.busTie2Ref },
                    FSComponent.buildComponent("div", { class: "elec-bus-tie-isln" }, "ISLN")),
                FSComponent.buildComponent("div", { class: "elec-bus-tie elec-bus-tie-3", ref: this.busTie3Ref },
                    FSComponent.buildComponent("div", { class: "elec-bus-tie-isln" }, "ISLN")),
                FSComponent.buildComponent("div", { class: "elec-bus-tie elec-bus-tie-4", ref: this.busTie4Ref },
                    FSComponent.buildComponent("div", { class: "elec-bus-tie-isln" }, "ISLN")),
                FSComponent.buildComponent("div", { class: "elec-bus elec-bus-1", ref: this.bus1Ref }, "BUS 1"),
                FSComponent.buildComponent("div", { class: "elec-bus elec-bus-2", ref: this.bus2Ref }, "BUS 2"),
                FSComponent.buildComponent("div", { class: "elec-bus elec-bus-3", ref: this.bus3Ref }, "BUS 3"),
                FSComponent.buildComponent("div", { class: "elec-bus elec-bus-4", ref: this.bus4Ref }, "BUS 4"),
                FSComponent.buildComponent("div", { class: "utility-container bus-utility-1", ref: this.bus1UtilityRef },
                    FSComponent.buildComponent("div", { class: "utility-border utility-left" }),
                    FSComponent.buildComponent("div", null, "UTILITY")),
                FSComponent.buildComponent("div", { class: "utility-container bus-galley-1", ref: this.bus1GalleyRef },
                    FSComponent.buildComponent("div", { class: "utility-border galley utility-left" }),
                    FSComponent.buildComponent("div", null, "GALLEY")),
                FSComponent.buildComponent("div", { class: "utility-container bus-utility-2", ref: this.bus2UtilityRef },
                    FSComponent.buildComponent("div", { class: "utility-border utility-left" }),
                    FSComponent.buildComponent("div", null, "UTILITY")),
                FSComponent.buildComponent("div", { class: "utility-container bus-galley-2", ref: this.bus2GalleyRef },
                    FSComponent.buildComponent("div", { class: "utility-border galley utility-left" }),
                    FSComponent.buildComponent("div", null, "GALLEY")),
                FSComponent.buildComponent("div", { class: "utility-container bus-utility-3", ref: this.bus3UtilityRef },
                    FSComponent.buildComponent("div", null, "UTILITY"),
                    FSComponent.buildComponent("div", { class: "utility-border utility-right" })),
                FSComponent.buildComponent("div", { class: "utility-container bus-galley-3", ref: this.bus3GalleyRef },
                    FSComponent.buildComponent("div", null, "GALLEY"),
                    FSComponent.buildComponent("div", { class: "utility-border galley utility-right" })),
                FSComponent.buildComponent("div", { class: "utility-container bus-utility-4", ref: this.bus4UtilityRef },
                    FSComponent.buildComponent("div", null, "UTILITY"),
                    FSComponent.buildComponent("div", { class: "utility-border utility-right" })),
                FSComponent.buildComponent("div", { class: "utility-container bus-galley-4", ref: this.bus4GalleyRef },
                    FSComponent.buildComponent("div", null, "GALLEY"),
                    FSComponent.buildComponent("div", { class: "utility-border galley utility-right" })),
                FSComponent.buildComponent("div", { class: "elec-gen-cont elec-gen-cont-1", ref: this.genCont1Ref },
                    FSComponent.buildComponent("div", { class: "elec-gen-cont-off" }, "OFF")),
                FSComponent.buildComponent("div", { class: "elec-gen-cont elec-gen-cont-2", ref: this.genCont2Ref },
                    FSComponent.buildComponent("div", { class: "elec-gen-cont-off" }, "OFF")),
                FSComponent.buildComponent("div", { class: "elec-gen-cont elec-gen-cont-3", ref: this.genCont3Ref },
                    FSComponent.buildComponent("div", { class: "elec-gen-cont-off" }, "OFF")),
                FSComponent.buildComponent("div", { class: "elec-gen-cont elec-gen-cont-4", ref: this.genCont4Ref },
                    FSComponent.buildComponent("div", { class: "elec-gen-cont-off" }, "OFF")),
                FSComponent.buildComponent("div", { class: "elec-drive elec-drive-1", ref: this.drive1Ref },
                    FSComponent.buildComponent("div", { class: "elec-drive-temp-press" },
                        "DRIVE",
                        FSComponent.buildComponent("br", null),
                        "TEMP/",
                        FSComponent.buildComponent("br", null),
                        "PRESS")),
                FSComponent.buildComponent("div", { class: "elec-drive elec-drive-2", ref: this.drive2Ref },
                    FSComponent.buildComponent("div", { class: "elec-drive-temp-press" },
                        "DRIVE",
                        FSComponent.buildComponent("br", null),
                        "TEMP/",
                        FSComponent.buildComponent("br", null),
                        "PRESS")),
                FSComponent.buildComponent("div", { class: "elec-drive elec-drive-3", ref: this.drive3Ref },
                    FSComponent.buildComponent("div", { class: "elec-drive-temp-press" },
                        "DRIVE",
                        FSComponent.buildComponent("br", null),
                        "TEMP/",
                        FSComponent.buildComponent("br", null),
                        "PRESS")),
                FSComponent.buildComponent("div", { class: "elec-drive elec-drive-4", ref: this.drive4Ref },
                    FSComponent.buildComponent("div", { class: "elec-drive-temp-press" },
                        "DRIVE",
                        FSComponent.buildComponent("br", null),
                        "TEMP/",
                        FSComponent.buildComponent("br", null),
                        "PRESS")),
                FSComponent.buildComponent("div", { class: "elec-page-label eng-1-label" }, "1"),
                FSComponent.buildComponent("div", { class: "elec-page-label eng-2-label" }, "2"),
                FSComponent.buildComponent("div", { class: "elec-page-label eng-3-label" }, "3"),
                FSComponent.buildComponent("div", { class: "elec-page-label eng-4-label" }, "4"))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}

/** The B78xNavigationMap component. */
class B748FlightControls extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.adc = this.props.bus.getSubscriber();
        this.ctrlSurfaceEvents = this.props.bus.getSubscriber();
        this.hydSystemSub = this.props.bus.getSubscriber();
        this.hydSys1Pressure = ConsumerSubject.create(this.hydSystemSub.on('b748_hyd_pressure_1').whenChangedBy(50), 0);
        this.hydSys2Pressure = ConsumerSubject.create(this.hydSystemSub.on('b748_hyd_pressure_2').whenChangedBy(50), 0);
        this.hydSys3Pressure = ConsumerSubject.create(this.hydSystemSub.on('b748_hyd_pressure_3').whenChangedBy(50), 0);
        this.hydSys4Pressure = ConsumerSubject.create(this.hydSystemSub.on('b748_hyd_pressure_4').whenChangedBy(50), 0);
        this.hydSysCombined = MappedSubject.create(this.hydSys1Pressure, this.hydSys2Pressure, this.hydSys3Pressure, this.hydSys4Pressure);
        this.hydSysStatusContainerRef = FSComponent.createRef();
        this.hydSys1StatusRef = FSComponent.createRef();
        this.hydSys2StatusRef = FSComponent.createRef();
        this.hydSys3StatusRef = FSComponent.createRef();
        this.hydSys4StatusRef = FSComponent.createRef();
        this.aileronLeftPct = ConsumerSubject.create(this.ctrlSurfaceEvents.on('aileron_left_percent').atFrequency(6), 0);
        this.spoilersLeftPct = ConsumerSubject.create(this.ctrlSurfaceEvents.on('spoilers_left_percent').whenChanged(), 0);
        this.aileronRightPct = ConsumerSubject.create(this.ctrlSurfaceEvents.on('aileron_right_percent').atFrequency(6), 0);
        this.spoilersRightPct = ConsumerSubject.create(this.ctrlSurfaceEvents.on('spoilers_right_percent').whenChanged(), 0);
        this.elevatorPercent = ConsumerSubject.create(this.ctrlSurfaceEvents.on('elevator_percent').atFrequency(6), 0);
        this.rudderPercent = ConsumerSubject.create(this.ctrlSurfaceEvents.on('rudder_percent').atFrequency(6), 0);
        this.pitchTrimAngle = ConsumerSubject.create(this.ctrlSurfaceEvents.on('elevator_trim_angle').whenChanged(), 0);
        this.onGround = ConsumerSubject.create(this.adc.on('on_ground').whenChanged(), true);
        this.pitchCurrent = Subject.create(0);
        this.pitchCurrentString = Subject.create('');
        this.pitchTrimInGreenAndIsOnGround = MappedSubject.create(([trimValue, isOnGround]) => {
            const pitchTrimIsGreen = this.isPitchTrimValueInGreenZone(trimValue);
            return pitchTrimIsGreen && isOnGround;
        }, this.pitchCurrent, this.onGround);
        this.pitchTrimRef = FSComponent.createRef();
        this.aileronOutboardLeftRef = FSComponent.createRef();
        this.aileronInboardLeftRef = FSComponent.createRef();
        this.spoilersLeftRef = [
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
        ];
        this.aileronOutboardRightRef = FSComponent.createRef();
        this.aileronInboardRightRef = FSComponent.createRef();
        this.spoilersRightRef = [
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
        ];
        this.elevatorLeft1Ref = FSComponent.createRef();
        this.elevatorLeft2Ref = FSComponent.createRef();
        this.elevatorRight1Ref = FSComponent.createRef();
        this.elevatorRight2Ref = FSComponent.createRef();
        this.rudderTopRef = FSComponent.createRef();
        this.rudderBottomRef = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.aileronLeftPct.sub(v => this.onAileronLeftChange(v), true));
        this.subs.push(this.aileronRightPct.sub(v => this.onAileronRightChange(v), true));
        this.subs.push(this.spoilersLeftPct.sub(v => this.onSpoilersLeftChange(v), true));
        this.subs.push(this.spoilersRightPct.sub(v => this.onSpoilersRightChange(v), true));
        this.subs.push(this.elevatorPercent.sub(v => this.onElevatorChange(v), true));
        this.subs.push(this.rudderPercent.sub(v => this.onRudderChange(v), true));
        this.subs.push(this.hydSys1Pressure.sub(v => this.onHydraulicSystemPressureChange(v, this.hydSys1StatusRef), true));
        this.subs.push(this.hydSys2Pressure.sub(v => this.onHydraulicSystemPressureChange(v, this.hydSys2StatusRef), true));
        this.subs.push(this.hydSys3Pressure.sub(v => this.onHydraulicSystemPressureChange(v, this.hydSys3StatusRef), true));
        this.subs.push(this.hydSys4Pressure.sub(v => this.onHydraulicSystemPressureChange(v, this.hydSys4StatusRef), true));
        this.subs.push(this.hydSysCombined.sub(([sys1, sys2, sys3, sys4]) => {
            this.hydSysStatusContainerRef.instance.classList.toggle('hidden', [sys1, sys2, sys3, sys4].every(v => v > 2500));
        }, true));
        this.subs.push(this.pitchTrimAngle.sub(this.updatePitchTrim.bind(this), true));
        this.subs.push(this.pitchTrimInGreenAndIsOnGround.sub(v => {
            this.pitchTrimRef.instance.classList.toggle('fc-stab-trim-valid', v);
        }, true));
    }
    /**
     * When the left aileron moves
     * @param percent The percentage of aileron deflection
     */
    onAileronLeftChange(percent) {
        this.aileronOutboardLeftRef.instance.style.transform = `translate3d(0px, ${-51 + (percent * 0.5142)}px, 0px)`;
        this.aileronInboardLeftRef.instance.style.transform = `translate3d(0px, ${-51 + (percent * 0.5142)}px, 0px)`;
    }
    /**
     * When the right aileron moves
     * @param percent The percentage of aileron deflection
     */
    onAileronRightChange(percent) {
        this.aileronOutboardRightRef.instance.style.transform = `translate3d(0px, ${-51 + (-percent * 0.5142)}px, 0px)`;
        this.aileronInboardRightRef.instance.style.transform = `translate3d(0px, ${-51 + (-percent * 0.5142)}px, 0px)`;
    }
    /**
     * When the left spoiler moves
     * @param percent The percentage of spoiler deflection
     */
    onSpoilersLeftChange(percent) {
        this.spoilersLeftRef.forEach(spoiler => {
            spoiler.instance.style.transition = `transform ${Math.random() * 0.05 + 0.1}s steps(2, start)`;
            spoiler.instance.style.transform = `translate3d(0px, ${65 - (percent * 0.65)}px, 0px)`;
        });
    }
    /**
     * When the right spoiler moves
     * @param percent The percentage of aileron deflection
     */
    onSpoilersRightChange(percent) {
        this.spoilersRightRef.forEach(spoiler => {
            spoiler.instance.style.transition = `transform ${Math.random() * 0.05 + 0.1}s steps(2, start)`;
            spoiler.instance.style.transform = `translate3d(0px, ${65 - (percent * 0.65)}px, 0px)`;
        });
    }
    /**
     * When the elevator moves
     * @param percent The percentage of elevator deflection
     */
    onElevatorChange(percent) {
        this.elevatorLeft1Ref.instance.style.transform = `translate3d(0px, ${-51 + (-percent * 0.5142)}px, 0px)`;
        this.elevatorLeft2Ref.instance.style.transform = `translate3d(0px, ${-51 + (-percent * 0.5142)}px, 0px)`;
        this.elevatorRight1Ref.instance.style.transform = `translate3d(0px, ${-51 + (-percent * 0.5142)}px, 0px)`;
        this.elevatorRight2Ref.instance.style.transform = `translate3d(0px, ${-51 + (-percent * 0.5142)}px, 0px)`;
    }
    /**
     * When the rudder moves
     * @param percent The percentage of rudder deflection
     */
    onRudderChange(percent) {
        this.rudderTopRef.instance.style.transform = `translate3d(0px, ${-percent * 0.86}px, 0px)`;
        this.rudderBottomRef.instance.style.transform = `translate3d(0px, ${percent * 0.86}px, 0px)`;
    }
    /**
     * Updates hydraulic system status displays
     * @param pressure The current hydraulic system pressure in psi
     * @param statusRef A NodeReference to the system status display div
     */
    onHydraulicSystemPressureChange(pressure, statusRef) {
        statusRef.instance.classList.toggle('fc-hydraulics-warning', pressure < 2500);
    }
    /**
     * Updates the stabilizer trim.
     * @param data The data the sim gives.
     * Trim pitch is -15 to +15 degrees. The 748 displays 0 to 15. This turns -15/15 to 0/1 and converts it.
     * The trim indication line is 164px.
     */
    updatePitchTrim(data) {
        const newData = MathUtils.round(((((data / 15) + 1) / 2) * 15), .1);
        const newDataString = StringUtils.useZeroWidthDecimal(newData.toFixed(1));
        this.pitchCurrentString.set(newDataString);
        this.pitchCurrent.set(newData);
    }
    /**
     * Checks what the pitch trim green zone is.
     * @param v The pitch trim value the gauge receives.
     * @returns The boolean check for being in the green zone.
     */
    isPitchTrimValueInGreenZone(v) {
        return v >= 5.8 && v <= 10;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "sys-fctl-page-container" },
            FSComponent.buildComponent("div", { class: "fctl-page-aicraft-diagram-container" },
                FSComponent.buildComponent("svg", { class: "fctl-page-aircraft-diagram-svg", viewBox: "-5 -343 964 1274" },
                    FSComponent.buildComponent("path", { d: "M 831 203 c -3 -27 -5 -54 0 -80 l 60 0 c 5 26 3 66 2 80 l -6 0 l -17 27 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 677 119 c -3 -27 -5 -54 0 -80 l 60 0 c 5 26 3 66 2 80 l -6 0 l -17 27 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 677 119 c -3 -27 -5 -54 0 -80 l 60 0 c 5 26 3 66 2 80 l -6 0 l -17 27 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 217 119 c -3 -27 -5 -54 0 -80 l 60 0 c 5 26 3 66 2 80 l -36 27 l -20 -27 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 62 203 c -3 -27 -5 -54 0 -80 l 60 0 c 5 26 3 66 2 80 l -36 27 l -20 -27 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 124 203 l -62 0", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3px" }),
                    FSComponent.buildComponent("path", { d: "M 279 119 l -62 0", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3px" }),
                    FSComponent.buildComponent("path", { d: "M 893 203 l -62 0", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3px" }),
                    FSComponent.buildComponent("path", { d: "M 893 203 l -62 0", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3px" }),
                    FSComponent.buildComponent("path", { d: "M 739 119 l -62 0", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3px" }),
                    FSComponent.buildComponent("path", { d: "M 430 35 l -430 229 l 0 156 l 266 -57 l 422 0 l 266 57 l 0 -156 l -427 -229 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 428 546 l -204 171 l -2 56 l 242 -60 l 29 0 l 242 60 l -2 -57 l -204 -171 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 423 -146 l 0 630 c 1 82 13 137 17 157 c 8 34 23 77 38.5 113 c 16.5 -36 30.5 -79 38.5 -113 c 4 -20 16 -75 17 -157 l 0 -630 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 478.5 504 c -11.5 15 -16.5 183 0 257 c 15 -74 10 -242 0 -257 z", fill: "var(--boeing-colors-darker-gray)", stroke: "var(--boeing-colors-cyan)", "stroke-width": "5px" }))),
            FSComponent.buildComponent("div", { class: "fc-left-outboard-spoilers fc-spoilers-array" },
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersLeftRef[0] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersLeftRef[1] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersLeftRef[2] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersLeftRef[3] }))),
            FSComponent.buildComponent("div", { class: "fc-left-inboard-spoilers fc-spoilers-array" },
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersLeftRef[4] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersLeftRef[5] }))),
            FSComponent.buildComponent("div", { class: "fc-spoilers-text fc-gauge-title" }, "SPOILERS"),
            FSComponent.buildComponent("div", { class: "fc-right-inboard-spoilers fc-spoilers-array" },
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersRightRef[0] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersRightRef[1] }))),
            FSComponent.buildComponent("div", { class: "fc-right-outboard-spoilers fc-spoilers-array" },
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersRightRef[2] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersRightRef[3] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersRightRef[4] })),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("div", { class: "fc-spoilers-mask fc-spoilers-gauge-transit", ref: this.spoilersRightRef[5] }))),
            FSComponent.buildComponent("div", { class: "fc-left-aileron-gauge fc-gauge-package" },
                FSComponent.buildComponent("div", { class: "fc-gauge-template" },
                    FSComponent.buildComponent("svg", { viewBox: "10 10 45 140", height: "120px" },
                        FSComponent.buildComponent("line", { x1: "35", y1: "20", x2: "35", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "20", x2: "42", y2: "20", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "80", x2: "42", y2: "80", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "140", x2: "42", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" })),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.aileronOutboardLeftRef },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" })))),
                FSComponent.buildComponent("div", { class: "fc-gauge-title" },
                    "L AIL",
                    FSComponent.buildComponent("br", null),
                    "OUTBD")),
            FSComponent.buildComponent("div", { class: "fc-left-flaperon-gauge fc-gauge-package" },
                FSComponent.buildComponent("div", { class: "fc-gauge-template" },
                    FSComponent.buildComponent("svg", { viewBox: "10 10 45 140", height: "120px" },
                        FSComponent.buildComponent("line", { x1: "35", y1: "20", x2: "35", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "20", x2: "42", y2: "20", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "80", x2: "42", y2: "80", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "140", x2: "42", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" })),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.aileronInboardLeftRef },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" })))),
                FSComponent.buildComponent("div", { class: "fc-gauge-title" },
                    "L AIL",
                    FSComponent.buildComponent("br", null),
                    "INBD")),
            FSComponent.buildComponent("div", { class: "fc-right-flaperon-gauge fc-gauge-package" },
                FSComponent.buildComponent("div", { class: "fc-gauge-template" },
                    FSComponent.buildComponent("svg", { viewBox: "10 10 45 140", height: "120px" },
                        FSComponent.buildComponent("line", { x1: "35", y1: "20", x2: "35", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "20", x2: "42", y2: "20", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "80", x2: "42", y2: "80", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "140", x2: "42", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" })),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer-right" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.aileronInboardRightRef },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" })))),
                FSComponent.buildComponent("div", { class: "fc-gauge-title" },
                    "R AIL",
                    FSComponent.buildComponent("br", null),
                    "INBD")),
            FSComponent.buildComponent("div", { class: "fc-right-aileron-gauge fc-gauge-package" },
                FSComponent.buildComponent("div", { class: "fc-gauge-template" },
                    FSComponent.buildComponent("svg", { viewBox: "10 10 45 140", height: "120px" },
                        FSComponent.buildComponent("line", { x1: "35", y1: "20", x2: "35", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "20", x2: "42", y2: "20", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "80", x2: "42", y2: "80", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "140", x2: "42", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" })),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer-right" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.aileronOutboardRightRef },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" })))),
                FSComponent.buildComponent("div", { class: "fc-gauge-title" },
                    "R AIL",
                    FSComponent.buildComponent("br", null),
                    "OUTBD")),
            FSComponent.buildComponent("div", { class: "fc-left-elev-gauge fc-gauge-package" },
                FSComponent.buildComponent("div", { class: "fc-gauge-template" },
                    FSComponent.buildComponent("svg", { viewBox: "10 10 45 140", height: "120px" },
                        FSComponent.buildComponent("line", { x1: "35", y1: "20", x2: "35", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "20", x2: "42", y2: "20", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "80", x2: "42", y2: "80", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "140", x2: "42", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" })),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.elevatorLeft1Ref },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" }))),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer-right" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.elevatorLeft2Ref },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" })))),
                FSComponent.buildComponent("div", { class: "fc-gauge-title-left-elev fc-gauge-title" }, "L ELEV")),
            FSComponent.buildComponent("div", { class: "fc-right-elev-gauge fc-gauge-package" },
                FSComponent.buildComponent("div", { class: "fc-gauge-template" },
                    FSComponent.buildComponent("svg", { viewBox: "10 10 45 140", height: "120px" },
                        FSComponent.buildComponent("line", { x1: "35", y1: "20", x2: "35", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "20", x2: "42", y2: "20", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "80", x2: "42", y2: "80", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" }),
                        FSComponent.buildComponent("line", { x1: "28", y1: "140", x2: "42", y2: "140", stroke: "var(--boeing-colors-white)", "stroke-width": "4px" })),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.elevatorRight1Ref },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" }))),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer-right" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.elevatorRight2Ref },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" })))),
                FSComponent.buildComponent("div", { class: "fc-gauge-title-right-elev fc-gauge-title" }, "R ELEV")),
            FSComponent.buildComponent("div", { class: "fc-rudder-gauge fc-gauge-package" },
                FSComponent.buildComponent("div", { class: "fc-rudder-gauge-template" },
                    FSComponent.buildComponent("svg", { width: "180px", viewBox: "5 10 310 40" },
                        FSComponent.buildComponent("line", { x1: "10", y1: "35", x2: "310", y2: "35", stroke: "var(--boeing-colors-white)", "stroke-width": "5px" }),
                        FSComponent.buildComponent("line", { x1: "10", y1: "20", x2: "10", y2: "50", stroke: "var(--boeing-colors-white)", "stroke-width": "5px" }),
                        FSComponent.buildComponent("line", { x1: "160", y1: "25", x2: "160", y2: "45", stroke: "var(--boeing-colors-white)", "stroke-width": "5px" }),
                        FSComponent.buildComponent("line", { x1: "310", y1: "20", x2: "310", y2: "50", stroke: "var(--boeing-colors-white)", "stroke-width": "5px" })),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer-rudder-top" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.rudderTopRef },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" }))),
                    FSComponent.buildComponent("div", { class: "fc-gauge-pointer-rudder-bottom" },
                        FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25", ref: this.rudderBottomRef },
                            FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "var(--boeing-colors-white)" })))),
                FSComponent.buildComponent("div", { class: "fc-gauge-title" }, "RUDDER")),
            FSComponent.buildComponent("div", { class: "fc-hydraulics-container", ref: this.hydSysStatusContainerRef },
                FSComponent.buildComponent("div", { class: "fc-hydraulics-row fc-gauge-title" }, "HYDRAULICS"),
                FSComponent.buildComponent("div", { class: "fc-hydraulics-row" },
                    FSComponent.buildComponent("div", { class: "fc-hydraulics-status", ref: this.hydSys1StatusRef }, "1"),
                    FSComponent.buildComponent("div", { class: "fc-hydraulics-status", ref: this.hydSys2StatusRef }, "2"),
                    FSComponent.buildComponent("div", { class: "fc-hydraulics-status", ref: this.hydSys3StatusRef }, "3"),
                    FSComponent.buildComponent("div", { class: "fc-hydraulics-status", ref: this.hydSys4StatusRef }, "4"))),
            FSComponent.buildComponent("div", { class: "fc-stab-trim-container" },
                FSComponent.buildComponent("div", { class: "fc-stab-trim-row fc-gauge-title" }, "STAB"),
                FSComponent.buildComponent("div", { class: "fc-stab-trim-row" },
                    FSComponent.buildComponent("div", { class: "fc-stab-trim-value fc-stab-trim-valid", ref: this.pitchTrimRef }, this.pitchCurrentString)))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}

/** The B748 Fuel synoptics page component. */
class B748Fuel extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.gameUnitsMetric = ConsumerSubject.create(this.props.bus.getSubscriber().on('game_units_metric'), false);
        this.engineSub = this.props.bus.getSubscriber();
        this.fuelSub = this.props.bus.getSubscriber();
        this.unitString = this.gameUnitsMetric.map((isMetric) => {
            return BoeingUnitUtils.getUnitString(isMetric ? UnitType.KILOGRAM : UnitType.POUND);
        });
        this.onGround = ConsumerValue.create(this.props.bus.getSubscriber().on('on_ground'), true);
        // FUEL AMOUNTS
        this.main1ValueRef = FSComponent.createRef();
        this.main2ValueRef = FSComponent.createRef();
        this.main3ValueRef = FSComponent.createRef();
        this.main4ValueRef = FSComponent.createRef();
        this.fuelPoundsPerGallon = ConsumerSubject.create(this.engineSub.on('fuel_weight_per_gallon').whenChanged(), 0);
        this.totalFuelGals = ConsumerSubject.create(this.engineSub.on('fuel_usable_total').whenChangedBy(10), 0);
        this.centerFuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_1').whenChangedBy(10), 0);
        this.main1FuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_2').whenChangedBy(10), 10);
        this.main2FuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_3').whenChangedBy(10), 0);
        this.main3FuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_4').whenChangedBy(10), 0);
        this.main4FuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_5').whenChangedBy(10), 0);
        this.reserve1FuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_6').whenChangedBy(10), 0);
        this.reserve4FuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_7').whenChangedBy(10), 0);
        this.stabFuelGals = ConsumerSubject.create(this.fuelSub.on('fuel_system_tank_quantity_8').whenChangedBy(10), 0);
        this.totalFuelWeight = this.createFuelWeightSubject(this.totalFuelGals);
        this.centerFuelWeight = this.createFuelWeightSubject(this.centerFuelGals);
        this.main1FuelWeight = this.createFuelWeightSubject(this.main1FuelGals);
        this.main2FuelWeight = this.createFuelWeightSubject(this.main2FuelGals);
        this.main3FuelWeight = this.createFuelWeightSubject(this.main3FuelGals);
        this.main4FuelWeight = this.createFuelWeightSubject(this.main4FuelGals);
        this.reserve2FuelWeight = this.createFuelWeightSubject(this.reserve1FuelGals);
        this.reserve3FuelWeight = this.createFuelWeightSubject(this.reserve4FuelGals);
        this.stabFuelWeight = this.createFuelWeightSubject(this.stabFuelGals);
        this.main14TankWarningData = MappedSubject.create(this.main1FuelGals, this.main2FuelGals, this.main3FuelGals, this.main4FuelGals, this.reserve1FuelGals, this.reserve4FuelGals);
        this.wasMain14Imbalanced = false;
        this.wasMain23Imbalanced = false;
        this.wasMainLeftImbalanced = false;
        this.wasMainRightImbalanced = false;
        // FUEL LINE REFS
        this.main1TankLine = FSComponent.createRef();
        this.main2TankOvrdLine = FSComponent.createRef();
        this.main2TankLine = FSComponent.createRef();
        this.ctrLeftTankLine = FSComponent.createRef();
        this.ctrRightTankLine = FSComponent.createRef();
        this.main3TankLine = FSComponent.createRef();
        this.main3TankOvrdLine = FSComponent.createRef();
        this.main4TankLine = FSComponent.createRef();
        this.main1ToOvrdCrossfeedLine = FSComponent.createRef();
        this.main2ToOvrdCrossfeedLine = FSComponent.createRef();
        this.main3ToOvrdCrossfeedLine = FSComponent.createRef();
        this.main4ToOvrdCrossfeedLine = FSComponent.createRef();
        this.ctrLeftLine = FSComponent.createRef();
        this.ctrMiddleLine = FSComponent.createRef();
        this.ctrRightLine = FSComponent.createRef();
        this.eng1Line = FSComponent.createRef();
        this.eng2Line = FSComponent.createRef();
        this.eng3Line = FSComponent.createRef();
        this.eng4Line = FSComponent.createRef();
        this.stabTankArrowGroup = FSComponent.createRef();
        this.resLeftArrowGroup = FSComponent.createRef();
        this.resRightArrowGroup = FSComponent.createRef();
        // PUMPS
        this.main1FwdPump = FSComponent.createRef();
        this.main1AftPump = FSComponent.createRef();
        this.main2OvrdFwdPump = FSComponent.createRef();
        this.main2OvrdAftPump = FSComponent.createRef();
        this.main2FwdPump = FSComponent.createRef();
        this.main2AftPump = FSComponent.createRef();
        this.main3FwdPump = FSComponent.createRef();
        this.main3AftPump = FSComponent.createRef();
        this.main3OvrdFwdPump = FSComponent.createRef();
        this.main3OvrdAftPump = FSComponent.createRef();
        this.main4FwdPump = FSComponent.createRef();
        this.main4AftPump = FSComponent.createRef();
        this.ctrLeftPump = FSComponent.createRef();
        this.ctrRightPump = FSComponent.createRef();
        this.stabLeftPump = FSComponent.createRef();
        this.stabRightPump = FSComponent.createRef();
        // XFEED VALVES
        this.engine1CrossfeedOpen = Subject.create(true);
        this.engine2CrossfeedOpen = Subject.create(true);
        this.engine3CrossfeedOpen = Subject.create(true);
        this.engine4CrossfeedOpen = Subject.create(true);
        // JETTISON REFS
        this.jettisonContainerRef = FSComponent.createRef();
        this.leftMainJettisonLine = FSComponent.createRef();
        this.ctrLeftJettisonLine = FSComponent.createRef();
        this.ctrRightJettisonLine = FSComponent.createRef();
        this.rightMainJettisonLine = FSComponent.createRef();
        this.leftMainToStabJctJettisonLine = FSComponent.createRef();
        this.rightMainToStabJctJettisonLine = FSComponent.createRef();
        this.stabTankJettisonLine = FSComponent.createRef();
        this.stabLeftJettisonLine = FSComponent.createRef();
        this.stabRightJettisonLine = FSComponent.createRef();
        this.leftNozzleJettisonLine = FSComponent.createRef();
        this.rightNozzleJettisonLine = FSComponent.createRef();
        this.leftJettisonNozzleRef = FSComponent.createRef();
        this.rightJettisonNozzleRef = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.main14TankWarningData.sub(([main1Gals, main2Gals, main3Gals, main4Gals, res1Gals, res4Gals]) => {
            // TODO: add condition of 'when crossfeed valve 1 or 4 open'
            const fuelEngConditionReached = main2Gals <= main1Gals + res1Gals + (this.onGround.get() ? 164.5 : 0);
            let imbalanceThreshold = this.wasMain14Imbalanced ? B748FuelConstants.FUEL_IMBALANCE_OFF_THRESHOLD : B748FuelConstants.FUEL_IMBALANCE_MAINS_14_THRESHOLD;
            this.wasMain14Imbalanced = Math.abs(main1Gals - main4Gals) >= imbalanceThreshold;
            imbalanceThreshold = this.wasMain23Imbalanced ? B748FuelConstants.FUEL_IMBALANCE_OFF_THRESHOLD : B748FuelConstants.FUEL_IMBALANCE_MAINS_23_THRESHOLD;
            this.wasMain23Imbalanced = Math.abs(main2Gals - main3Gals) >= imbalanceThreshold;
            imbalanceThreshold = this.wasMainLeftImbalanced ? B748FuelConstants.FUEL_IMBALANCE_OFF_THRESHOLD : B748FuelConstants.FUEL_IMBALANCE_MAINS_23_THRESHOLD;
            this.wasMainLeftImbalanced = fuelEngConditionReached && Math.abs((main1Gals + res1Gals) - main2Gals) >= imbalanceThreshold;
            imbalanceThreshold = this.wasMainRightImbalanced ? B748FuelConstants.FUEL_IMBALANCE_OFF_THRESHOLD : B748FuelConstants.FUEL_IMBALANCE_MAINS_23_THRESHOLD;
            this.wasMainRightImbalanced = fuelEngConditionReached && Math.abs(main3Gals - (main4Gals + res4Gals)) >= imbalanceThreshold;
            this.main1ValueRef.instance.classList.toggle('fuel-warning', main1Gals < B748FuelConstants.FUEL_LOW_MAINS_THRESHOLD || this.wasMain14Imbalanced || this.wasMainLeftImbalanced);
            this.main2ValueRef.instance.classList.toggle('fuel-warning', main2Gals < B748FuelConstants.FUEL_LOW_MAINS_THRESHOLD || this.wasMain23Imbalanced || this.wasMainLeftImbalanced);
            this.main3ValueRef.instance.classList.toggle('fuel-warning', main3Gals < B748FuelConstants.FUEL_LOW_MAINS_THRESHOLD || this.wasMain23Imbalanced || this.wasMainRightImbalanced);
            this.main4ValueRef.instance.classList.toggle('fuel-warning', main4Gals < B748FuelConstants.FUEL_LOW_MAINS_THRESHOLD || this.wasMain14Imbalanced || this.wasMainRightImbalanced);
        }, true));
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /**
     * Creates a subject for fuel weight display purposes.
     * @param fuelGals A subscribable for the fuel quantity in gallons.
     * @returns A mapped subject.
     */
    createFuelWeightSubject(fuelGals) {
        return MappedSubject.create((([qty, weight, isMetric]) => {
            const fuelInPounds = qty * weight / 1000;
            return (isMetric ? UnitType.POUND.convertTo(fuelInPounds, UnitType.KILOGRAM) : fuelInPounds).toFixed(1).replace('.', '·');
        }), fuelGals, this.fuelPoundsPerGallon, this.gameUnitsMetric);
    }
    /** @inheritdoc */
    render() {
        // STAB and RES lines: add .pump-on to show the inactive elements, .line-active to show the green lines (line hidden by default)
        // FUEL LINES: add .active to the referenced div
        // PUMPS: add .active or .fail to referenced div. Default is off.
        // VALVES: shows open or closed based on Subscribable boolean value in the 'open' prop.
        // JETTISON: use .hidden to hide the container div (including jettison time display in top right corner)
        //    Jettison fuel lines, nozzles: toggle .active on the corresponding line or nozzle
        return (FSComponent.buildComponent("div", { class: "sys-fuel-page-container" },
            FSComponent.buildComponent("div", { class: "total-fuel-container" },
                FSComponent.buildComponent("div", { class: "total-fuel-label-container" },
                    FSComponent.buildComponent("div", { class: "fuel-page-label" }, "TOTAL FUEL"),
                    FSComponent.buildComponent("div", { class: "total-fuel-unit" },
                        this.unitString,
                        "S X 1000")),
                FSComponent.buildComponent("div", { class: "total-fuel-value" }, this.totalFuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container center-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "CENTER"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value" }, this.centerFuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container main1-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "MAIN 1"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value", ref: this.main1ValueRef }, this.main1FuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container main2-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "MAIN 2"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value", ref: this.main2ValueRef }, this.main2FuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container main3-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "MAIN 3"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value", ref: this.main3ValueRef }, this.main3FuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container main4-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "MAIN 4"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value", ref: this.main4ValueRef }, this.main4FuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container stab-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "STAB"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value" }, this.stabFuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container res1-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "RES 1"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value" }, this.reserve2FuelWeight)),
            FSComponent.buildComponent("div", { class: "tank-fuel-level-container res2-tank-fuel-level" },
                FSComponent.buildComponent("div", { class: "fuel-page-label" }, "RES 4"),
                FSComponent.buildComponent("div", { class: "tank-fuel-level-value" }, this.reserve3FuelWeight)),
            FSComponent.buildComponent("div", { class: "fuel-diagram-container" },
                FSComponent.buildComponent("svg", { class: "fuel-diagram", viewBox: "-25 -3 675 550" },
                    FSComponent.buildComponent("path", { d: "M 0 260 l 0 -110 m 10 0 l 0 30 l 115 -35 l 0 -145 l 375 0 l 0 145 l 115 35 l 0 -30 m -605 110 l 0 -70 l 115 -35 l 0 25", stroke: "var(--boeing-colors-white)", "stroke-width": "2px" }),
                    FSComponent.buildComponent("path", { d: "M 135 180 l 0 -28 l 75 -23 l 0 51 m 10 0 l 0 -100 m -10 0 l 0 39 l -75 23 l 0 -132 l 150 0 l 0 30", stroke: "var(--boeing-colors-white)", "stroke-width": "2px" }),
                    FSComponent.buildComponent("path", { d: "M 295 40 l 0 -30 l 35 0 l 0 30 m 10 0 l 0 -30 l 150 0 l 0 132 l -75 -23 l 0 -39", stroke: "var(--boeing-colors-white)", "stroke-width": "2px" }),
                    FSComponent.buildComponent("path", { d: "M 405 80 l 0 100 m 10 0 l 0 -51 l 75 23 l 0 28 m 10 0 l 0 -25 l 115 35 l 0 70 m 10 0 l 0 -110", stroke: "var(--boeing-colors-white)", "stroke-width": "2px" }),
                    FSComponent.buildComponent("g", { class: "stab-tank-arrow-container", ref: this.stabTankArrowGroup },
                        FSComponent.buildComponent("path", { d: "M 307.5 500 l 0 -300 l -7 0 l 12 -15 l 12 15 l -7 0 l 0 300", stroke: "var(--boeing-colors-white)", "stroke-width": "2px", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "stab-tank-line-active", d: "M 305.5 500 l 0 -297.5 l -10 0 l 17 -20 l 17 20 l -10 0 l 0 297.5 z", stroke: "none", fill: "var(--boeing-colors-green)" })),
                    FSComponent.buildComponent("g", { class: "stab-tank-arrow-container", ref: this.resLeftArrowGroup },
                        FSComponent.buildComponent("path", { d: "M 0 490 l 0 -40 l -7 0 l 12 -15 l 12 15 l -7 0 l 0 40", stroke: "var(--boeing-colors-white)", "stroke-width": "2px", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "stab-tank-line-active", d: "M -2.5 490 l 0 -38 l -10 0 l 17 -20 l 17 20 l -10 0 l 0 38 z", stroke: "none", fill: "var(--boeing-colors-green)" })),
                    FSComponent.buildComponent("g", { class: "stab-tank-arrow-container", ref: this.resRightArrowGroup },
                        FSComponent.buildComponent("path", { d: "M 615 490 l 0 -40 l -7 0 l 12 -15 l 12 15 l -7 0 l 0 40", stroke: "var(--boeing-colors-white)", "stroke-width": "2px", fill: "none" }),
                        FSComponent.buildComponent("path", { class: "stab-tank-line-active", d: "M 612.5 490 l 0 -38 l -10 0 l 17 -20 l 17 20 l -10 0 l 0 38 z", stroke: "none", fill: "var(--boeing-colors-green)" })),
                    FSComponent.buildComponent("path", { d: "M 203 80 c -2 -2 -4 -6 -5 -10 l 0 -28 l -10 0 c 0 -8 1 -16 5 -25 l 44 0 c 4 9 5 17 5 25 l -10 0 l 0 28 c -1 4 -3 8 -5 10 z", stroke: "var(--boeing-colors-white)", "stroke-width": "6px", fill: "var(--boeing-colors-black)" }),
                    FSComponent.buildComponent("path", { d: "M 398 80 c -2 -2 -4 -6 -5 -10 l 0 -28 l -10 0 c 0 -8 1 -16 5 -25 l 44 0 c 4 9 5 17 5 25 l -10 0 l 0 28 c -1 4 -3 8 -5 10 z", stroke: "var(--boeing-colors-white)", "stroke-width": "6px", fill: "var(--boeing-colors-black)" }),
                    FSComponent.buildComponent("path", { d: "M 608 150 c -2 -2 -4 -6 -5 -10 l 0 -28 l -10 0 c 0 -8 1 -16 5 -25 l 44 0 c 4 9 5 17 5 25 l -10 0 l 0 28 c -1 4 -3 8 -5 10 z", stroke: "var(--boeing-colors-white)", "stroke-width": "6px", fill: "var(--boeing-colors-black)" }),
                    FSComponent.buildComponent("path", { d: "M -7 150 c -2 -2 -4 -6 -5 -10 l 0 -28 l -10 0 c 0 -8 1 -16 5 -25 l 44 0 c 4 9 5 17 5 25 l -10 0 l 0 28 c -1 4 -3 8 -5 10 z", stroke: "var(--boeing-colors-white)", "stroke-width": "6px", fill: "var(--boeing-colors-black)" })),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-1-tank-line", ref: this.main1TankLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "79px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 75 l 0 -75 l 10 0 l 0 75 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-2-tank-ovrd-line", ref: this.main2TankOvrdLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "35px" },
                        FSComponent.buildComponent("path", { d: "M 2 31 l 0 -31 l 10 0 l 0 31 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-2-tank-line", ref: this.main2TankLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "61px" },
                        FSComponent.buildComponent("path", { d: "M 2 57 l 0 -57 l 10 0 l 0 57 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container ctr-left-tank-line", ref: this.ctrLeftTankLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "46px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 42 l 0 -42 l 10 0 l 0 42 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container ctr-right-tank-line", ref: this.ctrRightTankLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "46px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 42 l 0 -42 l 10 0 l 0 42 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-3-tank-line", ref: this.main3TankLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "61px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 57 l 0 -57 l 10 0 l 0 57 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-3-tank-ovrd-line", ref: this.main3TankOvrdLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "35px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 31 l 0 -31 l 10 0 l 0 31 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-4-tank-line", ref: this.main4TankLine },
                    FSComponent.buildComponent("svg", { width: "15px", height: "79px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 75 l 0 -75 l 10 0 l 0 75 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container ctr-left-line", ref: this.ctrLeftLine },
                    FSComponent.buildComponent("svg", { width: "180px", height: "170px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 163.5 l 0 -161 l 176 0 l 0 10 l -166 0 l 0 148 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container ctr-middle-line", ref: this.ctrMiddleLine },
                    FSComponent.buildComponent("svg", { width: "70px", height: "15px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 12 l 57 0 l 0 -10 l -57 0 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container ctr-right-line", ref: this.ctrRightLine },
                    FSComponent.buildComponent("svg", { width: "180px", height: "170px" },
                        FSComponent.buildComponent("path", { d: "M 2 163.5 l 0 -161 l 176 0 l 0 10 l -166 0 l 0 148 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-1-crossfeed-line", ref: this.main1ToOvrdCrossfeedLine },
                    FSComponent.buildComponent("svg", { width: "150px", height: "60px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 55 l 139.5 -42.36 l 0 -10 l -139.5 42.36 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-2-crossfeed-line", ref: this.main2ToOvrdCrossfeedLine },
                    FSComponent.buildComponent("svg", { width: "103px", height: "50px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 44 l 101.5 -31 l 0 -10 l -101.5 31 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-3-crossfeed-line", ref: this.main3ToOvrdCrossfeedLine },
                    FSComponent.buildComponent("svg", { width: "103px", height: "50px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 44 l 101.5 -31 l 0 -10 l -101.5 31 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container main-4-crossfeed-line", ref: this.main4ToOvrdCrossfeedLine },
                    FSComponent.buildComponent("svg", { width: "150px", height: "60px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 55 l 139.5 -42.36 l 0 -10 l -139.5 42.36 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container eng-1-line", ref: this.eng1Line },
                    FSComponent.buildComponent("svg", { width: "15px", height: "40px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 36 l 0 -36 l 10 0 l 0 36 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container eng-2-line", ref: this.eng2Line },
                    FSComponent.buildComponent("svg", { width: "15px", height: "45px" },
                        FSComponent.buildComponent("path", { d: "M 2 43 l 0 -43 l 10 0 l 0 43 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container eng-3-line", ref: this.eng3Line },
                    FSComponent.buildComponent("svg", { width: "15px", height: "45px" },
                        FSComponent.buildComponent("path", { d: "M 2 43 l 0 -43 l 10 0 l 0 43 z" }))),
                FSComponent.buildComponent("div", { class: "fuel-line-container eng-4-line", ref: this.eng4Line },
                    FSComponent.buildComponent("svg", { width: "15px", height: "40px" },
                        FSComponent.buildComponent("path", { d: "M 2.5 36 l 0 -36 l 10 0 l 0 36 z" }))),
                FSComponent.buildComponent("div", { class: "left-1-crossfeed-valve" },
                    FSComponent.buildComponent(FuelValvePath, { open: this.engine1CrossfeedOpen })),
                FSComponent.buildComponent("div", { class: "left-2-crossfeed-valve" },
                    FSComponent.buildComponent(FuelValvePath, { open: this.engine2CrossfeedOpen })),
                FSComponent.buildComponent("div", { class: "right-3-crossfeed-valve" },
                    FSComponent.buildComponent(FuelValvePath, { open: this.engine3CrossfeedOpen })),
                FSComponent.buildComponent("div", { class: "right-4-crossfeed-valve" },
                    FSComponent.buildComponent(FuelValvePath, { open: this.engine4CrossfeedOpen })),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-1-fwd", ref: this.main1FwdPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-1-aft", ref: this.main1AftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-large fuel-pump-left-ovrd-fwd", ref: this.main2OvrdFwdPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-large fuel-pump-left-ovrd-aft", ref: this.main2OvrdAftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-2-fwd", ref: this.main2FwdPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-2-aft", ref: this.main2AftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-ctr-left", ref: this.ctrLeftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-ctr-right", ref: this.ctrRightPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-3-fwd", ref: this.main3FwdPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-3-aft", ref: this.main3AftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-large fuel-pump-right-ovrd-fwd", ref: this.main3OvrdFwdPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-large fuel-pump-right-ovrd-aft", ref: this.main3OvrdAftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-4-fwd", ref: this.main4FwdPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-main-4-aft", ref: this.main4AftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-stab-left", ref: this.stabLeftPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "fuel-pump fuel-pump-small fuel-pump-stab-right", ref: this.stabRightPump },
                    FSComponent.buildComponent("div", null)),
                FSComponent.buildComponent("div", { class: "engine-1-label fuel-page-label" }, "1"),
                FSComponent.buildComponent("div", { class: "engine-2-label fuel-page-label" }, "2"),
                FSComponent.buildComponent("div", { class: "engine-3-label fuel-page-label" }, "3"),
                FSComponent.buildComponent("div", { class: "engine-4-label fuel-page-label" }, "4")),
            FSComponent.buildComponent("div", { class: "fuel-jettison-container hidden", ref: this.jettisonContainerRef },
                FSComponent.buildComponent("div", { class: "jett-time-display-container" },
                    FSComponent.buildComponent("div", { class: "fuel-page-label" }, "JETTISON TIME"),
                    FSComponent.buildComponent("div", { class: "jett-time-value" },
                        "76",
                        FSComponent.buildComponent("span", { class: "jett-time-unit" }, "MIN"))),
                FSComponent.buildComponent("svg", { viewBox: "-25 -3 675 566" },
                    FSComponent.buildComponent("path", { d: "M 286 84 l 0 12 l -30 0 l 0 181 l -105 0 l 0 -11 M 142 266 l 0 19 l 114 0 l 0 179 l -171 41", "stroke-width": "2", stroke: "var(--boeing-colors-white)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 295 84 l 0 20 l -31 0 l 0 281 l 92 0 M 325 84 l 0 20 l 31 0 l 0 281", "stroke-width": "2", stroke: "var(--boeing-colors-white)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 334 84 l 0 12 l 30 0 l 0 180 l 104 0 l 0 -10 M 477 266 l 0 18 l -113 0 l 0 180 l 171 41", "stroke-width": "2", stroke: "var(--boeing-colors-white)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 306 460 l 0 -67 l -42 0 l 0 77 l -176.56 42.48 M 314 460 l 0 -67 l 42 0 l 0 77 l 176.56 42.48", "stroke-width": "2", stroke: "var(--boeing-colors-white)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 535 505 l -13 40 l 26 0 z M 85 505 l -13 40 l 26 0 z", "stroke-width": "2", stroke: "var(--boeing-colors-white)", fill: "none" }),
                    FSComponent.buildComponent("path", { ref: this.leftMainJettisonLine, class: "jettison-fuel-line", d: "M 144 266 l 0 17 l 118 0 l 0 -4 l -113 0 l 0 -13 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.ctrLeftJettisonLine, class: "jettison-fuel-line", d: "M 288 84 l 0 14 l -30 0 l 0 181 l 4 0 l 0 -177 l 31 0 l 0 -18 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.ctrRightJettisonLine, class: "jettison-fuel-line active", d: "M 327 84 l 0 18 l 31 0 l 0 176 l 4 0 l 0 -180 l -30 0 l 0 -14 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.rightMainJettisonLine, class: "jettison-fuel-line active", d: "M 475 266 l 0 16 l -117 0 l 0 -4 l 112 0 l 0 -12 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.leftMainToStabJctJettisonLine, class: "jettison-fuel-line", d: "M 258 279 l 0 108 l 4 0 l 0 -108 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.rightMainToStabJctJettisonLine, class: "jettison-fuel-line active", d: "M 358 278 l 0 109 l 4 0 l 0 -109 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.stabTankJettisonLine, class: "jettison-fuel-line active", d: "M 308 460 l 0 -73 l 4 0 l 0 73 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.stabLeftJettisonLine, class: "jettison-fuel-line", d: "M 310 391 l -52 0 l 0 -4 l 52 0 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.stabRightJettisonLine, class: "jettison-fuel-line active", d: "M 310 387 l 52 0 l 0 4 l -52 0 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.leftNozzleJettisonLine, class: "jettison-fuel-line", d: "M 258 387 l 0 78.5 l -172.33 41.513 l 1.141 3.573 l 175.189 -42.086 l 0 -81.5 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.rightNozzleJettisonLine, class: "jettison-fuel-line active", d: "M 362 387 l 0 78.482 l 172.325 41.559 l -1.14 3.538 l -175.185 -42.059 l 0 -81.52 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.leftJettisonNozzleRef, class: "jettison-fuel-line", d: "M 75 543 l 20 0 l -10 -33 z", stroke: "none", fill: "var(--boeing-colors-magenta)" }),
                    FSComponent.buildComponent("path", { ref: this.rightJettisonNozzleRef, class: "jettison-fuel-line active", d: "M 525 543 l 20 0 l -10 -33 z", stroke: "none", fill: "var(--boeing-colors-magenta)" })),
                FSComponent.buildComponent("div", { class: "jett-label-left fuel-page-label" }, "JETT"),
                FSComponent.buildComponent("div", { class: "jett-label-right fuel-page-label" }, "JETT"))));
    }
}
/** Component for engine bleed valves */
class FuelValvePath extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.bleedValveMask = FSComponent.createRef();
        this.bleedValveFill = FSComponent.createRef();
        this.bleedValveClosed = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.sub = this.props.open.sub(open => {
            this.bleedValveFill.instance.classList.toggle('fuel-valve-open', open);
            this.bleedValveFill.instance.classList.toggle('fuel-valve-closed', !open);
            this.bleedValveMask.instance.classList.toggle('hidden', !open);
            this.bleedValveClosed.instance.classList.toggle('hidden', open);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { class: "fuel-valve-svg", viewBox: "-5 -5 120 120" },
            FSComponent.buildComponent("path", { ref: this.bleedValveFill, d: "M 55 55 a 1 1 0 0 0 0 -55 a 1 1 0 0 0 0 55" }),
            FSComponent.buildComponent("path", { ref: this.bleedValveMask, d: "M 85 34 l -60 0 l 0 -11 l 60 0 z", fill: "var(--boeing-colors-black)" }),
            FSComponent.buildComponent("path", { ref: this.bleedValveClosed, d: "M 50 54.5 l 0 -54 m 10 0 l 0 54", stroke: "var(--boeing-colors-white)", "stroke-width": "5", fill: "none" })));
    }
    /** @inheritdoc */
    destroy() {
        if (this.sub) {
            this.sub.destroy();
        }
    }
}

var B748EdpStates;
(function (B748EdpStates) {
    B748EdpStates[B748EdpStates["OFF"] = 0] = "OFF";
    B748EdpStates[B748EdpStates["ON"] = 1] = "ON";
    B748EdpStates[B748EdpStates["ACTIVE"] = 2] = "ACTIVE";
})(B748EdpStates || (B748EdpStates = {}));
/** The B78xNavigationMap component. */
class B748Hydraulics extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.adc = this.props.bus.getSubscriber();
        this.hydSub = this.props.bus.getSubscriber();
        this.b748HydSystemSub = this.props.bus.getSubscriber();
        this.cockpitVarSub = this.props.bus.getSubscriber();
        this.onGround = ConsumerSubject.create(this.adc.on('on_ground').whenChanged(), true);
        this.hydPressure1 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_1').whenChangedBy(10), 0);
        this.hydPressure2 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_2').whenChangedBy(10), 0);
        this.hydPressure3 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_3').whenChangedBy(10), 0);
        this.hydPressure4 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_4').whenChangedBy(10), 0);
        this.pressureDisplay1 = this.createPressureDisplaySubject();
        this.pressureDisplay2 = this.createPressureDisplaySubject();
        this.pressureDisplay3 = this.createPressureDisplaySubject();
        this.pressureDisplay4 = this.createPressureDisplaySubject();
        this.hydReservoir1 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.hydReservoir2 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.hydReservoir3 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.hydReservoir4 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.reservoirDisplay1 = this.createReservoirDisplaySubject();
        this.reservoirDisplay2 = this.createReservoirDisplaySubject();
        this.reservoirDisplay3 = this.createReservoirDisplaySubject();
        this.reservoirDisplay4 = this.createReservoirDisplaySubject();
        this.hydTemp1 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_1').whenChangedBy(0.5), 0);
        this.hydTemp2 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_2').whenChangedBy(0.5), 0);
        this.hydTemp3 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_3').whenChangedBy(0.5), 0);
        this.hydTemp4 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_4').whenChangedBy(0.5), 0);
        this.tempDisplay1 = this.createTempDisplaySubject();
        this.tempDisplay2 = this.createTempDisplaySubject();
        this.tempDisplay3 = this.createTempDisplaySubject();
        this.tempDisplay4 = this.createTempDisplaySubject();
        // refs
        // system 1
        this.demandPump1Ref = FSComponent.createRef();
        this.auxPump1Ref = FSComponent.createRef();
        this.engineDrivenPump1Ref = FSComponent.createRef();
        this.shutoffValve1Ref = FSComponent.createRef();
        this.rsvrPressWarning1Ref = FSComponent.createRef();
        // system 1 lines
        this.system1RightReservoirLine = FSComponent.createRef();
        this.system1DemandLine = FSComponent.createRef();
        this.system1EngineDrivenLine = FSComponent.createRef();
        this.system1AuxLine = FSComponent.createRef();
        this.system1RightToArrowLine = FSComponent.createRef();
        this.system1ArrowLine = FSComponent.createRef();
        // system 2
        this.demandPump2Ref = FSComponent.createRef();
        this.engineDrivenPump2Ref = FSComponent.createRef();
        this.shutoffValve2Ref = FSComponent.createRef();
        this.rsvrPressWarning2Ref = FSComponent.createRef();
        // system 2 lines
        this.system2DemandLine = FSComponent.createRef();
        this.system2EngineDrivenLine = FSComponent.createRef();
        this.system2ArrowLine = FSComponent.createRef();
        // system 3
        this.demandPump3Ref = FSComponent.createRef();
        this.ratRef = FSComponent.createRef();
        this.engineDrivenPump3Ref = FSComponent.createRef();
        this.shutoffValve3Ref = FSComponent.createRef();
        this.rsvrPressWarning3Ref = FSComponent.createRef();
        // system 3 lines
        this.system3ArrowLine = FSComponent.createRef();
        this.system3DemandLine = FSComponent.createRef();
        this.system3EngineDrivenLine = FSComponent.createRef();
        // system 4
        this.demandPump4Ref = FSComponent.createRef();
        this.auxPump4Ref = FSComponent.createRef();
        this.engineDrivenPump4Ref = FSComponent.createRef();
        this.shutoffValve4Ref = FSComponent.createRef();
        this.rsvrPressWarning4Ref = FSComponent.createRef();
        // system 4 lines
        this.system4RightReservoirLine = FSComponent.createRef();
        this.system4DemandLine = FSComponent.createRef();
        this.system4EngineDrivenLine = FSComponent.createRef();
        this.system4AuxLine = FSComponent.createRef();
        this.system4RightToArrowLine = FSComponent.createRef();
        this.system4ArrowLine = FSComponent.createRef();
        // disabled systems displays
        this.disabledSystemsTopLeftRef = FSComponent.createRef();
        this.disabledSystemsTopRightRef = FSComponent.createRef();
        this.disabledSystemsMidCtrRef = FSComponent.createRef();
        this.disabledSystemsMidRightRef = FSComponent.createRef();
        this.disabledSystemsEng1Ref = FSComponent.createRef();
        this.disabledSystemsEng2Ref = FSComponent.createRef();
        this.disabledSystemsEng3Ref = FSComponent.createRef();
        this.disabledSystemsEng4Ref = FSComponent.createRef();
        // disabled system lines
        this.disabledSystemsRightLine = FSComponent.createRef();
        this.disabledSystemsLeftLine = FSComponent.createRef();
        this.disabledSystemsCtrBottomRightLine = FSComponent.createRef();
        this.disabledSystemsCtrMiddleRightLine = FSComponent.createRef();
        this.disabledSystemsCtrBottomLeftLine = FSComponent.createRef();
        this.disabledSystemsCtrTopLeftLine = FSComponent.createRef();
        // this one should be used when system 4 is on, but all the others are off to connect system 3 to the top left
        this.disabledSystemsCtrTopRightLine = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.hydPressure1.pipe(this.pressureDisplay1));
        this.subs.push(this.hydPressure2.pipe(this.pressureDisplay2));
        this.subs.push(this.hydPressure3.pipe(this.pressureDisplay3));
        this.subs.push(this.hydPressure4.pipe(this.pressureDisplay4));
        this.subs.push(this.hydReservoir1.pipe(this.reservoirDisplay1));
        this.subs.push(this.hydReservoir2.pipe(this.reservoirDisplay2));
        this.subs.push(this.hydReservoir3.pipe(this.reservoirDisplay3));
        this.subs.push(this.hydReservoir4.pipe(this.reservoirDisplay4));
        this.subs.push(this.hydTemp1.pipe(this.tempDisplay1));
        this.subs.push(this.hydTemp2.pipe(this.tempDisplay2));
        this.subs.push(this.hydTemp3.pipe(this.tempDisplay3));
        this.subs.push(this.hydTemp4.pipe(this.tempDisplay4));
        this.subs.push();
        const eng1PumpState = this.wireEnginePumpState(1, this.engineDrivenPump1Ref);
        const eng2PumpState = this.wireEnginePumpState(2, this.engineDrivenPump2Ref);
        const eng3PumpState = this.wireEnginePumpState(3, this.engineDrivenPump3Ref);
        const eng4PumpState = this.wireEnginePumpState(4, this.engineDrivenPump4Ref);
        const dem1PumpState = this.wireElectricPumpState(1, this.demandPump1Ref);
        const dem2PumpState = this.wireElectricPumpState(2, this.demandPump2Ref);
        const dem3PumpState = this.wireElectricPumpState(3, this.demandPump3Ref);
        const dem4PumpState = this.wireElectricPumpState(4, this.demandPump4Ref);
        // AUX LINES currently not implemented
        const dem1LineState = this.wirePumpCircuitLineState([this.system1DemandLine], dem1PumpState, this.hydPressure1);
        const eng1LineState = this.wirePumpCircuitLineState([this.system1EngineDrivenLine, this.system1RightReservoirLine, this.system1RightToArrowLine], eng1PumpState, this.hydPressure1);
        this.wireCircuitLineState([this.system1ArrowLine], [eng1LineState, dem1LineState]);
        const dem2LineState = this.wirePumpCircuitLineState([this.system2DemandLine], dem2PumpState, this.hydPressure2);
        const eng2LineState = this.wirePumpCircuitLineState([this.system2EngineDrivenLine], eng2PumpState, this.hydPressure2);
        this.wireCircuitLineState([this.system2ArrowLine], [eng2LineState, dem2LineState]);
        const dem3LineState = this.wirePumpCircuitLineState([this.system3DemandLine], dem3PumpState, this.hydPressure3);
        const eng3LineState = this.wirePumpCircuitLineState([this.system3EngineDrivenLine], eng3PumpState, this.hydPressure3);
        this.wireCircuitLineState([this.system3ArrowLine], [eng3LineState, dem3LineState]);
        const dem4LineState = this.wirePumpCircuitLineState([this.system4DemandLine], dem4PumpState, this.hydPressure4);
        const eng4LineState = this.wirePumpCircuitLineState([this.system4EngineDrivenLine, this.system4RightReservoirLine, this.system4RightToArrowLine], eng4PumpState, this.hydPressure4);
        this.wireCircuitLineState([this.system4ArrowLine], [eng4LineState, dem4LineState]);
        // system availability for disabled systems
        this.subs.push(MappedSubject.create(([s1, s2, s3, s4]) => {
            return [s1 > 2000, s2 > 2000, s3 > 2000, s4 > 2000];
        }, this.hydPressure1, this.hydPressure2, this.hydPressure3, this.hydPressure4)
            .sub(this.updateSystemStatuses.bind(this), true));
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /**
     * Generates a ComputedSubject to format the hydraulic pressure values to the display format
     * @returns A ComputedSubject for the pressure display
     */
    createPressureDisplaySubject() {
        return ComputedSubject.create(0, v => MathUtils.round(v, 10));
    }
    /**
     * Generates a ComputedSubject to format the hydraulic reservoir values to the display format
     * @returns A ComputedSubject for the reservoir display
     */
    createReservoirDisplaySubject() {
        return ComputedSubject.create(0, v => MathUtils.round(v, 0.01));
    }
    /**
     * Generates a ComputedSubject to format the temperature values to the display format
     * @returns A ComputedSubject for the temperature display
     */
    createTempDisplaySubject() {
        return ComputedSubject.create(0, v => MathUtils.round(v, 1));
    }
    /**
     * Wires up the state of a combined hydraulics circuit line.
     * @param refs The reference to the HTML elements.
     * @param lineStates The states of the related hydraulic lines.
     */
    wireCircuitLineState(refs, lineStates) {
        const mapStates = MappedSubject.create((states) => {
            return states.some((p) => p === true);
        }, ...lineStates);
        this.subs.push(mapStates.sub((v) => {
            refs.forEach((r) => r.instance.classList.toggle('active', v));
        }, true));
    }
    /**
     * Wires up the state of a hydraulics circuit line.
     * @param refs The reference to the HTML elements.
     * @param pumpState The state of the pump.
     * @param circuitPressure The pressure of the circuit.
     * @returns A subscribable that will emit the state of the line.
     */
    wirePumpCircuitLineState(refs, pumpState, circuitPressure) {
        const map = MappedSubject.create(([pump, press]) => {
            return pump === (B74_HYDRAULIC_PUMP_MODE.ON || B748EdpStates.ACTIVE) && press > 100;
        }, pumpState, circuitPressure);
        this.subs.push(map.sub((v) => {
            refs.forEach((r) => r.instance.classList.toggle('active', v));
        }, true));
        return map;
    }
    /**
     * Wires up and subscribes to the state of an engine pump.
     * @param hydIndex The index of the hydraulics system.
     * @param pumpRef The reference to the pump display element.
     * @returns A subscribable that contains the EDP state.
     */
    wireEnginePumpState(hydIndex, pumpRef) {
        const mappedState = MappedSubject.create(([s, p]) => {
            return !s ? B748EdpStates.OFF : p > 1500 ? B748EdpStates.ACTIVE : B748EdpStates.ON;
        }, ConsumerSubject.create(this.hydSub.on(`hyd_pump_switch_state_${hydIndex}`).whenChanged(), false), ConsumerSubject.create(this.hydSub.on(`hyd_pressure_${hydIndex}`).whenChangedBy(10), 0));
        this.subs.push(mappedState.sub(v => {
            pumpRef.instance.classList.toggle('edp-active', v === B748EdpStates.ACTIVE);
            pumpRef.instance.classList.toggle('edp-off', v === B748EdpStates.OFF);
        }, true));
        return mappedState;
    }
    /**
     * Wires up and subscribes to the state of an electric pump. AUX is not implemented.
     * @param hydIndex The index of the hydraulics system.
     * @param pumpRef The reference to the pump display element.
     * @returns A subscription.
     */
    wireElectricPumpState(hydIndex, pumpRef) {
        const mappedState = MappedSubject.create(([s, p]) => {
            if (s !== B74_HYDRAULIC_PUMP_MODE.AUTO) {
                return s;
            }
            return p > 1400 ? B74_HYDRAULIC_PUMP_MODE.ON : B74_HYDRAULIC_PUMP_MODE.AUTO;
        }, ConsumerSubject.create(this.cockpitVarSub.on(`b74_hyd_pump_${hydIndex}`).whenChanged(), B74_HYDRAULIC_PUMP_MODE.AUTO), ConsumerSubject.create(this.hydSub.on(`hyd_pressure_${hydIndex + 4}`).whenChangedBy(10), 0));
        this.subs.push(mappedState.sub(v => {
            pumpRef.instance.classList.toggle('pump-off', v === B74_HYDRAULIC_PUMP_MODE.OFF);
            pumpRef.instance.classList.toggle('pump-on', v === B74_HYDRAULIC_PUMP_MODE.ON);
        }, true));
        return mappedState;
    }
    /**
     * Updates the disabled systems displays whenever a system availability changes
     * @param root0 An array containing the system statuses as boolean
     * @param root0."0" System 1 status as a boolean
     * @param root0."1" System 2 status as a boolean
     * @param root0."2" System 3 status as a boolean
     * @param root0."3" System 4 status as a boolean
     */
    updateSystemStatuses([s1, s2, s3, s4]) {
        // systems
        this.disabledSystemsEng1Ref.instance.classList.toggle('hidden', s1);
        this.disabledSystemsEng2Ref.instance.classList.toggle('hidden', s2);
        this.disabledSystemsEng3Ref.instance.classList.toggle('hidden', s3);
        this.disabledSystemsEng4Ref.instance.classList.toggle('hidden', s4);
        this.disabledSystemsMidCtrRef.instance.classList.toggle('hidden', s2 || s3);
        this.disabledSystemsMidRightRef.instance.classList.toggle('hidden', s2 || s3 || s4);
        this.disabledSystemsTopRightRef.instance.classList.toggle('hidden', s2 || s3 || s4);
        this.disabledSystemsTopLeftRef.instance.classList.toggle('hidden', s1 || s2 || s3);
        // lines
        this.disabledSystemsCtrBottomRightLine.instance.classList.toggle('hidden', s2 || s3);
        this.disabledSystemsCtrBottomLeftLine.instance.classList.toggle('hidden', s2 || s3);
        this.disabledSystemsCtrMiddleRightLine.instance.classList.toggle('hidden', s2 || s3 || s4);
        this.disabledSystemsRightLine.instance.classList.toggle('hidden', s2 || s3 || s4);
        this.disabledSystemsCtrTopLeftLine.instance.classList.toggle('hidden', s1 || s2 || s3);
        this.disabledSystemsLeftLine.instance.classList.toggle('hidden', s1 || s2 || s3);
        // this one should be shown when system 4 is on, but all the others are off to connect system 3 to the top left
        this.disabledSystemsCtrTopRightLine.instance.classList.toggle('hidden', !(s4 && !s1 && !s2 && !s3));
    }
    /** @inheritdoc */
    render() {
        // DEMAND PUMPS: default is AUTO. OFF: add 'pump-off' class ON: add 'pump-on' class
        // AUX PUMPS: default is OFF. ON: add 'pump-on' class
        // EDPs: default is ON but no pressure (amber). ACTIVE: add 'edp-active' class. OFF: 'edp-off'
        // Shutoff valves: default is OPEN. CLOSED: add 'sov-closed' class
        // RAT: default is OFF. Deployed: add 'rat-deployed' class
        // DISABLED SYS (and lines between them): hide using 'hidden' class if systems available
        // HYD LINES: use 'active' class to show the green active lines
        // RSVR PRESS: displays when rsvr bleed air (?) pressure is low. Remove 'hidden' class to unhide.
        return (FSComponent.buildComponent("div", { class: "sys-hyd-page-container" },
            FSComponent.buildComponent("div", { class: "disabled-systems-display disabled-sys-mid-top disabled-sys-top-left", ref: this.disabledSystemsTopLeftRef },
                "L OUTBD AIL",
                FSComponent.buildComponent("br", null),
                "UPR RUDER",
                FSComponent.buildComponent("br", null),
                "L INBD AIL",
                FSComponent.buildComponent("br", null),
                "L INBD ELEV"),
            FSComponent.buildComponent("div", { class: "disabled-systems-display disabled-sys-mid-top disabled-sys-top-right", ref: this.disabledSystemsTopRightRef },
                "BRAKES",
                FSComponent.buildComponent("div", null),
                "R INBD AIL",
                FSComponent.buildComponent("div", null),
                "LWR RUDDER"),
            FSComponent.buildComponent("div", { class: "disabled-systems-display disabled-sys-mid-top disabled-sys-mid-ctr", ref: this.disabledSystemsMidCtrRef },
                "ELEV FEEL",
                FSComponent.buildComponent("br", null),
                "STAB TRIM",
                FSComponent.buildComponent("br", null),
                "PITCH AUGMT"),
            FSComponent.buildComponent("div", { class: "disabled-systems-display disabled-sys-mid-top disabled-sys-mid-right", ref: this.disabledSystemsMidRightRef },
                "R OUTBD AIL",
                FSComponent.buildComponent("br", null),
                "R INBD ELEV"),
            FSComponent.buildComponent("div", { class: "disabled-systems-display  disabled-sys-bottom disabled-sys-eng-1", ref: this.disabledSystemsEng1Ref },
                "INBD TE FLAPS",
                FSComponent.buildComponent("br", null),
                "BODY GEAR",
                FSComponent.buildComponent("br", null),
                "AUTOPILOT C",
                FSComponent.buildComponent("br", null),
                "L OUTBD ELEV",
                FSComponent.buildComponent("br", null),
                "NOSE GEAR",
                FSComponent.buildComponent("br", null),
                "STEERING",
                FSComponent.buildComponent("br", null),
                "THRUST REV"),
            FSComponent.buildComponent("div", { class: "disabled-systems-display disabled-sys-bottom disabled-sys-eng-2", ref: this.disabledSystemsEng2Ref },
                "AUTOPILOT R",
                FSComponent.buildComponent("br", null),
                "SPLR 2,3,10,11",
                FSComponent.buildComponent("br", null),
                "YAW DAMPER LWR",
                FSComponent.buildComponent("br", null),
                "THRUST REV"),
            FSComponent.buildComponent("div", { class: "disabled-systems-display disabled-sys-bottom disabled-sys-eng-3", ref: this.disabledSystemsEng3Ref },
                "AUTOPILOT L",
                FSComponent.buildComponent("br", null),
                "SPLR 1,4,9,12",
                FSComponent.buildComponent("br", null),
                "YAW DAMPER UPR",
                FSComponent.buildComponent("br", null),
                "THRUST REV"),
            FSComponent.buildComponent("div", { class: "disabled-systems-display disabled-sys-bottom disabled-sys-eng-4", ref: this.disabledSystemsEng4Ref },
                "OUTBD TE FLAPS",
                FSComponent.buildComponent("br", null),
                "R OUTBD ELEV",
                FSComponent.buildComponent("br", null),
                "SPLR 5,6,7,8",
                FSComponent.buildComponent("br", null),
                "WING GEAR",
                FSComponent.buildComponent("br", null),
                "THRUST REV"),
            FSComponent.buildComponent("div", { class: "right-disabled-lines", ref: this.disabledSystemsRightLine },
                FSComponent.buildComponent("svg", { width: "207px", viewBox: "-1 -1 206 173" },
                    FSComponent.buildComponent("path", { d: "M 2 2 l 200 0 l 0 167 M 202 60 l -20 0", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "left-disabled-lines", ref: this.disabledSystemsLeftLine },
                FSComponent.buildComponent("svg", { width: "37px", viewBox: "-1 -1 36 146" },
                    FSComponent.buildComponent("path", { d: "M 32 2 l -30 0 l 0 115", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "ctr-right-bottom-disabled-lines", ref: this.disabledSystemsCtrBottomRightLine },
                FSComponent.buildComponent("svg", { width: "22px", viewBox: "-1 -1 21 96" },
                    FSComponent.buildComponent("path", { d: "M 2 2 l 15 0 l 0 76", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "ctr-right-middle-disabled-lines", ref: this.disabledSystemsCtrMiddleRightLine },
                FSComponent.buildComponent("svg", { width: "212px", viewBox: "-2.5 -63 212 120" },
                    FSComponent.buildComponent("path", { d: "M 2 2 l 0 52 M 0.5 2 l 206 0 M 171 2 l 0 52 M 2 2 l 0 -60 l 35 0 M 171 2 l 0 -60 l -15 0", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "ctr-left-bottom-disabled-lines", ref: this.disabledSystemsCtrBottomLeftLine },
                FSComponent.buildComponent("svg", { width: "28px", viewBox: "-1 -1 27 96" },
                    FSComponent.buildComponent("path", { d: "M 25 2 l -23 0 l 0 76", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "ctr-left-top-disabled-lines", ref: this.disabledSystemsCtrTopLeftLine },
                FSComponent.buildComponent("svg", { width: "79px", viewBox: "-3 -1 76 177" },
                    FSComponent.buildComponent("path", { d: "M 0 2 l 35 0 l 0 110 M 35 2 l 35 0", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "ctr-right-top-disabled-lines", ref: this.disabledSystemsCtrTopRightLine },
                FSComponent.buildComponent("svg", { width: "212px", viewBox: "-3 -1 209 116" },
                    FSComponent.buildComponent("path", { d: "M 0 2 l 35 0 l 0 110 M 35 2 l 167 0 l 0 110", stroke: "var(--boeing-colors-cyan)", "stroke-width": "3", fill: "none" }))),
            FSComponent.buildComponent("div", { class: "hyd-reservoir-1" },
                FSComponent.buildComponent(HydSystemReservoirDisplay, { reservoirPct: this.reservoirDisplay1 })),
            FSComponent.buildComponent("div", { class: "rsvr-press-1 hidden", ref: this.rsvrPressWarning1Ref },
                "RSVR",
                FSComponent.buildComponent("br", null),
                "PRESS"),
            FSComponent.buildComponent("div", { class: "hyd-reservoir-2" },
                FSComponent.buildComponent(HydSystemReservoirDisplay, { reservoirPct: this.reservoirDisplay2 })),
            FSComponent.buildComponent("div", { class: "rsvr-press-2 hidden", ref: this.rsvrPressWarning2Ref },
                "RSVR",
                FSComponent.buildComponent("br", null),
                "PRESS"),
            FSComponent.buildComponent("div", { class: "hyd-reservoir-3" },
                FSComponent.buildComponent(HydSystemReservoirDisplay, { reservoirPct: this.reservoirDisplay3 })),
            FSComponent.buildComponent("div", { class: "rsvr-press-3 hidden", ref: this.rsvrPressWarning3Ref },
                "RSVR",
                FSComponent.buildComponent("br", null),
                "PRESS"),
            FSComponent.buildComponent("div", { class: "hyd-reservoir-4" },
                FSComponent.buildComponent(HydSystemReservoirDisplay, { reservoirPct: this.reservoirDisplay4 })),
            FSComponent.buildComponent("div", { class: "rsvr-press-4 hidden", ref: this.rsvrPressWarning4Ref },
                "RSVR",
                FSComponent.buildComponent("br", null),
                "PRESS"),
            FSComponent.buildComponent("div", { class: "hyd-system-diagram hyd-system-1" },
                FSComponent.buildComponent("div", { class: "edp-display", ref: this.engineDrivenPump1Ref },
                    FSComponent.buildComponent("div", { class: "edp-inactive-lines" }),
                    FSComponent.buildComponent("div", { class: "edp-inactive-mask" }),
                    FSComponent.buildComponent("div", { class: "edp-off-label" }, "OFF"),
                    FSComponent.buildComponent("div", { class: "hyd-page-label" }, "EDP")),
                FSComponent.buildComponent("div", { class: "pump-display demand-pump", ref: this.demandPump1Ref },
                    FSComponent.buildComponent("div", { class: "pump-status-label" },
                        FSComponent.buildComponent("span", { class: "pump-off-label" }, "OFF"),
                        FSComponent.buildComponent("span", { class: "pump-auto-label" }, "AUTO")),
                    FSComponent.buildComponent("div", { class: "pump-label hyd-page-label" }, "DEM")),
                FSComponent.buildComponent("div", { class: "pump-display aux-pump", ref: this.auxPump1Ref },
                    FSComponent.buildComponent("div", { class: "pump-status-label" },
                        FSComponent.buildComponent("span", { class: "pump-off-label" }, "OFF")),
                    FSComponent.buildComponent("div", { class: "pump-label hyd-page-label" }, "AUX")),
                FSComponent.buildComponent("div", { class: "sov-display", ref: this.shutoffValve1Ref },
                    FSComponent.buildComponent("div", { class: "sov-closed-lines" }),
                    FSComponent.buildComponent("div", { class: "sov-label hyd-page-label" }, "SOV")),
                FSComponent.buildComponent("svg", { height: "325px", viewBox: "4 -13 170 351" },
                    FSComponent.buildComponent("path", { d: "M 35 335 l 0 -95 l -28 0 l 0 -215 l 39 0 l 0 -20 M 43 335 l 0 -103 l -28 0 l 0 -199 l 70 0", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 65 320 l 0 -80 l 28 0 l 78 0 l 0 -215 l -78 0 M 93 232 l 0 -199 l 70 0 l 0 199 l -70 0", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 93 25 l -39 0 l 0 -20 M 57 320 l 0 -88 l 28 0 l 0 -199", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 37 335 l 4 0 l 0 -101 l -28 0 l 0 -203 l 74 0 l 0 203 l -28 0 l 0 86 l 4 0 l 0 -82 l 28 0 l 0 -211 l -39 0 l 0 -22 l -4 0 l 0 22 l -39 0 l 0 211 l 28 0 z", fill: "var(--boeing-colors-black)", stroke: "var(--boeing-colors-black)", "stroke-width": "1" }),
                    FSComponent.buildComponent("path", { d: "M 91 238 l 78 0 l 0 -211 l -78 0 l 0 4 l 74 0 l 0 203 l -74 0 z", fill: "var(--boeing-colors-black)", stroke: "var(--boeing-colors-black)", "stroke-width": "1" }),
                    FSComponent.buildComponent("path", { ref: this.system1DemandLine, class: "hyd-line", d: " M 35 333.5 l 8 0 l 0 -101.5 l -28 0 l 0 -199 l 31 0 l 0 -8 l -39 0 l 0 215 l 28 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system1RightReservoirLine, class: "hyd-line", d: "M 57 318.5 l 8 0 l 0 -78.5 l 28 0 l 0 -8 l -36 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system1AuxLine, class: "hyd-line", d: "M 93 240 l 78 0 l 0 -215 l -78 0 l 0 8 l 70 0 l 0 199 l -70 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system1EngineDrivenLine, class: "hyd-line", d: "M 85 232 l 8 0 l 0 -199 l -8 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system1RightToArrowLine, class: "hyd-line", d: "M 93 33 l -39 0 l 0 -8 l 39 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system1ArrowLine, class: "hyd-line", d: "M 46 33 l 8 0 l 0 -28 l 11 0 l -15 -15 l -15 15 l 11 0 z" }))),
            FSComponent.buildComponent("div", { class: "hyd-system-diagram hyd-system-2" },
                FSComponent.buildComponent("div", { class: "edp-display", ref: this.engineDrivenPump2Ref },
                    FSComponent.buildComponent("div", { class: "edp-inactive-lines" }),
                    FSComponent.buildComponent("div", { class: "edp-inactive-mask" }),
                    FSComponent.buildComponent("div", { class: "edp-off-label" }, "OFF"),
                    FSComponent.buildComponent("div", { class: "hyd-page-label" }, "EDP")),
                FSComponent.buildComponent("div", { class: "pump-display demand-pump", ref: this.demandPump2Ref },
                    FSComponent.buildComponent("div", { class: "pump-status-label" },
                        FSComponent.buildComponent("span", { class: "pump-off-label" }, "OFF"),
                        FSComponent.buildComponent("span", { class: "pump-auto-label" }, "AUTO")),
                    FSComponent.buildComponent("div", { class: "pump-label hyd-page-label" }, "DEM")),
                FSComponent.buildComponent("div", { class: "sov-display", ref: this.shutoffValve2Ref },
                    FSComponent.buildComponent("div", { class: "sov-closed-lines" }),
                    FSComponent.buildComponent("div", { class: "sov-label hyd-page-label" }, "SOV")),
                FSComponent.buildComponent("svg", { height: "325px", viewBox: "4 -13 92 351" },
                    FSComponent.buildComponent("path", { d: "M 35 335 l 0 -95 l -28 0 l 0 -215 l 39 0 l 0 -20 M 43 335 l 0 -103 l -28 0 l 0 -199 l 70 0", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 65 320 l 0 -80 l 28 0 l 0 -215 l -39 0 l 0 -20 M 57 320 l 0 -88 l 28 0 l 0 -199", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 37 335 l 4 0 l 0 -101 l -28 0 l 0 -203 l 74 0 l 0 203 l -28 0 l 0 86 l 4 0 l 0 -82 l 28 0 l 0 -211 l -39 0 l 0 -22 l -4 0 l 0 22 l -39 0 l 0 211 l 28 0 z", fill: "var(--boeing-colors-black)", stroke: "var(--boeing-colors-black)", "stroke-width": "1" }),
                    FSComponent.buildComponent("path", { ref: this.system2EngineDrivenLine, class: "hyd-line", d: "M 57 318.5 l 8 0 l 0 -78.5 l 28 0 l 0 -215 l -39 0 l 0 8 l 31 0 l 0 199 l -28 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system2DemandLine, class: "hyd-line", d: "M 35 333.5 l 8 0 l 0 -101.5 l -28 0 l 0 -199 l 31 0 l 0 -8 l -39 0 l 0 215 l 28 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system2ArrowLine, class: "hyd-line", d: "M 46 33 l 8 0 l 0 -28 l 11 0 l -15 -15 l -15 15 l 11 0 z" }))),
            FSComponent.buildComponent("div", { class: "hyd-system-diagram hyd-system-3" },
                FSComponent.buildComponent("div", { class: "edp-display", ref: this.engineDrivenPump3Ref },
                    FSComponent.buildComponent("div", { class: "edp-inactive-lines" }),
                    FSComponent.buildComponent("div", { class: "edp-inactive-mask" }),
                    FSComponent.buildComponent("div", { class: "edp-off-label" }, "OFF"),
                    FSComponent.buildComponent("div", { class: "hyd-page-label" }, "EDP")),
                FSComponent.buildComponent("div", { class: "pump-display demand-pump", ref: this.demandPump3Ref },
                    FSComponent.buildComponent("div", { class: "pump-status-label" },
                        FSComponent.buildComponent("span", { class: "pump-off-label" }, "OFF"),
                        FSComponent.buildComponent("span", { class: "pump-auto-label" }, "AUTO")),
                    FSComponent.buildComponent("div", { class: "pump-label hyd-page-label" }, "DEM")),
                FSComponent.buildComponent("div", { class: "sov-display", ref: this.shutoffValve3Ref },
                    FSComponent.buildComponent("div", { class: "sov-closed-lines" }),
                    FSComponent.buildComponent("div", { class: "sov-label hyd-page-label" }, "SOV")),
                FSComponent.buildComponent("div", { class: "rat-display", ref: this.ratRef },
                    FSComponent.buildComponent("span", { class: "rat-off-label" }, "OFF"),
                    FSComponent.buildComponent("div", { class: "rat-label hyd-page-label" }, "RAT")),
                FSComponent.buildComponent("svg", { height: "327px", viewBox: "-74 -13 170 346" },
                    FSComponent.buildComponent("path", { d: "M 35 330 l 0 -95 l -28 0 l -78 0 l 0 -210 l 78 0 M 7 227 l 0 -194 l -70 0 l 0 194 l 70 0", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 7 25 l 39 0 l 0 -20 M 43 330 l 0 -103 l -28 0 l 0 -194 l 70 0", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 65 315 l 0 -80 l 28 0 l 0 -210 l -39 0 l 0 -20 M 57 315 l 0 -88 l 28 0 l 0 -194", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 37 330 l 4 0 l 0 -101 l -28 0 l 0 -198 l 74 0 l 0 198 l -28 0 l 0 86 l 4 0 l 0 -82 l 28 0 l 0 -206 l -39 0 l 0 -22 l -4 0 l 0 22 l -39 0 l 0 206 l 28 0 z", fill: "var(--boeing-colors-black)", stroke: "var(--boeing-colors-black)", "stroke-width": "1" }),
                    FSComponent.buildComponent("path", { d: "M 9 233 l -78 0 l 0 -206 l 78 0 l 0 4 l -74 0 l 0 198 l 74 0 z", fill: "var(--boeing-colors-black)", stroke: "var(--boeing-colors-black)", "stroke-width": "1" }),
                    FSComponent.buildComponent("path", { ref: this.system3EngineDrivenLine, class: "hyd-line", d: "M 57 313.5 l 8 0 l 0 -78.5 l 28 0 l 0 -210 l -39 0 l 0 8 l 31 0 l 0 194 l -28 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system3DemandLine, class: "hyd-line", d: "M 35 328.5 l 8 0 l 0 -101.5 l -28 0 l 0 -194 l 31 0 l 0 -8 l -39 0 l 0 210 l 28 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system3ArrowLine, class: "hyd-line", d: "M 54 33 l 0 -28 l 11 0 l -15 -15 l -15 15 l 11 0 l 0 28 z" }))),
            FSComponent.buildComponent("div", { class: "hyd-system-diagram hyd-system-4" },
                FSComponent.buildComponent("div", { class: "edp-display", ref: this.engineDrivenPump4Ref },
                    FSComponent.buildComponent("div", { class: "edp-inactive-lines" }),
                    FSComponent.buildComponent("div", { class: "edp-inactive-mask" }),
                    FSComponent.buildComponent("div", { class: "edp-off-label" }, "OFF"),
                    FSComponent.buildComponent("div", { class: "hyd-page-label" }, "EDP")),
                FSComponent.buildComponent("div", { class: "pump-display demand-pump", ref: this.demandPump4Ref },
                    FSComponent.buildComponent("div", { class: "pump-status-label" },
                        FSComponent.buildComponent("span", { class: "pump-off-label" }, "OFF"),
                        FSComponent.buildComponent("span", { class: "pump-auto-label" }, "AUTO")),
                    FSComponent.buildComponent("div", { class: "pump-label hyd-page-label" }, "DEM")),
                FSComponent.buildComponent("div", { class: "pump-display aux-pump", ref: this.auxPump4Ref },
                    FSComponent.buildComponent("div", { class: "pump-status-label" },
                        FSComponent.buildComponent("span", { class: "pump-off-label" }, "OFF")),
                    FSComponent.buildComponent("div", { class: "pump-label hyd-page-label" }, "AUX")),
                FSComponent.buildComponent("div", { class: "sov-display", ref: this.shutoffValve4Ref },
                    FSComponent.buildComponent("div", { class: "sov-closed-lines" }),
                    FSComponent.buildComponent("div", { class: "sov-label hyd-page-label" }, "SOV")),
                FSComponent.buildComponent("svg", { height: "325px", viewBox: "4 -13 170 351" },
                    FSComponent.buildComponent("path", { d: "M 35 335 l 0 -95 l -28 0 l 0 -215 l 39 0 l 0 -20 M 43 335 l 0 -103 l -28 0 l 0 -199 l 70 0", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 65 320 l 0 -80 l 28 0 l 78 0 l 0 -215 l -78 0 M 93 232 l 0 -199 l 70 0 l 0 199 l -70 0", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 93 25 l -39 0 l 0 -20 M 57 320 l 0 -88 l 28 0 l 0 -199", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                    FSComponent.buildComponent("path", { d: "M 37 335 l 4 0 l 0 -101 l -28 0 l 0 -203 l 74 0 l 0 203 l -28 0 l 0 86 l 4 0 l 0 -82 l 28 0 l 0 -211 l -39 0 l 0 -22 l -4 0 l 0 22 l -39 0 l 0 211 l 28 0 z", fill: "var(--boeing-colors-black)", stroke: "var(--boeing-colors-black)", "stroke-width": "1" }),
                    FSComponent.buildComponent("path", { d: "M 91 238 l 78 0 l 0 -211 l -78 0 l 0 4 l 74 0 l 0 203 l -74 0 z", fill: "var(--boeing-colors-black)", stroke: "var(--boeing-colors-black)", "stroke-width": "1" }),
                    FSComponent.buildComponent("path", { ref: this.system4DemandLine, class: "hyd-line", d: " M 35 333.5 l 8 0 l 0 -101.5 l -28 0 l 0 -199 l 31 0 l 0 -8 l -39 0 l 0 215 l 28 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system4RightReservoirLine, class: "hyd-line", d: "M 57 318.5 l 8 0 l 0 -78.5 l 28 0 l 0 -8 l -36 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system4AuxLine, class: "hyd-line", d: "M 93 240 l 78 0 l 0 -215 l -78 0 l 0 8 l 70 0 l 0 199 l -70 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system4EngineDrivenLine, class: "hyd-line", d: "M 85 232 l 8 0 l 0 -199 l -8 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system4RightToArrowLine, class: "hyd-line", d: "M 93 33 l -39 0 l 0 -8 l 39 0 z" }),
                    FSComponent.buildComponent("path", { ref: this.system4ArrowLine, class: "hyd-line", d: "M 46 33 l 8 0 l 0 -28 l 11 0 l -15 -15 l -15 15 l 11 0 z" }))),
            FSComponent.buildComponent("div", { class: "hyd-system-data-1" },
                FSComponent.buildComponent(HydSystemDataDisplay, { index: 1, reservoirPct: this.reservoirDisplay1, pressure: this.pressureDisplay1, temp: this.tempDisplay1, onGround: this.onGround })),
            FSComponent.buildComponent("div", { class: "hyd-system-data-2" },
                FSComponent.buildComponent(HydSystemDataDisplay, { index: 2, reservoirPct: this.reservoirDisplay2, pressure: this.pressureDisplay2, temp: this.tempDisplay2, onGround: this.onGround })),
            FSComponent.buildComponent("div", { class: "hyd-system-data-labels" },
                FSComponent.buildComponent("div", { class: "hyd-page-label" }, "QTY"),
                FSComponent.buildComponent("div", { class: "hyd-page-label" }, "PRESS"),
                FSComponent.buildComponent("div", { class: "hyd-page-label" }, "TEMP")),
            FSComponent.buildComponent("div", { class: "hyd-system-data-3" },
                FSComponent.buildComponent(HydSystemDataDisplay, { index: 3, reservoirPct: this.reservoirDisplay3, pressure: this.pressureDisplay3, temp: this.tempDisplay3, onGround: this.onGround })),
            FSComponent.buildComponent("div", { class: "hyd-system-data-4" },
                FSComponent.buildComponent(HydSystemDataDisplay, { index: 4, reservoirPct: this.reservoirDisplay4, pressure: this.pressureDisplay4, temp: this.tempDisplay4, onGround: this.onGround }))));
    }
}
/** Component to display hydraulic system data on hydraulic synoptics */
class HydSystemDataDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.reservoirValueDisplay = ComputedSubject.create(0, v => v.toFixed(2).replace('.', '·'));
        this.pressureValueDisplay = ComputedSubject.create(0, v => MathUtils.round(v, 10));
        this.tempValueDisplay = ComputedSubject.create(0, v => MathUtils.round(v, 1));
        this.pressureValueRef = FSComponent.createRef();
        this.tempValueRef = FSComponent.createRef();
        this.rsvrWarningRef = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.props.reservoirPct.sub(v => {
            this.reservoirValueDisplay.set(v);
            this.rsvrWarningRef.instance.classList.toggle('rsvr-low', v <= 0.5);
            this.rsvrWarningRef.instance.classList.toggle('rsvr-refill', v > 0.5 && v <= 0.75 && this.props.onGround.get());
        }, true));
        this.subs.push(this.props.pressure.sub(v => {
            this.pressureValueDisplay.set(v);
            this.pressureValueRef.instance.classList.toggle('system-data-warning', v < 2000);
        }, true));
        this.subs.push(this.props.temp.sub(v => {
            this.tempValueDisplay.set(v);
            this.tempValueRef.instance.classList.toggle('system-data-warning', v > 107);
        }, true));
        this.subs.push(this.props.onGround.sub(onGround => {
            const pct = this.props.reservoirPct.get();
            this.rsvrWarningRef.instance.classList.toggle('rsvr-refill', pct > 0.5 && pct <= 0.75 && onGround);
        }, false)); // the reservoir level sub will take care of initial value
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "hyd-system-data-display-container" },
            FSComponent.buildComponent("div", { class: "hyd-system-data-value qty-value" }, this.reservoirValueDisplay),
            FSComponent.buildComponent("div", { class: "hyd-system-data-value press-value", ref: this.pressureValueRef }, this.pressureValueDisplay),
            FSComponent.buildComponent("div", { class: "hyd-system-data-value temp-value", ref: this.tempValueRef }, this.tempValueDisplay),
            FSComponent.buildComponent("div", { class: "hyd-page-label" }, this.props.index.toString()),
            FSComponent.buildComponent("div", { class: "reservoir-warning", ref: this.rsvrWarningRef },
                FSComponent.buildComponent("span", { class: "rsvr-low-label" }, "LO"),
                FSComponent.buildComponent("span", { class: "rsvr-refill-label" }, "RF"))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}
/** Component to display reservoir fill status on hydraulic synoptics */
class HydSystemReservoirDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.reservoirLevelRef = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.props.reservoirPct.sub(pct => {
            // 1.00 doesn't go all the way to the top - that would be 69px
            this.reservoirLevelRef.instance.style.transform = `translateY(${MathUtils.clamp(-pct * 60, -69, 0)}px)`;
        }, true));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "hyd-system-reservoir-display-container" },
            FSComponent.buildComponent("svg", { width: "55px", viewBox: "1 1 63 83" },
                FSComponent.buildComponent("path", { d: "M 5 5 l 55 0 l 0 75 l -55 0 z", fill: "none", stroke: "var(--boeing-colors-white)", "stroke-width": "3" }),
                FSComponent.buildComponent("path", { ref: this.reservoirLevelRef, class: "reservoir-level", d: "M 5 77 l 55 0", stroke: "var(--boeing-colors-green)", "stroke-width": "6" }))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}

/** The B78xNavigationMap component. */
class B748Info extends DisplayPaneView {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "display-pane-info" }, "INFO FUNCTION NOT AVAILABLE"));
    }
}

/** The GearBogieInfoDisplay component. */
class B748GearBogieInfo extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.brakeTempTexts = Array.from({ length: 4 }, () => ComputedSubject.create(0, v => v.toFixed(1)));
        this.brakeTempRef = Array.from({ length: 4 }, () => FSComponent.createRef());
        this.tirePressRef = Array.from({ length: 4 }, () => FSComponent.createRef());
        this.gearDoorRef = FSComponent.createRef();
        this.gearDoorStatusText = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritDoc */
    onAfterRender() {
        this.props.brakeTemps.forEach((tempSub, i) => {
            this.subs.push(tempSub.sub(t => {
                this.brakeTempTexts[i].set(t);
                this.brakeTempRef[i].instance.classList.toggle('temp-warning', t >= 5);
            }, true));
        });
        this.props.tirePressures.forEach((pressSub, i) => {
            this.subs.push(pressSub.sub(p => {
                const maxPressure = OPTIMAL_MAIN_GEAR_PRESSURE * 1.2;
                const minPressure = OPTIMAL_MAIN_GEAR_PRESSURE * 0.6;
                this.tirePressRef[i].instance.classList.toggle('pressure-warning', p > maxPressure || p < minPressure);
            }, true));
        });
        this.subs.push(this.props.gearDoorClosed.sub(closed => {
            // add random delay to closing doors (max 1 second)
            setTimeout(() => {
                this.gearDoorStatusText.instance.classList.toggle('hidden', !closed);
                this.gearDoorRef.instance.classList.toggle('gear-door-transit', !closed);
            }, closed ? Math.random() * 1000 : 0);
        }, true));
    }
    /** @inheritDoc */
    onSuspend() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritDoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "gear-bogie-info-display" },
            FSComponent.buildComponent("svg", { xmlns: "http://www.w3.org/2000/svg", class: "gear-bogie-diagram", viewBox: "-94 -140.25 188 280.5" },
                FSComponent.buildComponent("path", { d: "M -10 0 A 1 1 0 0 0 10 0 A 1 1 0 0 0 -10 0 M 0 -10 L 0 -70", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" }),
                FSComponent.buildComponent("path", { d: "M -15 -70 L 15 -70 l 0 40 a 1 0.7 0 0 0 75 0 l 0 -80 a 1 0.7 0 0 0 -75 0 l 0 40", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" }),
                FSComponent.buildComponent("path", { d: "M -90 -70 l 0 40 a 1 0.7 0 0 0 75 0 l 0 -80 a 1 0.7 0 0 0 -75 0 l 0 40 M 0 10 L 0 70", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" }),
                FSComponent.buildComponent("path", { d: "M -15 70 L 15 70 l 0 40 a 1 0.7 0 0 0 75 0 l 0 -80 a 1 0.7 0 0 0 -75 0 l 0 40", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" }),
                FSComponent.buildComponent("path", { d: "M -90 70 l 0 40 a 1 0.7 0 0 0 75 0 l 0 -80 a 1 0.7 0 0 0 -75 0 l 0 40", stroke: "var(--boeing-colors-white)", "stroke-width": "6", fill: "none" })),
            FSComponent.buildComponent("div", { class: "front-left-tire-pressure pressure-display-text", ref: this.tirePressRef[0] }, this.props.tirePressures[0]),
            FSComponent.buildComponent("div", { class: "front-right-tire-pressure pressure-display-text", ref: this.tirePressRef[1] }, this.props.tirePressures[1]),
            FSComponent.buildComponent("div", { class: "rear-left-tire-pressure pressure-display-text", ref: this.tirePressRef[2] }, this.props.tirePressures[2]),
            FSComponent.buildComponent("div", { class: "rear-right-tire-pressure pressure-display-text", ref: this.tirePressRef[3] }, this.props.tirePressures[3]),
            FSComponent.buildComponent("div", { class: "front-left-brake-temp temp-display-text", ref: this.brakeTempRef[0] }, this.brakeTempTexts[0]),
            FSComponent.buildComponent("div", { class: "front-right-brake-temp temp-display-text", ref: this.brakeTempRef[1] }, this.brakeTempTexts[1]),
            FSComponent.buildComponent("div", { class: "rear-left-brake-temp temp-display-text", ref: this.brakeTempRef[2] }, this.brakeTempTexts[2]),
            FSComponent.buildComponent("div", { class: "rear-right-brake-temp temp-display-text", ref: this.brakeTempRef[3] }, this.brakeTempTexts[3]),
            FSComponent.buildComponent("div", { class: "gear-door-display", ref: this.gearDoorRef },
                FSComponent.buildComponent("span", { class: "gear-door-closed", ref: this.gearDoorStatusText }, "CLOSED"))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
/** The B78xNavigationMap component. */
class B748LandingGear extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.gear = this.props.bus.getSubscriber();
        this.noseGearTirePressures = Array.from({ length: 2 }, () => Subject.create(OPTIMAL_NOSE_GEAR_PRESSURE));
        this.leftOutboardTirePressures = Array.from({ length: 4 }, () => Subject.create(OPTIMAL_MAIN_GEAR_PRESSURE));
        this.leftInboardTirePressures = Array.from({ length: 4 }, () => Subject.create(OPTIMAL_MAIN_GEAR_PRESSURE));
        this.rightOutboardTirePressures = Array.from({ length: 4 }, () => Subject.create(OPTIMAL_MAIN_GEAR_PRESSURE));
        this.rightInboardTirePressures = Array.from({ length: 4 }, () => Subject.create(OPTIMAL_MAIN_GEAR_PRESSURE));
        this.leftInboardBrakeTempTexts = Array.from({ length: 4 }, () => Subject.create(0));
        this.leftOutboardBrakeTempTexts = Array.from({ length: 4 }, () => Subject.create(0));
        this.rightInboardBrakeTempTexts = Array.from({ length: 4 }, () => Subject.create(0));
        this.rightOutboardBrakeTempTexts = Array.from({ length: 4 }, () => Subject.create(0));
        this.leftGearDoorClosed = ConsumerSubject.create(this.gear.on('left_main_gear_door_closed').whenChanged(), true);
        this.rightGearDoorClosed = ConsumerSubject.create(this.gear.on('right_main_gear_door_closed').whenChanged(), true);
        this.noseGearPressRef = Array.from({ length: 2 }, () => FSComponent.createRef());
        this.noseGearDoorRef = FSComponent.createRef();
        this.noseGearDoorStatusText = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate(time) {
        // noop
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.gear.on('nose_tire_pressures').whenChanged().handle(this.updateNoseTirePressures.bind(this)));
        this.subs.push(this.gear.on('main_tire_pressures').whenChanged().handle(this.updateMainTirePressures.bind(this)));
        this.subs.push(this.gear.on('nose_gear_door_closed').whenChanged().handle(this.updateNoseGearDoorDisplay.bind(this)));
        this.subs.push(this.gear.on('left_main_gear_brake_temps').whenChanged().handle(this.updateLeftMainBrakeTemps.bind(this)));
        this.subs.push(this.gear.on('right_main_gear_brake_temps').whenChanged().handle(this.updateRightMainBrakeTemps.bind(this)));
    }
    /**
     * Updates nose gear tire pressure values
     * @param pressures Nose gear tire pressure array
     * @private
     */
    updateNoseTirePressures(pressures) {
        pressures.forEach((p, i) => {
            this.noseGearTirePressures[i].set(p);
            const maxPressure = OPTIMAL_NOSE_GEAR_PRESSURE * 1.2;
            const minPressure = OPTIMAL_NOSE_GEAR_PRESSURE * 0.6;
            this.noseGearPressRef[i].instance.classList.toggle('pressure-warning', p > maxPressure || p < minPressure);
        });
    }
    /**
     * Updates main gear tire pressure values
     * @param pressures Main gear tire pressure array
     * @private
     */
    updateMainTirePressures(pressures) {
        pressures.forEach((p, i) => {
            if (i < 4) {
                this.leftOutboardTirePressures[i].set(p);
            }
            else if (i < 8) {
                this.leftInboardTirePressures[i % 4].set(p);
            }
            else if (i < 12) {
                this.rightInboardTirePressures[i % 4].set(p);
            }
            else {
                this.rightOutboardTirePressures[i % 4].set(p);
            }
        });
    }
    /**
     * Updates nose gear door display
     * @param closed whether the door is closed
     * @private
     */
    updateNoseGearDoorDisplay(closed) {
        this.noseGearDoorRef.instance.classList.toggle('gear-door-transit', !closed);
        this.noseGearDoorStatusText.instance.classList.toggle('hidden', !closed);
    }
    /**
     * Updates left main gear brake temperature values
     * @param temps Left main gear brake temperatures array
     * @private
     */
    updateLeftMainBrakeTemps(temps) {
        temps.forEach((temp, i) => {
            if (i < 4) {
                this.leftOutboardBrakeTempTexts[i].set(temp);
            }
            else {
                this.leftInboardBrakeTempTexts[i % 4].set(temp);
            }
        });
    }
    /**
     * Updates right main gear brake temperature values
     * @param temps Right main gear brake temperatures array
     * @private
     */
    updateRightMainBrakeTemps(temps) {
        temps.forEach((temp, i) => {
            if (i < 4) {
                this.rightInboardBrakeTempTexts[i].set(temp);
            }
            else {
                this.rightOutboardBrakeTempTexts[i % 4].set(temp);
            }
        });
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "sys-gear-container" },
            FSComponent.buildComponent("div", { class: "nose-gear-container" },
                FSComponent.buildComponent("div", { class: "nose-gear-press", ref: this.noseGearPressRef[0] }, this.noseGearTirePressures[0]),
                FSComponent.buildComponent("svg", { xmlns: "http://www.w3.org/2000/svg", class: "gear-bogie-diagram", viewBox: "-101 -72.25 202 144.5" },
                    FSComponent.buildComponent("path", { d: "M -10 0 A 1 1 0 0 0 10 0 A 1 1 0 0 0 -10 0 M 10 0 L 20 0 l 0 40 a 1 0.7 0 0 0 75 0 l 0 -80 a 1 0.7 0 0 0 -75 0 l 0 40 M -95 0 l 0 40 a 1 0.7 0 0 0 75 0 l 0 -80 a 1 0.7 0 0 0 -75 0 l 0 40 M -10 0 L -20 0", stroke: "#FFFFFF", "stroke-width": "6", fill: "none" })),
                FSComponent.buildComponent("div", { class: "nose-gear-press", ref: this.noseGearPressRef[1] }, this.noseGearTirePressures[1]),
                FSComponent.buildComponent("div", { class: "gear-door-display", ref: this.noseGearDoorRef },
                    FSComponent.buildComponent("span", { class: "gear-door-closed", ref: this.noseGearDoorStatusText }, "CLOSED"))),
            FSComponent.buildComponent("div", { class: "gear-page-info-border brake-temp-text-border" },
                FSComponent.buildComponent("div", { class: "brake-temp-text-container" },
                    FSComponent.buildComponent("div", { class: "gear-page-info-text" }, "BRAKE TEMP"))),
            FSComponent.buildComponent("div", { class: "gear-page-info-border tire-press-text-border" },
                FSComponent.buildComponent("div", { class: "tire-press-text-container" },
                    FSComponent.buildComponent("div", { class: "gear-page-info-text" }, "TIRE PRESS"))),
            FSComponent.buildComponent("div", { class: "gear-page-info-border gear-doors-text-border" },
                FSComponent.buildComponent("div", { class: "gear-doors-text-container" },
                    FSComponent.buildComponent("div", { class: "gear-doors-info-text" }, "GEAR DOORS"))),
            FSComponent.buildComponent("div", { class: "gear-info-container left-outboard-gear-info-container" },
                FSComponent.buildComponent(B748GearBogieInfo, { gearDoorClosed: this.leftGearDoorClosed, tirePressures: this.leftOutboardTirePressures, brakeTemps: this.leftOutboardBrakeTempTexts })),
            FSComponent.buildComponent("div", { class: "gear-info-container left-inboard-gear-info-container" },
                FSComponent.buildComponent(B748GearBogieInfo, { gearDoorClosed: this.leftGearDoorClosed, tirePressures: this.leftInboardTirePressures, brakeTemps: this.leftInboardBrakeTempTexts })),
            FSComponent.buildComponent("div", { class: "gear-info-container right-outboard-gear-info-container" },
                FSComponent.buildComponent(B748GearBogieInfo, { gearDoorClosed: this.rightGearDoorClosed, tirePressures: this.rightOutboardTirePressures, brakeTemps: this.rightOutboardBrakeTempTexts })),
            FSComponent.buildComponent("div", { class: "gear-info-container right-inboard-gear-info-container" },
                FSComponent.buildComponent(B748GearBogieInfo, { gearDoorClosed: this.rightGearDoorClosed, tirePressures: this.rightInboardTirePressures, brakeTemps: this.rightInboardBrakeTempTexts }))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}

/**
 * Keep this in sync with WTB748_Common.css
 * The sizes of the display panes in the 787.
 */
class B748PaneSizes {
}
B748PaneSizes.sizePx = 784;

// TODO Make sure tht this is correct for the 748, it was copied from the 787
/**
 * TCAS operating mode setting values.
 */
var TcasOperatingModeSetting;
(function (TcasOperatingModeSetting) {
    TcasOperatingModeSetting["TA_RA"] = "TA_RA";
    TcasOperatingModeSetting["TAOnly"] = "TAOnly";
    TcasOperatingModeSetting["Standby"] = "Standby";
})(TcasOperatingModeSetting || (TcasOperatingModeSetting = {}));
const trafficSettings = [
    {
        name: 'trafficOperatingMode',
        defaultValue: TcasOperatingModeSetting.TAOnly
    },
    {
        name: 'trafficShowOther',
        defaultValue: true
    },
    {
        name: 'trafficAltitudeRelative',
        defaultValue: true
    },
    {
        name: 'trafficShowAbove',
        defaultValue: false
    },
    {
        name: 'trafficShowBelow',
        defaultValue: false
    }
];
/**
 * Utility class for retrieving the traffic user setting manager.
 */
class TrafficUserSettings {
    /**
     * Retrieves a setting manager with traffic user settings.
     * @param bus The event bus.
     * @returns A setting manager with traffic user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, trafficSettings));
    }
}

/** A controller which handles map traffic settings. */
class B748MapTrafficController extends BoeingMapTrafficController {
    constructor() {
        super(...arguments);
        this.trafficSettings = TrafficUserSettings.getManager(this.context.bus);
    }
    /** @inheritdoc */
    wireSettings() {
        super.wireSettings();
        this.subs.push(this.trafficSettings.getSetting('trafficShowOther').sub(show => {
            this.trafficModule.alertLevelVisibility.set(BitFlags.not(MapTrafficAlertLevelVisibility.All, show ? 0 : MapTrafficAlertLevelVisibility.Other));
        }, true), this.trafficSettings.getSetting('trafficAltitudeRelative').sub(isRelative => {
            this.trafficModule.isAltitudeRelative.set(isRelative);
        }, true), this.trafficSettings.getSetting('trafficShowAbove').sub(show => {
            this.trafficModule.altitudeRestrictionAbove.set(show
                ? BoeingMapTrafficController.ALTITUDE_RESTRICTION_FULL
                : BoeingMapTrafficController.ALTITUDE_RESTRICTION_NORMAL);
        }, true), this.trafficSettings.getSetting('trafficShowBelow').sub(show => {
            this.trafficModule.altitudeRestrictionBelow.set(show
                ? BoeingMapTrafficController.ALTITUDE_RESTRICTION_FULL
                : BoeingMapTrafficController.ALTITUDE_RESTRICTION_NORMAL);
        }, true));
    }
}

var _a;
/** Collection of common data used by the map system. */
class MapSystemCommon {
}
_a = MapSystemCommon;
// Should really only be 1 or 0.5
MapSystemCommon.canvasScale = 1;
/** The number to scale elements designed for MAX displays by so it will be the correct size for the older square Boeing displays. */
MapSystemCommon.maxToOldBoeingScale = 0.765;
MapSystemCommon.labelFontSize = 22 * _a.canvasScale;
MapSystemCommon.fontOutlineWidth = 1 * _a.canvasScale;
MapSystemCommon.labelLineHeight = 20 * _a.canvasScale;
MapSystemCommon.strokeWidth = 3 * _a.canvasScale;
MapSystemCommon.arrowStrokeWidth = 2 * _a.canvasScale;
MapSystemCommon.outlineWidth = 1 * _a.canvasScale;
MapSystemCommon.smallLabelOffsetPx = 9 * _a.canvasScale;
MapSystemCommon.smallLabelOffset = new Float64Array([_a.smallLabelOffsetPx, _a.smallLabelOffsetPx]);
MapSystemCommon.bigLabelOffsetPx = 14 * _a.canvasScale;
MapSystemCommon.bigLabelOffset = new Float64Array([_a.bigLabelOffsetPx, _a.bigLabelOffsetPx]);
MapSystemCommon.mapIconSize = 38 * _a.canvasScale;
MapSystemCommon.mapStyles = {
    canvasScale: MapSystemCommon.canvasScale,
    labelFontSize: MapSystemCommon.labelFontSize,
    fontOutlineWidth: MapSystemCommon.fontOutlineWidth,
    labelLineHeight: MapSystemCommon.labelLineHeight,
    strokeWidth: MapSystemCommon.strokeWidth,
    arrowStrokeWidth: MapSystemCommon.arrowStrokeWidth,
    outlineWidth: MapSystemCommon.outlineWidth,
    smallLabelOffsetPx: MapSystemCommon.smallLabelOffsetPx,
    smallLabelOffset: MapSystemCommon.smallLabelOffset,
    bigLabelOffsetPx: MapSystemCommon.bigLabelOffsetPx,
    bigLabelOffset: MapSystemCommon.bigLabelOffset,
    mapIconSize: MapSystemCommon.mapIconSize,
    maxToOldBoeingScale: MapSystemCommon.maxToOldBoeingScale,
};
MapSystemCommon.mapCompassMaskHeight = 660 * _a.canvasScale;
MapSystemCommon.rangeTickWidth = 13 * _a.canvasScale;
MapSystemCommon.mapCompassRadiusUnscaled = 536;
MapSystemCommon.mapCtrCompassRadiusUnscaled = 260;
MapSystemCommon.planCompassRadiusUnscaled = 330;
MapSystemCommon.mapCompassRadius = _a.mapCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.mapCtrCompassRadius = _a.mapCtrCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.planCompassRadius = _a.planCompassRadiusUnscaled * _a.canvasScale;

// TODO Move to Boeing SDK
ImageCache.addToCache('AIRPORT', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/airport_c.png');
ImageCache.addToCache('INTERSECTION', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/intersection.png');
ImageCache.addToCache('NDB', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/ndb.png');
ImageCache.addToCache('VOR', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/vor.png');
ImageCache.addToCache('DME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/dme.png');
ImageCache.addToCache('VORDME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/vordme.png');
ImageCache.addToCache('VORTAC', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/vortac.png');
ImageCache.addToCache('TACAN', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/tacan.png');
ImageCache.addToCache('STA_VOR', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/sta_vor.png');
ImageCache.addToCache('STA_DME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/sta_dme.png');
ImageCache.addToCache('STA_NDB', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/sta_ndb.png');
ImageCache.addToCache('STA_VORDME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/sta_vordme.png');
ImageCache.addToCache('STA_VORTAC', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/sta_vortac.png');
ImageCache.addToCache('STA_TACAN', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/sta_tacan.png');
ImageCache.addToCache('FLIGHTPLAN', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/flightplan.png');
ImageCache.addToCache('FLIGHTPLAN_M', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/flightplan_m.png');
ImageCache.addToCache('FLIGHTPLAN_C', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/flightplan_c.png');
ImageCache.addToCache('FLIGHTPLAN_CIRCLE_WHITE', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/flightplan_circle_white.png');
ImageCache.addToCache('FLIGHTPLAN_CIRCLE_MAGENTA', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/flightplan_circle_magenta.png');
ImageCache.addToCache('TOD', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/tod.png');
/** The map builder for the B748. */
class B748MapBuilder {
    /**
     * Creates a new B748MapBuilder.
     * @param boeingMapBuilder Boeing map builder instance.
     * @param bus The event bus.
     * @param ndDataProvider The nd data provider.
     * @param flightPlanner The flight planner.
     */
    constructor(boeingMapBuilder, bus, ndDataProvider, flightPlanner) {
        this.boeingMapBuilder = boeingMapBuilder;
        this.bus = bus;
        this.ndDataProvider = ndDataProvider;
        this.flightPlanner = flightPlanner;
        this.mapSystemConfig = new MapSystemConfig(MapSystemCommon.mapStyles);
        /**
         * Add the flight plans.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withFlightPlans = (builder) => {
            return builder
                .with(this.boeingMapBuilder.withFlightPlans, this.mapSystemConfig);
        };
        /**
         * Add the map select waypoint layer.
         * @param builder The map system builder.
         * @param offScaleTcasAlertLevel The offScaleTcasAlertLevel subject.
         * @returns The map system builder, after it has been configured.
         */
        this.withTraffic = (builder, offScaleTcasAlertLevel) => {
            return builder
                .with(this.boeingMapBuilder.withTraffic, this.mapSystemConfig, false, (context) => new B748MapTrafficController(context, this.ndDataProvider), offScaleTcasAlertLevel);
        };
        /**
         * Add the altitude arc.
         * @param builder The map system builder.
         * @param arcRadius The radius of the arc, in pixels.
         * @param arcAngularWidth The angular width of the arc, in degrees.
         * @returns The map system builder, after it has been configured.
         */
        this.withAltitudeArc = (builder, arcRadius, arcAngularWidth) => {
            return this.boeingMapBuilder.withAltitudeArc(builder, {
                arcRadius: arcRadius,
                arcAngularWidth: arcAngularWidth,
                strokeStyle: BoeingColors.green,
                strokeWidth: MapSystemCommon.strokeWidth,
                outlineWidth: MapSystemCommon.outlineWidth,
            });
        };
        /**
         * Add the altitude arc.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withBoeingMapStyles = (builder) => {
            return builder
                .withModule(BoeingMapKeys.MapStyles, () => new BoeingMapStylesModule(MapSystemCommon.mapStyles));
        };
        /**
         * Add the nearest waypoints layer.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withNearestWaypoints = (builder) => {
            return builder
                .with(this.boeingMapBuilder.withNearestWaypoints, this.mapSystemConfig);
        };
        /**
         * The map builder for the airplane icon.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withAirplaneIcon = (builder) => {
            return this.boeingMapBuilder.withAirplaneIcon(builder, {
                fontSize: 22,
                height: 22,
                padding: 2,
                top: 30,
            }, 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/ownship_tri.svg', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/icons/ownship_outline.svg', MapSystemCommon.maxToOldBoeingScale);
        };
    }
}

/** Provides data for ND. */
class B748NdInfoDataProvider extends BoeingNdDataProvider {
    /**
     * @inheritdoc
     * @param bus The event bus.
     * @param navIndicators The nav indicators.
     * @param settings The map settings.
     */
    constructor(bus, navIndicators, settings) {
        super(bus, navIndicators, settings);
        this.boeingType = '748';
        this.canvasScale = MapSystemCommon.canvasScale;
        settings.getSetting('navAidLeftState').pipe(this._navAidLeftState);
        settings.getSetting('navAidRightState').pipe(this._navAidRightState);
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
const COMPASS_ARC_LAYER_KEYS = [
    BoeingMapKeys.CompassArcLowerLayer,
    BoeingMapKeys.CompassArcUpperLayer,
    ...BoeingMapCommon.COMPASS_FORMAT_COMMON_LAYER_KEYS,
];
const COMPASS_CTR_LAYER_KEYS = [
    BoeingMapKeys.CompassCenterLowerLayer,
    BoeingMapKeys.CompassCenterUpperLayer,
    ...BoeingMapCommon.COMPASS_FORMAT_COMMON_LAYER_KEYS,
];
const PLAN_LAYER_KEYS = [
    BoeingMapKeys.PlanLowerLayer,
    BoeingMapKeys.PlanUpperLayer,
    ...BoeingMapCommon.PLAN_FORMAT_COMMON_LAYER_KEYS,
];
const ND_FORMAT_CONFIGS = {
    'MAP': Object.assign({ compassType: 'arc', targetProjectedOffsetUnscaledY: 230, compassRadiusUnscaled: MapSystemCommon.mapCompassRadiusUnscaled, mapHeightUnscaled: B748PaneSizes.sizePx, layerKeys: COMPASS_ARC_LAYER_KEYS }, BoeingMapCommon.COMPASS_DEFAULT_CONFIG),
    'MAPCTR': Object.assign({ compassType: 'center', targetProjectedOffsetUnscaledY: 25, compassRadiusUnscaled: MapSystemCommon.mapCtrCompassRadiusUnscaled, mapHeightUnscaled: B748PaneSizes.sizePx, layerKeys: COMPASS_CTR_LAYER_KEYS }, BoeingMapCommon.COMPASS_DEFAULT_CONFIG),
    'PLAN': Object.assign({ compassType: 'center', 
        // TODO Adjust
        targetProjectedOffsetUnscaledY: 15, compassRadiusUnscaled: MapSystemCommon.planCompassRadiusUnscaled, mapHeightUnscaled: B748PaneSizes.sizePx, layerKeys: PLAN_LAYER_KEYS }, BoeingMapCommon.PLAN_DEFAULT_CONFIG),
};
/**
 * A map system controller that controls the display settings of the various format
 * and terrain/wxr combinations.
 */
class B748NdFormatController extends BoeingMapFormatController {
    /**
     * Creates an instance of the MapFormatController.
     * @param context The map system context to use with this controller.
     * @param mfdIndex The index of the mfd this map is on.
     */
    constructor(context, mfdIndex) {
        const mfdSettings = MapUserSettings.getAliasedManager(context.bus, 'MFD', mfdIndex);
        const currentMapFormatConfig = MappedSubject.create(([mapFormat]) => {
            var _a;
            // TODO This is temp hack until we implement the other formats like APP and VOR
            return (_a = ND_FORMAT_CONFIGS[mapFormat]) !== null && _a !== void 0 ? _a : ND_FORMAT_CONFIGS['MAP'];
        }, mfdSettings.getSetting('mapFormat'));
        super(context, MapSystemCommon.canvasScale, currentMapFormatConfig, mfdSettings.getSetting('terrWxState'));
        // Start with all map format layers hidden.
        this.hideAllMapFormatLayers();
    }
    /** Hide all layers associated with map formats. */
    hideAllMapFormatLayers() {
        const allLayerKeys = new Set();
        for (const [_, formatConfig] of Object.entries(ND_FORMAT_CONFIGS)) {
            formatConfig.layerKeys.forEach(x => allLayerKeys.add(x));
        }
        for (const layerKey of allLayerKeys) {
            this.context.getLayer(layerKey).setVisible(false);
        }
    }
}

/* eslint-disable max-len */
/** Map compass overlay components which go below the flight plan rotue lines. */
class MapCompassLowerLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.ndMapTrackRotatingSvgRef = FSComponent.createRef();
        this.isArc = this.props.type === 'arc';
        this.compassSvgSize = this.props.compassSvgSize;
        this.compassRadius = this.props.compassRadius;
        this.classList = SetSubject.create([
            `map-${this.props.type}`,
            `map-${this.props.type}-lower`,
            'map-compass-overlay',
        ]);
    }
    /** @inheritdoc */
    onAfterRender() {
        if (this.ndMapTrackRotatingSvgRef.getOrDefault()) {
            this.props.ndDataProvider.compassTrackRotationAnimated.sub(rot => {
                this.ndMapTrackRotatingSvgRef.instance.style.transform = `rotate3d(0, 0, 1, ${rot * -1}deg)`;
            });
        }
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.classList.toggle('hidden', !isVisible);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static renderCompass(ref, compassSvgSize, compassRadius, isArc) {
        return (FSComponent.buildComponent("svg", { ref: ref, class: "compass-circle-ticks", viewBox: `0 0 ${compassSvgSize} ${compassSvgSize}`, width: compassSvgSize, height: compassSvgSize, style: "position: absolute;" },
            FSComponent.buildComponent(CompassRoseTicks, { svgViewBoxSize: compassSvgSize, ticksRadius: compassRadius, shortTickLength: 15 * MapSystemCommon.canvasScale, longTickLength: (isArc ? 26 : 15) * MapSystemCommon.canvasScale, tickDirection: 'Inwards', withCircle: isArc, degreesPerTick: isArc ? 5 : 10 }),
            FSComponent.buildComponent(CompassRoseNumbers, { svgViewBoxSize: compassSvgSize, numbersRadius: isArc
                    ? compassRadius - (50 * MapSystemCommon.canvasScale)
                    : compassRadius - (37 * MapSystemCommon.canvasScale), fontSize: ((isArc ? 28 : 23) * MapSystemCommon.canvasScale) + 'px', strokeWidth: (isArc ? 2 : 1) * MapSystemCommon.canvasScale })));
    }
    /** @inheritdoc */
    render() {
        const trackLineSvgPaddingY = 10 * MapSystemCommon.canvasScale;
        const trackLineSvgWidth = this.compassSvgSize;
        const trackLineSvgHeight = this.isArc
            ? this.compassRadius + trackLineSvgPaddingY
            : this.compassSvgSize;
        const trackLineSvgMinY = this.isArc
            ? -(trackLineSvgHeight - (trackLineSvgPaddingY / 2))
            : -trackLineSvgHeight / 2;
        const translateY = this.isArc
            ? -this.compassRadius / 2
            : 0;
        const trackLinePathArc = `M 0 0 l 0 ${-this.props.compassRadius}`;
        const trackLinePathCtr = `
      M 0 ${this.compassRadius}
      L 0 ${108 * MapSystemCommon.canvasScale}
      M 0 0
      L 0 ${-this.compassRadius}
    `;
        const trackLinePath = this.isArc ? trackLinePathArc : trackLinePathCtr;
        const rangeTickWidth = MapSystemCommon.rangeTickWidth;
        const rangeTicksPathArc = `
      M ${-(rangeTickWidth / 2)} ${-((this.compassRadius / 4) * 1)} l ${rangeTickWidth} 0
      M ${-(rangeTickWidth / 2)} ${-((this.compassRadius / 4) * 2)} l ${rangeTickWidth} 0
      M ${-(rangeTickWidth / 2)} ${-((this.compassRadius / 4) * 3)} l ${rangeTickWidth} 0
    `;
        const rangeTicksPathCtr = `
      M ${-(rangeTickWidth / 2)} ${-this.compassRadius / 2} l ${rangeTickWidth} 0
      M ${-(rangeTickWidth / 2)} ${this.compassRadius / 2} l ${rangeTickWidth} 0
    `;
        const rangeTicksPath = this.isArc ? rangeTicksPathArc : rangeTicksPathCtr;
        return (FSComponent.buildComponent("div", { class: this.classList },
            FSComponent.buildComponent(MapCompassOffset, { compassSvgSize: this.props.compassSvgSize, targetProjectedOffsetY: this.props.ndDataProvider.targetProjectedOffsetY },
                !this.isArc &&
                    FSComponent.buildComponent(MapCompassArcMask, { isEnabled: this.isArc, maskHeightPx: MapSystemCommon.mapCompassMaskHeight, innerHeightPx: this.props.compassSvgSize }, MapCompassLowerLayer.renderCompass(this.ndMapTrackRotatingSvgRef, this.compassSvgSize, this.compassRadius, this.isArc)),
                FSComponent.buildComponent("svg", { class: "track-line-ticks-circles", viewBox: `${-trackLineSvgWidth / 2} ${trackLineSvgMinY} ${trackLineSvgWidth} ${trackLineSvgHeight}`, width: trackLineSvgWidth, height: trackLineSvgHeight, style: `position: absolute; transform: translateY(${translateY}px)` },
                    FSComponent.buildComponent(OutlinedElement, { tag: "path", className: "track-line", outlineClass: "nd-path-shadow", d: trackLinePath }),
                    FSComponent.buildComponent(OutlinedElement, { tag: "path", className: "track-line-with-ticks", outlineClass: "nd-path-shadow", d: `${trackLinePath} ${rangeTicksPath}` }),
                    this.isArc &&
                        FSComponent.buildComponent(OutlinedElement, { tag: "path", className: "range-circles", outlineClass: "nd-path-shadow", d: SVGUtils.describeArc(0, 0, (this.compassRadius / 4) * 1, 270, 90) +
                                SVGUtils.describeArc(0, 0, (this.compassRadius / 4) * 2, 270, 90) +
                                SVGUtils.describeArc(0, 0, (this.compassRadius / 4) * 3, 270, 90) }),
                    !this.isArc &&
                        FSComponent.buildComponent(OutlinedElement, { tag: "circle", className: "range-circles", outlineClass: "nd-path-shadow", cx: 0, cy: 0, r: this.compassRadius / 2 })),
                this.isArc && FSComponent.buildComponent("div", { class: "half-range-number" }, this.props.ndDataProvider.halfRangeNumber),
                !this.isArc && FSComponent.buildComponent("div", { class: "half-range-number" }, this.props.ndDataProvider.quarterRangeNumber),
                !this.isArc && FSComponent.buildComponent("div", { class: "half-range-number-2" }, this.props.ndDataProvider.quarterRangeNumber))));
    }
}

/* eslint-disable max-len */
/** Map compass overlay components. */
class MapCompassUpperLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.isArc = this.props.type === 'arc';
        this.containerRef = FSComponent.createRef();
        this.ndMapTrackRotatingSvgRef = FSComponent.createRef();
        this.compassSvgSize = this.props.compassSvgSize;
        this.compassRadius = this.props.compassRadius;
        this.classList = SetSubject.create([
            `map-${this.props.type}`,
            `map-${this.props.type}-upper`,
            'map-compass-overlay',
        ]);
    }
    /** @inheritdoc */
    onAfterRender() {
        if (this.ndMapTrackRotatingSvgRef.getOrDefault()) {
            this.props.ndDataProvider.compassTrackRotationAnimated.sub(rot => {
                this.ndMapTrackRotatingSvgRef.instance.style.transform = `rotate3d(0, 0, 1, ${rot * -1}deg)`;
            });
        }
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.containerRef.instance.classList.toggle('hidden', !isVisible);
    }
    /** @inheritdoc */
    render() {
        const halfPaneWidthPx = B748PaneSizes.sizePx * MapSystemCommon.canvasScale;
        const extra = 82;
        const arcMaskHeight = (256 + extra) * MapSystemCommon.canvasScale;
        const trackBoxSvgSize = 150;
        let trackBoxPath = 'M -42 -66 l 0 40 l 84 0 l 0 -40';
        const trackBoxDownwardsLinePath = ` m -42 40 l 0 ${26 + extra}`;
        if (this.isArc) {
            trackBoxPath += trackBoxDownwardsLinePath;
        }
        return (FSComponent.buildComponent("div", { class: this.classList, ref: this.containerRef },
            this.isArc &&
                FSComponent.buildComponent(FSComponent.Fragment, null,
                    FSComponent.buildComponent("svg", { class: "nd-map-mask", viewBox: `0 0 ${halfPaneWidthPx} ${arcMaskHeight}`, style: 'position: absolute; top: 0;' },
                        FSComponent.buildComponent("path", { d: `M 0 0 l 0 ${arcMaskHeight} ` +
                                `a ${this.props.compassRadius - 52} ${this.props.compassRadius - 52} 0 0 1 ${halfPaneWidthPx} 0 ` +
                                `l 0 -${arcMaskHeight} z`, fill: "var(--boeing-colors-black)", stroke: "none", "stroke-linecap": "unset", "stroke-linejoin": "unset" }))),
            !this.isArc &&
                FSComponent.buildComponent("div", { class: "nd-map-ctr-mask", style: "position: absolute; top: 0; left 0; width: 100%; height: 133px; background: black;" }),
            FSComponent.buildComponent(MapCompassOffset, { compassSvgSize: this.props.compassSvgSize, targetProjectedOffsetY: this.props.ndDataProvider.targetProjectedOffsetY },
                FSComponent.buildComponent("svg", { class: "track-box", viewBox: `${-trackBoxSvgSize / 2} ${-trackBoxSvgSize / 2} ${trackBoxSvgSize} ${trackBoxSvgSize}`, width: trackBoxSvgSize * MapSystemCommon.canvasScale, height: trackBoxSvgSize * MapSystemCommon.canvasScale, style: `transform: translateY(${this.props.compassRadius * -1}px)` },
                    this.isArc &&
                        // This hides where the two track lines meet, so it shouldn't have an outline or round caps
                        FSComponent.buildComponent("path", { "vector-effect": "non-scaling-stroke", d: trackBoxPath }),
                    !this.isArc &&
                        FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", "vector-effect": "non-scaling-stroke", d: trackBoxPath })),
                FSComponent.buildComponent(MapCompassArcMask, { isEnabled: this.isArc, maskHeightPx: MapSystemCommon.mapCompassMaskHeight, innerHeightPx: this.props.compassSvgSize },
                    this.isArc &&
                        // For Arc style map formats, we need the ticks and numbers above the arc mask
                        MapCompassLowerLayer.renderCompass(this.ndMapTrackRotatingSvgRef, this.compassSvgSize, this.compassRadius, this.isArc),
                    FSComponent.buildComponent(BearingPointer, { type: "VOR", leftOrRight: "left", color: "var(--boeing-colors-green)", isVisible: this.props.ndDataProvider.vorPointerLeftIsVisible, rotation: this.props.ndDataProvider.vorLeftRotationAnimated, compassRadiusUnscaled: this.props.compassRadius / MapSystemCommon.canvasScale, heightUnscaled: this.props.compassSvgSize / MapSystemCommon.canvasScale, canvasScale: MapSystemCommon.canvasScale, svgScale: MapSystemCommon.maxToOldBoeingScale }),
                    FSComponent.buildComponent(BearingPointer, { type: "VOR", leftOrRight: "right", color: "var(--boeing-colors-green)", isVisible: this.props.ndDataProvider.vorPointerRightIsVisible, rotation: this.props.ndDataProvider.vorRightRotationAnimated, compassRadiusUnscaled: this.props.compassRadius / MapSystemCommon.canvasScale, heightUnscaled: this.props.compassSvgSize / MapSystemCommon.canvasScale, canvasScale: MapSystemCommon.canvasScale, svgScale: MapSystemCommon.maxToOldBoeingScale }),
                    FSComponent.buildComponent(BearingPointer, { type: "ADF", leftOrRight: "left", color: "var(--boeing-colors-cyan)", isVisible: this.props.ndDataProvider.adfPointerLeftIsVisible, rotation: this.props.ndDataProvider.adfLeftRotationAnimated, compassRadiusUnscaled: this.props.compassRadius / MapSystemCommon.canvasScale, heightUnscaled: this.props.compassSvgSize / MapSystemCommon.canvasScale, canvasScale: MapSystemCommon.canvasScale, svgScale: MapSystemCommon.maxToOldBoeingScale }),
                    FSComponent.buildComponent(BearingPointer, { type: "ADF", leftOrRight: "right", color: "var(--boeing-colors-cyan)", isVisible: this.props.ndDataProvider.adfPointerRightIsVisible, rotation: this.props.ndDataProvider.adfRightRotationAnimated, compassRadiusUnscaled: this.props.compassRadius / MapSystemCommon.canvasScale, heightUnscaled: this.props.compassSvgSize / MapSystemCommon.canvasScale, canvasScale: MapSystemCommon.canvasScale, svgScale: MapSystemCommon.maxToOldBoeingScale })),
                FSComponent.buildComponent(SelectedHeadingLine, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius }),
                FSComponent.buildComponent(SelectedTrackLine, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius }),
                FSComponent.buildComponent(MapCompassArcMask, { isEnabled: this.isArc, maskHeightPx: MapSystemCommon.mapCompassMaskHeight, innerHeightPx: this.props.compassSvgSize },
                    FSComponent.buildComponent(SelectedHeadingBug, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius, svgScale: MapSystemCommon.maxToOldBoeingScale }),
                    FSComponent.buildComponent(SelectedTrackBug, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius, svgScale: MapSystemCommon.maxToOldBoeingScale }),
                    FSComponent.buildComponent(CurrentHeadingTriangle, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius, svgScale: MapSystemCommon.maxToOldBoeingScale })))));
    }
}

/** Map plan overlay components which go below the flight plan rotue lines. */
class MapPlanLowerLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.quarterRangeNumberTop = FSComponent.createRef();
        this.quarterRangeNumberBottom = FSComponent.createRef();
        this.halfRangeNumberTop = FSComponent.createRef();
        this.halfRangeNumberBottom = FSComponent.createRef();
        this.classList = SetSubject.create(['nd-plan-overlay', 'nd-plan-lower', 'map-compass-overlay']);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.compassRadius.sub(radius => {
            this.quarterRangeNumberTop.instance.style.transform = `translateY(${-radius / 2}px)`;
            this.quarterRangeNumberBottom.instance.style.transform = `translateY(${radius / 2}px)`;
            this.halfRangeNumberTop.instance.style.transform = `translateY(${-radius}px)`;
            this.halfRangeNumberBottom.instance.style.transform = `translateY(${radius}px)`;
        }, true);
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.classList.toggle('hidden', !isVisible);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.classList },
            FSComponent.buildComponent(MapCompassOffset, { targetProjectedOffsetY: this.props.ndDataProvider.targetProjectedOffsetY },
                FSComponent.buildComponent("div", { class: "range-number quarter-range-number-1", ref: this.quarterRangeNumberTop }, this.props.ndDataProvider.quarterRangeNumber),
                FSComponent.buildComponent("div", { class: "range-number quarter-range-number-2", ref: this.quarterRangeNumberBottom }, this.props.ndDataProvider.quarterRangeNumber),
                FSComponent.buildComponent("div", { class: "range-number half-range-number-1", ref: this.halfRangeNumberTop }, this.props.ndDataProvider.halfRangeNumber),
                FSComponent.buildComponent("div", { class: "range-number half-range-number-2", ref: this.halfRangeNumberBottom }, this.props.ndDataProvider.halfRangeNumber))));
    }
}

/** Map plan overlay components which go below the flight plan rotue lines. */
class MapPlanUpperLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.classList = SetSubject.create(['nd-plan-overlay', 'nd-plan-upper', 'map-compass-overlay']);
        this.compassSvgSize = 1000 * MapSystemCommon.canvasScale;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.containerRef.instance.classList.toggle('hidden', !isVisible);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.classList, ref: this.containerRef },
            FSComponent.buildComponent(MapCompassOffset, { compassSvgSize: this.compassSvgSize, targetProjectedOffsetY: this.props.ndDataProvider.targetProjectedOffsetY },
                FSComponent.buildComponent("svg", { class: "nd-plan-circles", viewBox: `${-this.compassSvgSize / 2} ${-this.compassSvgSize / 2} ${this.compassSvgSize} ${this.compassSvgSize}`, width: this.compassSvgSize, height: this.compassSvgSize, style: "position: absolute;" },
                    FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: this.props.compassRadius.map(radius => SVGUtils.describeArc(0, 0, radius, 5, 175) +
                            SVGUtils.describeArc(0, 0, radius, 185, 355) +
                            SVGUtils.describeArc(0, 0, radius / 2, 10, 170) +
                            SVGUtils.describeArc(0, 0, radius / 2, 190, 350)) })),
                FSComponent.buildComponent("div", { class: "plan-map-nesw" },
                    FSComponent.buildComponent("div", { class: "east" }, "E"),
                    FSComponent.buildComponent("div", { class: "west" }, "W"))),
            FSComponent.buildComponent("div", { class: "nd-centered" },
                FSComponent.buildComponent("div", { class: "plan-map-nesw" },
                    FSComponent.buildComponent("div", { class: "north" }, "N"),
                    FSComponent.buildComponent("div", { class: "south" }, "S"),
                    FSComponent.buildComponent("svg", { class: "north-arrow", viewBox: "-30 -30 60 60", width: 50 * MapSystemCommon.canvasScale, height: 50 * MapSystemCommon.canvasScale },
                        FSComponent.buildComponent(OutlinedElement, { tag: "path", className: "north-arrow-path", outlineClass: "nd-path-shadow", "vector-effect": "non-scaling-stroke", stroke: "var(--boeing-colors-green)", d: "M 0 -16 L 11 -4 M 0 -16 L -11 -4 M 0 -16 L 0 16" }))))));
    }
}

var NdClockState;
(function (NdClockState) {
    NdClockState[NdClockState["UTC"] = 0] = "UTC";
    NdClockState[NdClockState["CHR_Start"] = 1] = "CHR_Start";
    NdClockState[NdClockState["CHR_Stop"] = 2] = "CHR_Stop";
})(NdClockState || (NdClockState = {}));
/** The B748ElapsedTimeChronograph component. */
class B748ElapsedTimeChronograph extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgCircleRef = FSComponent.createRef();
        this.svgNeedleRef = FSComponent.createRef();
        this.divContainerRef = FSComponent.createRef();
        this.timerPublisher = this.props.bus.getPublisher();
        this.timerSubscriber = this.props.bus.getSubscriber();
        this.elapsedTimeDigitalDisplay = ComputedSubject.create(0, (v) => v < B748ElapsedTimeChronograph.MS_PER_HOUR
            ? B748ElapsedTimeChronograph.ELAPSED_TIME_FORMATTER_CAP_MINUTE(v)
            : B748ElapsedTimeChronograph.ELAPSED_TIME_FORMATTER_CAP_HOUR(v));
    }
    /** @inheritdoc */
    onAfterRender() {
        this.clockStateSub = this.props.clockState.sub((v) => {
            this.timerPublisher.pub(`timer_set_initial_value_${this.props.mfdIndex}`, -1);
            if (v === NdClockState.CHR_Start) {
                this.timerPublisher.pub(`timer_set_mode_${this.props.mfdIndex}`, FlightTimerMode.CountingUp);
                this.timerPublisher.pub(`timer_start_${this.props.mfdIndex}`, undefined);
            }
            else if (v === NdClockState.CHR_Stop) {
                this.timerPublisher.pub(`timer_stop_${this.props.mfdIndex}`, undefined);
            }
            else {
                this.timerPublisher.pub(`timer_stop_${this.props.mfdIndex}`, undefined);
                this.timerPublisher.pub(`timer_reset_${this.props.mfdIndex}`, undefined);
            }
        }, true);
        this.timerSub = this.timerSubscriber.on(`timer_value_ms_${this.props.mfdIndex}`).handle(this.rotateChrNeedle.bind(this));
        this.visibilitySub = this.props.isVisible.sub((isVisible) => {
            this.svgCircleRef.instance.classList.toggle('hidden', !isVisible);
            this.svgNeedleRef.instance.classList.toggle('hidden', !isVisible);
            this.divContainerRef.instance.classList.toggle('hidden', !isVisible);
        }, true);
    }
    /** Builds the tick marks.
     * @returns A SVG path string as collection of tick line elements. */
    buildChrTicks() {
        const { ticksRadius, shortTickLength, longTickLength, tickDirection } = this.props;
        const half = this.props.svgViewBoxSize / 2;
        const direction = tickDirection === 'Inwards' ? 1 : -1;
        const radialOffset = tickDirection === 'Inwards' ? 0 : 1;
        let path = '';
        for (let i = 0; i < 360; i += this.props.degreesPerTick) {
            const length = (i % 90 == 0 ? longTickLength : shortTickLength) * direction;
            const startX = half + (ticksRadius - length + radialOffset) * Math.cos(i * Avionics.Utils.DEG2RAD);
            const startY = half + (ticksRadius - length + radialOffset) * Math.sin(i * Avionics.Utils.DEG2RAD);
            const endX = startX + (length * Math.cos(i * Avionics.Utils.DEG2RAD));
            const endY = startY + (length * Math.sin(i * Avionics.Utils.DEG2RAD));
            path += `M ${startX} ${startY} L ${endX} ${endY}`;
        }
        return path;
    }
    /**
     * Rotates the CHR needle SVG around the chronograph in realTime. Needle completes a 360-degree rotation per minute.
     * @param elapsedTimeMs Timer time in ms.
     */
    rotateChrNeedle(elapsedTimeMs) {
        this.elapsedTimeDigitalDisplay.set(elapsedTimeMs);
        const elapsedNeedleDegree = (elapsedTimeMs / 1000) * 6;
        this.svgNeedleRef.instance.style.transform = `rotate3d(0,0,1, ${elapsedNeedleDegree}deg)`;
    }
    /** @inheritdoc */
    onResume() {
        var _a;
        (_a = this.timerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /** @inheritdoc */
    onPause() {
        var _a;
        (_a = this.timerSub) === null || _a === void 0 ? void 0 : _a.pause();
    }
    /** @inheritdoc */
    render() {
        const ticksPath = this.buildChrTicks();
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("svg", { class: "b748-nd-elapsed-time-chronograph-svg", viewBox: `0 0 ${this.props.svgViewBoxSize} ${this.props.svgViewBoxSize}`, width: this.props.svgViewBoxSize, height: this.props.svgViewBoxSize, ref: this.svgCircleRef },
                FSComponent.buildComponent("circle", { class: "chr-circle", id: "chr-circle", cx: "50%", cy: "50%", r: this.props.ticksRadius, stroke: "white", "stroke-width": this.props.strokeWidth }),
                FSComponent.buildComponent("path", { class: "chr-tick-lines", d: ticksPath, fill: "white", stroke: "white", "stroke-width": this.props.strokeWidth - 2 })),
            FSComponent.buildComponent("svg", { class: "b748-nd-elapsed-time-chronograph-svg", viewBox: `0 0 ${this.props.svgViewBoxSize} ${this.props.svgViewBoxSize}`, width: this.props.svgViewBoxSize, height: this.props.svgViewBoxSize, ref: this.svgNeedleRef },
                FSComponent.buildComponent("line", { class: "chr-needle", x2: "35", y2: "3", x1: "35", y1: "35", fill: "white", stroke: "white", "stroke-width": this.props.strokeWidth - 2 })),
            FSComponent.buildComponent("div", { class: "b748-nd-elapsed-time-digital-display", ref: this.divContainerRef },
                FSComponent.buildComponent("span", { class: "time-digits" }, this.elapsedTimeDigitalDisplay),
                "\u00A0",
                FSComponent.buildComponent("span", { class: "clock-mode" }, "CHR"))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.timerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.clockStateSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.visibilitySub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}
B748ElapsedTimeChronograph.ELAPSED_TIME_FORMATTER_CAP_HOUR = DurationFormatter.create('{hh}:{mm}:{ss}', UnitType.MILLISECOND, 100, '--:--:--');
B748ElapsedTimeChronograph.ELAPSED_TIME_FORMATTER_CAP_MINUTE = DurationFormatter.create('{mm}:{ss}', UnitType.MILLISECOND, 100, '--:--:--');
B748ElapsedTimeChronograph.MS_PER_HOUR = 3600000000;

/** The B748ElapsedTimeChronograph component. */
class B748UtcTimeDigitalDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.utcTimeDigitalDisplay = ComputedSubject.create(0, (v) => B748UtcTimeDigitalDisplay.TIME_FORMATTER(v));
        this.containerRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.simTimeSub = this.props.bus.getSubscriber().on('simTime').atFrequency(15).handle(this.setUtcSimTime.bind(this));
        this.visibilitySub = this.props.isVisible.sub((isVisible) => {
            this.containerRef.instance.classList.toggle('hidden', !isVisible);
        }, true);
    }
    /**
     * Sets UTC sim time to display.
     * @param v the UNIX timestamp corresponding to the simulation time.
     */
    setUtcSimTime(v) {
        this.utcTimeDigitalDisplay.set(v);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "b748-nd-utc-time-digital-display", ref: this.containerRef },
            FSComponent.buildComponent("span", { class: "time-digits" }, this.utcTimeDigitalDisplay),
            "\u00A0",
            FSComponent.buildComponent("span", { class: "clock-mode" }, "UTC")));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        (_a = this.simTimeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.visibilitySub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}
B748UtcTimeDigitalDisplay.TIME_FORMATTER = DateTimeFormatter.create('{HH}:{mm}:{ss}');

/** The B747NdClock component. */
class B748NdClock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgViewBoxSize = 70 * MapSystemCommon.canvasScale;
        this.chrClockRadius = 32 * MapSystemCommon.canvasScale;
        this.clockState = Subject.create(NdClockState.UTC);
        this.isUtcClockVisible = Subject.create(false);
        this.isChrClockVisible = Subject.create(false);
        this.clockContainerRef = FSComponent.createRef();
        this.chrRef = FSComponent.createRef();
        this.utcRef = FSComponent.createRef();
        /**
         * Need to manually check if the timer of this MFD screen is running or not since both
         * cockpit clock buttons are emitting the same 'Generic_BTN_Clock_1' event at the moment.
         * TODO: Remove this and check for `Generic_BTN_Clock_${this.props.mfdIndex}`.
         */
        this.timerSubscriber = this.props.bus.getSubscriber();
        this.isThisMfdTimerRunning = ConsumerSubject.create(this.timerSubscriber.on(`timer_is_running_${this.props.mfdIndex}`), false);
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs = [
            this.props.bus.getSubscriber().on('hEvent').handle(hEvent => {
                const currentClockState = this.clockState.get();
                if (hEvent === `Generic_BTN_Clock_${this.props.mfdIndex}`) {
                    switch (currentClockState) {
                        case NdClockState.UTC:
                            this.clockState.set(NdClockState.CHR_Start);
                            break;
                        case NdClockState.CHR_Start:
                            this.clockState.set(NdClockState.CHR_Stop);
                            break;
                        case NdClockState.CHR_Stop:
                            this.clockState.set(NdClockState.UTC);
                            break;
                        default:
                            console.error('Invalid ND Clock state: ', currentClockState);
                            break;
                    }
                }
            }),
            this.props.ndDataProvider.isClockSupported.sub((isClockSupported) => {
                this.clockContainerRef.instance.classList.toggle('hidden', !isClockSupported);
            }, true),
            this.clockState.sub((v) => {
                this.isUtcClockVisible.set(v === NdClockState.UTC);
                this.isChrClockVisible.set(v !== NdClockState.UTC);
            }, true),
        ];
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "b748-nd-clock-container", ref: this.clockContainerRef },
            FSComponent.buildComponent(B748ElapsedTimeChronograph, { bus: this.props.bus, mfdIndex: this.props.mfdIndex, svgViewBoxSize: this.svgViewBoxSize, shortTickLength: 2 * MapSystemCommon.canvasScale, longTickLength: 6 * MapSystemCommon.canvasScale, tickDirection: 'Inwards', degreesPerTick: 30, ticksRadius: this.chrClockRadius, strokeWidth: 4, clockState: this.clockState, ref: this.chrRef, isVisible: this.isChrClockVisible }),
            FSComponent.buildComponent(B748UtcTimeDigitalDisplay, { bus: this.props.bus, ref: this.utcRef, isVisible: this.isUtcClockVisible })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        this.subs.map((sub) => sub.destroy());
        (_a = this.chrRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.utcRef.getOrDefault()) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/** The NdInfomation component. */
class NdInformation extends DisplayComponent {
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "nd-information-container" },
            FSComponent.buildComponent(SpeedWindRangeInfoBlock, { bus: this.props.bus, showRange: true, ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(ActiveWaypointDataBlock, { bus: this.props.bus, activeRoutePredictor: this.props.activeRoutePredictor, distancePad: 4, flightPlanner: this.props.flightPlanner }),
            FSComponent.buildComponent(AircraftTrack, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(TcasAdvisoryStatus, { bus: this.props.bus, tcasOffScaleStatus: this.props.offScaleTcasAlertLevel, ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent("div", { class: "nd-information-lower-section" },
                FSComponent.buildComponent(WxTerrTfcDataBlock, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider, showMapSymbolsBlock: true }),
                FSComponent.buildComponent(VorDisplay, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider }),
                FSComponent.buildComponent(AdfDisplay, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider }),
                FSComponent.buildComponent(MapNavigationPerformance, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider, verticalDeviationDataProvider: this.props.verticalDeviationDataProvider, lineThickness: 4, fontSize: 22, marginBottom: 90, scaleRatio: 0.76 }),
                FSComponent.buildComponent(B748NdClock, { bus: this.props.bus, mfdIndex: this.props.mfdIndex, ndDataProvider: this.props.ndDataProvider }))));
    }
}

/** The 748 ND Map component. */
class NdMap extends DisplayPaneView {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.navMapContainerRef = FSComponent.createRef();
        this.settings = MapUserSettings.getAliasedManager(this.props.bus, 'MFD', this.props.mfdIndex);
        this.ndDataProvider = new B748NdInfoDataProvider(this.props.bus, this.props.navIndicators, this.settings);
        this.verticalDeviationDataProvider = new DefaultVerticalDeviationDataProvider(this.props.bus, this.props.navIndicators.get('ils'), this.props.instrumentIndex);
        this.offScaleTcasAlertLevel = Subject.create(TcasAlertLevel.None);
        this.classList = SetSubject.create(['navigation-display']);
        this.compassArcSvgSize = 1200 * MapSystemCommon.canvasScale;
        this.compassCenterSvgSize = 600 * MapSystemCommon.canvasScale;
        this.compassArcRadius = Subject.create(MapSystemCommon.mapCompassRadius);
        this.compassCenterRadius = Subject.create(MapSystemCommon.mapCtrCompassRadius);
        this.planCompassRadius = Subject.create(MapSystemCommon.planCompassRadius);
        this.useRangeCircles = MappedSubject.create(([tfc, terrWx]) => {
            return tfc || terrWx !== 'OFF';
        }, this.settings.getSetting('tfcEnabled'), this.settings.getSetting('terrWxState'));
        this.mapSystem = this.buildMapSystem().build('map-system' + (MapSystemCommon.canvasScale === 0.5 ? ' map-system-canvas-half-scale' : ''));
        this.ndDataProvider.initMapProjection(this.mapSystem.context.projection);
        this.verticalDeviationDataProvider.init();
    }
    /**
     * Builds the map system for the navigation map.
     * @returns The configured map system builder.
     */
    buildMapSystem() {
        if (NdMap.mapBuilder === undefined) {
            const boeingMapBuilder = new BoeingMapBuilder(this.props.bus, this.ndDataProvider, 'MFD', this.props.facLoader, this.props.flightPlanner, this.props.activeRoutePredictor, this.props.perfPlanRepository, this.props.tcas);
            const b748MapBuilder = new B748MapBuilder(boeingMapBuilder, this.props.bus, this.ndDataProvider, this.props.flightPlanner);
            return MapSystemBuilder.create(this.props.bus)
                .withBing(`b748-map-mfd-${this.props.mfdIndex}`, 0, undefined, undefined, 'bing-map')
                .with(b748MapBuilder.withBoeingMapStyles)
                .with(boeingMapBuilder.withTerrainColors)
                .withModule(BoeingMapKeys.NdDataProvider, () => this.ndDataProvider)
                .withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule())
                .withController(MapSystemKeys.AutopilotProps, context => new BoeingMapAutopilotPropsController(context))
                .withLayer(BoeingMapKeys.CompassArcLowerLayer, context => FSComponent.buildComponent(MapCompassLowerLayer, { type: "arc", model: context.model, mapProjection: context.projection, ndDataProvider: this.ndDataProvider, compassRadius: this.compassArcRadius.get(), compassSvgSize: this.compassArcSvgSize }))
                .withLayer(BoeingMapKeys.CompassCenterLowerLayer, context => FSComponent.buildComponent(MapCompassLowerLayer, { type: "ctr", model: context.model, mapProjection: context.projection, ndDataProvider: this.ndDataProvider, compassRadius: this.compassCenterRadius.get(), compassSvgSize: this.compassCenterSvgSize }))
                .withLayer(BoeingMapKeys.PlanLowerLayer, context => FSComponent.buildComponent(MapPlanLowerLayer, { model: context.model, mapProjection: context.projection, ndDataProvider: this.ndDataProvider, compassRadius: this.planCompassRadius }))
                .with(boeingMapBuilder.withPlanAirportsRunways)
                .with(b748MapBuilder.withNearestWaypoints)
                .with(b748MapBuilder.withFlightPlans)
                .with(boeingMapBuilder.withTopOfDescent)
                .with(boeingMapBuilder.withMapSelectWpt)
                .with(boeingMapBuilder.positionTrendVector, { minRangeVisible: 10, strokeWidth: MapSystemCommon.strokeWidth, outlineWidth: MapSystemCommon.outlineWidth })
                .with(b748MapBuilder.withAltitudeArc, 285 * MapSystemCommon.canvasScale, 70)
                .withLayer(BoeingMapKeys.CompassArcUpperLayer, context => FSComponent.buildComponent(MapCompassUpperLayer, { type: "arc", model: context.model, mapProjection: context.projection, ndDataProvider: this.ndDataProvider, compassRadius: this.compassArcRadius.get(), compassSvgSize: this.compassArcSvgSize }))
                .withLayer(BoeingMapKeys.CompassCenterUpperLayer, context => FSComponent.buildComponent(MapCompassUpperLayer, { type: "ctr", model: context.model, mapProjection: context.projection, ndDataProvider: this.ndDataProvider, compassRadius: this.compassCenterRadius.get(), compassSvgSize: this.compassCenterSvgSize }))
                .withLayer(BoeingMapKeys.PlanUpperLayer, context => FSComponent.buildComponent(MapPlanUpperLayer, { model: context.model, mapProjection: context.projection, ndDataProvider: this.ndDataProvider, compassRadius: this.planCompassRadius }))
                .with(b748MapBuilder.withAirplaneIcon)
                .withFollowAirplane()
                .withRotation()
                .withController(BoeingMapKeys.MapFormatController, context => new B748NdFormatController(context, this.props.mfdIndex))
                .withController(BoeingMapKeys.RangeController, context => new MapRangeController(context, this.ndDataProvider.mapRange))
                .with(boeingMapBuilder.withWaypointDisplayController)
                .withController(BoeingMapKeys.PlanFormatController, context => new PlanFormatController(context, this.props.mfdIndex, this.props.flightPlanner, this.ndDataProvider))
                .with(b748MapBuilder.withTraffic, this.offScaleTcasAlertLevel)
                .withProjectedSize(new Float64Array([B748PaneSizes.sizePx * MapSystemCommon.canvasScale, B748PaneSizes.sizePx * MapSystemCommon.canvasScale]))
                .withClockUpdate(30);
        }
        else {
            return NdMap.mapBuilder;
        }
    }
    /** @inheritdoc */
    onResume() {
        this.mapSystem.ref.instance.wake();
    }
    /** @inheritdoc */
    onPause() {
        this.mapSystem.ref.instance.sleep();
    }
    /** @inheritdoc */
    onAfterRender() {
        const translate = (MapSystemCommon.canvasScale === 1 ? 0 : (MapSystemCommon.canvasScale * 50)) + '%';
        this.navMapContainerRef.instance.style.setProperty('--nd-canvas-transform', `scale(${1 / MapSystemCommon.canvasScale}) translate(${translate}, ${translate})`);
        this.navMapContainerRef.instance.style.setProperty('--nd-canvas-scale', MapSystemCommon.canvasScale.toString());
        this.settings.getSetting('mapFormat').sub(format => {
            this.classList.toggle('map-mode', format === 'MAP');
            this.classList.toggle('map-ctr-mode', format === 'MAPCTR');
            this.classList.toggle('plan-mode', format === 'PLAN');
        }, true);
        this.useRangeCircles.sub(useRangeCircles => {
            this.classList.toggle('use-range-circles', useRangeCircles);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.navMapContainerRef, class: this.classList },
            this.mapSystem.map,
            FSComponent.buildComponent(NdInformation, { bus: this.props.bus, mfdIndex: this.props.mfdIndex, activeRoutePredictor: this.props.activeRoutePredictor, ndDataProvider: this.ndDataProvider, verticalDeviationDataProvider: this.verticalDeviationDataProvider, flightPlanner: this.props.flightPlanner, offScaleTcasAlertLevel: this.offScaleTcasAlertLevel })));
    }
}

/** The B78xNavigationMap component. */
class B748Status extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.clock = this.props.bus.getSubscriber();
        this.adc = this.props.bus.getSubscriber();
        this.apu = this.props.bus.getSubscriber();
        this.elec = this.props.bus.getSubscriber();
        this.b748HydSystemSub = this.props.bus.getSubscriber();
        this.vSpeedSettings = VSpeedUserSettings.getManager(this.props.bus);
        this.timeSubject = ConsumerSubject.create(this.clock.on('simTime').atFrequency(1), 0);
        this.timeSeconds = this.timeSubject.map(B748Status.SECOND_PRECISION_MAP);
        this.date = new Date();
        this.dateText = Subject.create('__ ___ __');
        this.timeText = Subject.create('__:__:__');
        /* Elapsed time display */
        this.elapsedTimeRunning = Subject.create(false);
        this.elapsedTimeSubject = ComputedSubject.create(0, (v) => {
            const minutes = Math.floor((v / 60) % 60).toString().padStart(2, '0');
            const hours = Math.floor(v / 3600).toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        });
        this.isOnGround = Subject.create(true);
        this.areVSpeedsCleared = MappedSubject.create(([v1, v2, vr]) => !(v1 > 50) && !(v2 > 50) && !(vr > 50), this.vSpeedSettings.getSettings(VSpeedType.V1).value, this.vSpeedSettings.getSettings(VSpeedType.V2).value, this.vSpeedSettings.getSettings(VSpeedType.Vr).value);
        this.elapsedTimeStopTimer = null;
        /* HYD DISPLAY */
        this.hydPressure1 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_1').whenChangedBy(10), 0);
        this.hydPressure2 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_2').whenChangedBy(10), 0);
        this.hydPressure3 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_3').whenChangedBy(10), 0);
        this.hydPressure4 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_pressure_4').whenChangedBy(10), 0);
        this.pressureDisplay1 = this.createPressureDisplaySubject();
        this.pressureDisplay2 = this.createPressureDisplaySubject();
        this.pressureDisplay3 = this.createPressureDisplaySubject();
        this.pressureDisplay4 = this.createPressureDisplaySubject();
        this.hydReservoir1 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.hydReservoir2 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.hydReservoir3 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.hydReservoir4 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_reservoir_1').whenChangedBy(0.1), 0);
        this.reservoirDisplay1 = this.createReservoirDisplaySubject();
        this.reservoirDisplay2 = this.createReservoirDisplaySubject();
        this.reservoirDisplay3 = this.createReservoirDisplaySubject();
        this.reservoirDisplay4 = this.createReservoirDisplaySubject();
        this.hydTemp1 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_1').whenChangedBy(0.5), 0);
        this.hydTemp2 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_2').whenChangedBy(0.5), 0);
        this.hydTemp3 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_3').whenChangedBy(0.5), 0);
        this.hydTemp4 = ConsumerSubject.create(this.b748HydSystemSub.on('b748_hyd_temperature_4').whenChangedBy(0.5), 0);
        this.tempDisplay1 = this.createTempDisplaySubject();
        this.tempDisplay2 = this.createTempDisplaySubject();
        this.tempDisplay3 = this.createTempDisplaySubject();
        this.tempDisplay4 = this.createTempDisplaySubject();
        /* OXYGEN DISPLAY */
        this.crewOxy = Subject.create(0);
        this.passOxy = Subject.create(0);
        /* NAV DATA DISPLAY */
        this.navDataActiveDate = SimVar.GetGameVarValue('FLIGHT_NAVDATA_DATE_RANGE', SimVarValueType.String);
        /* APU DATA DISPLAY */
        this.apuEgt = ConsumerSubject.create(this.apu.on('apu_egt').withPrecision(0).atFrequency(3), 0);
        this.apuN1 = ComputedSubject.create(0, v => v.toFixed(1).replace('.', '·'));
        this.apuN2 = ComputedSubject.create(0, v => v.toFixed(1).replace('.', '·'));
        this.apuOilQty = ComputedSubject.create(0, v => v.toFixed(1).replace('.', '·'));
        /* BATT DATA DISPLAY */
        this.batA1 = ConsumerSubject.create(this.elec.on('elec_bat_a_1').withPrecision(0).atFrequency(1), 0);
        this.batV1 = ConsumerSubject.create(this.elec.on('elec_bat_v_1').withPrecision(0).atFrequency(1), 0);
        this.batA2 = ConsumerSubject.create(this.elec.on('elec_bat_a_2').withPrecision(0).atFrequency(1), 0);
        this.batV2 = ConsumerSubject.create(this.elec.on('elec_bat_v_2').withPrecision(0).atFrequency(1), 0);
        this.bat1ChgRef = FSComponent.createRef();
        this.bat2ChgRef = FSComponent.createRef();
        this.subs = [];
    }
    /** @inheritdoc */
    onResume() {
        this.subs.forEach(sub => sub.resume(true));
    }
    /** @inheritdoc */
    onPause() {
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritdoc */
    onResize() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.apu.on('apu_n1').withPrecision(1).atFrequency(3).handle(v => this.apuN1.set(v)));
        this.subs.push(this.apu.on('apu_n2').withPrecision(1).atFrequency(3).handle(v => this.apuN2.set(v)));
        this.subs.push(this.apu.on('apu_oil_qty').withPrecision(1).atFrequency(3).handle(v => this.apuOilQty.set(v)));
        this.subs.push(this.batA1.sub(v => this.bat1ChgRef.instance.classList.toggle('hidden', v >= 0), true));
        this.subs.push(this.batA2.sub(v => this.bat2ChgRef.instance.classList.toggle('hidden', v >= 0), true));
        this.subs.push(this.adc.on('on_ground').whenChanged().handle(onGround => {
            this.toggleElapsedTime(!onGround);
            this.isOnGround.set(onGround);
        }));
        this.subs.push(this.areVSpeedsCleared.sub(areVSpeedsCleared => {
            if (areVSpeedsCleared && this.isOnGround.get()) {
                this.resetElapsedTime();
            }
        }));
        this.generateRandomOxygenPressures();
        this.subs.push(this.timeSeconds.sub(this.timeUpdateHandler.bind(this), true));
        this.subs.push(this.hydPressure1.pipe(this.pressureDisplay1));
        this.subs.push(this.hydPressure2.pipe(this.pressureDisplay2));
        this.subs.push(this.hydPressure3.pipe(this.pressureDisplay3));
        this.subs.push(this.hydPressure4.pipe(this.pressureDisplay4));
        this.subs.push(this.hydReservoir1.pipe(this.reservoirDisplay1));
        this.subs.push(this.hydReservoir2.pipe(this.reservoirDisplay2));
        this.subs.push(this.hydReservoir3.pipe(this.reservoirDisplay3));
        this.subs.push(this.hydReservoir4.pipe(this.reservoirDisplay4));
        this.subs.push(this.hydTemp1.pipe(this.tempDisplay1));
        this.subs.push(this.hydTemp2.pipe(this.tempDisplay2));
        this.subs.push(this.hydTemp3.pipe(this.tempDisplay3));
        this.subs.push(this.hydTemp4.pipe(this.tempDisplay4));
    }
    /**
     * Handles timeSeconds subscription events
     * @param utcTime the current UTC timestamp in seconds
     */
    timeUpdateHandler(utcTime) {
        this.updateDisplayedDateTime(utcTime);
    }
    /**
     * Updates the displayed date and time.
     * @param utcTime the current UTC timestamp in seconds
     */
    updateDisplayedDateTime(utcTime) {
        if (isNaN(utcTime)) {
            this.dateText.set('__ ___ __');
            this.timeText.set('__:__:__');
        }
        else {
            this.date.setTime(utcTime);
            const seconds = this.date.getUTCSeconds().toString().padStart(2, '0');
            const minutes = this.date.getUTCMinutes().toString().padStart(2, '0');
            const hours = this.date.getUTCHours().toString().padStart(2, '0');
            this.timeText.set(`${hours}:${minutes}:${seconds}`);
            const day = this.date.getUTCDate().toString().padStart(2, '0');
            const month = B748Status.MONTH_NAMES[this.date.getUTCMonth()];
            const year = this.date.getUTCFullYear();
            this.dateText.set(`${day} ${month} ${year.toString().substring(2, 4)}`);
        }
    }
    /**
     * Toggle (start/stop) elapsed time counter
     * @param start Whether we're starting (or stopping) the counter
     */
    toggleElapsedTime(start) {
        if (start) {
            this.resetElapsedTime();
            this.elapsedTimeRunning.set(true);
            // this subscription is stored separately, because it has to run even when the page is in the background
            this.elapsedTimeSubscription = this.timeSubject.sub(() => {
                this.elapsedTimeSubject.set(this.elapsedTimeSubject.getRaw() + 1);
            }, false, false);
        }
        else {
            // elapsed time has to stop 30 seconds after touchdown
            this.elapsedTimeStopTimer = window.setTimeout(() => {
                if (this.elapsedTimeSubscription) {
                    this.elapsedTimeSubscription.destroy();
                }
                this.elapsedTimeRunning.set(false);
            }, 30000);
        }
    }
    /**
     * Reset elapsed time counter
     */
    resetElapsedTime() {
        // prevent resetting elapsed time in the air after a touch and go
        if (this.elapsedTimeStopTimer) {
            clearTimeout(this.elapsedTimeStopTimer);
            this.elapsedTimeStopTimer = null;
        }
        if (this.elapsedTimeSubscription) {
            this.elapsedTimeSubscription.destroy();
        }
        this.elapsedTimeRunning.set(false);
        this.elapsedTimeSubject.set(0);
    }
    /**
     * Generates random crew and passenger oxygen values to display on STAT page
     */
    generateRandomOxygenPressures() {
        this.crewOxy.set(Math.floor(Math.random() * 8 + 161) * 10);
        this.passOxy.set(Math.floor(Math.random() * 8 + 161) * 10);
    }
    /**
     * Generates a ComputedSubject to format the hydraulic pressure values to the display format
     * @returns A ComputedSubject for the pressure display
     */
    createPressureDisplaySubject() {
        return ComputedSubject.create(0, v => MathUtils.round(v, 10));
    }
    /**
     * Generates a ComputedSubject to format the hydraulic reservoir values to the display format
     * @returns A ComputedSubject for the reservoir display
     */
    createReservoirDisplaySubject() {
        return ComputedSubject.create(0, v => MathUtils.round(v, 0.01).toFixed(2).replace('.', '·'));
    }
    /**
     * Generates a ComputedSubject to format the temperature values to the display format
     * @returns A ComputedSubject for the temperature display
     */
    createTempDisplaySubject() {
        return ComputedSubject.create(0, v => MathUtils.round(v, 1));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "sys-stat-container" },
            FSComponent.buildComponent("div", { class: "stat-page-container-hydraulic" },
                FSComponent.buildComponent("div", { class: "stat-row" },
                    FSComponent.buildComponent("div", { class: "stat-hyd-label" }),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content stat-label stat-label-centered" }, "1"),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content stat-label stat-label-centered" }, "2"),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content stat-label stat-label-centered" }, "3"),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content stat-label stat-label-centered" }, "4")),
                FSComponent.buildComponent("div", { class: "stat-row stat-row-spaced" },
                    FSComponent.buildComponent("div", { class: "stat-hyd-label stat-label" }, "HYD QTY"),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.reservoirDisplay1),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.reservoirDisplay2),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.reservoirDisplay3),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.reservoirDisplay4)),
                FSComponent.buildComponent("div", { class: "stat-row stat-row-spaced" },
                    FSComponent.buildComponent("div", { class: "stat-hyd-label stat-label" }, "HYD PR"),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.pressureDisplay1),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.pressureDisplay2),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.pressureDisplay3),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.pressureDisplay4)),
                FSComponent.buildComponent("div", { class: "stat-row " },
                    FSComponent.buildComponent("div", { class: "stat-hyd-label stat-label" }, "HYD TEMP"),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.tempDisplay1),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.tempDisplay2),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.tempDisplay3),
                    FSComponent.buildComponent("div", { class: "stat-hyd-content" }, this.tempDisplay4))),
            FSComponent.buildComponent("div", { class: "stat-page-container-apu" },
                FSComponent.buildComponent("div", { class: "stat-row" },
                    FSComponent.buildComponent("div", { class: "stat-label" }, "APU:")),
                FSComponent.buildComponent("div", { class: "stat-row" },
                    FSComponent.buildComponent("div", { class: "stat-apu-label stat-label" }, "EGT"),
                    FSComponent.buildComponent("div", { class: "stat-apu-content" }, this.apuEgt),
                    FSComponent.buildComponent("div", { class: "stat-apu-label stat-label" }, "N1"),
                    FSComponent.buildComponent("div", { class: "stat-apu-content" }, this.apuN1),
                    FSComponent.buildComponent("div", { class: "stat-apu-label stat-label" }, "N2"),
                    FSComponent.buildComponent("div", { class: "stat-apu-content" }, this.apuN2),
                    FSComponent.buildComponent("div", { class: "stat-apu-label stat-label" }, "OIL QTY"),
                    FSComponent.buildComponent("div", { class: "stat-apu-content" }, this.apuOilQty))),
            FSComponent.buildComponent("div", { class: "stat-page-container-oxy-batt" },
                FSComponent.buildComponent("div", { class: "stat-row stat-row-spaced" },
                    FSComponent.buildComponent("div", { class: "stat-oxy-title stat-label" }, "OXY PR:"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-label-crew stat-label" }, "CREW"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-content" }, this.crewOxy),
                    FSComponent.buildComponent("div", { class: "stat-oxy-label-pass stat-label" }, "PASS"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-content" }, this.passOxy)),
                FSComponent.buildComponent("div", { class: "stat-row stat-row-spaced" },
                    FSComponent.buildComponent("div", { class: "stat-oxy-title stat-label" }, "MAIN BATT:"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-label-crew stat-label" }, "V-DC"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-content" }, this.batV1),
                    FSComponent.buildComponent("div", { class: "stat-oxy-label-pass stat-label" }, "A-DC"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-content" }, this.batA1),
                    FSComponent.buildComponent("div", { class: "stat-batt-chg stat-label hidden", ref: this.bat1ChgRef }, "CHG")),
                FSComponent.buildComponent("div", { class: "stat-row" },
                    FSComponent.buildComponent("div", { class: "stat-oxy-title stat-label" }, "APU BATT:"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-label-crew stat-label" }, "V-DC"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-content" }, this.batV2),
                    FSComponent.buildComponent("div", { class: "stat-oxy-label-pass stat-label" }, "A-DC"),
                    FSComponent.buildComponent("div", { class: "stat-oxy-content" }, this.batA2),
                    FSComponent.buildComponent("div", { class: "stat-batt-chg stat-label hidden", ref: this.bat2ChgRef }, "CHG"))),
            FSComponent.buildComponent("div", { class: "stat-page-container-navdata" },
                FSComponent.buildComponent("div", { class: "stat-row" },
                    FSComponent.buildComponent("div", { class: "stat-navdata-label stat-label" }, "AIRPORT MAP DATABASE"),
                    FSComponent.buildComponent("div", { class: "stat-navdata-content" }, this.navDataActiveDate))),
            FSComponent.buildComponent("div", { class: "stat-page-container-datetime" },
                FSComponent.buildComponent("div", { class: "stat-row" },
                    FSComponent.buildComponent("div", { class: "stat-datetime-clock-container" },
                        FSComponent.buildComponent("div", { class: "stat-datetime-clock-content stat-label" }, "UTC"),
                        FSComponent.buildComponent("div", { class: "stat-datetime-clock-content" }, this.timeText)),
                    FSComponent.buildComponent("div", { class: "stat-datetime-clock-container" },
                        FSComponent.buildComponent("div", { class: "stat-datetime-date-content stat-label" }, "DATE"),
                        FSComponent.buildComponent("div", { class: "stat-datetime-date-content" }, this.dateText)),
                    FSComponent.buildComponent("div", { class: "stat-datetime-clock-container" },
                        FSComponent.buildComponent("div", { class: "stat-datetime-elapsed-content stat-label" }, "ELAPSED TIME"),
                        FSComponent.buildComponent("div", { class: "stat-datetime-elapsed-content" }, this.elapsedTimeSubject))))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}
B748Status.SECOND_PRECISION_MAP = SubscribableMapFunctions.withPrecision(1000);
B748Status.MONTH_NAMES = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];

/**
 * A Boeing 747-8i MFD instrument.
 */
class WTB748MfdInstrument extends WTB748FsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        super(instrument, config);
        this.iauIndex = this.instrument.instrumentIndex;
        this.displayPaneContainerRef = FSComponent.createRef();
        this.paneIndex = this.iauIndex;
        this.displayPaneViewFactory = new DisplayPaneViewFactory();
        this.efisNdController = (this.iauIndex === 1 || this.iauIndex === 2)
            ? new EfisNdController(this.bus, this.iauIndex)
            : undefined;
        this.efisSimVarPublisher = new B748EfisSimVarPublisher(this.bus);
        this.boeingChecklistRepo = new BoeingChecklistRepository(this.bus, this.iauIndex, B748Checklists.getNormalChecklists(), B748Checklists.getNonNormalChecklists());
        this.fmcSimVarPublisher = new FmcSimVarPublisher(this.bus);
        this.hydraulicsPublisher = new HydraulicsPublisher(this.bus);
        this.b748ApuInstrument = new B748ApuDataInstrument(this.bus);
        this.b748FlightTimerInstrument = new FlightTimerInstrument(this.bus, 2);
        this.boeingTurbinePublisher = new BoeingTurbinePublisher(this.bus);
        this.casSystem = new CasSystem(this.bus, this.iauIndex === 3);
        this.casPresentationController = new CasPresentationController(this.bus, this.casSystem, 'B747_8_EICAS_2_EICAS_PUSH_canc_rcl');
        this.createSystems();
        // For left and right MFD's only, auto enable TFC when there is a TA or RA
        if (this.iauIndex === 1 || this.iauIndex === 2) {
            const settings = MapUserSettings.getAliasedManager(this.bus, 'MFD', this.iauIndex);
            this.autoTfcManager = new BoeingAutoTfcManager(this.bus, settings.getSetting('tfcEnabled'));
        }
        if (this.iauIndex < 3) {
            this.efisEventPublisher = new EfisEventPublisher(this.bus, true, this.iauIndex);
        }
        else if (this.iauIndex === 3) {
            this.soundServer = new SoundServer(this.bus);
            // Requires a CasSystem instance on the same instrument
            this.auralAlertSystem = new AuralAlertSystem(this.bus);
            // TODO Sleep and wake based on power
            this.auralAlertSystem.wake();
            // TODO Turn on and off with power
            this.gpws = new Gpws(this.bus, 1)
                // TODO The 500 is conditional, see FCOM
                .addModule(new TouchdownCalloutModule(this.bus, [2500, 1000, 500, 400, 300, 200, 100, 50, 40, 30, 20, 10]));
            this.displayPaneController = new DisplayPaneController(this.bus);
            this.b748DoorPositionPublisher = new B748DoorPositionPublisher(this.bus);
            this.backplane.addPublisher('b748DoorPositionPublisher', this.b748DoorPositionPublisher);
            this.b748DoorInstrument = new B748DoorDataInstrument(this.bus);
            this.backplane.addInstrument('b748DoorInstrument', this.b748DoorInstrument);
            this.b748GearInstrument = new B748GearDataInstrument(this.bus);
            this.backplane.addInstrument('b748GearDataInstrument', this.b748GearInstrument);
            this.b748ApuInstrument = new B748ApuDataInstrument(this.bus);
            this.backplane.addInstrument('b748ApuDataInstrument', this.b748ApuInstrument);
            this.b748ElecSystemInstrument = new B748ElectricalSystem(this.bus);
            this.backplane.addInstrument('b748ElecSystemInstrument', this.b748ElecSystemInstrument);
            this.b748FuelSystemInstrument = new B748FuelSystemInstrument(this.bus);
            this.backplane.addInstrument('b748FuelSystemInstrument', this.b748FuelSystemInstrument);
            this.b748HydraulicsSystemInstrument = new B748HydraulicsSystem(this.bus);
            this.backplane.addInstrument('b748HydraulicsSystemInstrument', this.b748HydraulicsSystemInstrument);
            this.b748HydraulicsDataInstrument = new B748HydraulicsDataInstrument(this.bus);
            this.backplane.addInstrument('b748HydraulicsDataInstrument', this.b748HydraulicsDataInstrument);
            this.altimeterBaroKeyEventHandler = new AltimeterBaroKeyEventHandler(this.bus, this.perfPlanRepository.getActivePlan(), [
                { index: 1, supportStd: true, supportBaroPreselect: true },
                { index: 2, supportStd: false } // standby altimeter
            ]);
            this.altimeterBaroKeyEventHandler.init();
            // this.casSystem = new CasSystem(this.bus, this.iauIndex === 3);
            // this.casPresentationController = new CasPresentationController(this.bus, this.casSystem);
            // initialize CAS system logic only on MFD1
            const casPublisher = this.bus.getPublisher();
            casPublisher.pub('cas_set_initial_acknowledge', false, true, false);
            // CAS alerters:
            const engineCount = 4;
            new BoeingOpPhaseStateInhibitor(this.bus, this.performanceMath);
            new DoorsStateCrewAlerts(this.bus);
            new EngineCrewAlerts(this.bus, engineCount, this.performanceMath);
            //new FuelCrewAlerts(this.bus);
            new GearAndBrakeCrewAlerts(this.bus, engineCount);
            //new HydraulicsAlerts(this.bus);
            new FlightControlAlerts(this.bus, engineCount, this.speedData);
            //new ElectricAlerts(this.bus);
            new WarningSystemAlerts(this.bus, engineCount, this.speedData, 
            // The ra polynomial is explained in the WarningSystemAlerts class itself:
            // ra/pitch value pairs for 748:
            // 16/-7.7 18/-9.3 20/-11 22/-12.3 24/-13.3 26/-14.2 28/-15.05
            // y(x) = 0.02485x2 - 1.703x + 13.21
            (ra) => { return 0.02485 * ra * ra - 1.703 * ra + 13.21; }, 
            // Flaps index 5 is flaps 25 which is the highest flaps allowed on APPROACH REF page
            5);
        }
        this.backplane.addInstrument('b748FlightTimerInstrument', this.b748FlightTimerInstrument);
        this.controlSurfacesPublisher = new ControlSurfacesPublisher(this.bus, 3);
        this.backplane.addPublisher(InstrumentBackplaneNames.ControlSurfaces, this.controlSurfacesPublisher);
        this.backplane.addPublisher('fmcSimVars', this.fmcSimVarPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Hydraulics, this.hydraulicsPublisher);
        // this.backplane.addInstrument(InstrumentBackplaneNames.B78Hydraulics, this.b78HydraulicsInstrument);
        this.backplane.addPublisher('efisSimVars', this.efisSimVarPublisher);
        this.navSources = new NavSources(new NavRadioNavSource(this.bus, 'NAV1', 1), new NavRadioNavSource(this.bus, 'NAV2', 2), new AdfRadioSource(this.bus, 'ADF1', 1), new AdfRadioSource(this.bus, 'ADF2', 2), new NavRadioNavSource(this.bus, 'ILS1', 3));
        this.backplane.addInstrument('navSources', this.navSources);
        this.navIndicators = new NavIndicators(new Map([
            ['vorLeft', new NavIndicator(this.navSources, 'NAV1')],
            ['vorRight', new NavIndicator(this.navSources, 'NAV2')],
            ['adfLeft', new NavIndicator(this.navSources, 'ADF1')],
            ['adfRight', new NavIndicator(this.navSources, 'ADF2')],
            ['ils', new NavIndicator(this.navSources, 'ILS1')],
        ]));
        this.backplane.addInstrument('navIndicators', this.navIndicators);
        this.backplane.addPublisher('boeingTurbinePublisher', this.boeingTurbinePublisher);
        this.doInit();
    }
    /** @inheritdoc */
    getSourceSelectSide() {
        switch (this.instrument.instrumentIndex) {
            case 1:
                return 'left';
            case 2:
                return 'right';
            default:
                return 'center';
        }
    }
    /** Performs initialization tasks. */
    async doInit() {
        var _a;
        this.eisDataProvider = new BoeingEisDataProvider(this.bus, this.backplane, this.facLoader, 4, this.flightPlanner, 4);
        this.backplane.init();
        // Make sure to init plan and await it before rendering anything, to avoid plan doesn't exist errors
        await this.initFlightPlan();
        this.registerDisplayPaneViews();
        this.eisDataProvider.init();
        (_a = this.gpws) === null || _a === void 0 ? void 0 : _a.init();
        FSComponent.render(this.renderComponents(), document.getElementById('Electricity'));
        this.tryRunOnFlightStart();
    }
    /** @inheritdoc */
    onFlightStart() {
        var _a;
        super.onFlightStart();
        (_a = this.efisNdController) === null || _a === void 0 ? void 0 : _a.initLVarsFromSettings();
    }
    /** Registers display pane views with this instrument's display pane view factory. */
    registerDisplayPaneViews() {
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.NAV, (index) => {
            const sideIndex = DisplayPaneController.isPilotSideMfd(index) ? 1 : 2;
            return (FSComponent.buildComponent(NdMap, { bus: this.bus, index: index, facLoader: this.facLoader, activeRoutePredictor: this.activeRoutePredictor, flightPlanner: this.flightPlanner, mfdIndex: sideIndex, navIndicators: this.navIndicators, tcas: this.tcas, perfPlanRepository: this.perfPlanRepository, instrumentIndex: this.instrument.instrumentIndex }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.EICAS, index => {
            return (FSComponent.buildComponent(B748EicasPrimary, { bus: this.bus, index: index, casPresentationController: this.casPresentationController, dataProvider: this.eisDataProvider }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.ENG, index => {
            return (FSComponent.buildComponent(B748EicasSecondary, { bus: this.bus, index: index, dataProvider: this.eisDataProvider }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.DRS, index => {
            return (FSComponent.buildComponent(B748Doors, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.STAT, index => {
            return (FSComponent.buildComponent(B748Status, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.ELEC, index => {
            return (FSComponent.buildComponent(B748Electrical, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.FUEL, index => {
            return (FSComponent.buildComponent(B748Fuel, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.ECS, index => {
            return (FSComponent.buildComponent(B748EcsAirSystem, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.FCTL, index => {
            return (FSComponent.buildComponent(B748FlightControls, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.HYD, index => {
            return (FSComponent.buildComponent(B748Hydraulics, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.GEAR, index => {
            return (FSComponent.buildComponent(B748LandingGear, { bus: this.bus, index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.INFO, index => {
            return (FSComponent.buildComponent(B748Info, { index: index }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.CHKL, index => {
            return (FSComponent.buildComponent(B748ChecklistPage, { bus: this.bus, index: index, repo: this.boeingChecklistRepo }));
        });
        this.displayPaneViewFactory.registerView(DisplayPaneViewKey.BLANK, index => {
            return (FSComponent.buildComponent(BlankMfd, { index: index }));
        });
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        var _a;
        if (!((_a = this.efisEventPublisher) === null || _a === void 0 ? void 0 : _a.handleHEvent(args[0]))) {
            super.onInteractionEvent(args);
        }
    }
    /**
     * Renders this instrument's components.
     * @returns This instrument's rendered components, as a VNode.
     */
    renderComponents() {
        return (FSComponent.buildComponent(B748Square, { pfdOrMfd: "MFD", instrumentIndex: this.instrument.instrumentIndex },
            FSComponent.buildComponent(DisplayPaneContainer, { ref: this.displayPaneContainerRef, bus: this.bus, paneIndex: this.paneIndex, displayPaneViewFactory: this.displayPaneViewFactory, updateFreq: 10, class: 'display-pane-container' }),
            FSComponent.buildComponent(MfdReferenceOverlay, null)));
    }
    /** Makes sure that we have the flight plan, requesting sync if needed. */
    async initFlightPlan() {
        // Wait for primary CDU to init the plan
        await Wait.awaitDelay(2000);
        // Request sync from primary CDU
        this.flightPlanner.requestSync();
        // Wait for sync
        await Wait.awaitDelay(500);
    }
    /** @inheritdoc */
    Update() {
        super.Update();
    }
    /** @inheritdoc */
    onSoundEnd(soundEventId) {
        var _a;
        (_a = this.soundServer) === null || _a === void 0 ? void 0 : _a.onSoundEnd(soundEventId);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A Boeing 747-8i MFD/ND/CDU BaseInstrument.
 */
class WTB748_MFD extends FsBaseInstrument {
    /** @inheritdoc */
    get isInteractive() {
        return true; // Enabling touch for all instruments for development.
    }
    /** @inheritdoc */
    constructInstrument() {
        return new WTB748MfdInstrument(this, new AvionicsConfig(this, this.xmlConfig));
    }
    /** @inheritdoc */
    get templateID() {
        return 'WTB748_MFD';
    }
    /** @inheritdoc */
    onPowerOn() {
        super.onPowerOn();
        this.fsInstrument.onPowerOn();
    }
    /** @inheritdoc */
    onShutDown() {
        super.onShutDown();
        this.fsInstrument.onPowerOff();
    }
}
registerInstrument('wtb748-mfd', WTB748_MFD);
